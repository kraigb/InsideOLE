<HTML><HEAD><TITLE>Inside the Advise Sink</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Inside the Advise Sink</H3><P>The GetData On Change and Paint On Change menu items allow you to control how <I>IAdviseSink::OnDataChange </I>behaves. Two flags in <I>CApp</I>, <I>m</I><I>_</I><I>fGetData </I>and <I>m</I><I>_</I><I>fRepaint</I>, hold the current state of your menu selections. DataUser disables both of these menu items and sets these flags to FALSE unless it's using the in-process server DDataObj as the source of the data objects. Reasons for this will become clear shortly.</P>
<P>As you might expect, only the implementation of <I>OnDataChange </I>is important in the advise sink (besides the <I>IUnknown </I>members) because the other notifications are not relevant to data objects themselves. The bulk of code in the sink is contained in this single function:</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(void) CAdviseSink::OnDataChange(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM)<BR>    {<BR>    BOOL        fUsable=TRUE;<BR>    UINT        cf;<BR><BR>    STGMEDIUM   stm;<BR><BR>    if (!m_pApp-&gt;m_fGetData &amp;&amp; !m_pApp-&gt;m_fEXE)<BR>        return;<BR><BR>    //See whether we're interested in format and aspect that changed.<BR>    cf=pFE-&gt;cfFormat;<BR><BR>    if ((CF_TEXT!=cf &amp;&amp; CF_BITMAP!=cf &amp;&amp; CF_METAFILEPICT!=cf)<BR>        œœ !(DVASPECT_CONTENT &amp; pFE-&gt;dwAspect))<BR>        return;<BR><BR>    //Check medium if we got data.<BR>    switch (cf)<BR>        {<BR>        case CF_TEXT:<BR>            fUsable=(BOOL)(TYMED_HGLOBAL &amp; pFE-&gt;tymed);<BR>            break;<BR><BR>        case CF_BITMAP:<BR>            fUsable=(BOOL)(TYMED_GDI &amp; pFE-&gt;tymed);<BR>            break;<BR><BR>        case CF_METAFILEPICT:<BR>            fUsable=(BOOL)(TYMED_MFPICT &amp; pFE-&gt;tymed);<BR>            break;<BR><BR>        default:<BR>            break;<BR>        }<BR><BR>    if (!fUsable)<BR>        return;<BR><BR>    if (NULL==m_pApp-&gt;m_pIDataObject)<BR>        return;<BR><BR>    if (m_pApp-&gt;m_fEXE)<BR>        {<BR>        ReleaseStgMedium(&amp;(m_pApp-&gt;m_stm));<BR>        m_pApp-&gt;m_cf=cf;<BR>        m_pApp-&gt;m_stm.tymed=TYMED_NULL;<BR><BR>        InvalidateRect(m_pApp-&gt;m_hWnd, NULL, TRUE);<BR>        return;<BR>        }<BR><BR>    if (FAILED(m_pApp-&gt;m_pIDataObject-&gt;GetData(pFE, &amp;stm)))<BR>        return;<BR><BR>    //Get rid of old data and update.<BR>    ReleaseStgMedium(&amp;(m_pApp-&gt;m_stm));<BR><BR>    m_pApp-&gt;m_cf=cf;<BR>    m_pApp-&gt;m_stm=stm;<BR><BR>    InvalidateRect(m_pApp-&gt;m_hWnd, NULL, TRUE);<BR><BR>    if (m_pApp-&gt;m_fRepaint)<BR>        UpdateWindow(m_pApp-&gt;m_hWnd);<BR><BR>    return;<BR>    }</code></pre>
<P>On entry, this function immediately checks whether the <I>m</I><I>_</I><I>fGetData </I>flag is FALSE (and whether we're specifically using DDataObj so that <I>CApp::m</I><I>_</I><I>fEXE </I>is FALSE), and if so, it returns immediately, doing nothing else. If you remove the additional check on <I>m</I><I>_</I><I>fEXE </I>in the first line, you can run basic performance tests between DDataObj and EDataObj as far as raw notification rates are concerned. To run such a test, start DataUser, select Advise for any format (it doesn't matter which format), switch to the Small DLL Advisor #1 window, and select 572 from the Iterations menu. This causes that object to send 572 <I>OnDataChange </I>calls, but because you probably have a fast machine (486/66), you'll end up with a short elapsed time—perhaps 90 ms—with an average time per call of less than 1 ms (0.16 ms), or 6350 calls per second. Now select DataUser's Use EXE Object menu item, select Advise for any format, switch to the Small EXE Advisor #1 window, and select 572 from the Iterations menu again. After a considerably longer time lapse, you'll get a message box reporting the total time, on the relative order of 1532 ms, for an average of 2.7 ms per call, or 370 calls per second. You can see that working with an in-process data object is somewhat faster than working with a local one, simply because there is no marshaling overhead involved. This overhead, in fact, is where most of the extra time is spent: even with the extra <I>m</I><I>_</I><I>fEXE </I>condition intact (and the calls to <I>ReleaseStgMedium </I>and <I>InvalidateRect</I>),<I> </I>the total time for a local object to send 572 notifications was 1603 ms on my machine, hardly different from before. Still, 370 notifications per second is a fast rate, good enough for most notification purposes.</P>
<P>Anyway, if <I>OnDataChange </I>proceeds past this first check, it then ensures that the data object sent a notification for the format, aspect, and storage medium you're interested in watching. If there are any differences, it ignores the call altogether. Otherwise, what it does next depends on the server in question. If you're using EDataObj, <I>OnDataChange </I>frees whatever data it currently holds (by calling <I>ReleaseStgMedium</I>) and saves the format that changed inside <I>CApp::m</I><I>_</I><I>stm.cf</I> but marks that storage medium as TYMED_NULL. After this, it invalidates but does not update the main window. <I>OnDataChange</I> is telling the main application that it should repaint itself but that it has to call <I>IDataObject::GetData </I>when repainting occurs because the data is not yet available. TYMED_NULL indicates the absence of data, and the call to <I>InvalidateRect </I>basically posts a WM_PAINT to the main window. Therefore, when painting next occurs, DataUser will no longer be inside <I>IAdviseSink::OnDataChange</I>. It detects that it doesn't have a rendering, so it must ask the data object for one before painting, which all occurs in <I>CApp::Paint</I>:</P>
<P><BR></P>
<pre><code>void CApp::Paint(void)<BR>    {<BR>    [Other code omitted]<BR><BR>    if (m_fEXE)<BR>        {<BR>        if (TYMED_NULL==m_stm.tymed &amp;&amp; 0!=m_cf)<BR>            {<BR>            SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL<BR>                œ TYMED_MFPICT œ TYMED_GDI);<BR><BR>            if (NULL!=m_pIDataObject)<BR>                m_pIDataObject-&gt;GetData(&amp;fe, &amp;m_stm);<BR>            }<BR>        }<BR><BR>    [Other code omitted]<BR>    }</code></pre>
<P>You can see how this works when you run iterations from one of the EXE object windows. When the notifications have all been sent, DataUser draws the data in whatever format you selected. With a large number of iterations, you might also see a repaint occur during the iterations themselves because DataUser gets a chance to process some of its own messages, one of which could be WM_PAINT.</P>
<P>If DataUser is talking to an in-process data object, it can turn around and request a new rendering right away by calling <I>IDataObject::GetData. </I>Because there is no marshaling with an in-process object, there is no chance of such a call being rejected. If it gets the new data and then releases the old rendering that's held in <I>CApp:m</I><I>_</I><I>stm</I>, it replaces that rendering with the new one and invalidates the window to post a WM_PAINT message. Furthermore, if you've selected the Paint On Change menu item, DataUser calls <I>UpdateWindow </I>to force an immediate repaint. This gives you an opportunity to evaluate performance differences between a delayed repaint scheme and a synchronous one. Of course, repainting every time makes the whole process take longer because the data object will be waiting for all of this to occur before the call to <I>OnDataChange</I> returns.</P>
<P>It is a worthwhile exercise to modify these samples in order to send the data along with each notification and then to compare the relative performance in each case. For all cases except when DataUser asks the in-process object for a rendering inside <I>OnDataChange</I>, you will see a noticeable performance drop. In the cases outlined earlier, very few actual calls were sent into <I>IDataObject::GetData</I>. Sending the data with every notification means rendering the data each time and also freeing the data each time. This can get very expensive where large bitmaps or metafiles are concerned. The techniques demonstrated in DataUser and the two data objects represent more efficient implementations.</P></font></body></HTML>
