<HTML><HEAD><TITLE>Manage and Process Accelerators</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Manage and Process Accelerators</H3><P>The UI-active object always has first crack at accelerators. If the object is implemented in a local server, your own message loop will be the first to retrieve keystrokes headed for its window, in which case you process accelerators by calling the Windows function <I>TranslateAccelerator</I> as you always have. If you have an in-process object, however, the container's message loop will pick up the message and call your <I>IOleInPlaceActiveObject::TranslateAccelerator</I> function before it dares to translate the accelerator itself. This member of <I>IOleInPlaceActiveObject </I>is not called in a local object, so Cosmo leaves it empty. The Polyline sample in this chapter doesn't do anything with it either because it has no accelerators.</P>
<P>Nevertheless, Cosmo, as a local server, has two other considerations for its message loop in order to handle accelerators properly. First, it must avoid calling the Windows function <I>TranslateMDISysAccel</I> if it is an MDI application because the Window menu is not available during an in-place session. Second, it must call <I>OleTranslateAccelerator</I> to give the container a shot at the accelerators before the server dumps the message to <I>TranslateMessage</I> and <I>DispatchMessage</I>. Therefore, Cosmo's message loop, <I>CCosmoFrame::MessageLoop,</I> appears as follows:</P>
<P><BR></P>
<pre><code>WPARAM CCosmoFrame::MessageLoop(void)<BR>    {<BR>    MSG     msg;<BR><BR>    while (GetMessage(&amp;msg, NULL, 0,0 ))<BR>        {<BR>        //If we're in place, don't bother with MDI accelerators.<BR>        if (NULL==m_pIOleIPFrame)<BR>            {<BR>            if (m_pCL-&gt;TranslateAccelerator(&amp;msg))<BR>                continue;<BR>            }<BR><BR>        //Translate our accelerators.<BR>        if (TranslateAccelerator(m_hWnd, m_hAccel, &amp;msg))<BR>            continue;<BR><BR>        if (NULL!=m_pIOleIPFrame)<BR>            {<BR>            if (NOERROR==OleTranslateAccelerator(m_pIOleIPFrame<BR>                , &amp;m_frameInfo, &amp;msg))<BR>                continue;<BR>            }<BR><BR>        TranslateMessage(&amp;msg);<BR>        DispatchMessage(&amp;msg);<BR>        }<BR><BR>    return msg.wParam;<BR>    }</code></pre>
<P>The <I>IOleInPlaceFrame</I> pointer (<I>m</I><I>_</I><I>pIOleIPFrame</I>) and the OLEINPLACEFRAMEINFO structure (<I>m</I><I>_</I><I>frameInfo</I>) passed to <I>OleTranslateAccelerator</I> are those obtained from <I>IOleInPlaceSite::GetWindowContext</I>. We saved these earlier in <I>CFigure::InPlaceActivate.</I></P>
<P><B>Note:</B><B> </B><B> </B>A local MDI and multiple-use server will have a more complex test to determine whether to call <I>OleTranslateAccelerator. </I>You <I>must </I>call the function with the <I>IO</I><I>leInPlaceFrame </I>pointer and OLEINPLACEFRAMEINFO structure of the container that's involved with the in-place object in the <I>currently active </I>document.</P></font></body></HTML>
