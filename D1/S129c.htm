<HTML><HEAD><TITLE>Save and Load the Document with Embedded Objects</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Save and Load the Document with Embedded Objects</H3><P>At some point, it would be nice to save all the objects we've been creating and editing so that we can reload them at a later time. We've by and large covered all the steps for saving an object in a document: providing an <I>IStorage</I>, calling <I>OleSave</I> when asked through <I>IOleClientSite::SaveObject</I> or when closing the object, and doing the same through <I>CTenant::Update</I>.</P>
<P>On a larger scale, Patron's document saving starts in <I>CPatronDoc::Save</I>, which first asks <I>CPages</I> to update, which in turn asks the currently open <I>CPage</I> to update, which in turn asks each tenant to update by using the preceding code. After all that, the document commits itself, and because it is the owner of the root storage, that commitment writes the file to disk. Little of this storage code has changed from previous versions of Patron.</P>
<P>Patron, by the way, is designed—and I won't argue that this is the best design—to keep only the current page open. This means that when you switch pages, all open or running objects on the old page are closed to the passive state and all objects on the new page are opened to the loaded state.</P>
<P>Loading a document in Patron starts with opening a root storage for the document and initializing the pages. Then Patron opens the current page by using <I>CPage::Open</I>. This, in turn, re-creates all the tenants on the page, but instead of calling <I>CTenant::Create</I>, Patron calls <I>CTenant::Load</I>, indicating the object's storage, what is in this storage, and the rectangle occupied by the tenant on the page:</P>
<P><BR></P>
<pre><code>BOOL CTenant::Load(LPSTORAGE pIStorage, PTENANTINFO pti)<BR>    {<BR>    HRESULT         hr;<BR>    LPUNKNOWN       pObj;<BR>    DWORD           dwState=TENANTSTATE_DEFAULT;<BR><BR>    if (NULL==pIStorage œœ NULL==pti)<BR>        return FALSE;<BR><BR>    /*<BR>     * If we already initialized once, clean up, releasing<BR>     * everything before we attempt to reload. This happens<BR>     * when using the Convert dialog.<BR>     */<BR>    if (m_fInitialized)<BR>        {<BR>        //Preserve all states except open.<BR>        dwState=(m_dwState &amp; ~TENANTSTATE_OPEN);<BR>        m_cRef++;   //Prevent accidental closure.<BR><BR>        //This should release all holds on our IStorage as well.<BR>        if (NULL!=m_pIViewObject2)<BR>            {<BR>            m_pIViewObject2-&gt;SetAdvise(m_fe.dwAspect, 0, NULL);<BR>            ReleaseInterface(m_pIViewObject2);<BR>            }<BR><BR>        ReleaseInterface(m_pIOleObject);<BR>        ReleaseInterface(m_pObj);<BR><BR>        m_pIStorage=NULL;   //We'll have already released this.<BR>        m_cRef--;           //Match safety increment above.<BR>        }<BR><BR>    m_fInitialized=TRUE;<BR><BR>    //Open storage for this tenant.<BR>    if (!Open(pIStorage))<BR>        return FALSE;<BR><BR>    hr=OleLoad(m_pIStorage, IID_IUnknown, NULL, (PPVOID)&amp;pObj);<BR><BR>    if (FAILED(hr))<BR>        {<BR>        Destroy(pIStorage);<BR>        return FALSE;<BR>        }<BR><BR>    m_fSetExtent=pti-&gt;fSetExtent;<BR>    ObjectInitialize(pObj, &amp;pti-&gt;fe, NULL);<BR><BR>    //Restore original state before reloading.<BR>    m_dwState=dwState;<BR><BR>    RectSet(&amp;pti-&gt;rcl, FALSE, FALSE);<BR>    return TRUE;<BR>    }</code></pre>
<P>Most of this is unchanged from previous versions. <I>OleLoad</I> brings passive objects into the loaded state and returns an interface pointer. Now, however, to support embedded objects, we call <I>ObjectInitialize</I> to perform the same initialization sequence as was required after <I>OleCreate</I> and to position the object on the page before repainting. In addition, we check to ensure that we are not simply reloading this object from an already initialized state, which might occur when we deal with conversion and emulation. We'll see why this is important shortly.</P>
<P>Patron's file handling still has one small modification that you can find in <I>CPatronDoc::Rename</I>. This is called whenever the user does a File Save As or otherwise changes the name of a document. After doing the usual document renaming work, Patron calls <I>CPage::NotifyTenantsOfRename</I>,<I> </I>which cycles through all the tenants in the current page, calling <I>CTenant::NotifyOfRename </I>with the new filename. The tenant now uses this information to call <I>IOleObject::SetHostNames </I>once again, updating the information it passed through object initialization:</P>
<P><BR></P>
<pre><code>void CTenant::NotifyOfRename(LPTSTR pszFile, LPVOID pvReserved)<BR>    {<BR>    TCHAR       szObj[40];<BR>    TCHAR       szApp[40];<BR><BR>    if (NULL==m_pIOleObject)<BR>        return;<BR><BR>    if (TEXT('\0')==*pszFile)<BR>        {<BR>        LoadString(m_pPG-&gt;m_hInst, IDS_UNTITLED, szObj<BR>            , sizeof(szObj));<BR>        }<BR>    else<BR>        GetFileTitle(pszFile, szObj, sizeof(szObj));<BR><BR>    LoadString(m_pPG-&gt;m_hInst, IDS_CAPTION, szApp, sizeof(szApp));<BR>    m_pIOleObject-&gt;SetHostNames(szApp, szObj);<BR>    return;<BR>    }</code></pre>
<P>If you leave out this small part, your current document name will not be reflected in open server windows, which is not very user friendly.</P></font></body></HTML>
