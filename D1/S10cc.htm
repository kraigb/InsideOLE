<HTML><HEAD><TITLE>Connectable Objects</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Connectable Objects</H3><P>The set of interfaces that a client can access through <I>QueryInterface </I>forms an object's <I>incoming </I>interfaces when calls to those interfaces come into the object. However, this alone is not entirely sufficient to completely describe the possible features of objects: sometimes an object will want to notify external clients when events happen in the object—for example, when data changes or when a user performs an action such as clicking the mouse on the object. In order to send such notifications (or to "fire events," as it is sometimes called), the object supports <I>outgoing </I>(sometimes called <I>source</I>) interfaces, illustrated as an arrow coming out of an object, as shown in Figure 1-8.</P>
<P>    <img src="f01dd08.gif"></P>
<P><B>Figure 1-8.</B></P>
<P><B>An object's outgoing interfaces are drawn as outgoing arrows alongside the jacks that represent incoming interfaces.</B></P>
<P>Outgoing interfaces are not ones that the object implements itself. Instead, the object is a client of the interface as implemented on an external object. The most frequent use of this sort of relationship is the forming of a two-way channel of communication between two components, where each is both client and object. In order not to confuse the terminology, the object that sends the notifications is called the <I>source,</I> and the client that receives the notifications is called the <I>sink,</I> as illustrated in Figure 1-9.</P>
<P>    <img src="f01dd09.gif"></P>
<P><B>Figure 1-9.</B></P>
<P><B>A client that implements an object's outgoing interface is a sink for the object's notifications and events.</B></P>
<P>What is special in this outgoing interface relationship that differentiates it from the usual incoming interfaces is that the object generally defines the exact outgoing interface itself. This is why we still call it the <I>object</I><I>'</I><I>s </I>interface even though the client implements it—the object defines outgoing interfaces as part of its feature set.</P>
<P>The exact mechanism used to establish this two-way channel of communication is the technology called Connectable Objects, which is the topic of Chapter 4. When any object wants to express the fact that it has outgoing interfaces, it implements an interface named <I>IConnectionPointContainer</I>, and in doing so it qualifies as a connectable object. When a client wants to check whether an object has outgoing interfaces, that client will call <I>QueryInterface</I>, asking for <I>IConnectionPointContainer.</I> With this interface, the client can browse through individual entities called <I>connection points;</I> each connection point represents a single outgoing interface. These connection points are small objects themselves (with their own <I>IUnknown </I>behavior), managed within the larger object, each of which implements an interface named <I>IConnectionPoint</I>. It is through this interface that the client can ask the connection point for the identifier of its outgoing interface and give the connection point the interface pointer through which the connectable object sends notifications (that is, calls interface member functions). In other words, to establish the two-way channel, the client has to be able to pass its own interface pointers to the connectable object, and connection points are the means for doing so.</P>
<P>Some outgoing interfaces involved in a two-way dialogue are known to both sides at compile time. These are known as standard event sets, or standard notification interfaces, which are defined in header files. In other cases, however, the client does not know the exact details of the interface until run time, which requires the object to supply type information.</P>
<P>The idea of events, which connectable objects provide, is a very powerful one. So many things—controls, menus, the keyboard, the mouse, modems, power failures, bothersome relatives—generate events. Anything that somehow has something to say is an event source, and connection points are how you listen. What you do when you hear that a certain event has occurred is completely open. Events are really the triggers that make things happen and that transform user actions (such as typing, moving the mouse, and speaking into a microphone) into information that a piece of software can use as a stimulus to drive a particular response. Stimulus-response makes things seem <I>alive</I>. This makes events a key to dynamic software, and connectable objects are how events are implemented in OLE.</P></font></body></HTML>
