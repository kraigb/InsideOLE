<HTML><HEAD><TITLE>Object States and Activation</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Object States and Activation</H2><P>OLE Documents introduces a few object states above and beyond the simple passive, loaded, and running states that we've seen in earlier chapters. The following table explains how OLE defines and differentiates these states:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>State</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Passive</P></TD><TD VALIGN="TOP"><P>The object exists only as a persistent representation in some storage medium (disk, memory, and so on).</P></TD></TR><TR><TD VALIGN="TOP"><P>Loaded</P></TD><TD VALIGN="TOP"><P>Some in-process code is loaded for the object in the client's process and can access the persistent data as necessary. This state indicates that at least an in-process handler is loaded for the object. Loading an object does not mean launching a local or remote server.</P></TD></TR><TR><TD VALIGN="TOP"><P>Running</P></TD><TD VALIGN="TOP"><P>The object's server is fully loaded and running and has complete access to its persistent data. The object is registered in the running object table. The object has created its user interface, but that UI is not visible to the end user.</P></TD></TR><TR><TD VALIGN="TOP"><P>Active</P></TD><TD VALIGN="TOP"><P>The object's user interface is visible to the end user.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>We've seen many objects in earlier chapters that blur the distinction between these states: some objects make no distinction between loaded and running; others make no distinction between running and active. In OLE Documents, however, all of these states are distinct for both embedded and linked objects. (Objects that are also in-place capable have additional states, as we'll see in Chapters 22 and 23.) Also, specific actions on behalf of the client control how the object moves from state to state. OLE Documents is primarily concerned with the control of active objects, as activation is one of its primary features.</P>
<P>The sequence of <I>CoCreateInstance </I>followed by <I>IPersistStream::Load </I>or <I>IPersistStor</I><I>age::Load </I>moves a passive object into at least the loaded state, depending on the object. These sequences are encapsulated in API functions such as <I>OleLoadFromStream</I> and <I>OleLoad</I>, both of which return a new interface pointer to the newly loaded object. Calling this object's <I>Release </I>member will take the object back to the passive state. (A client usually does this after saving the object with <I>OleSaveToStream </I>or <I>OleSave</I>.)</P>
<P>In OLE Documents, the loaded state means that only some in-process code is loaded for the object. If the object has an in-process server, that server DLL is in memory. If an in-process server is not available, OLE will try to load an in-process handler, be it a custom handler or the OLE default handler. In OLE Documents, the default handler is always loaded in the absence of a custom handler. Outside OLE Documents, of course, the most that is loaded is a simple object proxy. In any case, a client always has an interface pointer to a loaded object and can call members in that interface as desired.</P>
<P>The client, or container, can now precisely move the object into the running state through an interface named <I>IRunnableObject</I>,<I> </I>which includes member functions named <I>Run</I>,<I> IsRunning</I>,<I> LockRunning</I>,<I> </I>and <I>SetContainedObject</I>. Calls to these members are wrapped for convenience in the OLE API functions <I>OleRun</I>,<I> OleIsRunning</I>,<I> OleLockRunning</I>,<I> </I>and <I>OleSetContainedObject</I>. When <I>Run </I>is called on an in-process server that supports OLE Documents (as we'll see in Chapter 19), the object initializes any user interface it needs when active and registers itself in the running object table. It does not, however, show itself. When called on a handler or the generic proxy, <I>Run </I>causes that handler to launch the local server (through <I>CoCreateInstance</I>). Servers that support OLE Documents will use the presence of <I>-Embedding </I>on the command line as a signal that the object in question has now entered the running state but should not be visible. This is why servers, such as those we saw with OLE Automation, are not generally supposed to make themselves visible on startup when <I>-Embedding </I>is present.</P>
<P>Some other means are necessary to make the object visible. In OLE Automation, this is usually controlled through an object's <I>Visible</I> property—setting <I>Visible</I> to TRUE makes the object visible, and setting it to FALSE hides the object. In cases outside OLE Documents, having the user close the object's UI directly or having the client release the object programmatically is the only way to get an object out of the running state and all the way back to passive.</P>
<P>OLE Documents, however, gives an added layer of control, represented through two member functions of the interface <I>IOleObject</I>. As we'll see later in this chapter, this interface represents objects that understand OLE Documents. Two of its member functions interest us here. The first is <I>IOleObject::DoVerb</I>,<I> </I>which takes an integer verb identifier. A <I>verb</I> is a specific action the object can execute that has meaning to the end user. Typical verbs are Edit, Open, Show, Hide, and Play. A container uses an object's registry information to determine which verbs to display to the end user on an object-specific pop-up menu. When the user selects one of these items, the container calls <I>IOleObject::DoVerb</I>, which will run an object first if the object is not already in that state.</P>
<P>The Show verb moves the object from the invisible running state into the visible active state. This verb has a value named OLEIVERB_SHOW and can be implicit in some of the object's other custom verbs at the object's choosing. In any case, Show makes the object visible so that the end user can now manipulate the object directly. Once the object is visible, the Hide verb, OLEIVERB_HIDE, tells the object to move back to the invisible running state and stay there. By using these verbs, passed to the object through <I>IOleObject::DoVerb</I>, a container can precisely control an object's transitions between hidden and visible.</P>
<P>The other function of interest is <I>IOleObject::Close</I>, which takes an active or a running object back to the loaded state—but not as far back as passive. After <I>IOleObject::Close</I>, the container will still have valid interface pointers to the object because that object is still loaded. The container can then call <I>OleRun </I>or <I>IOleObject::DoVerb </I>again to get the object running or active.</P>
<P>With this basic understanding of the various states of content objects, we're now ready to see the compound document architecture as a whole.</P></font></body></HTML>
