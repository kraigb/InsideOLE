<HTML><HEAD><TITLE>Standard Marshaling Architecture</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Standard Marshaling Architecture</H2><P>When an object does not want to provide its own custom marshaling, COM will automatically install standard marshaling for the object and all of its interfaces, employing specific interface marshalers as necessary.<I> </I>In standard marshaling, the proxy is connected to a stub that is then connected to the remote object itself.<I> </I>Underneath it all, both proxy and stub communicate with what is called the <I>RPC Channel, </I>an object (inside the COM Library) that encapsulates all the details about the underlying cross-process or cross-network transport, as illustrated in Figure 6-2.<I> </I>The RPC Channel itself makes calls into whatever RPC API exists on the system, so it only needs to control the data packets sent across the wire, so to speak, leaving the physical transport to the system.</P>
<P>    <img src="f06dd02.gif"></P>
<P><B>Figure 6-2.</B></P>
<P><B>Proxies and stubs communicate with the RPC Channel, which in turn generates the necessary RPC sequences for cross-process or cross-machine communication.</B></P>
<P>A key point here is that COM performs standard marshaling interface by interface, not object by object. In other words, COM does not create a connection between a proxy and a stub for a particular interface until the client actually has a pointer to that interface itself. In Figure 6-2, the proxy object manages <I>facelets,</I> one for each interface, that individually communicate with a corresponding <I>stublet </I>managed by the stub object, as shown in the exploded view in Figure 6-3.</P>
<P>    <img src="f06dd03.gif"></P>
<P><B>Figure 6-3.</B></P>
<P><B>A proxy manager contains any number of facelets (one per interface); and the stub manager, any number of stublets. Client calls go directly to the appropriate facelet, which marshals the call to the stublet through the RPC Channel. The stublet maintains the pointer to the remote object's interface to make the real call.</B></P>
<P>Facelets and stublets perform all the communication because they, not the proxy or stub managers, know how to marshal arguments, out-parameters, and return values correctly for their specific interfaces. In other words, the semantics of each interface member function are known somewhat to the facelet and stublet implementations. They know when an out-parameter, for example, is an interface pointer to a new and separate object, which then requires a call to <I>CoMarshalInterface</I>. An interface pointer to the same object, on the other hand, requires only a new facelet and stublet pair.</P>
<P>As you might expect, there are a great many details about the way proxy and stub managers are built and how they get into memory along with facelets and stublets.<B><I> </I></B>For interested readers, APPB.WRI on the companion CD describes the architectural objects and how they come into and out of memory.<B><I> </I></B>APPB.WRI discusses a short piece of client code that calls <I>CoGetClassObject</I>,<I> IClassFactory::CreateInstance</I>,<I> </I>and <I>IProvideClassInfo::GetTypeInfo</I>, an example that involves three objects, each with different interfaces.<B> </B>A few points, however, are worth mentioning here to help us understand other topics in this chapter.</P>
<P>Three members of the <I>IRpcChannelBuffer </I>interface, implemented on the RPC Channel objects shown in Figure 6-3, are important to the operation of standard marshaling.<B><I> </I></B>By calling the function <I>GetBuffer</I>, a facelet obtains a buffer in which it stores the function arguments to pass to its corresponding stublet. (This buffer is freed with the member function <I>FreeBuffer</I>.)<B><I> </I></B>When it's ready to transmit the call, the facelet calls the member function <I>SendReceive</I>.<B><I> </I></B>The stublet is then told to call the appropriate member function of the remote object through <I>IRpcStubBuffer</I>. When that stublet is ready to return out-parameters and return values, it calls <I>GetBuffer</I> as well and stores the data.<B><I> </I></B>When the stublet returns, the RPC Channel brings the data back to the facelet, which recognizes it as an out-parameter from <I>SendReceive.</I></P>
<P>In most cases, the call is <I>synchronous</I>. This means that <I>SendReceive </I>will not return until the call has been completely processed in the remote object.<B><I> </I></B>Calls might also be <I>asynchronous </I>or <I>input-synchronized,</I> as discussed in the section "Concurrency Management" later in this chapter.<B><I> </I></B>When a call is blocked inside <I>SendReceive</I>, concurrency management allows the caller to control how long it is willing to wait for the call to be completed.</P>
<P>In some cases, the interface member that was called in this manner might create a new object and return an interface pointer to that object as an out-parameter.<B><I> </I></B>The stublet, knowing the semantics of that interface pointer, then has to call <I>CoMarshalInterface </I>and store the contents of the stream in the return buffer.<B><I> </I></B>The facelet that receives this buffer reintegrates the stream and passes it to <I>CoUnmarshalInterface</I> to obtain the correct pointer to return to the client.<B><I> </I></B>This mechanism is the same when the facelet has to pass an interface pointer to some object to the stublet (such as with a sink interface pointer).<B><I> </I></B>In this case, the facelet calls <I>CoMarshalInterface </I>and stores the stream in the buffer so that the stublet can then reintegrate the stream and call <I>CoUnmarshalInterface </I>to get the pointer to pass to the object itself.<B><I> </I></B>In each case, the form of marshaling is established according to the needs of the new object being marshaled.</P>
<P>In other cases, the interface member being called from the client returns a pointer to an interface other than the one being used, but still one that is on the same object. Here the correct proxy and stub already exist, but they now need to create a new facelet/stublet pair for the new pointer (assuming it doesn't already exist).<B><I> </I></B>This is one of the operations that <I>QueryInterface</I> must perform inside COM's standard <I>IUnknown </I>marshaler.<B><I> </I></B>Whatever code needs the new interface marshaler takes the IID and looks for a registry entry that maps to a CLSID.<B><I> </I></B>That CLSID then maps to a server that implements the appropriate facelet and stublet for the IID in question.<B><I> </I></B>The class factory in that server implements the interface <I>IPSFactoryBuffer</I>,<I> </I>whose members <I>CreateProxy </I>and <I>CreateStub </I>create the necessary facelet and stublet, as described in detail in APPB.WRI on the companion CD.</P>
<P>Interfaces that have no standard marshaling support simply do not have either the necessary registry entries or a server that provides the marshalers (which is, of course, irrelevant for objects using their own custom marshaling). The lack of marshaling support will cause any operation involving a cross-process <I>QueryInterface </I>call to fail. In other words, any facelet or stublet for any interface member that takes IID and <I>void </I>**<I> </I>arguments to identify an interface pointer will fail when the appropriate registry entries for the IID in question are not found.<B><I> </I></B>The specific error is REGDB_E_IIDNOTREG.<B><I> </I></B>If the entries do exist but the server doesn't, the error is CO_E_DLLNOTFOUND. There are other possibilities, of course, and these are the errors you will see if you try to use an interface across process boundaries when marshaling support doesn't exist.<B><I> </I></B>The nice thing is that you can install marshalers on a running system and make marshaling suddenly work for whatever interface.<B><I> </I></B>The same code that failed before will now work without a hitch because the necessary marshaling support is available.</P>
<P>The following section describes the process of creating marshalers for custom interfaces, after which we'll look at one more topic of relevance to standard marshaling—strong and weak references.</P></font></body></HTML>
