<HTML><HEAD><TITLE>If You Already Have a Data Object…Component Cosmo</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>If You Already Have a Data Object…Component Cosmo</H3><P>If a source is about to copy an object that is already a data object, it's not necessary to use an entirely different class as does DataTran. For example, the Polyline object used by CoCosmo implements <I>IDataObject</I>, so CoCosmo can make another Polyline and copy data directly into it. Any data object works as well as any other. The copying is necessary to create a snapshot of the current, visible Polyline so changes to it will not cause problems with delayed rendering. End users will expect that the data they paste is exactly the same data they copied. If CoCosmo places the visible Polyline on the clipboard, the data is <I>live, </I>so any change made to the Polyline object will show up when the data is pasted later. What the end user copied and what that user pasted is not the same. Not good.</P>
<P>Instead, CoCosmo instantiates an extra hidden Polyline with the same dimensions as the visible one and copies the visible object's data into it. A perfect snapshot. CoCosmo then tosses the hidden Polyline onto the clipboard, as shown in the following code (taken from CHAP12\COCOSMO\DOCUMENT.CPP, which continues to use the Polyline implementation from Chapter 10):</P>
<P><BR></P>
<pre><code>BOOL CCosmoDoc::Clip(HWND hWndFrame, BOOL fCut)<BR>    {<BR>    PPOLYLINE               pPL;<BR>    LPDATAOBJECT            pDataSrc, pIDataObject;<BR>    FORMATETC               fe;<BR>    STGMEDIUM               stm;<BR>    BOOL                    fRet=TRUE;<BR>    HRESULT                 hr;<BR>    RECT                    rc;<BR><BR>    hr=CoCreateInstance(CLSID_Polyline10, NULL, CLSCTX_INPROC_SERVER<BR>        , IID_IPolyline10, (PPVOID)&amp;pPL);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    m_pPL-&gt;RectGet(&amp;rc);<BR><BR>    if (FAILED(pPL-&gt;Init(m_hWnd, &amp;rc, WS_CHILD, ID_POLYLINE)))<BR>        {<BR>        pPL-&gt;Release();<BR>        return FALSE;<BR>        }<BR><BR>    m_pPL-&gt;QueryInterface(IID_IDataObject, (PPVOID)&amp;pDataSrc);<BR><BR>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL);<BR>    fRet=SUCCEEDED(pDataSrc-&gt;GetData(&amp;fe, &amp;stm));<BR>    pDataSrc-&gt;Release();<BR><BR>    if (!fRet)<BR>        {<BR>        pPL-&gt;Release();<BR>        return FALSE;<BR>        }<BR><BR>    pPL-&gt;QueryInterface(IID_IDataObject, (PPVOID)&amp;pIDataObject);<BR>    pPL-&gt;Release();<BR><BR>    pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE);<BR><BR>    fRet=SUCCEEDED(OleSetClipboard(pIDataObject));<BR><BR>    if (NULL!=m_pIDataClip)<BR>        m_pIDataClip-&gt;Release();<BR><BR>    m_pIDataClip=pIDataObject;<BR><BR>    //Delete our current data if "cut" succeeded.<BR>    if (fRet &amp;&amp; fCut)<BR>        {<BR>        m_pPL-&gt;New();<BR>        FDirtySet(TRUE);<BR>        }<BR><BR>    return fRet;<BR>    }</code></pre>
<P>The preceding code handles both Cut and Copy operations with identical vigor, but Cut removes the affected data from the document. Keep in mind, however, that you still need to create a snapshot of the data regardless of whether you are cutting it or copying it.</P></font></body></HTML>
