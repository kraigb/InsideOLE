<HTML><HEAD><TITLE>Calling IDispatch: A Simple Automation Client</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Calling <I>IDispatch</I>: A Simple Automation Client</H2><P>After reading Chapter 14, you should already understand much of what a controller will do when it calls an object's automation interfaces. Here we can take a look at this topic from the controller's point of view. First we'll examine the initialization steps involved in creating the object, loading an LCID, retrieving its type information, and finding the object's help directory. Then we'll look at calling the <I>IDispatch</I> member functions <I>GetIDsOfNames </I>and <I>Invoke</I>. We won't deal with type information because that is outside the scope of this sample. Calling <I>IDispatch</I> functions means that we're dealing with a dispinterface but not the custom part of a dual interface. To call the latter, either we'd hard code the vtable offsets by including the IBEEPER.H file from the Beeper4 sample in Chapter 14, or we'd have to manually build the correct stack frame based on type information. We'll look at a process such as this later, but it is not demonstrated by a sample program in this book. Finally we'll look at how a controller handles exceptions that come back from <I>IDispatch::Invoke</I>.</P>
<P>The AutoCli sample discussed here (CHAP15\AUTOCLI) will work with the dispinterface of any of the Beeper object variations in Chapter 14. The only parts that AutoCli does not exercise are the custom portion of the dual interface of Beeper4 and the <I>IProvideClassInfo </I>implementation of Beeper5. In any case, be sure to create the proper registry entries for each Beeper object using the REG files included with each of those samples before attempting to run AutoCli with them.</P>
<P>For whatever Beeper variation is used, AutoCli displays the same menu commands as shown in Figure 15-1. These commands allow you to get the value of the <I>Sound </I>property, set that property to its legal values, set <I>Sound </I>to a bogus value to generate an exception, and call the object's <I>Beep</I> method. AutoCli also displays the return value of a property get or a call to <I>Beep</I> in its client area as well as any error codes that come back, such as DISP_E_EXCEPTION.</P>
<P>    <img src="f15dd01p.gif"></P>
<P><B>Figure 15-1.</B></P>
<P><B>AutoCli and its menu structure.</B></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H3><A NAME="sec0"></A>MFC's COleDispatchDriver</H3><P>One thing you will notice in this section is that it takes considerable C or C++ code to make any call or to access a property through <I>IDispatch::Invoke</I>. Tools such as Visual Basic hide much of the complexity by providing a simpler language structure that translates into <I>IDispatch</I> calls. For controllers written in C++, the Microsoft Foundation Classes provide a class called <I>COleDispatchDriver</I> that makes <I>IDispatch </I>calls just as easy.  Instead of having to fill all the structures to call <I>IDispatch::Invoke</I> yourself, you can pass arguments to members of this class on the stack. In other words, <I>COleDispatchDriver</I> can make calling members of a dispinterface as simple as calling members of a custom interface, where MFC does the dirty work of filling all the structures required by <I>Invoke</I>.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
