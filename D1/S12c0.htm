<HTML><HEAD><TITLE>Obtain a Default Handler IUnknown</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Obtain a Default Handler <I>IUnknown</I></H3><P>When initializing the handler object, you should create a default handler instance using <I>OleCreateDefaultHandler</I>, passing your CLSID and a pointer to your object's controlling <I>IUnknown</I> because you must aggregate on the handler in this situation. You get back an <I>IUnknown </I>pointer to this default object according to the aggregation rules. You need to pass your own CLSID so that the default handler can implement various functions using your registry entries.</P>
<P>After you have this default handler's <I>IUnknown</I>, you should query for <I>IOleObject</I>, <I>IPersistStorage</I>, and <I>IViewObject2</I> (and also perhaps <I>IDataObject</I>). You can later delegate to these interfaces, calling the controlling unknown's <I>Release </I>after each query according to the aggregation rules we saw in earlier chapters. This is much more efficient than calling <I>QueryInterface</I>, delegating the function, and calling <I>Release</I> every time you need to delegate. HCosmo does all this in <I>CFigure::Init </I>(called from <I>IClassFactory::CreateInstance</I>) after allocating its own interface implementations:</P>
<P><BR></P>
<pre><code>BOOL CFigure::Init(void)<BR>    {<BR>    LPUNKNOWN       pIUnknown=(LPUNKNOWN)this;<BR>    HRESULT         hr;<BR>    DWORD           dwConn;<BR>    FORMATETC       fe;<BR><BR>    if (NULL!=m_pUnkOuter)<BR>        pIUnknown=m_pUnkOuter;<BR><BR>    [Create interface implementations.]<BR><BR>    m_cRef++;<BR><BR>    hr=OleCreateDefaultHandler(CLSID_CosmoFigure, pIUnknown<BR>        , IID_IUnknown, (PPVOID)&amp;m_pDefIUnknown);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    //Now try to get other interfaces to which we delegate.<BR>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IOleObject<BR>        , (PPVOID)&amp;m_pDefIOleObject);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    pIUnknown-&gt;Release();<BR><BR>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IViewObject2<BR>        , (PPVOID)&amp;m_pDefIViewObject2);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    pIUnknown-&gt;Release();<BR><BR>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IDataObject<BR>        , (PPVOID)&amp;m_pDefIDataObject);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    pIUnknown-&gt;Release();<BR><BR>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IPersistStorage<BR>        , (PPVOID)&amp;m_pDefIPersistStorage);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    pIUnknown-&gt;Release();<BR>    m_cRef--;<BR><BR>    //Set up an advise on native data so we can keep in sync.<BR>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL);<BR>    m_pDefIDataObject-&gt;DAdvise(&amp;fe, 0, m_pIAdviseSink, &amp;dwConn);<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>When we want to free this default handler object, we need to call the controlling unknown's <I>AddRef </I>and<I> </I>then call <I>Release </I>through each <I>m</I><I>_</I><I>pDefI</I>* that we obtained earlier, again according to aggregation rules. This is done in <I>CFigure::~CFigure</I>.</P>
<P>Otherwise, everything about this code should look familiar by now, except for the part at the end, which sets up a data change advise connection. The default handler will connect our <I>IAdviseSink </I>here to the local object when the latter becomes a running object. We use this connection to synchronize with the local object as described in "Synchronizing with a Local Server" in Chapter 11 on page 551 and "Synchronized Swimming with Your Local Server" later in this chapter. Note that I don't save the connection key from <I>DAdvise</I> because I won't need to call <I>DUnadvise</I> until I release <I>m</I><I>_</I><I>pDefIDataObject</I>, which will terminate the connection for me.</P></font></body></HTML>
