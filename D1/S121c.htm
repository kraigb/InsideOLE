<HTML><HEAD><TITLE>Tenant Pick Regions and Drop Sourcing</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Tenant Pick Regions and Drop Sourcing</H3><P>In Patron, I've defined the outer rectangular boundary of any tenant as the pick region, excluding those areas already occupied by sizing handles. The width and height of the region are the same as the dimensions of sizing handles.</P>
<P><img src="f13dd06f.gif"></P>
<P>In Chapter 12, we added the <I>CPage::OnNCHitTest </I>(PAGEMOUS.CPP) function to Patron to determine when the mouse was over a sizing handle. We used the return value from this function in <I>CPage::SetCursor</I> to show an appropriate mouse cursor for each sizing handle. For drag and drop, we modify <I>OnNCHitTest</I> to also check for the pick region (after the sizing) and modify <I>CPage::SetCursor</I> to show a four-pointed move cursor:</P>
<P><img src="f13dd06g.gif"></P>
<P>When <I>OnNCHitTest</I> determines that the mouse is within a pick region, it stores the code HTCAPTION in <I>CPage::m</I><I>_</I><I>uHTCode</I>, which <I>CPage::SetCursor </I>uses to set the move cursor. When <I>CPage::OnLeftDown </I>detects the HTCAPTION code, it calls <I>CPage::DragDrop </I>to create the data object (<I>CPage::TransferObjectCreate</I>) and the drop source object and then calls <I>DoDragDrop</I>. When the latter function returns, Patron checks whether a move effect occurred and handles the selected data appropriately.</P>
<H4><A NAME="sec0"></A>Da Bears, Da Bulls, Da Bounce</H4><P>Often end users accidentally press a mouse button so that it stays down for only a short period of time. This is called a mouse bounce. It is preferable for an application to avoid executing actions on accidental mouse clicks by debouncing the mouse.2 In Patron, we want to avoid the extra work to set up a drag-and-drop operation unless the end user really does want to do one. To do this, we need to debounce the mouse in the following way:</P>
<P>When the mouse button is pressed in the pick region, start a delay timer with a period defined by the DragDelay value in the [windows] section of WIN.INI. OLE's default DD_DEFDRAGDELAY value is 200 ms.</P>
<P>If the mouse moves a small distance away from its button down point before the timer expires, start the drag-and-drop operation. (Enough mouse movement means that the end user wants to drag the data.) The "small distance" is the number of pixels defined by the DragMinDist value in the [windows] section of WIN.INI. OLE's default DD_DEFDRAGMINDIST value is 2.</P>
<P>When the timer elapses, start the drag-and-drop operation.</P>
<P>The version of Patron in Chapter 12 contains code to do this for the sizing handles as well. Here's how it works. The <I>CPage </I>constructor (PAGE.CPP) reads the delay and distance values and stores them in the page object. It also initializes size pending and drag pending flags:</P>
<P><BR></P>
<pre><code>m_fDragPending=FALSE;<BR>m_fSizePending=FALSE;<BR><BR>m_cxyDist=GetProfileInt(TEXT("windows"), TEXT("DragMinDist")<BR>    , DD_DEFDRAGMINDIST);<BR>m_cDelay=GetProfileInt(TEXT("windows"), TEXT("DragDelay")<BR>    , DD_DEFDRAGDELAY);</code></pre>
<P>When the left mouse button is pressed in a sizing handle or the pick region, <I>CPage::OnLeftDown </I>sets the type of operation pending, saves the exact location of the click, and starts a timer, as shown in the code  for the drag operation. (The FALSE return value indicates that the mouse event doesn't modify the tenant.)</P>
<P><BR></P>
<pre><code>if (HTCAPTION==m_uHTCode)<BR>    {<BR>    m_fDragPending=TRUE;<BR>    m_ptDown.x=x;<BR>    m_ptDown.y=y;<BR>    m_uKeysDown=uKeys;<BR>    m_fTimer=TRUE;<BR>    SetTimer(m_hWnd, IDTIMER_DEBOUNCE, m_cDelay, NULL);<BR>    return FALSE;<BR>    }</code></pre>
<P>When the timer expires, Patron's pages window (managed in <I>CPages</I>) picks up a WM_TIMER message and calls <I>CPage::OnTimer </I>(PAGEMOUS.CPP), which kills the timer and starts the type of operation that was pending:</P>
<P><BR></P>
<pre><code>void CPage::OnTimer(UINT uID)<BR>    {<BR>    if (m_fSizePending œœ m_fDragPending)<BR>        {<BR>        BOOL        fSize=m_fSizePending;<BR>        BOOL        fDrag=m_fDragPending;<BR><BR>        m_fSizePending=FALSE;<BR>        m_fDragPending=FALSE;<BR><BR>        KillTimer(m_hWnd, IDTIMER_DEBOUNCE);<BR>        m_fTimer=FALSE;<BR><BR>        if (fDrag)<BR>            {<BR>            POINT       pt;<BR><BR>            GetCursorPos(&amp;pt);<BR>            m_pPG-&gt;m_fDirty œ= DragDrop(m_uKeysDown<BR>                , m_ptDown.x, m_ptDown.y);<BR>            return;<BR>            }<BR><BR>        if (fSize)<BR>            StartSizeTracking();<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>If the mouse moves during this delay period, <I>CPage::OnMouseMove </I>is called. If there is a pending size or drag and the mouse has moved more than the minimum distance, the appropriate operation is started:</P>
<P><BR></P>
<pre><code>void CPage::OnMouseMove(UINT uKeys, int x, int y)<BR>    {<BR>    §<BR><BR>    if (m_fSizePending œœ m_fDragPending)<BR>        {<BR>        int     dx, dy;<BR><BR>        dx=(x&gt;m_ptDown.x) ? (x-m_ptDown.x) : (m_ptDown.x-x);<BR>        dy=(y&gt;m_ptDown.y) ? (y-m_ptDown.y) : (m_ptDown.y-y);<BR><BR>        if (dx&gt;m_cxyDist œœ dy&gt;m_cxyDist)<BR>            {<BR>            [Code like that in OnTimer to start a drag or a size]<BR>            }<BR>        [Other code omitted]<BR>        }<BR><BR>    [Other code omitted]<BR>    }</code></pre>
<P>The final thing to remember is to kill the timer if the mouse button is released before the timer elapses. This is done in <I>CPage::OnLeftUp</I>,<I> </I>which also resets both pending operation flags to FALSE.</P>
<H4><A NAME="sec1"></A>Moving a Tenant on a Page</H4><P>After a drag-and-drop operation is finished, Patron checks to see whether the source and the target were the same window, using the <I>m</I><I>_</I><I>fDragSource </I>flag as we did in Cosmo to avoid extra work. This flag is stored in the <I>CPages </I>class. Patron also has a flag in <I>CPages </I>named <I>m</I><I>_</I><I>fMoveInPage</I>, initially set to FALSE. Now look at <I>IDropTarget::Drop</I> in DROPTGT.CPP—if <I>m</I><I>_</I><I>fDragSource</I> is TRUE and the last effect was DROPEFFECT_MOVE, we can set <I>m</I><I>_</I><I>fMoveInPage</I> to TRUE. In all other cases, <I>m</I><I>_</I><I>fMoveInPage</I> remains FALSE. Setting <I>m</I><I>_</I><I>fMoveInPage</I> to TRUE tells <I>CPage::DragDrop </I>to do nothing more than move a tenant after <I>DoDragDrop </I>returns. This invalidates the tenant's old position (for repaint) and ensures that the new tenant position is clipped to the page boundaries. The following sequence of code performs all the operations necessary for this special case:</P>
<P><BR></P>
<pre><code>//In CPage::DragDrop<BR>m_pPG-&gt;m_fDragSource=TRUE;<BR>m_pPG-&gt;m_fMoveInPage=FALSE;<BR>hr=DoDragDrop(...);<BR><BR>//In CDropTarget::Drop<BR>if (m_pDoc-&gt;m_pPG-&gt;m_fDragSource &amp;&amp; !(grfKeyState &amp; MK_CONTROL))<BR>    {<BR>    *pdwEffect=DROPEFFECT_MOVE;<BR>    m_pDoc-&gt;m_pPG-&gt;m_fMoveInPage=TRUE;<BR>    m_pDoc-&gt;m_pPG-&gt;m_ptDrop=po.ptl;<BR>    return NOERROR;<BR>    }<BR><BR>//In CPage::DragDrop<BR>if (m_pPG-&gt;m_fMoveInPage)<BR>    {<BR>    m_pTenantCur-&gt;Invalidate();<BR><BR>    [Code to clip the rectangle to page boundaries]<BR><BR>    m_pTenantCur-&gt;RectSet(&amp;rcl, TRUE);<BR>    m_pTenantCur-&gt;Repaint();<BR>    return TRUE;<BR>    }</code></pre>
<P>If <I>m</I><I>_</I><I>fMoveInPage </I>is not set after <I>DoDragDrop</I>, Patron knows that the end user is either copying a tenant on the same page or accepting a drop from something external. In either case, <I>CDropTarget::Drop </I>pastes a new tenant by calling <I>CPatronDoc::PasteFromData</I>—that manifestly useful function. <I>PasteFromData</I> doesn't know or care about the source of the data; it simply makes a new copy. Therefore, no special cases are needed to copy a tenant within the same page:</P>
<P><BR></P>
<pre><code>//In CDropTarget::Drop<BR>m_pDoc-&gt;m_pPG-&gt;m_fMoveInPage=FALSE;<BR>fRet=m_pDoc-&gt;FQueryPasteFromData(pIDataSource, &amp;fe, &amp;tType);<BR><BR>if (fRet)<BR>    {<BR>    po.fe=(m_pDoc-&gt;m_cf==fe.cfFormat) ? m_fe : fe;<BR>    fRet=m_pDoc-&gt;PasteFromData(pIDataSource, &amp;fe, tType, &amp;po, 0);<BR>    }<BR><BR>if (!fRet)<BR>    return ResultFromScode(E_FAIL);<BR><BR>*pdwEffect=DROPEFFECT_MOVE;<BR><BR>if (grfKeyState &amp; MK_CONTROL)<BR>    *pdwEffect=DROPEFFECT_COPY;<BR><BR>return NOERROR;</code></pre>
<P>Finally, <I>CPage::DragDrop</I> must delete the originally picked tenant if a move occurred to an external target. It accomplishes this by calling <I>CPage::TenantDestroy</I>:</P>
<P><BR></P>
<pre><code>if (DROPEFFECT_MOVE==dwEffect)<BR>    {<BR>    TenantDestroy();<BR>    return TRUE;<BR>    }</code></pre>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 Some applications perform different actions on selected data depending on whether the end user quickly clicked the mouse button or clicked it and held it down for a little while. Microsoft Word 6 for example will start a drag and drop if you click and hold the mouse button in a block of selected text for 200 ms or so. If you click quickly it will remove the selection and place the text caret at the click point.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
