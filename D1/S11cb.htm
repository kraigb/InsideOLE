<HTML><HEAD><TITLE>Creating or Obtaining Monikers and Display Names</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Creating or Obtaining Monikers and Display Names</H3><P>The first interesting question for LinkUser is how it will come by the monikers it holds in its lists. We could have LinkSource copy a moniker for one of its objects to the clipboard where the data is essentially a piece of global memory containing a moniker's persistent stream. In other words, LinkSource might call <I>CreateStreamOnHGlobal</I>, save a moniker into it with <I>OleSaveToStream</I>, and then put that memory on the clipboard; LinkUser could then paste the global memory, call <I>CreateStreamOnHGlobal </I>itself, and then call <I>OleLoadFromStream </I>to re-create the moniker. LinkSource could also copy a display name to the clipboard, which LinkUser could paste as text and then parse into a moniker (which would be very expensive for just a paste!). Either solution would work perfectly fine, in fact, but as we'll see in the next few chapters, OLE has a specific stream-based moniker format that allows us to copy links via the clipboard as well as through OLE Drag and Drop.</P>
<P>So for now, LinkUser creates the monikers itself because it has intimate knowledge of LinkSource. As we discussed earlier in this chapter, however, you can create an identical moniker with the same sequence of function calls. So while we could have LinkSource create monikers and pass them to LinkUser, simplicity argues to have LinkUser do it. This is, of course, not feasible when you have a client that wants to use links to a variety of sources of which it does not<I> </I>have intimate knowledge—that's the whole idea behind linked objects in OLE Documents.</P>
<P>LinkUser creates its monikers from hard-coded strings inside <I>CApp::CreateMonikers </I>(LINKUSER.CPP), in which the strings assume knowledge of LinkSource (such as the proper delimiter and the filename—do change the filename if you installed these samples in a directory other than C:\INOLE):</P>
<P><BR></P>
<pre><code>BOOL CApp::CreateMonikers(void)<BR>    {<BR>    TCHAR       szFile[]=TEXT("c:\\inole\\chap09\\linksrc\\goop.lks");<BR>    TCHAR       szItem1[]=TEXT("Object 2");<BR>    TCHAR       szItem2[]=TEXT("Sub-Object 3");<BR>    TCHAR       szDelim[]=TEXT("!");<BR>    IMoniker   *pmkItem;<BR>    HRESULT     hr;<BR><BR>    //Create simple file moniker.<BR>    if (FAILED(CreateFileMoniker(szFile, &amp;m_rgpmk[0])))<BR>        return FALSE;<BR><BR>    //Create File!Item moniker--item first, then composite.<BR>    if (FAILED(CreateItemMoniker(szDelim, szItem1, &amp;pmkItem)))<BR>        return FALSE;<BR><BR>    //The output here will be File!Item moniker.<BR>    hr=m_rgpmk[0]-&gt;ComposeWith(pmkItem, FALSE, &amp;m_rgpmk[1]);<BR>    pmkItem-&gt;Release();<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    /*<BR>     * Now create File!Item!Item by appending another item<BR>     * to the File!Item just created.<BR>     */<BR>    if (FAILED(CreateItemMoniker(szDelim, szItem2, &amp;pmkItem)))<BR>        return FALSE;<BR><BR>    hr=m_rgpmk[1]-&gt;ComposeWith(pmkItem, FALSE, &amp;m_rgpmk[2]);<BR>    pmkItem-&gt;Release();<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>You can see that the basic idea is to create the simplest moniker first and then compose more specific monikers to append to the first in order to create more complex names. Stripped to the bare minimum, the sequence is essentially as follows:</P>
<P><BR></P>
<pre><code>CreateFileMoniker(..., &amp;pmkFile);<BR>CreateItemMoniker(..., &amp;pmkItem1);<BR>pmkFile-&gt;ComposeWith(pmkItem1, ..., &amp;pmkComp1);<BR>CreateItemMoniker(..., &amp;pmkItem2);<BR>pmkComp1-&gt;ComposeWith(pmkItem2, ..., &amp;pmkComp2);</code></pre>
<P>Note that to create a composite we're always calling one moniker's <I>ComposeWith </I>member instead of directly creating a generic composite. Because we're using nothing but OLE's standard file and item monikers, we actually know that each of them will create a generic composite internally, so we might do the same ourselves. However, this is not a valid assumption for other moniker types or for composing a file moniker to another file moniker, which results in a single file moniker. For this reason, clients that are not familiar with the types of monikers they are fabricating should always use <I>ComposeWith</I>. A source that understands those monikers can use <I>CreateGenericComposite </I>directly if you want it to, but that is hardly more efficient than calling <I>ComposeWith</I>. I recommend the latter.</P>
<P>With these three monikers in hand (inside the array <I>CApp::m</I><I>_</I><I>rgpmk</I>), LinkUser places their display names in a list box that fills its client area, as shown in Figure 9-7. This all happens in <I>CApp::ListInitialize</I>, which makes a call to <I>IMoniker::GetDisplayName</I>:</P>
<P><BR></P>
<pre><code>BOOL CApp::ListInitialize(void)<BR>    {<BR>    UINT        i;<BR><BR>    for (i=0; i &lt; CMONIKERS; i++)<BR>        {<BR>        LPOLESTR    pszName;<BR>        HRESULT     hr;<BR>        IBindCtx   *pbc;<BR><BR>        if (FAILED(CreateBindCtx(0, &amp;pbc)))<BR>            return FALSE;<BR><BR>        hr=m_rgpmk[i]-&gt;GetDisplayName(pbc, NULL, &amp;pszName);<BR>        pbc-&gt;Release();<BR><BR>        if (FAILED(hr))<BR>            return FALSE;<BR><BR>        SendMessage(m_hWndList, LB_ADDSTRING, 0, (LPARAM)pszName);<BR>        CoTaskMemFree((void *)pszName);<BR>        }<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>You'll see that because <I>GetDisplayName </I>needs a bind context, we create a default one here, and the output string must be freed with <I>CoTaskMemFree</I>.</P>
<P>LinkUser will hold these three monikers until termination, at which point cleanup is a simple call to <I>IMoniker::Release</I>.</P>
<P>    <img src="f09dd07p.gif"></P>
<P><B>Figure 9-7.</B></P>
<P><B>LinkUser's list of moniker display names.</B></P></font></body></HTML>
