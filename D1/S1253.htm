<HTML><HEAD><TITLE>Variation V: The Standard Dispatch</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Variation V: The Standard Dispatch</H3><P>All of our variations on the Beeper object so far have supported both English and German. If you don't need to support more than one language in an automation object, you can simplify your implementation even more by completely eliminating your own <I>IDispatch</I> entry points, as demonstrated in the Beeper5 sample, which is English-only (CHAP14\BEEPER5).</P>
<P>This is made possible through a standard implementation of <I>IDispatch</I> that OLE provides through the function <I>CreateStdDispatch</I>. This function creates an object on which your own object must aggregate, as you learned in  Chapter 2. In other words, the standard dispatch object provides only an <I>IDispatch</I> interface, and in order for it to provide the correct behavior through its <I>IUnknown</I> functions, it has to know about your object—the outer object.</P>
<P>The standard dispatch object supports only one locale because you have to pass a language-specific <I>ITypeInfo</I> pointer to <I>CreateStdDispatch</I>, so this is the only language that the object will recognize. If you need to support multiple languages from within a single instance of an object, it is best to stick with implementing <I>IDispatch</I> using <I>ITypeInfo</I>'s help. This doesn't mean that you can make only a binary that supports a single language with <I>CreateStdDispatch</I>; it's just that each instance will be fixed for a particular language, and at crea-tion time you do not yet know which language the controller will ask for later. But if you want to support only a neutral language or the user's local language, <I>CreateStdDispatch</I> is a great convenience.</P>
<P>Some documentation says that the standard dispatch object doesn't support custom exceptions, the kind of exceptions we've been raising in the last few variations. With the advent of the error object feature, this is no longer true. Internally, the standard dispatch looks about the same as the <I>IDispatch</I> in Beeper3 except that it doesn't handle multiple locales in <I>GetTypeInfo</I>. But it still uses <I>ITypeInfo::Invoke</I>, which in turn looks for an error object, so you can support exceptions now when using the standard dispatch object.</P>
<P>I got on a cleaning binge when I removed the <I>CImpIDispatch</I> class from Beeper5, so I also got rid of all the exception handling code to keep Beeper5 as simple as possible. What is left to show is how we create the standard dispatch object and how we have to modify <I>CBeeper::QueryInterface.</I> The rest of the implementation is the same as for Beepers 2 and 3, using an implementation of <I>IBeeper</I> (although <I>put</I><I>_</I><I>Sound</I> no longer raises exceptions).</P>
<P>To call <I>CreateStdDispatch</I>, as we do in <I>CBeeper::Init</I>, we must first have a pointer to the correct <I>ITypeInfo</I>, which we obtain using code similar to what we used in our <I>IDispatch::GetTypeInfo</I>:</P>
<P><BR></P>
<pre><code>BOOL CBeeper::Init(void)<BR>    {<BR>    LPUNKNOWN       pIUnknown=this;<BR>    ITypeLib       *pITypeLib;<BR>    HRESULT         hr;<BR><BR>    if (NULL!=m_pUnkOuter)<BR>        pIUnknown=m_pUnkOuter;<BR><BR>    if (FAILED(LoadRegTypeLib(LIBID_BeeperTypeLibrary, 1, 0<BR>        , LANG_NEUTRAL, &amp;pITypeLib)))<BR>        {<BR>        if (FAILED(LoadTypeLib(OLETEXT("BEEP0000.TLB"), &amp;pITypeLib)))<BR>            return FALSE;<BR>        }<BR><BR>    hr=pITypeLib-&gt;GetTypeInfoOfGuid(IID_IBeeper, &amp;m_pITINeutral);<BR>    pITypeLib-&gt;Release();<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    hr=CreateStdDispatch(pIUnknown, (IBeeper *)this, m_pITINeutral<BR>        , &amp;m_pIUnkStdDisp);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>You'll see that <I>CreateStdDispatch</I> also takes a pointer to our controlling unknown—our custom interface (which in turn is given to <I>ITypeInfo::Invoke</I>)—and always returns an <I>IUnknown</I> pointer. This last point is true because our Beeper object aggregates the <I>IDispatch</I> interface from the standard dispatch object. According to the aggregation rules, a newly created object in an aggregate must return an <I>IUnknown</I> pointer initially.</P>
<P>This <I>IUnknown</I> pointer is then used in the implementation of <I>QueryInterface</I> as follows:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeper::QueryInterface(REFIID riid, PPVOID ppv)<BR>    {<BR>    *ppv=NULL;<BR><BR>    if (IID_IUnknown==riid)<BR>        *ppv=this;<BR><BR>    if (IID_IDispatch==riid œœ IID_IBeeper==riid)<BR>        return m_pIUnkStdDisp-&gt;QueryInterface(IID_IDispatch, ppv);<BR><BR>    if (NULL!=*ppv)<BR>        {<BR>        ((LPUNKNOWN)*ppv)-&gt;AddRef();<BR>        return NOERROR;<BR>        }<BR><BR>    return ResultFromScode(E_NOINTERFACE);<BR>    }</code></pre>
<P>You might be slightly surprised to know that <I>CreateStdDispatch</I> also works with a dual interface implementation. The standard dispatch object still implements <I>IDispatch</I> for you, although in having a dual interface you'll still have your own set of <I>IDispatch</I> entry points. Those entry points, however, need do nothing more than delegate the call to the standard dispatch's <I>IDispatch</I>, which you query for from the <I>IUnknown</I> returned from <I>CreateStdDispatch.</I> After you obtain this pointer, you should release that original <I>IUnknown</I> to keep your outer object's reference count correct.</P></font></body></HTML>
