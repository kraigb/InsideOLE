<HTML><HEAD><TITLE>Persistent Storage and Emulation</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Persistent Storage and Emulation</H2><P>Chapter 5 described how one server could mark itself to emulate another CLSID using the <I>TreatAs </I>and <I>AutoTreatAs </I>registry keys. In that discussion, emulation was related only to a component's objects and interfaces—that is, its run-time functionality. But what if those objects implement <I>IPersistStorage</I>, <I>IPersistStream[Init]</I>, or <I>IPersistFile</I>? In that case, not only must the emulating object match the original's functionality, it must also emulate the original's storage. In other words, the emulating object must be able to read and write the same data formats as the original. This means that the object has knowledge about the original object's persistence model and data structures in order for it to read and write those structures.</P>
<P>When an emulating object overwrites the original object's storage, the object (the CLSID and the persistent data) is said to be permanently <I>converted </I>to the newer CLSID. This means that if emulation were removed, the original object could no longer work with the data in the storage. This process is currently limited to compound document objects and OLE controls that support <I>IPersistStorage</I>. The user interface elements and API functions that deal with conversion are found in OLE Documents. We'll see them in Chapters 17–19. The client and object must cooperate to make conversion work, and the only standards defined for that cooperation are part of OLE Documents.</P></font></body></HTML>
