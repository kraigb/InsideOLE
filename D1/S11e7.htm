<HTML><HEAD><TITLE>IDataObject as a Standard for Object Data Transfer</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2><I>IDataObject</I> as a Standard for Object Data Transfer</H2><P>As I mentioned, <I>IDataObject</I> is the standardized interface for data exchange. It makes sense for any object capable of performing any type of data transfer to do as much as it can through <I>IDataObject</I> instead of through custom interfaces. We can see this in practice with the Polyline component object we've used in earlier chapters. In Chapter 8, we eliminated the private members of the <I>IPolyline5 </I>interface that had to do with file input and output and replaced those members with the <I>IPersistStorage </I>and <I>IPersistStreamInit </I>interfaces. Now we can do the same thing in CHAP10\POLYLINE, replacing the data exchange members of <I>IPolyline8</I>, shown in the following, with <I>IDataObject</I>:</P>
<P><BR></P>
<pre><code>//From Chapter 8's Polyline<BR>interface IPolyline8 : public IUnknown<BR>    {<BR>    [Other members]<BR><BR>    STDMETHOD(DataSet)      (THIS_ LPPOLYLINEDATA, BOOL, BOOL) PURE;<BR>    STDMETHOD(DataGet)      (THIS_ LPPOLYLINEDATA) PURE;<BR>    STDMETHOD(DataSetMem)   (THIS_ HGLOBAL, BOOL, BOOL, BOOL) PURE;<BR>    STDMETHOD(DataGetMem)   (THIS_ HGLOBAL FAR *) PURE;<BR>    STDMETHOD(RenderBitmap) (THIS_ HBITMAP FAR *) PURE;<BR>    STDMETHOD(RenderMetafile) (THIS_ HMETAFILE FAR *) PURE;<BR>    STDMETHOD(RenderMetafilePict) (THIS_ HGLOBAL FAR *) PURE;<BR><BR>    [Other members]<BR>    }</code></pre>
<P>In other words, we can eliminate from <I>IPolyline8</I> all the separate functions for exchange of its native data in both get and set directions because FORMATETC allows us to specify different formats and different mediums through <I>IDataObject </I>calls directly. The new interface, <I>IPolyline10</I>,<I> </I>for this chapter's version of Polyline no longer has these specific member functions.</P>
<P>In addition, Polyline has been working with its own private notification interface, <I>IPolylineAdviseSink8</I>, with members such as <I>OnDataChange</I>, <I>OnPointChange</I>, and so on. With the addition of <I>IDataObject </I>to the Polyline object, we can remove the <I>OnDataChange</I> member from the updated <I>IPolylineAdviseSink10 </I>interface and instead use <I>IAdviseSink </I>for this notification. Any client can now use Polyline for data exchange and notification without having to be aware of the custom <I>IPolyline10</I> and <I>IPolylineAdviseSink10</I> interfaces.</P>
<P>Along with these changes to Polyline are the necessary changes to Component Cosmo (CHAP10\COCOSMO), as follows:</P>
<UL><LI>Polyline has one additional file, IDATAOBJ.CPP, which implements the <I>IDataObject</I> interface for the <I>CPolyline</I> class.</LI><LI>Polyline maintains a data advise holder object internally for implementing the advise members of <I>IDataObject.  </I>Where Polyline used to call <I>IPolylineAdviseSink8::OnDataChange</I>, it now calls <I>IDataAdviseHolder:</I><I>:SendOnDataChange</I>.</LI><LI><I>IPolyline8::DataSet</I> and <I>IPolyline8::DataGet</I> are now private member functions of the C++ <I>CPolyline</I> class because they are used internally by the Polyline object in the rest of its implementation.</LI><LI>Polyline now registers a private clipboard format ("Polyline Figure") to identify its native data.</LI><LI>Polyline implements <I>IDataObject::EnumFormatEtc </I>using <I>OleRegEnumFormatEtc  </I>and registry entries for its native Polyline Figure format, CF_METAFILEPICT, and for CF_BITMAP.</LI><LI>CoCosmo adds the file IADVSINK.CPP, in which it receives <I>OnDataChange</I> notifications from Polyline. CoCosmo implements the <I>IAdviseSink</I> interface as part of its <I>CCosmoDoc</I> object, which now uses multiple inheritance from both its normal base class <I>CDocument </I>and <I>IAdviseSink.</I>  Take a look at <I>CCosmoDoc::QueryInterface </I>to see why you must be careful to correctly typecast the pointers you assign to the <I>void </I>**<I> </I>out-parameter.  Failure to do this can cause all sorts of strange problems, such as premature calls to the document destructor, as we described in Chapter 2.</LI><LI>CoCosmo implements a set of <I>IUnknown</I> members on its <I>CCosmoDoc</I> class to support the interface implementation of <I>IAdviseSink</I>.</LI><LI>All of CoCosmo's clipboard handling in <I>CCosmoDoc::RenderFormat</I> and <I>CCosmoDoc::Paste</I> now work through Polyline's <I>IDataObject</I>, which CoCosmo queries for when needed.</LI></UL><P>None of the code to implement these features is much different from the code we've seen so far, so there's no need to show any of it here. However, with the addition of <I>IDataObject</I> along with <I>IPersistStorage</I>, the Polyline object is now very close to an embedded content object. What it lacks are the interfaces <I>IViewObject2</I>, which we'll see in the next chapter, and <I>IOleObject</I>, which we'll see in Chapter 19. Even when we make those changes, Component Cosmo can still use Polyline as before, totally ignoring any additional interfaces. This shows the flexibility of the multiple interface paradigm made possible by <I>QueryInterface. </I>In later chapters, we'll see how Polyline can support two different types of client (CoCosmo with inside knowledge and a container with no knowledge outside OLE Documents) merely by implementing a number of interfaces for both.</P></font></body></HTML>
