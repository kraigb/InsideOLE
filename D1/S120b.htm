<HTML><HEAD><TITLE>Sources and Targets: The OLE Drag and Drop Protocol</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Sources and Targets: The OLE Drag and Drop Protocol</H2><P>To illustrate how OLE Drag and Drop works, let's begin with an end user who wants to transfer selected data from a source to a consumer. The source and the consumer might be different applications, different windows (documents, say) in the same application, or the same window inside a single application. As shown in Figure 13-1, OLE sits between the two, so there really isn't any distinction. As with the clipboard, the source must wrap its selected data into a data object.</P>
<P>The problem for drag and drop is how to get the <I>IDataObject</I> pointer from the source to the consumer or target. To prepare for this, the source first requires an implementation of the <I>IDropSource</I> interface, as shown in Figure 13-2, in which the object in question needs only to support this one interface. <I>IDropSource</I> has two specific member functions, as shown in the table on the facing page.</P>
<P>    <img src="f13dd01.gif"></P>
<P><B>Figure 13-1.</B></P>
<P><B>Prior to a drag-and-drop operation, the source has a data object for the selected data. The source and the consumer can be different applications, different documents in the same application, or the same document.</B></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="118pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>QueryContinueDrag</P></TD><TD VALIGN="TOP"><P>Determines what conditions continue or cancel an operation. Also determines what causes a drop because only the source knows what started the operation.</P></TD></TR><TR><TD VALIGN="TOP"><P>GiveFeedback</P></TD><TD VALIGN="TOP"><P>Sets the mouse cursor appropriate for an <I>effect</I> flag that indicates what would happen if the data were dropped in the target under the mouse cursor. The source can also control other user interface elements within this function.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>    <img src="f13dd02.gif"></P>
<P><B>Figure 13-2.</B></P>
<P><B>Objects necessary in both the source and the target to facilitate a drag-and-drop operation.</B></P>
<P>The target, in order to accept data from a drag-and-drop operation, must provide an object implementing <I>IDropTarget</I>,<I> </I>also shown in Figure 13-2. This object must then be attached to some window so that OLE can retrieve the <I>IDropTarget</I><I> </I>pointer from the HWND it finds under the mouse cursor during a drag-and-drop operation. This association is accomplished through the OLE API function <I>RegisterDragDrop</I>, as shown in Figure 13-3. <I>RegisterDragDrop</I> takes an HWND and an <I>IDropTarget</I> pointer, calls <I>IDropTarget::AddRef</I>, and attaches that pointer as a window property to the HWND (using the Windows API <I>SetWindowProp</I>). At this point, the window is an open target. When the consumer no longer wants to be a target, it calls <I>RevokeDragDrop</I>,<I> </I>which removes the window property and releases the pointer.</P>
<P><B>N</B><B>ote</B><B>:</B>  IDropTarget members are given the current mouse position in screen coordinates (in a POINTL structure). The target usually needs to call ScreenToClient before hit-testing the mouse position against other client-area coordinates.</P>
<P></P>
<P>    <img src="f13dd03.gif"></P>
<P><B>Figure 13-3.</B></P>
<P><B>A consumer registers itself as a drop target by passing a window handle and an <I>IDropTarget</I> pointer to <I>RegisterDragDrop</I>.</B></P>
<P><I>IDropTarget</I> itself has four specific member functions:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="74pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>DragEnter</P></TD><TD VALIGN="TOP"><P>Indicates that the mouse has entered the window associated with this drop target. The target initializes its drag-and-drop state and provides visible feedback to the user.</P></TD></TR><TR><TD VALIGN="TOP"><P>DragOver</P></TD><TD VALIGN="TOP"><P>Indicates that the mouse has moved within the window, the keyboard state has changed, or an internal OLE timer has expired. This function provides the target with a <I>pulse</I> through which it controls user feedback and indicates the effect of a drop if it occurred at this very moment. The source is given this effect flag through <I>IDropSource::GiveFeedback</I>,<I> </I>in which it controls the mouse cursor.</P></TD></TR><TR><TD VALIGN="TOP"><P>DragLeave</P></TD><TD VALIGN="TOP"><P>Indicates that the mouse has moved out of the window. The target cleans up its state from <I>DragEnter </I>and <I>DragOver </I>and removes any visual feedback.</P></TD></TR><TR><TD VALIGN="TOP"><P>Drop</P></TD><TD VALIGN="TOP"><P>Indicates that the source's <I>IDropSource::QueryContinueDrag</I> said "drop." The target performs a paste and cleans up as in <I>DragLeave</I>.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The stage is now set for the operation to commence. The source must provide some means for starting a drag-and-drop operation, which is typically a WM_LBUTTONDOWN (or other mouse button message) on a particular region of the selected data, such as the outer edge of a rectangle. When this event occurs, the source passes its <I>IDropSource</I> and <I>IDataObject</I> pointers to the OLE function <I>DoDragDrop</I>, as shown in Figure 13-4.</P>
<P>    <img src="f13dd04.gif"></P>
<P><B>Figure 13-4.</B></P>
<P><B>A source starts a drag-and-drop operation by passing its <I>IDataObject</I> and <I>IDropSource</I> to <I>DoDragDrop</I>.</B></P>
<P>Internally, <I>DoDragDrop</I> enters a loop that monitors changes in the state of the mouse and the keyboard, executing the following sequence, as illustrated in Figure 13-5:</P>
<P>Call <I>WindowFromPoint </I>(Win32) with the current mouse coordinates, and then attempt to retrieve the <I>IDropTarget </I>associated with the window if it exists. If not, <I>DoDragDrop</I> passes DROPEFFECT_NONE to the source's <I>IDropSource::GiveFeedback</I>,<I> </I>which displays a no-drop mouse cursor. If OLE doesn't find a drop target for a child window, it will attempt to find one for the parent window of the child, up to the top-level window of any such ancestry.</P>
<P>Call <I>IDropTarget::DragEnter</I>, passing the source's <I>IDataObject</I> (marshaled if necessary). The target determines whether there is usable data in the data object and returns an appropriate effect flag (DROPEFFECT_*) after initializing the data object's internal state.</P>
<P><I>DoDragDrop</I> passes the effect flag to <I>IDropSource::GiveFeedback. </I>This changes the mouse cursor to indicate the effect and provides whatever feedback is appropriate in the source (such as indicating that a drop would delete the source data).</P>
<P>When the mouse moves within the target window, or when the Ctrl or Shift key is pressed, or when an internal pulse timer elapses, <I>DoDragDrop </I>calls <I>IDropTarget::DragOver. IDropTarget::DragOver</I> displays user feedback, scrolls the target window if necessary, and returns an effect flag (which OLE passes to the source). If the mouse moves out of the window, <I>DoDragDrop</I> calls <I>IDropTarget::DragLeave</I> for that target, possibly calling <I>DragEnter </I>for a new target (back to step 1).</P>
<P>If the Esc key is pressed or there is a change in a mouse button state, <I>DoDragDrop </I>calls <I>IDropSource::QueryContinueDrag</I>,<I> </I>which tells OLE to continue the operation, cancel it (if the Esc key is pressed), or perform a drop (if the correct mouse conditions are met to reverse the pick). A cancellation will result in a call to the current target's <I>IDropTarget::DragLeave</I>,<I> </I>whereas a drop calls <I>IDropTarget::Drop.</I></P>
<P>The loop repeats until a drop or a cancellation occurs.</P>
<P>    <img src="f13dd05.gif"></P>
<P><B>Figure 13-5.</B></P>
<P><B>The execution sequence of <I>DoDragDrop.</I></B></P>
<P>Why does the source always maintain control of the mouse cursor? The reasoning is that when a drag-and-drop operation begins, the user is staring at the mouse cursor. From that point on, the cursor should consistently reflect any move, copy, or link effects regardless of the target under the mouse cursor. In other words, the three effects should have the same mouse cursor no matter what target specified that effect. The cursor should not change in different ways for different targets as a result of the same effect because the same cursor might then be used twice to indicate different effects. The only single agent in an entire operation is the source, so it retains control over this user interface element.</P></font></body></HTML>
