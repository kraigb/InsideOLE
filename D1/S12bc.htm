<HTML><HEAD><TITLE>Delegating to the Default Handler and Data Cache</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Delegating to the Default Handler and Data Cache</H2><P>We programmers generally do not like to make extra work for ourselves—if code has already been written somewhere, we use it. I'm not saying we're lazy; we simply like to be as resourceful as possible in finding reusable code. That's why a language such as C++ was invented in the first place and why OLE has the code-reuse mechanisms of containment and aggregation.</P>
<P>In writing handlers and in-process servers, there are a lot of interfaces to implement: <I>IOleObject</I>,<I> IDataObject</I>,<I> IPersistStorage</I>,<I> IRunnableObject</I>,<I> IOleCache2</I>,<I> </I>and possibly<I> IOleCacheControl. </I>Many of these, however, you can obtain through aggregation with the default handler or the data cache. A handler always aggregates on the default handler by calling <I>OleCreateDefaultHandler </I>(which takes arguments similar to <I>CoCreateInstance</I>), exposing many of the default handler's interfaces directly through aggregation and delegating other selected calls through containment as necessary. An in-process server aggregates on the data cache through <I>CreateDataCache</I>, again exposing some of its interfaces directly and delegating to others. The in-process server generally implements <I>IOleObject </I>and <I>IRunnableObject </I>by itself, exposes the caching interfaces directly, and delegates a good number of calls to the other three interfaces to the cache's implementation, especially for display aspects that the server doesn't want to manage directly.</P>
<P>We've already explored the behavior of the data cache in Chapter 11, where we articulated the specific functionality of its <I>IDataObject</I>,<I> IPersistStorage</I>,<I> IViewObject2</I>,<I> IOleCache2</I>,<I> </I>and<I> IOleCacheControl </I>interfaces. (Please refer to Tables 11-1 through 11-4 on pages 552 through 556 for a refresher on the data cache.) Remember that the data cache will never attempt to launch a local server itself. That's not part of its design! Nor does an in-process server ever need a local server, of course.</P>
<P>Running the local server is, however, part of the design of the default handler. To understand how we can make use of the handler we need to see how it behaves through all of these interfaces as well as through <I>IOleObject. </I>In general, an object handler will directly expose the default handler's <I>IDataObject</I>,<I> IRunnableObject</I>,<I> IOleCache2</I>,<I> </I>and <I>IOleCacheControl </I>interfaces (and possibly also <I>IOleObject </I>and <I>IPersistStorage</I>) through aggregation. Handlers designed for the express purpose of display and printing optimization will generally implement only portions of <I>IViewObject2 </I>themselves and then delegate the remainder of that interface to the default handler. We'll see an example later in this chapter.</P>
<P>The default handler itself uses the data cache internally. In fact, the default handler generally exposes the cache's <I>IPersistStorage</I>, <I>IViewObject2</I>,<I> IOleCache2</I>,<I> </I>and <I>IOleCacheControl </I>interfaces. For <I>IPersistStorage</I>,<I> </I>the default handler will delegate the call to a running object and then to the cache; otherwise, it just delegates to the cache. In either case, the behavior of these interfaces through the default handler is identical to the behavior of the cache. That leaves us to examine <I>IOleObject </I>and <I>IDataObject</I> (which are covered in the next two sections) and <I>IRunnableObject</I>. This last interface has a simple implementation: if the object isn't running, calling <I>IRunnableObject::Run </I>will launch the server but all other members will fail. (<I>IsRunning </I>will return S_FALSE.) If the object is running, <I>Run </I>and <I>IsRunning </I>will succeed and other calls are forwarded to the object.</P></font></body></HTML>
