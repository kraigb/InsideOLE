<HTML><HEAD><TITLE>Data Change Notifications with IAdviseSink</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Data Change Notifications with <I>IAdviseSink</I></H3><P>A consumer of data from a particular source frequently wants to know when the data changes in that source so that the consumer can request a new rendering. For example, a client application that displays real-time market data would want to know when certain stock issues change their value or volume. In this sort of relationship, the source must notify the consumer when data changes occur, which means the consumer must provide some sort of sink implementation to absorb these notifications.</P>
<P>We've already explored the general concept of a sink object in Chapter 4; for the purposes of change notification, a data object needs an <I>IAdviseSink </I>pointer to the sink:</P>
<P><BR></P>
<pre><code>interface IAdviseSink : IUnknown<BR>    {<BR>    void OnDataChange(FORMATETC *pFE, STGMEDIUM *pSTM);<BR>    void OnViewChange(DWORD dwAspect, LONG lindex);<BR>    void OnRename(LPMONIKER pmk);<BR>    void OnSave(void);<BR>    void OnClose(void);<BR>    };</code></pre>
<P>Only the <I>OnDataChange </I>member function of <I>IAdviseSink</I> has relevance to data objects. <I>OnViewChange </I>has relevance to viewable objects, which we'll see in Chapter 11, and the other members have relevance to OLE Documents. (See Chapters 17 and 18.) There is also an <I>IAdviseSink2 </I>interface with one more member function—<I>OnLinkSourceChange</I>—that is used in OLE Document linking scenarios, but that does not concern us here.</P>
<P>A client interested in data change notifications implements a small object with <I>IAdviseSink </I>and nothing more. Like other sinks, this object needs no CLSID and no component structure around it—the object serves no other purpose than to accept notification calls. But two major differences exist between the sink for data change notifications and the sinks we saw in Chapter 4. First, <I>IAdviseSink </I>is a completely asynchronous interface—that is, OLE's standard marshalers are built to send these notifications asynchronously. Second, data objects do not use connection points to establish a connection with a sink. To make a long story short, <I>IDataObject</I> and a few other interfaces were designed before <I>IConnectionPointContainer </I>and <I>IConnectionPoint</I>, so <I>IDataObject</I> has its own private member functions through which it handles notification: <I>DAdvise</I>, <I>DUnadvise</I>, and <I>EnumDAdvise</I>. <I>DAdvise </I>receives the client's sink and establishes a connection, <I>DUnadvise </I>terminates a connection, and <I>EnumDAdvise </I>enumerates current connections, as described earlier. <I>DAdvise </I>is somewhat richer than <I>IConnectionPoint::Advise</I>,<I> </I>as we can see by its arguments:</P>
<P><BR></P>
<pre><code>HRESULT DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink<BR>    , LPDWORD pdwConnection);</code></pre>
<P>Here <I>pAdvSink </I>specifies the client's sink object, and <I>pdwConnection </I>receives the connection key for later use with <I>DUnadvise</I>. The <I>pFE </I>argument describes the specific format and aspect for which the client would like to receive notifications, meaning that a consumer can ask for notifications concerning a single format in the data source as opposed to all formats. In addition, the consumer can ask for notifications on a specific aspect of a specific format because these can, in fact, be different renderings. In short, the notification is established for whatever format and aspect you specify in <I>pFE</I>. This is important, of course, because consumers typically use only one of many formats and aspects that the source is able to provide and thus want a change notification only for specific ones. A consumer can establish notifications for multiple formats using the same sink by calling <I>DAdvise </I>multiple times. If the consumer wants a wildcard notification, it can fill the fields of the FORMATETC structure by using <I>cfFo</I><I>rmat</I><I>=</I><I>0</I>, <I>ptd</I><I>=</I><I>NULL</I>,<I> dwAspect</I><I>=</I><FONT FACE="Symbol"><I>-</I></FONT><I>1</I>,<I> lindex</I><I>=</I><FONT FACE="Symbol"><I>-</I></FONT><I>1</I>,<I> </I>and <I>tymed</I><I>=</I><FONT FACE="Symbol"><I>-</I></FONT><I>1</I>. The sink will then receive a notification for any change in any format, where the <I>pFE </I>structure sent to <I>OnDataChange </I>will identify the exact format that changed.</P>
<P><img src="f10ddaa.gif"></P>
<P>The <I>grfAdv </I>argument specifies how the notifications should occur. The values for <I>grfAdv </I>are listed in the ADVF enumeration (shown below) and can be combined as needed. The effects of the flags relevant to <I>IDataObject::DAdvise </I>are described in Table 10-1 on the following page.4 </P>
<P><BR></P>
<pre><code>typedef enum tagADVF<BR>    {<BR>    ADVF_NODATA             = 1,<BR>    ADVF_PRIMEFIRST         = 2,<BR>    ADVF_ONLYONCE           = 4,<BR>    ADVF_DATAONSTOP         = 64,<BR>    ADVFCACHE_NOHANDLER     = 8,<BR>    ADVFCACHE_FORCEBUILTIN  = 16,<BR>    ADVFCACHE_ONSAVE        = 32<BR>    } ADVF;</code></pre>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="129pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Flag</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>ADVF_NODATA</P></TD><TD VALIGN="TOP"><P>Prevents the data object from sending data along with the <I>OnDataChange</I> notification, the default mode of operation. When ADVF_NODATA is specified, the <I>tymed</I> field of the STGMEDIUM passed to <I>OnDataChange</I> will usually contain TYMED_NULL. Some data objects might still send data anyway and <I>tymed</I> will contain another value, in which case <I>OnDataChange</I> is still responsible for freeing the STGMEDIUM contents. Be sure to check.</P></TD></TR><TR><TD VALIGN="TOP"><P>ADVF_PRIMEFIRST</P></TD><TD VALIGN="TOP"><P>Causes an initial <I>OnDataChange</I> call even when the data has not changed from its present state. If you combine ADVF_PRIMEFIRST with ADVF_ONLYONCE, you create a single asynchronous <I>IDataObject::GetData</I> call.</P></TD></TR><TR><TD VALIGN="TOP"><P>ADVF_ONLYONCE</P></TD><TD VALIGN="TOP"><P>Automatically terminates the advisory connection after the first call to <I>OnDataChange</I>. It is not necessary to call <I>DUnadvise</I> when you use this flag. You can still, however, call <I>DUnadvise</I> if you have not yet received a notification.</P></TD></TR><TR><TD VALIGN="TOP"><P>ADVF_DATAONSTOP</P></TD><TD VALIGN="TOP"><P>When provided with ADVF_NODATA, causes the last <I>OnDataChange</I> sent from the data object (before that object was destroyed) to actually provide the data—that is, <I>pSTM-&gt;tymed</I> will be a value other than TYMED_NULL. This flag is meaningless without ADVF_NODATA.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 10-1.</B></P>
<P><B>The advise flags usable with <I>IDataObject::DAdvise</I>.</B></P>
<P>A consumer must design carefully around the use of ADVF_NODATA when the source exists in another process: that consumer cannot call <I>IDataObject::GetData </I>for a new rendering from within <I>IAdviseSink::OnDataChange</I>. Recall from Chapter 6 that COM does not allow external calls to be made from within an asynchronous call, and that rule applies here. Any attempt to make such a call will result in RPC_E_CANTCALLOUT_INASYNCCALL. This means the consumer must post itself a message and return from <I>OnDataChange</I> and then call <I>IDataObject::GetData </I>later in response to that message. This allows the consumer, however, to cache multiple data change notifications together until it really needs a new rendering of the data for a repaint, which can significantly improve overall performance. The source doesn't need to render the data for each notification.</P>
<P>The next point regarding <I>IAdviseSink </I>is that like a connection point, a data object must support multicasting of data change notifications when multiple consumers can connect to that same source. OLE, however, provides a convenient service in the form of a standard <I>data advise holder</I> object that implements the interface <I>IDataAdviseHolder</I>:</P>
<P><BR></P>
<pre><code>interface IDataAdviseHolder : IUnknown<BR>    {<BR>    HRESULT Advise(LPDATAOBJECT pDataObject, FORMATETC *pFE<BR>        , DWORD advf, LPADVISESINK pAdvise, DWORD *pdwConnection);<BR>    HRESULT Unadvise(DWORD dwConnection);<BR>    HRESULT EnumAdvise(LPENUMSTATDATA *ppEnum);<BR>    HRESULT SendOnDataChange(LPDATAOBJECT pDataObject<BR>        ,DWORD dwReserved, DWORD advf);<BR>    };</code></pre>
<P>The OLE API function <I>CreateDataAdviseHolder </I>instantiates and returns a data advise holder object with this interface, exposing this particular OLE service. With this object, a source can delegate the <I>IDataObject </I>functions of <I>DAdvise</I>, <I>DUnadvise</I>, and <I>EnumDAdvise </I>directly to the <I>Advise</I>, <I>Unadvise</I>, and <I>EnumAdvise </I>members of <I>IDataAdviseHolder</I>. OLE's implementation will hold on to all of the <I>IAdvis</I><I>eSink </I>pointers itself, freeing the data object from the burden. When the data object wants to send a notification, it passes its own <I>IDataObject </I>pointer along with some ADVF_* flags to <I>SendOnDataChange</I>. The data advise holder then checks the flags for every one of the advise sinks it holds and calls <I>IAdviseSink::OnDataChange </I>for each matching one. If the flags do not include ADVF_NODATA, <I>SendOnDataChange</I> calls <I>IDataObject::GetData </I>first to obtain a rendering and sends that rendering to the sink.</P>
<P><img src="f10ddbb.gif"></P>
<P>The data advise holder thus makes the implementation of a data object's notification members trivial, as we will see later in this chapter when we look at some sample code. Note that this standard data advise holder is not exactly the fastest possible implementation of this service. If performance is really important to you, you can implement your own holder or eliminate it altogether. The latter choice is optimal if you know that the data object will have only a fixed number of connections to it, making a generic mechanism unnecessary.</P>
<P>The final point in this discussion about <I>IAdviseSink </I>is that a data object should generally call only <I>IAdviseSink::OnDataChange </I>through the pointers it received in <I>IDataObject::DAdvise</I>. According to the basic rule of interfaces, the data object could actually call any of the other members. However, this is not part of the defined relationship between <I>IDataObject</I> and <I>IAdviseSink</I>, and you can use the other notifications only when you have a consumer that expects them. So calling other data members is not a good practice when a consumer expects that only <I>OnDataChange </I>notifications will come from a data object.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="540pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>4 These are also the same flags that can appear in the <I>advf </I>field of the STATDATA structure that comes through <I>EnumDAdvise </I>and <I>IEnumSTATDATA</I>. The ADVFCACHE_* flags are related to caching as we'll see in Chapter 11.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
