<HTML><HEAD><TITLE>Who Can Use This Book</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Who Can Use This Book</H2><P>In writing this book, I assumed that readers are familiar with the Windows API (primarily the Win32 API) because OLE itself, unlike Win32, is not a technology for writing a complete application (although you could build one out of OLE components). I don't describe how to use Windows API functions, nor do I describe any of the intricate details of Windows itself. The focus of this book is strictly on OLE.</P>
<P>I also assume that readers are at least somewhat familiar with object-oriented programming because I can spend only a paragraph or two defining terms such as <I>polymorphism</I> and <I>encapsulation</I>. (Entire books could be written about these terms.) In addition, I assume a working familiarity with C++; almost all the samples are written using basic C++ constructs. If you are a C programmer, I've included some material on the companion CD that should help you understand enough C++ to understand the samples.</P>
<P>This book, however, is not intended only for programmers. In fact, the chapter organization allows a designer to gain architectural knowledge of OLE without having to wade through pages of source code listings. The first half or so of each chapter (except for Chapters 1 and 2) is devoted to architectural and theoretical concepts. The latter half of each chapter contains primarily programming details, plus a detailed look at the samples and a discussion of implementation issues.</P>
<P>The samples are written to work on systems with Windows 95, Windows NT 3.51, and Windows 3.1x (if you're still doing 16-bit work). They compile to 16-bit systems (with a couple of exceptions) as well as 32-bit systems (both ANSI and Unicode). To that end, you'll need the following development software on your system to work with the samples in this book:</P>
<UL><LI>Either Windows 95, Windows NT 3.51, or Windows 3.1 (or 3.11)</LI><LI>Microsoft Visual C++ 2.0 (or later, for 32-bit platforms) or Microsoft Visual C++ 1.51 (or later, for 16-bit platforms). Both products include the Windows Software Development Kit (SDK) for their respective platforms, which is also required. The make files for the samples in this book are specific to Microsoft compilers, so some adjustment will be necessary for other environments. Elements such as compiler flags and import libraries, however, are centralized in one file. Chapter 1 includes more information about creating the appropriate build environment for the book's samples.</LI><LI>Certain samples require the OLE Control Development Kit (CDK), which is included with Visual C++ 2.0 (and later) and Visual C++ 1.51 (and later).</LI><LI>Depending on your compiler, you may need the Win32 Software Development Kit (SDK) for certain samples as well.</LI></UL><P>Let me also mention that the OLE documentation is indispensable for working with this technology. In it you'll find all the OLE API functions and interfaces fully documented, which is not possible to do in a book such as this one. Typically, I just mention an API function, sometimes providing all the arguments but never providing the complete documentation. The same is true for OLE interfaces and their member functions.</P>
<P>In this book, I refer to the documentation simply as the <I>OLE Programme</I><I>r</I><I>'</I><I>s Reference</I>. At the time of writing, the documentation was actually named the <I>OLE 2 Programmer</I><I>'</I><I>s Reference </I>and was published in two volumes. (The second contains OLE Automation topics separately.) Over time, the organization of these volumes might change, new volumes might be added, or the documentation might be called something different. So when I point you to the <I>OLE Programmer</I><I>'</I><I>s Reference,</I> I mean you should look in your development kit for the latest documentation.</P>
<P>One last note about writing conventions before I gush with acknowledgments. OLE interfaces are sets of member functions, and I always present them in a C++ notation. When I refer to an interface as a whole, I use a notation such as <I>IDataObject.</I> In references to a member function of an interface, I use a C++ double colon, as in <I>IDataObject::GetData. </I>Once I've introduced the interface and have established the context, I often drop the interface name and refer to the function simply as <I>GetData</I>, for example. In this case, I am not referring to a global API function named <I>GetData</I> but to a member function of the interface under discussion.</P></font></body></HTML>
