<HTML><HEAD><TITLE>Binding a Composite Moniker</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Binding a Composite Moniker</H3><P>The individual binding operations of most simple monikers make sense only in the context of a composite. The binding processes for those simple monikers that can stand alone are also quite simple, as we've already seen with the file and pointer monikers. You might expect that because a composite usually contains more than one element within it, binding is just a matter of following the map, right? You only have to follow each step in order to get to the right place…or do you? There are, in fact, many reasons why following the entire sequence isn't necessary.</P>
<P>Composite monikers actually bind in a right to left order (instead of left to right), which has the practical effect of doing only as much binding as necessary. When following a map, you do not always start at the beginning—if your present location is already partway down the map. A composite moniker achieves this by reading the map in reverse order until it comes to a deterministic point. From that point, it can bind forward again.</P>
<P>A composite actually delegates most of its binding to the monikers within it by using the following algorithm, executed in its <I>IMoniker::BindToObject </I>(and <I>IMoniker::BindToStorage</I>):</P>
<P>(<I>BindToObject </I>only) Check whether the object named by this composite is currently registered in the running object table. If so, the object's <I>IUnknown </I>pointer is available from there, so the composite retrieves it and calls <I>QueryInterface </I>to obtain the pointer to return to the client. See "Binding Optimizations I: The Running Object Table" later in this chapter for more details about the running object table.</P>
<P>Separate the composite into two pieces: a <I>rightmost,</I> or <I>last,</I> moniker (<I>pmkRight</I>) and a composite containing the <I>left,</I> or <I>all but last,</I> moniker (<I>pmkLeft</I>). The composite as a whole can be viewed as AllButLast!Last or Left!Right for this purpose.</P>
<P>Call <I>pmkRight-&gt;BindToObject</I>, passing <I>pmkLeft </I>as an argument. Whatever this rightmost moniker returns from <I>BindToObject </I>is what the composite returns from its own <I>BindToObje</I><I>ct</I>.</P>
<P>The result of separating a composite into Left!Right is depicted in Figure 9-3 on the next page. In general, the Right moniker requires some services of the Left moniker in order to bind itself, which is why the composite passes Left as an argument to Right's <I>BindToObject. </I>Thus, Right usually calls <I>pmkLeft-&gt;BindToObject </I>again, and if Left is itself a composite, we'll go right back through this algorithm again.</P>
<P>    <img src="f09dd03.gif"></P>
<P><B>Figure 9-3.</B></P>
<P><B>Binding a composite moniker splits the moniker into left and right pieces and then calls <I>BindToObject </I>on the right moniker passing the left moniker. (The services of the left moniker may be required by the right.)</B></P>
<P>This algorithm effectively walks backward through the composite, asking each piece to bind in turn.<I> </I>Three conditions will stop this right to left progression:</P>
<UL><LI>The moniker to the left refers to a running object, in which case calling <I>BindToObject </I>on that left piece returns immediately.<I> </I>This does not apply to <I>BindToStorage</I>.</LI><LI>Binding reaches the first moniker in the original composite, which cannot depend on anything to its left because there is nothing to the left.<I> </I>Only a file, pointer, or suitable custom moniker can bind in the absence of a moniker to the left.</LI><LI>Partway through the original composite, binding reaches a moniker that does not depend on the moniker to the left at all.<I> </I>For example, binding a File!Item!File!Item composite would need to progress only as far as the rightmost file moniker.<I> </I>A File!Item!Pointer would end at the pointer moniker.</LI></UL><H4><A NAME="sec0"></A>A Composite Binding Example</H4><P>To illustrate this process, let's walk through the binding of a File!Item1!Item2 composite, in which the names Item1 and Item2 help us to distinguish which moniker is which.<I> </I>Let's say we have a client with a pointer to this moniker in the variable <I>pmkComp</I>.<I> </I>That client wants to obtain an <I>IProvideClassInfo </I>pointer for the object named by this moniker, so it calls <I>pmkComp-&gt;BindToObject(</I><I>…</I><I>, IID</I><I>_</I><I>IDescription, (void </I><I>**</I><I>)</I><I>&amp;</I><I>pIDesc)</I> to get the pointer.<I> </I>No problem.</P>
<P>Now we enter what we'll call the <I>outer</I> composite's <I>BindToObject</I>.<I> </I>According to the algorithm, <I>BindToObject</I> checks the running object table first.<I> </I>Let's say the object is not running (or else it would take all the fun away).<I> </I>The composite divides itself into left and right pieces, where the left piece is a File!Item1 composite and the right piece is simply Item2.<I> </I>The outer composite then calls Item2's <I>BindToObject</I>, passing File!Item1 as <I>pmkLeft</I>.</P>
<P>As described before, an item moniker must have a context in which to make sense of its persistent name.<I> </I>It depends on the <I>pmkLeft </I>it receives to provide that context in the form of an <I>IOleItemContainer </I>interface.<I> </I>So Item2 now calls <I>pmkLeft-&gt;BindToObject(</I><I>…</I><I>, IID</I><I>_</I><I>IOleItemContainer, (void </I><I>**</I><I>)</I><I>&amp;</I><I>pCont2)</I>, which puts us into the File!Item1 composite. Once again, this second composite checks whether the object is running, and failing that, it splits itself into File and Item1 monikers.<I> </I>It then calls Item1's <I>BindToObject</I>,<I> </I>passing File as <I>pmkLeft</I>.<I> </I>Item1, being an item moniker, also needs a context in which to make sense of its persistent name, so it calls <I>pmkLeft-&gt;BindToObject(</I><I>…</I><I>, IID</I><I>_</I><I>IOleItemContainer, (void </I><I>**</I><I>)</I><I>&amp;</I><I>pCont1)</I>, where <I>pmkLeft </I>is the File moniker.</P>
<P>At this point, we are four levels deep into various <I>BindToObject </I>calls.<I> </I>The outer composite called Item2, which then called Item1, which has now called the File moniker.<I> </I>Fortunately, this File moniker doesn't depend on anything to its left, so it takes its filename, calls <I>GetClassFile</I>, <I>CoCreateInstance</I>, and <I>IPersistFile::Load(pszFile)</I>. After loading is complete, the File moniker calls <I>IPersistFile::QueryInterface(riid1, ppv1)</I>, where <I>riid1 </I>and <I>ppv1 </I>are the same arguments that the File moniker received in its <I>BindToObject </I>call.<I> </I>These arguments will be <I>IID</I><I>_</I><I>IOleItemContainer </I>and <I>pCont1 </I>as passed from Item1.</P>
<P>The object that implements <I>IPersistFile </I>must also support <I>IOleItemContainer </I>to support binding this File!Item1!Item2 moniker.<I> </I>This should not be a surprise to that object because its server (the source) is probably what gave away the composite moniker in the first place.<I> </I>Either that, or the client synthesized the moniker knowing that the object supported such binding.<I> </I>This is the big rule about implementing any link-source server:<I> </I>if you give away the moniker, you have to provide the support for binding it.</P>
<P>Anyway, the File moniker succeeds in obtaining the <I>IOleItemContainer </I>pointer, which it now returns to Item1.<I> </I>This item moniker calls <I>IOleItemContainer::GetObject(pszItem1, riid2, ppv2)</I>, where <I>riid2 </I>and <I>ppv2 </I>are the arguments that Item1's <I>BindToObject </I>received from Item2.<I> </I>The <I>GetObject </I>member now must find the object named by <I>pszItem1</I>, which is the name stored in Item1.<I> </I>In something like a File!Item!Item moniker this name might be for a specific sheet in a workbook or for a specific page in a document—that is, an item in the overall file that is itself a container for still other items.<I> </I>This <I>GetObject </I>member will find the correct object for <I>pszItem1 </I>and return whatever interface pointer it was asked for.<I> </I>In this example, we have one implementation of <I>IOleItemContainer </I>returning a pointer to the same interface but on a different object.<I> </I>In other words, Item2 requires an <I>IOleItemContainer </I>pointer from Item1, which also required the same pointer from File.<I> </I>But the containers named by File and Item1 are completely separate.<I> </I>It is only because we have two item monikers in a row that <I>IOleItemContainer </I>comes up twice.</P>
<P>So the file object's <I>IOleItemContainer </I>resolves <I>pszItem1 </I>into another <I>IOleItemContainer </I>interface on the Item1 object, and this pointer is returned to Item2.<I> </I>This item then calls <I>IOleItemContainer::GetObject(pszItem2, riidOrg, ppvOrg)</I>, where <I>pszItem2 </I>is Item2's persistent name and <I>riidOrg </I>and <I>ppvOrg </I>are the arguments originally passed from the client, in this case <I>IID</I><I>_</I><I>IDescription </I>and <I>&amp;</I><I>pIDesc</I>.<I> </I>The implementation of <I>GetObject </I>(which is part of the object named by Item1) finds the object identified with <I>pszItem2 </I>and returns the correct interface pointer to it.<I> </I>This interface pointer is implemented on the object named by Item2, in the context of File!Item1, which is exactly the object named by the File!Item1!Item2 composite.<I> </I>Item2 then returns this pointer from its own <I>BindToObject</I>, which the outer composite returns all the way back to the client.</P>
<P>This process is illustrated in Figure 9-4, assuming that a single server implements the File, Item1, and Item2 objects within the same process, which is usually the case when such a source hands out a File!Item!Item moniker.</P>
<P>Through the binding process, you can see how a composite delays as much work as possible, especially when we add the optimizations discussed in the next section.<I> </I>If, for example, the server in this example had already opened the file described by the File moniker and registered it in the running object table, the File moniker would not have had to call <I>CoCreate-Instance </I>at all.<I> </I>It would only need to extract the file object's <I>IUnknown </I>from the running object table and call its <I>QueryInterface</I>.<I> </I>Furthermore, if the server had had the file open and had been already viewing whatever object is described by Item1 (page, sheet, and so on), the File!Item1 moniker would have been registered as running; thus, binding File!Item1 would have gone no further than to extract a pointer and a query for <I>IOleItemContainer.</I></P>
<P>    <img src="f09dd04.gif"></P>
<P><B>Figure 9-4.</B></P>
<P><B>Binding a File!Item1!Item2 moniker.</B></P>
<H4><A NAME="sec1"></A>The <I>IOleItemContainer</I>, <I>IOleContainer</I>, and <I>IParseDisplayName</I> Interfaces</H4><P>Before we look at the running object table and the bind context, let's first look at <I>IOleItemContainer</I>, which plays such a prominent role in binding an item moniker.<I> </I>This interface derives from an interface named <I>IOleContainer</I>, which is itself derived from one named <I>IParseDisplayName</I>:</P>
<P><BR></P>
<pre><code>interface IParseDisplayName : IUnknown<BR>    {<BR>    HRESULT ParseDisplayName(IBindContext *pbc, LPOLESTR pszDisplayName<BR>        , ULONG *pchEaten, IMoniker **ppmkOut);<BR>    };<BR><BR>interface IOleContainer : IParseDisplayName<BR>    { <BR>    HRESULT EnumObjects(DWORD grfFlags, LPENUMUNKNOWN *ppEnum);<BR>    HRESULT LockContainer(BOOL fLock);<BR>    };<BR><BR>interface IOleItemContainer : IOleContainer<BR>    {<BR>    HRESULT GetObject(LPOLESTR pszItem, DWORD dwSpeedNeeded<BR>        , IBindCtx *pbc, REFIID riid, void **ppv);<BR>    HRESULT GetObjectStorage(LPOLESTR pszItem, IBindCtx *pbc<BR>        , REFIID riid, void **ppvStorage);<BR>    HRESULT IsRunning(LPOLESTR pszItem);<BR>    };</code></pre>
<P>We've already seen the use of <I>GetObject</I> and its <I>pszItem</I>, <I>riid</I>, and <I>ppv </I>arguments. Its <I>pbc </I>argument is a pointer to a bind context, described later in "Binding Optimizations II: The Bind Context," and <I>dwSpeedNeeded </I>indicates just how long the moniker wants to wait for the container to parse the item name into an object, taken from the BINDSPEED enumeration:</P>
<P><BR></P>
<pre><code>typedef enum tagBINDSPEED<BR>    {<BR>    BINDSPEED_INDEFINITE  =  1,  //Can wait forever.<BR>    BINDSPEED_MODERATE    =  2,  //Will wait ~2.5 seconds.<BR>    BINDSPEED_IMMEDIATE   =  3   //Object must be running.<BR>    } BINDSPEED;</code></pre>
<P>If the container cannot retrieve the object according to this limit, it should return MK_E_EXCEEDEDDEADLINE.</P>
<P>The other two members of <I>IOleItemContainer </I>are quite straightforward. <I>GetObjectStorage </I>is to <I>IMoniker::BindToStorage </I>as <I>GetObject </I>is to <I>IMoniker::BindToObject</I>. <I>IsRunning </I>asks the container whether the object identified with the item name is already up and running so that requesting a pointer to it is immediate.</P>
<P><I>IOleContainer</I> has only two members specific to itself. The first, <I>EnumObjects</I>, is asked to create an enumerator with <I>IEnumUnknown</I>, which iterates over a specific set of object types in the container according to the combination of OLECONTF flags passed in <I>grfFlags</I>:</P>
<P><BR></P>
<pre><code>typedef enum tagOLECONTF<BR>    {<BR>    OLECONTF_EMBEDDINGS     =  1,  //OLE Document embeddings only<BR>    OLECONTF_LINKS          =  2,  //OLE Document linkings only<BR>    OLECONTF_OTHERS         =  4,  //Anything outside OLE Documents<BR>    OLECONTF_ONLYUSER       =  8,  //Objects visible to end user<BR>    OLECONTF_ONLYIFRUNNING  = 16   //Running objects<BR>    } OLECONTF;</code></pre>
<P>(OLECONTF_OTHERS is basically the set of all objects that are not otherwise included with OLECONTF_EMBEDDINGS and OLECONTF_LINKS.)</P>
<P>The other function in <I>IOleContainer</I> is <I>LockContainer</I>, which gives any object inside this container a way to tell the container to stay in memory (when <I>fLock </I>is TRUE) or to release itself if necessary (when <I>fLock </I>is FALSE). A container will typically call <I>CoLockObjectExternal </I>to create or remove a strong lock on itself in response to this call.</P>
<P>Finally we come to <I>IParseDisplayName </I>and its single member <I>ParseDisplayName</I>. This function is asked to turn a display name string into a moniker. More precisely, the container is asked to parse as much of the display name as it can, from left to right, returning an appropriate moniker for what it parsed. The out-parameter <I>pchEaten </I>specifies how many characters were parsed out of the display name; if more remain, the caller will need to parse the rest of that name. We'll see later how this comes into play when we look at display names in the context of the <I>IMoniker </I>interface in "<I>IM</I><I>oniker</I>: Display Name Group."</P></font></body></HTML>
