<HTML><HEAD><TITLE>Provide In-Place Accelerators and Focus</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Provide In-Place Accelerators and Focus</H3><P>As described earlier, a UI-active object always has first crack at accelerators and keystrokes. If the UI-active object is an in-process object, the container's message loop will pick up accelerators first. To accommodate this possibility, the container must call <I>IOleInPlaceActiveObject::TranslateAccelerator</I> in its message loop before translating any of its own accelerators. If the object uses the keystroke, the container must now also use it. Patron handles this in its <I>CPatronFrame::MessageLoop</I>,<I> </I>in which <I>m</I><I>_</I><I>hAccel </I>contains its normal accelerators and <I>m</I><I>_</I><I>hAccelIP </I>contains those accelerators that are available with a UI-active object:9</P>
<P><BR></P>
<pre><code>WPARAM CPatronFrame::MessageLoop(void)<BR>    {<BR>    MSG     msg;<BR><BR>    while (GetMessage(&amp;msg, NULL, 0, 0))<BR>        {<BR>        HACCEL      hAccel=m_hAccel;<BR><BR>        //Always give object first crack at translation.<BR>        if (NULL!=m_pIOleIPActiveObject)<BR>            {<BR>            HRESULT      hr;<BR><BR>            hAccel=m_hAccelIP;<BR>            hr=m_pIOleIPActiveObject-&gt;TranslateAccelerator(&amp;msg);<BR><BR>            //If object translated the accelerator, we're done.<BR>            if (NOERROR==hr)<BR>                continue;<BR>            }<BR>        if (!m_pCL-&gt;TranslateAccelerator(&amp;msg))<BR>            {<BR>            //hAccel is either normal or in place.<BR>            if (!::TranslateAccelerator(m_hWnd, hAccel, &amp;msg))<BR>                {<BR>                TranslateMessage(&amp;msg);<BR>                DispatchMessage(&amp;msg);<BR>                }<BR>            }<BR>        }<BR><BR>    return msg.wParam;<BR>    }</code></pre>
<P>If <I>IOleInPlaceActiveObject::TranslateAccelerator</I> does not process the keystroke, we can resume our message loop as usual. This function is set up in such a way that when we're not servicing an in-place object, we use our normal accelerators. When we have an <I>IOleInPlaceActiveObject</I> pointer, however, which is the in-place session flag for Patron's frame, we use the in-place accelerators.</P>
<P>Now, if the object is implemented in a local server, its message loop will pick up the keystroke messages first. The server processes its own accelerators immediately, but if it doesn't use a particular message, it must pass the message to <I>OleTranslateAccelerator </I>along with the OLEINPLACEFRAMEINFO structure it received from our own <I>IOleInPlaceSite::GetWindowContext </I>and the <I>IOleInPlaceFrame </I>pointer obtained at the same time. The OLEINPLACEFRAMEINFO structure holds our container's in-place accelerators, and <I>OleTranslateAccelerator </I>uses this table to determine whether the keystroke matches any accelerator in the table (or one for an MDI Window menu if the structure's <I>fMDIApp </I>flag is set). If a match is found, <I>OleTranslateAccelerator</I> passes the message and the command ID to <I>IOleInPlaceFrame::TranslateAccelerator</I>; otherwise, it returns to the server's message loop with S_FALSE so that the server can process the message.</P>
<P>As the container is given the command ID, implementing <I>IOleInPlaceFrame::TranslateAccelerator </I>is fairly easy: just invoke the correct command. (Patron does this through <I>CPatronFrame::OnC</I><I>ommand.</I>) An MDI container should also call <I>TranslateMDISysAccel </I>to handle the Window menu:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CPatronFrame::TranslateAccelerator(LPMSG pMSG, WORD wID)<BR>    {<BR>    SCODE       sc;<BR><BR>    if ((IDM_PAGENEWPAGE &lt;= wID &amp;&amp; IDM_PAGELASTPAGE &gt;= wID)<BR>        œœ IDM_OPENOBJECT==wID œœ IDM_ENTERCONTEXTHELP==wID<BR>        œœ IDM_ESCAPECONTEXTHELP==wID)<BR>        {<BR>        //wID properly expands to 32 bits.<BR>        OnCommand(m_hWnd, (WPARAM)wID, 0L);<BR>        sc=S_OK;<BR>        }<BR>   #ifdef MDI<BR>    else if (TranslateMDISysAccel(m_pCL-&gt;Window(), pMSG))<BR>        sc=S_OK;<BR>   #endif<BR>    else<BR>        sc=S_FALSE;<BR><BR>    return ResultFromScode(sc);<BR>    }</code></pre>
<P>There is one more step to make accelerators work properly. Whenever there's a UI-active object, the container must ensure that the object has the keyboard focus so that keyboard messages are marked for the correct window. The object will initially take the focus itself when it becomes UI active, but if the user switches away from the container and back again, the container will receive a WM_SETFOCUS message. Window's default processing of this message will set the focus to the frame window, which is not what we want. To set it to the UI-active object, the container must call <I>SetFocus </I>on the window returned from <I>IOleInPlaceActiveObject::GetWindow</I>:</P>
<P><BR></P>
<pre><code>case WM_SETFOCUS:<BR>    if (NULL!=m_pIOleIPActiveObject)<BR>        { <BR>        HWND    hWndObj;<BR><BR>        m_pIOleIPActiveObject-&gt;GetWindow(&amp;hWndObj);<BR>        SetFocus(hWndObj);<BR>        }<BR><BR>    break;</code></pre>
<P><B>Note:</B><B> </B> Avoid the temptation to pass the ill-named <I>hWndObj </I>argu-ment from <I>IOleInPlaceFrame::SetMenu </I>to <I>SetFocus </I>because this might be the frame window handle of the object's server<I>. </I>If that were the case, your container would never get the focus at all. If you tried to reactivate your container's frame window, you would see it briefly flash active but then become inactive again when you made this <I>SetFocus </I>call. To bypass any problems, always use the window handle from <I>IOleInPlaceActiveObject::GetWindow</I>.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>9 In C++, <I>::TranslateAccelerator</I> calls the globally named Windows API. We need this because <I>CPatronFrame</I> has a <I>TranslateAccelerator</I> member function that would be called if we left off the <I>::</I> at the beginning of the function name. Don't feel bad if you didn't know this already—I had to ask other people how to do this when writing this code.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
