<HTML><HEAD><TITLE>Extended Controls</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Extended Controls</H3><P>To a container, an OLE control is already a convenient package of functionality and content set behind a large group of interfaces used for accessing those features. A control, however, will not maintain properties and support methods that are relevant only to the container. It would be beneficial, then, for the container to have a way to package its own custom properties and methods in a control so that those properties and methods appear as if they were native to the control itself. For example, a control does not maintain any information about its name or position within a container form. A container, however, might like to store this information as properties of that control. In this way, the rest of the container code can treat all properties as if they were native to the control itself.</P>
<P>An extended control is a partial control that wraps around another control through containment and aggregation in order to supply extended functionality that the control itself knows nothing about. In other words, the container provides its own extended control implementation that overrides specific interfaces on another control through containment and exposes the remaining interfaces through aggregation. This relationship is illustrated in Figure 24-3. An extended control typically augments the methods and properties exposed by a control by providing its own <I>IDispatch</I>. This interface implementation filters out container-specific dispIDs before passing the call to the control's <I>IDispatch</I>. If the extended control has its own events as well, it also implements <I>IConnectionPointContainer</I>. Other interfaces are overridden as necessary, in the same way that an in-process handler (as we saw in Chapter 19) overrides specific interfaces from the default handler as it sees fit. Whatever container code then communicates with the extended control sees it as nothing more than an ordinary control with added features.</P>
<P>    <img src="f24dd03.gif"></P>
<P><B>Figure 24-3.</B></P>
<P><B>An extended control wraps around another control through containment and aggregation to support container-specific properties, methods, and events.</B></P>
<P>This aggregation between control and extended control is one instance in which the extended control would delegate <I>QueryInterface </I>to the real control for all unrecognized interfaces. This allows the control to add new interfaces over time without requiring a change to the container or to the extended control itself. This works because the container, having intimate knowledge of its own extended control, knows exactly which interfaces the extended control will override. The container always knows that when it asks for <I>IDispatch</I>, for example, it will get the extended control's <I>IDispatch</I>.</P>
<P>A container doesn't have to implement extended controls if it has no reason to do so. In that case, <I>IOleControlSite::GetExtendedControl</I> should return E_NOTIMPL. Otherwise, this member function should return the <I>IDispatch </I>interface for the container's extended control managed by the site. A control can then access any properties of the extended control itself. (There are a few standards for this, as we'll see later in this chapter.) A control typically cannot depend on an extended property being present unless the control has intimate knowledge about the containers in which it will be embedded.</P></font></body></HTML>
