<HTML><HEAD><TITLE>Property Pages, Changes, and Persistence</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Property Pages, Changes, and Persistence</H3><P>Although interfaces such as <I>IDispatch </I>and <I>IDataObject </I>can provide access to an object's data programmatically, there are occasions when the user would like to work directly with an object's properties. OLE's mechanism for doing just this—the mechanism uses a tabbed-dialog user interface, as shown in Figure 1-13 on the following page—is called Property Pages, which was introduced initially with OLE Controls. Each separate tab in the dialog box is a property page, and each page is managed by a separate object, with its own CLSID, that implements the interface, <I>IPropertyPage </I>(or <I>IPropertyPage2</I>). An object that supports property pages implements <I>ISpecifyPropertyPages</I>, which supplies a list of property page CLSIDs that it would like displayed in the dialog.</P>
<P>A property page isn't all that useful by itself, so whatever component wants to show the pages creates a <I>property frame</I> (which is the dialog box) and hands that frame all the CLSIDs of all the property pages to display, along with the <I>IUnknown </I>pointers to all the objects that are being affected by changes in those property pages. When the user clicks on the Apply Now button in the dialog box to apply the changes to the affected objects, the frame notifies the current property page to notify each object in turn.</P>
<P>    <img src="f01dd13p.gif"></P>
<P><B>Figure 1-13.</B></P>
<P><B>The user interface for property pages involves a tabbed dialog box in which each tab is a separate property page.</B></P>
<P>Property pages are extremely useful for things like controls, and they will find more use for various user interface elements in future versions of Windows. As a technology, they are rather general purpose, so you'll likely find many uses for them.</P>
<P>Regardless of how a property changes, either programmatically or through a property page UI, some clients might be interested in knowing when certain properties (identified with a dispID) change. An object that supports notification of property changes supplies a connection point for the interface <I>IPropertyNotifySink</I>. Interested clients implement this interface and hand it to the object through the latter's connection point.</P>
<P>This interface handles two notifications. The first is that the property has actually changed value, in response to which the client can retrieve the new value. The second notification tells the client that the property is about<I> </I>to change, which allows the client to prevent the change altogether or perhaps to implement some sort of read-only behavior. Properties that support the first type of notification are called <I>bindable</I> properties, and those of the second type are <I>request edit</I> properties.</P>
<P>The final consideration for properties is a persistent storage method called <I>property sets,</I> by which a component can write properties into a stream in a self-describing manner. The actual structure of a property set starts with a header that describes the offsets in the stream of each property therein, and at each offset is a header describing the type of property and the offset of the actual data elsewhere in the stream. This structure is very flexible. It allows a component to write only those properties it has and allows another component or client to robustly read only the properties that are there. There are no expectations about the existence of any property—if it's in the stream, it's there completely.</P>
<P>Property pages, property change notification, and property sets are covered in Chapter 16.</P></font></body></HTML>
