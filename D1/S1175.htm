<HTML><HEAD><TITLE>A Simple Client-Side Message Filter: ObjectUser2</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>A Simple Client-Side Message Filter: ObjectUser2</H3><P>A client application will want to install a message filter to determine when a server has rejected a call or is otherwise not responding or to process Windows messages that come into the application message queue while a call is in progress. As described earlier, OLE's default message filter will cancel any rejected or delayed call and discard any input message. If you want to change this behavior, you need to install a message filter.</P>
<P><img src="16bit.gif"></P>
<P>To demonstrate the client side of message filtering, the ObjectUser2 program registers a message filter and provides a menu item to call <I>IPersist::GetClassID </I>on a Koala object obtained from EKoala3. <I>IPersist </I>is used here because it's the simplest interface for which OLE provides standard marshaling support (which means that we don't have to introduce some other complex interface into this specific sample). It is also a call that the proxy will forward to the object—we can't use <I>AddRef </I>or <I>Release </I>in this demonstration because OLE's standard proxy doesn't forward anything except the last <I>Release</I>. So <I>IPersist::GetClassID </I>fits the bill nicely.</P>
<P>ObjectUser2 uses a C++ class, <I>CMessageF</I><I>ilter</I>, which is similar to that in EKoala3 except that the version here fully implements <I>RetryRejectedCall</I>, leaves <I>MessagePending</I> the same as the default filter (returns PENDINGMSG_WAITDEFPROCESS)<I> </I>and returns E_NOTIMPL from <I>HandleInComingCall</I>. The application initialization code instantiates and registers the filter in <I>CApp::Init</I> and removes and releases it in <I>CApp::~CApp</I>, exactly as shown earlier with EKoala3. In other words, the registration process is identical for both clients and servers.</P>
<P>Inside ObjectUser2's <I>RetryRejectedCall</I>,<I> </I>we immediately cancel a rejected call (which returns RPC_E_CALL_REJECTED from the call itself). If the call is merely delayed, we print a message with the time elapsed since the call was made. If 5 seconds elapse, we display the busy dialog box:</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(DWORD) CMessageFilter::RetryRejectedCall<BR>    (HTASK htaskCallee, DWORD dwTickCount, DWORD dwRejectType)<BR>    {<BR>    UINT    uRet;<BR>    TCHAR   szMsg[256];<BR><BR>    if (SERVERCALL_REJECTED==dwRejectType)<BR>        return (DWORD)-1;<BR><BR>    wsprintf(szMsg, TEXT("RetryRejectedCall waiting %lu")<BR>        , dwTickCount);<BR>    m_pApp-&gt;Message(szMsg);<BR><BR>    if (dwTickCount &lt; 5000)<BR>        return 200;<BR><BR>    m_pApp-&gt;Message<BR>        (TEXT("CMessageFilter::RetryRejectedCall showing busy dialog box"));<BR><BR>    uRet=DisplayBusyDialog(htaskCallee, 0L);<BR><BR>    switch (uRet)<BR>        {<BR>        case OLEUI_CANCEL:<BR>            return (DWORD)-1;<BR><BR>        case OLEUI_BZ_SWITCHTOSELECTED:<BR>            /*<BR>             * This case won't happen without BZ_NOTRESPONDINGDIALOG,<BR>             * but we would wait maybe 10 seconds if it did happen.<BR>             */<BR>            return 10000;<BR><BR>        case OLEUI_BZ_RETRYSELECTED:<BR>            m_pApp-&gt;Message(TEXT("Waiting another second"));<BR>            return 1000;<BR><BR>        default:<BR>            break;<BR>        }<BR><BR>    return 0;<BR>    }<BR><BR>UINT CMessageFilter::DisplayBusyDialog(HTASK hTask, DWORD dwFlags)<BR>    {<BR>    OLEUIBUSY   bz;<BR><BR>    //Clear out everything we don't use.<BR>    memset(&amp;bz, 0, sizeof(bz));<BR><BR>    bz.cbStruct=sizeof(OLEUIBUSY);<BR>    bz.dwFlags=dwFlags;<BR>    bz.hWndOwner=m_pApp-&gt;m_hWnd;<BR>    bz.hTask=hTask;<BR>    bz.lphWndDialog=NULL;<BR><BR>    return OleUIBusy(&amp;bz);<BR>    }</code></pre>
<P>The OLEUI_CANCEL and OLEUI_BZ_* flags indicate the button the user chose in the dialog box. If the user clicks on the Cancel button in the dialog box, <I>RetryRejectedCall </I>will cancel the call, generating an RPC_E_CALL_REJECTED result. If the user clicks on Retry, we wait for another second by returning 1000 (milliseconds). If the call hasn't gone through by the time that second has elapsed, we come back into <I>RetryRejectedCall </I>and display the dialog box again as long as the user keeps clicking on Retry.</P>
<P>If the user chooses Switch To, the busy dialog box sets the focus to the server if possible (using the server's task handle to get at the window). If the dialog box can't find a window, it launches the Windows task manager. This tells the user to fix whatever the problem is in the server before switching back to the client. When the user does switch back, the busy dialog box automatically closes as if he or she had clicked on the Retry button, in which case our code will wait another second.</P>
<P>One of the little differences between the busy dialog box and the "not responding" dialog box is that choosing Switch To in the latter will, after switching to the server (or task manager), close the dialog box immediately and return OLEUI_BZ_SWITCHTOSELECTED. The client can choose to continue waiting (as the code on the preceding page would do), cancel the call, or wait for a while and then cancel the call if the server still doesn't respond (without invoking the dialog box again).</P>
<P>With ObjectUser2 and EKoala3, you can now fully explore how message filtering works. Run ObjectUser2 and choose Create. After going through all of EKoala3's <I>IExternalConnection </I>messages, choose the IPersist::GetClassID menu item in ObjectUser2. This call will succeed. Now choose Block in EKoala3 and try the call again. This time it fails with 0x80010001, or RPC_E_CALL_REJECTED. Now turn off Block, turn on Delay, and try the call again. This time you'll see ObjectUser2 show the elapsed time while it's waiting through <I>RetryRejectedCall. </I>While this is going on, turn off Delay in EKoala3, and you'll see the call completed with NOERROR, showing how a client will wait for a while and, if the server responds in the right amount of time, proceed without bothering the end user.</P>
<P>Now turn Delay back on and make the call again, but this time let ObjectUser2's counter go past 5000; now the busy dialog box appears. If you click on Cancel, the call will fail with RPC_E_CALL_REJECTED. If you click on Retry, you'll see a message in ObjectUser2, after which the busy dialog box appears again. You can keep choosing Retry as long as you want, to no avail. Now choose Switch To, which will place you in EKoala3. Turn Delay off and switch back to ObjectUser2, where you'll see the busy dialog box disappear. After waiting another second, you'll see the call succeed. You can see the same thing happen if, after you click on Retry, you quickly switch to EKoala3 and turn off Delay. (Or turn Block on and watch the call fail immediately.)</P>
<P>In all, these two samples let you take a look at the variations of rejected and delayed calls. If you watch ObjectUser2's <I>IMessageFilter::MessagePending </I>function as well, you'll see that it gets called during any waiting period if you press a key or do anything with the mouse in ObjectUser2's window, even moving the mouse over it. The preceding code doesn't generate any kind of message in such a case because it would overwrite those messages shown in <I>RetryRejectedCall</I>. But you can prove that calls are being made by inserting the following line into the code:</P>
<P><BR></P>
<pre><code>m_pApp-&gt;Message(TEXT("MessagePending called."));</code></pre>
<P>ObjectUser2 is itself a pretty lame application. It doesn't really care about input messages from the mouse and keyboard, so default processing from <I>MessagePending </I>is fine. But what if you want to preserve messages?</P></font></body></HTML>
