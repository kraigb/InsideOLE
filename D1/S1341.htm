<HTML><HEAD><TITLE>Initializing an Event Map</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Initializing an Event Map</H3><P>To handle the mapping between events and actions, Patron uses the class <I>CEventMap </I>(EVENTS.CPP). Each instance of <I>CTenant </I>that contains a control will manage an instance of <I>CEventMap</I>, which itself holds an array of EVENTMAP structures. All of these structures are defined as follows in TENANT.H:</P>
<P><BR></P>
<pre><code>//Event actions<BR>typedef enum<BR>    {<BR>    ACTION_NONE=-1,<BR>    ACTION_BEEPDEFAULT=MB_OK,<BR>    ACTION_BEEPASTERISK=MB_ICONASTERISK,<BR>    ACTION_BEEPEXCLAMATION=MB_ICONEXCLAMATION,<BR>    ACTION_BEEPHAND=MB_ICONHAND,<BR>    ACTION_BEEPQUESTION=MB_ICONQUESTION,<BR>    ACTION_TAILING=-2<BR>    } EVENTACTION;<BR><BR>typedef struct tagEVENTMAP<BR>    {<BR>    DISPID      id;             //Event ID<BR>    EVENTACTION iAction;        //Action to take<BR>    BSTR        bstrName;       //Event name (function only)<BR>    } EVENTMAP, *PEVENTMAP;<BR><BR>class CEventMap<BR>    {<BR>    public:<BR>        UINT            m_cEvents;<BR>        LPTYPEINFO      m_pITypeInfo;<BR>        PEVENTMAP       m_pEventMap;<BR><BR>    public:<BR>        CEventMap(LPTYPEINFO);<BR>        ~CEventMap(void);<BR><BR>        BOOL            Init(void);<BR>        BOOL            Set(DISPID, EVENTACTION);<BR>        EVENTACTION     Get(DISPID);<BR>        void            Serialize(LPSTREAM);<BR>        void            Deserialize(LPSTREAM);<BR>    };<BR><BR>typedef CEventMap *PCEventMap;<BR><BR>//Event stream in object storage<BR>#define SZEVENTSSTREAM  OLETEXT("\003Event Mappings")</code></pre>
<P>Each event map manages its own serialization and deserialization given any stream. Patron uses the stream name "\003Event Mappings," which it creates in the object's storage. Accordingly, we have to prefix the stream name with ASCII 3 to prevent an object from affecting this stream in any way.</P>
<P>Each EVENTMAP structure in an instance of <I>CEventMap </I>contains the name of an event (for displaying in the Control Events dialog box), the event's dispID, and whatever action is assigned to it. Regardless of the complexity of the container, these three elements will generally be present. A sophisticated container that allows a user to attach code to an event would, for example, replace the <I>iAction </I>field with a pointer to that code and would augment the structure with the names of an event's arguments for use elsewhere in that container's user interface.</P>
<P>You'll notice that the <I>CEventMap </I>constructor takes an <I>ITypeInfo </I>pointer. This pointer is eventually used to initialize the event map in <I>CEventMap::Init</I>. Here we cycle through the member functions of the interface described by <I>ITypeInfo</I>, storing each function name and dispID in a separate EVENTMAP structure (the BSTR name is freed in the <I>CEventMap </I>destructor):</P>
<P><BR></P>
<pre><code>BOOL CEventMap::Init(void)<BR>    {<BR>    LPTYPEATTR      pTA;<BR>    UINT            i;<BR><BR>    if (NULL==m_pITypeInfo)<BR>        return FALSE;<BR><BR>    if (FAILED(m_pITypeInfo-&gt;GetTypeAttr(&amp;pTA)))<BR>        return FALSE;<BR><BR>    m_cEvents=pTA-&gt;cFuncs;<BR>    m_pITypeInfo-&gt;ReleaseTypeAttr(pTA);<BR><BR>    m_pEventMap=new EVENTMAP[m_cEvents];<BR><BR>    if (NULL==m_pEventMap)<BR>        {<BR>        m_cEvents=0;<BR>        return FALSE;<BR>        }<BR><BR>    for (i=0; i &lt; m_cEvents; i++)<BR>        {<BR>        LPFUNCDESC     pFD;<BR><BR>        m_pEventMap[i].id=0;<BR>        m_pEventMap[i].bstrName=NULL;<BR>        m_pEventMap[i].iAction=ACTION_NONE;<BR><BR>        if (SUCCEEDED(m_pITypeInfo-&gt;GetFuncDesc(i, &amp;pFD)))<BR>            {<BR>            UINT        cNames;<BR>            HRESULT     hr;<BR><BR>            m_pEventMap[i].id=pFD-&gt;memid;<BR><BR>            hr=m_pITypeInfo-&gt;GetNames(pFD-&gt;memid<BR>                , &amp;m_pEventMap[i].bstrName, 1, &amp;cNames);<BR><BR>            m_pITypeInfo-&gt;ReleaseFuncDesc(pFD);<BR>            }<BR>        }<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>To get this far, of course, we need to retrieve the type information for at least the control's primary event set (the only one Patron uses). This is done through <I>ObjectTypeInfoEvents</I>, an internal function implemented in CONNECT.CPP:</P>
<P><BR></P>
<pre><code>BOOL ObjectTypeInfoEvents(LPUNKNOWN pObj, LPTYPEINFO *ppITypeInfo)<BR>    {<BR>    HRESULT             hr;<BR>    LPTYPEINFO          pITypeInfoAll;<BR>    LPTYPEATTR          pTA;<BR><BR>    if (NULL==pObj œœ NULL==ppITypeInfo)<BR>        return FALSE;<BR><BR>    if (!ObjectTypeInfo(pObj, &amp;pITypeInfoAll))<BR>        return FALSE;<BR><BR>    *ppITypeInfo=NULL;  //Use this to determine success.<BR><BR>    if (SUCCEEDED(pITypeInfoAll-&gt;GetTypeAttr(&amp;pTA)))<BR>        {<BR>        UINT        i;<BR>        int         iFlags;<BR><BR>        for (i=0; i &lt; pTA-&gt;cImplTypes; i++)<BR>            {<BR>            //Get the implementation type for this interface.<BR>            hr=pITypeInfoAll-&gt;GetImplTypeFlags(i, &amp;iFlags);<BR><BR>            if (FAILED(hr))<BR>                continue;<BR><BR>            if ((iFlags &amp; IMPLTYPEFLAG_FDEFAULT)<BR>                &amp;&amp; (iFlags &amp; IMPLTYPEFLAG_FSOURCE))<BR>                {<BR>                HREFTYPE    hRefType=NULL;<BR><BR>                pITypeInfoAll-&gt;GetRefTypeOfImplType(i, &amp;hRefType);<BR>                hr=pITypeInfoAll-&gt;GetRefTypeInfo(hRefType<BR>                    , ppITypeInfo);<BR><BR>                break;<BR>                }<BR>            }<BR><BR>        pITypeInfoAll-&gt;ReleaseTypeAttr(pTA);<BR>        }<BR><BR>    pITypeInfoAll-&gt;Release();<BR>    return (NULL!=*ppITypeInfo);<BR>    }</code></pre>
<P>This code employs straight usage of <I>ITypeInfo </I>member functions to look for an interface marked "source" and "default." The <I>ITypeInfo </I>pointer we use comes from another internal function in CONNECT.CPP, <I>ObjectTypeInfo</I>. This function simply queries for <I>IProvideClassInfo </I>and calls <I>IProvideClassInfo::GetClassInfo.</I> Nothing fancy.</P></font></body></HTML>
