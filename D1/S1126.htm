<HTML><HEAD><TITLE>Loading and Using a Type Library</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Loading and Using a Type Library</H2><P>Type information is a resource that both objects and clients of those objects can load directly. Objects usually load type information to give it to a client through an interface such as <I>IProvideClassInfo</I>, which we'll see later. In most cases, the client is the consumer of the type information because it is trying to learn about the object—trying to make sense of its owner's manual. If the object is not running, the client can load the library itself; if the object is running, the client can ask the object to do the honors.</P>
<P><img src="16bit.gif"></P>
<P>There are four loading-related functions in the OLE API. The first two rely on an object's registry entries and assume that the caller knows the LIBID of the type library (which the caller can load from the object's TypeLib entry under its CLSID). The first, <I>QueryPathOfRegTypeLib</I>, returns the full path-name of a type library given a version number and a language ID (both of which must match what is in the library itself), the path being the concatenation of the DIR entry and the appropriate name under Win16 or Win32 (depending on the platform). The second, <I>LoadRegTypeLib</I>, takes the same arguments and calls <I>QueryPathOfRegTypeLib</I> internally to retrieve the name of the library. It then calls one of the other two loading functions that do not depend on the registry. These are <I>LoadTypeLib</I> and <I>LoadTypeLibFromResource.</I> <I>LoadTypeLib</I> loads the library given a filename, which is used if the library is in a stand-alone file or in a compound file. <I>LoadTypeLibFromResource</I>, on the other hand, extracts a library from a module's resources.</P>
<P>Both <I>LoadTypeLib</I> and <I>LoadTypeLibFromResource</I> also have one other nice side effect: they call the OLE API function <I>RegisterTypeLib</I> to patch up any problems in the registry for this library. In light of this, when a running object wants to load its own type library, as it usually does on behalf of clients, it attempts <I>LoadRegTypeLib</I> first. If that fails because of a corrupt registry, the object can load the library directly using one of the other functions as a backup. If that backup loading succeeds, OLE will automatically correct the registry entries so that the next <I>LoadRegTypeLib</I> call succeeds.7</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H3><A NAME="sec0"></A>QueryPathRegTypeLib and the BSTR Type</H3><P>If you read the documentation for the <I>QueryPathRegTypeLib</I> function, you'll be told that the string it returns is a system-allocated string called a BSTR, for "Basic STRing." This string type is used particularly in OLE Automation because it is compatible with the strings used in Basic-language OLE Automation controllers, such as Microsoft Visual Basic. This data type will be described in more detail in Chapter 14; all you need to know now is that there are a number of OLE API functions of the form <I>Sys&lt;action&gt;String</I>, such as <I>SysAllocString</I> and <I>SysFreeString</I>, that you use to manipulate BSTRs. These functions internally use the task allocator from <I>CoGetMalloc</I> and require, like everything else, that at least <I>CoInitialize</I> (if not <I>OleInitialize</I>) has been called. The most important function to remember now is <I>SysFreeString,</I> which is used to free any BSTR that comes back from a function you might call.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>So now the big question: what does loading give you back to represent the loaded library? You can probably guess it: an interface pointer—specifically, a pointer to an interface called <I>ITypeLib.</I> In other words, loading a type library means loading a type library object and getting your first interface pointer to it. Through this interface, you can retrieve the library's attributes or navigate to individual elements in the library and retrieve their information. Whereas the library as a whole is handled by <I>ITypeLib</I>, each element is manipulated as a separate object through <I>ITypeInfo</I>. Through <I>ITypeInfo</I>, you can retrieve anything you can create through <I>ICreateTypeInfo</I>. A consequence of having different objects is that you have to always call <I>Release</I> through any of the pointers you obtain. Calling <I>ITypeLib::Release</I> effectively closes the type library file if all <I>ITypeInfo</I> pointers have also been released.</P>
<P>A simple representation of the relationship between the library, a few elements, and their interfaces is shown in Figure 3-3. You'll see that the <I>ITypeInfo</I> pointers for the interfaces and dispinterfaces that are specified as part of a <I>coclass</I> can be obtained either by navigating through the <I>ITypeInfo</I> interface for the <I>coclass</I> or by retrieving the <I>ITypeInfo</I> pointer for the IID directly.</P>
<P>    <img src="f03dd03.gif"></P>
<P><B>Figure 3-3.</B></P>
<P><B>A type library has an <I>ITypeLib</I> interface through which you can navigate to <I>ITypeInfo</I> interfaces that represent the various parts of the library.</B></P>
<P>A practical use of type information outside the scope of an instantiated object is for things called <I>type information browsers</I>. Type information browsers can look inside type libraries and present the available objects, interfaces, methods, and properties to an end user. These browsers can be the basis for powerful environments that might use drop-down list boxes and drag and drop in their programming user interfaces, greatly reducing the amount of typing that a programmer must do manually. I have not seen this sort of tool at the time of writing this text; I hope to see such innovative work in the future. However, two tools in the OLE SDK provide some sort of browsing capability. The first is TIBROWSE, for which the source code is provided as a sample. (It is also in Microsoft Visual C++.) This is a pretty simple tool, but it gives you the idea. A more complete tool, for which sources might not be provided, is OLE2VIEW. This tool allows you to peek into type libraries, among other things, through its File/View Type Library command or by locating a type library in OLE2VIEW's display of the registry. OLE2VIEW will show you just about everything that's in a library and can be very useful as a browser.</P>
<P>However you want to make use of all the type information available (and you're free to use it in any way you see fit—for precompiled headers, for example), you'll use the <I>ITypeLib</I> and <I>ITypeInfo</I> interfaces to navigate through the information. The following sections describe these interfaces in more detail. As a prelude, though, note that much of this information is expressed through the different data structures described in Table 3-7, many of which are used in some capacity through <I>ICreateTypeLib</I> and <I>ICreateTypeInfo</I>. Only TLIBATTR and TYPEKIND are available through <I>ITypeLib</I>; all other data structures are available only through <I>ITypeInfo</I>.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Structure</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>TLIBATTR</P></TD><TD VALIGN="TOP"><P>Contains a type library's LIBID (GUID), LCID, version number, flags ("restricted" being the only one), and the target operating system (Win16, Win32, Mac).</P></TD></TR><TR><TD VALIGN="TOP"><P>TYPEKIND</P></TD><TD VALIGN="TOP"><P>Enumerates the type of a particular element in the library: it could be TKIND_RECORD (<I>typedef struct)</I>, TKIND_MODULE, TKIND_INTERFACE, TKIND_DISPATCH (<I>dispinterface</I>), TKIND_COCLASS, TKIND_ALIAS (<I>typedef</I>), TKIND_ENUM, or TKIND_UNION. This is <I>very</I> useful for filling in items such as tree lists with the contents of a type library.*</P></TD></TR><TR><TD VALIGN="TOP"><P>TYPEATTR</P></TD><TD VALIGN="TOP"><P>Contains the attributes of any TYPEKIND element: GUID (IID, CLSID, etc.), LCID, member IDs of constructor and destructor methods (<I>interface</I> and <I>dispinterface</I>), size of an instance of the type, count of methods (<I>dispinterface</I>), count of properties, variables, and data members (<I>interface</I> and <I>dispinterface,</I> <I>typedef</I>), count of interfaces (for <I>coclass</I>), size of the vtable (<I>interface</I> and <I>dispinterface</I>), byte alignment, and version number. Also included are TYPEDESC, TYPEFLAGS, and IDLDESC fields. (See below.)</P></TD></TR><TR><TD VALIGN="TOP"><P>TYPEDESC</P></TD><TD VALIGN="TOP"><P>A structure that describes the type of a variable or argument or the return type of a method. Contains a VARTYPE (see Chapter 14, "VARIANT and VARIANTARG Structures") and a union that can contain either a TYPEDESC, an ARRAYDESC, or an HREFTYPE. (See below.) Nested TYPEDESCs describe nested structures.</P></TD></TR><TR><TD VALIGN="TOP"><P>ARRAYDESC</P></TD><TD VALIGN="TOP"><P>Describes an array of some type (TYPEDESC) with a specific number of dimensions and the bounds of each dimension.</P></TD></TR><TR><TD VALIGN="TOP"><P>HREFTYPE</P></TD><TD VALIGN="TOP"><P>A handle (unsigned long) that identifies a TYPEDESC.</P></TD></TR><TR><TD VALIGN="TOP"><P>TYPEFLAGS</P></TD><TD VALIGN="TOP"><P>An enumeration that contains TYPEFLAG_FAPPOBJECT, identifying a <I>coclass</I> with the <I>appobject</I> attribute; and TYPEFLAG_FCANCREATE, which indicates whether the function <I>ITypeInfo::CreateInstance</I> will work. See "The <I>ITypeInfo</I> Interface" on page 180.</P></TD></TR><TR><TD VALIGN="TOP"><P>IDLDESC</P></TD><TD VALIGN="TOP"><P>A structure containing information used in marshaling an argument; at present, this specifies only IDLFLAGS and contains a reserved BSTR<I>.</I></P></TD></TR><TR><TD VALIGN="TOP"><P>IDLFLAGS</P></TD><TD VALIGN="TOP"><P>An enumeration that identifies an argument as having the in or the out attribute, both attributes, or neither attribute.</P></TD></TR><TR><TD VALIGN="TOP"><P>ELEMDESC</P></TD><TD VALIGN="TOP"><P>A structure that describes a <I>typedef</I> <I>enum</I> using a TYPEDESC and an IDLDESC.</P></TD></TR><TR><TD VALIGN="TOP"><P>FUNCDESC</P></TD><TD VALIGN="TOP"><P>A structure that describes a method, including its dispID, an array and count of legal return SCODEs, the type of function (FUNCKIND), flags (FUNCFLAGS), the invocation style (INVOKEKIND), the calling convention (CALLCONV), the number of total arguments, the number of optional arguments, an array of ELEMDESC structures for each argument, the ELEMDESC of the return type, and the offset of this method in a virtual function table.</P></TD></TR><TR><TD VALIGN="TOP"><P>FUNCFLAGS</P></TD><TD VALIGN="TOP"><P>An enumeration that contains FUNCFLAG_FRESTRICTED, FUNCFLAG_FSOURCE, FUNCFLAG_FBINDABLE, FUNCFLAG_FREQUESTEDIT, FUNCFLAG_FDISPLAYBIND (<I>bindable</I> and displayed to user), and FUNCFLAG_FDEFAULTBIND (the method in an interface that best represents the object).</P></TD></TR><TR><TD VALIGN="TOP"><P>FUNCKIND</P></TD><TD VALIGN="TOP"><P>An enumeration that describes the function as either FUNC_VIRTUAL (called by an offset in a vtable), FUNC_PUREVIRTUAL, FUNC_NONVIRTUAL (called by address and takes a <I>this</I> pointer), FUNC_STATIC (called by address and takes no <I>this</I> pointer), or FUNC_DISPATCH (member of a <I>dispinterface</I> called through <I>IDispatch::Invoke</I>).</P></TD></TR><TR><TD VALIGN="TOP"><P>CALLCONV</P></TD><TD VALIGN="TOP"><P>An enumeration that identifies the calling convention as CC_CDECL, CC_PASCAL, CC_MACPASCAL, CC_STDCALL, or CC_SYSCALL.</P></TD></TR><TR><TD VALIGN="TOP"><P>INVOKEKIND</P></TD><TD VALIGN="TOP"><P>An enumeration that identifies the types of operations available through <I>IDispatch::Invoke</I>: INVOKE_FUNC, INVOKE_PROPERTYGET, INVOKE_PROPERTYPUT, INVOKE_PROPERTYPUTREF. These map exactly to DISPATCH_* values.</P></TD></TR><TR><TD VALIGN="TOP"><P>IMPLTYPE</P></TD><TD VALIGN="TOP"><P>An enumeration containing the implementation type of <I>interface</I> or <I>dispinterface</I> in a <I>coclass</I>: IMPLTYPE_FDEFAULT (<I>default</I>), IMPLTYPE_SOURCE (<I>source</I>), and IMPLTYPE_FRESTRICTED (<I>restricted</I>).</P></TD></TR><TR><TD VALIGN="TOP"><P>VARDESC</P></TD><TD VALIGN="TOP"><P>A structure that describes a variable, argument, constant, or data member and contains a dispID (MEMBERID), an offset or the variable within an object instance or a VARIANT with the actual value of a constant, an ELEMDESC, a value from VARFLAGS, and a type from VARKIND.</P></TD></TR><TR><TD VALIGN="TOP"><P>VARFLAGS</P></TD><TD VALIGN="TOP"><P>An enumeration that contains VARFLAG_FREADONLY, VARFLAG_FSOURCE, VARFLAG_FBINDABLE, VARFLAG_FREQUESTEDIT, VARFLAG_FDISPLAYBIND, and VARFLAG_FDEFAULTBIND.</P></TD></TR><TR><TD VALIGN="TOP"><P>VARKIND</P></TD><TD VALIGN="TOP"><P>An enumeration identifying a kind of variable or constant: VAR_PERINSTANCE (where the offset into an object in VARDESC makes sense), VAR_CONST (where the VARIANT in the VARDESC makes sense), VAR_STATIC (a single-instance global), or VAR_DISPATCH (a property in a dispinterface).</P></TD></TR><TR><TD VALIGN="TOP"><P>MEMBERID</P></TD><TD VALIGN="TOP"><P>Same as a dispID.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>* Using the Tree List control of Windows 95, you can easily imagine a very slick type library browser that would have top-level items with each of these names and a little + next to the name. If you clicked on the +, that item would expand to show the names of each individual element of that type, and the information you can get from <I>ITypeInfo </I>would allow further levels of expansion.</P>
<P><B>Table 3-7.</B></P>
<P><B>Data structures and enumerations obtainable through <I>ITypeLib</I> and <I>ITypeInfo</I> member functions. The descriptions in this table are not exhaustive; see the <I>OLE</I> <I>Programmer</I><I>'</I><I>s Reference</I>, for complete details.</B></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>7 <I>RegisterTypeLib </I>can also be useful for development environments that can both create objects and run client code against them if only just to test the objects. The developer could create and register an object and its type library and then immediately run a client script that would use that object as any other. This would provide a nice level of integration between object development and testing especially if the way a developer specifies the object's interfaces would allow the tool to automatically write a fair amount of the test script. Now there's a tool I'd like to see!</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
