<HTML><HEAD><TITLE>Variation III: Exceptions Through Error Objects</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Variation III: Exceptions Through Error Objects</H3><P><img src="16bit.gif"></P>
<P>A mechanism such as the one used in Beeper2 isn't suitable in a multiple-thread environment. To address this problem, the 32-bit versions of OLE support error objects, standard multithreaded devices for raising exceptions. These devices are also known to the 32-bit versions of <I>ITypeInfo::In</I><I>voke</I>, so you don't need your own postprocessing after that <I>Invoke</I> returns. We'll use the Beeper3 sample (CHAP14\BEEPER3) to demonstrate how to use error objects.</P>
<P>Each error object is basically an EXCEPINFO structure and an IID (of the dispinterface or interface raising the exception) wrapped in the interfaces <I>ICreateErrorInfo</I> and <I>IErrorInfo</I>. The member functions in <I>ICreateErrorInfo</I>—for example, <I>SetHelpFile</I>—store a value in the underlying EXCEPINFO structure. The functions in <I>IErrorInfo</I>—for example, <I>GetHelp</I><I>File</I>—retrieve those values, as illustrated in Figure 14-6.</P>
<P>    <img src="f14dd06.gif"></P>
<P><B>Figure 14-6.</B></P>
<P><B>An error object wraps an EXCEPINFO structure and an IID.</B></P>
<P>To raise an exception using error objects, you perform the following steps:</P>
<P>Before calling <I>ITypeInfo::Invoke</I>, call the OLE API function <I>SetErrorInfo(0L,</I> <I>NULL)</I> to clear the error object for the current thread. OLE manages a list of error objects on a per-thread basis through this function.</P>
<P>When an exception occurs from within a custom interface function called from <I>ITypeInfo::Invoke</I>, call <I>CreateErrorInfo(</I><I>&amp;</I><I>pICreateErrorInfo)</I> to obtain the <I>ICreateErrorInfo</I> pointer for a new error object.</P>
<P>Call <I>ICreateErrorInfo</I> functions to set your exception information in the object.</P>
<P>Call <I>pICreateErrorInfo-&gt;QueryInterface(IID</I><I>_</I><I>IErrorInfo</I> <I>&amp;</I><I>pIErrorInfo)</I> to obtain an <I>IErrorInfo</I> pointer that you pass to <I>SetErrorInfo(0L,</I> <I>pIErrorInfo)</I>. (This function takes an <I>IErrorInfo</I> pointer, not an <I>ICreateErrorInfo</I> pointer.) This assigns the error object to the current thread, which releases any previous object.</P>
<P>Release both your <I>IErrorInfo</I> and your <I>ICreateErrorInfo</I> pointer. <I>SetErrorInfo</I> will call <I>AddRef</I> as required to hold on to the pointer.</P>
<P>Return from your custom interface function. <I>ITypeInfo::Invoke</I> will then call <I>GetErrorInfo</I> to retrieve the <I>IErrorInfo</I> pointer for the current thread. If you do not raise an exception, this returns S_FALSE, and <I>Invoke</I> proceeds normally. Otherwise, <I>Invoke</I> extracts the information in the error object into the EXCEPINFO structure that you were given in your own <I>IDispatch::Invoke</I> and returns DISP_E_EXCEPTION.</P>
<P>In Beeper3's <I>IDispatch</I> implementation (found in BEEPER3\BEEPER.CPP), we can follow this procedure. First comes the Beeper's <I>IDispatch::Invoke</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid<BR>    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams<BR>    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)<BR>    {<BR>    HRESULT     hr;<BR>    ITypeInfo  *pTI;<BR><BR>    [Code to check for errors and obtain pTI omitted]<BR><BR>    //Clear exceptions.<BR>    SetErrorInfo(0L, NULL);<BR><BR>    hr=pTI-&gt;Invoke((IBeeper *)m_pObj, dispID, wFlags<BR>        , pDispParams, pVarResult, pExcepInfo, puArgErr);<BR><BR>    pTI-&gt;Release();<BR>    return hr;<BR>    }</code></pre>
<P>The implementation of <I>CBeeper::put</I><I>_</I><I>Sound</I> is the same in Beeper3 as in Beeper2, but the implementation of <I>CImpIDispatch</I> is much different because it implements the remaining steps in the preceding list:</P>
<P><BR></P>
<pre><code>void CImpIDispatch::Exception(WORD wException)<BR>    {<BR>    HRESULT             hr;<BR>    ICreateErrorInfo   *pICreateErr;<BR>    BOOL                fSuccess;<BR>    LPTSTR              psz;<BR>    LPOLESTR            pszHelp;<BR>    UINT                idsSource;<BR>    UINT                idsException;<BR>    DWORD               dwHelpID;<BR><BR>   [Other code omitted]<BR><BR>    //Not much we can do if this fails.<BR>    if (FAILED(CreateErrorInfo(&amp;pICreateErr)))<BR>        return;<BR><BR>    psz=(LPTSTR)malloc(1024*sizeof(TCHAR));<BR><BR>    if (NULL==psz)<BR>        {<BR>        pICreateErr-&gt;Release();<BR>        return;<BR>        }<BR><BR>    fSuccess=FALSE;<BR><BR>    switch (wException)<BR>        {<BR>        case EXCEPTION_INVALIDSOUND:<BR>            pICreateErr-&gt;SetGUID(DIID_DIBeeper);<BR>            dwHelpID=HID_SOUND_PROPERTY_LIMITATIONS;<BR><BR>            pszHelp=OLETEXT("beep0000.hlp");<BR>            idsSource=IDS_0_EXCEPTIONSOURCE;<BR>            idsException=IDS_0_EXCEPTIONINVALIDSOUND;<BR><BR>            switch (langID)<BR>                {<BR>                case LANG_GERMAN:<BR>                    idsSource=IDS_7_EXCEPTIONSOURCE;<BR>                    idsException=IDS_7_EXCEPTIONINVALIDSOUND;<BR>                    pszHelp=OLETEXT("beep0007.hlp");<BR>                    break;<BR><BR>                case LANG_ENGLISH:<BR>                case LANG_NEUTRAL:<BR>                default:<BR>                    break;<BR>                }<BR><BR>            fSuccess=TRUE;<BR>            break;<BR><BR>        default:<BR>            break;<BR>        }<BR><BR><BR>    if (fSuccess)<BR>        {<BR>        IErrorInfo *pIErr;<BR><BR>        pICreateErr-&gt;SetHelpFile(pszHelp);<BR>        pICreateErr-&gt;SetHelpContext(dwHelpID);<BR><BR>        LoadString(g_hInst, idsSource, psz, 1024);<BR>        pICreateErr-&gt;SetSource(psz);<BR><BR>        LoadString(g_hInst, idsDescri, psz, 1024);<BR>        pICreateErr-&gt;SetDescription(psz);<BR><BR>        hr=pICreateErr-&gt;QueryInterface(IID_IErrorInfo<BR>            , (PPVOID)&amp;pIErr);<BR><BR>        if (SUCCEEDED(hr))<BR>            {<BR>            SetErrorInfo(0L, pIErr);<BR>            pIErr-&gt;Release();<BR>            }<BR>        }<BR><BR>    free(psz);<BR><BR>    pICreateErr-&gt;Release();<BR>    return;<BR>    }</code></pre>
<P>This is all quite similar to the exception filling functions we've already seen. The only difference is in how we set the EXCEPINFO fields.</P>
<H4><A NAME="sec0"></A>Localized Error Objects</H4><P>If you have a sharp eye, you might have caught an ambiguity in the implementation of the <I>Exception</I> function. Where does that little <I>langID</I> value come from? It's not listed anywhere, yet I use it to determine the language in which to report the error information.</P>
<P>The source of <I>langID</I> is the <I>lcid</I> parameter in <I>CImpIDispatch::Invoke</I>—that's the only function that receives it during an invocation. Somehow we have to get that value from <I>Invoke</I> to <I>Exception</I>. We could use a member variable in <I>CImpIDispatch</I>, but that would make our whole implementation unsuitable for multiple threads—which is exactly what we are trying to avoid by doing this fancy error object stuff in the first place!</P>
<P>Because error objects are used primarily on Win32 platforms, we can take advantage of what is known as <I>thread-local</I> <I>storage</I> (TLS). TLS allows us to attach a pointer to a thread so that the system maintains one pointer per thread, just as OLE maintains one error object per thread. In order to use TLS, we have to obtain a TLS index with the Win32 API function <I>TlsAlloc</I>. This occurs, along with the reverse step, <I>TlsFree</I>, in the Beeper DLL's entry point found in DBEEPER.CPP:</P>
<P><BR></P>
<pre><code>DWORD       g_dwTLS;       //For thread-local storage<BR><BR>BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason<BR>    , LPVOID pvReserved)<BR>    {<BR>    g_hInst=hInstance;<BR><BR>    if (DLL_PROCESS_DETACH==ulReason)<BR>        {<BR>        TlsFree(g_dwTLS);<BR>        return TRUE;<BR>        }<BR>    else<BR>        {<BR>        if (DLL_PROCESS_ATTACH!=ulReason)<BR>            return TRUE;<BR><BR>        g_dwTLS=TlsAlloc();<BR>        }<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>The TLS index is stored in the global variable <I>g</I><I>_</I><I>dwTLS</I>, which is declared as an extern in Beeper3's BEEPER.CPP file. This gives us the means to assign a pointer to the thread by calling <I>TlsSetValue</I> and to retrieve that pointer elsewhere by calling <I>TlsGetValue</I>. Both functions take the index as the first parameter. So to communicate the LANGID from <I>Invoke</I> to <I>Exception</I>, <I>Invoke</I> declares a LANGID on the stack (which is already thread-local), saves the language from <I>lcid</I> in it, and assigns its pointer to the thread:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDispatch::Invoke(...)<BR>    {<BR>    §<BR>    LANGID      langID=PRIMARYLANGID(lcid);<BR><BR>    TlsSetValue(g_dwTLS, &amp;langID);<BR>    §<BR>    }</code></pre>
<P>Inside <I>Exception</I>, we can then retrieve the same value that is currently on <I>Invoke</I>'s stack, which is where we get the right <I>langID</I> value:</P>
<P><BR></P>
<pre><code>void CImpIDispatch::Exception(WORD wException)<BR>    {<BR>    §<BR>    LANGID              langID=LANG_NEUTRAL;<BR>    LANGID             *pLangID;<BR><BR>    pLangID=(LANGID *)TlsGetValue(g_dwTLS);<BR><BR>    if (NULL!=pLangID)<BR>        langID=*pLangID;<BR><BR>    §<BR>    }</code></pre>
<P>No magic—just straightforward multithreaded Win32 programming!</P>
<H4><A NAME="sec1"></A>The <I>ISupportErrorInfo</I> Interface</H4><P>One final piece of the error object framework that I have not mentioned yet is the <I>ISupportErrorInfo</I> interface, which lets an object say, "Hey, I support error objects!" You implement this interface on the same object as <I>IDispatch</I> and your custom interface.11 It has a single function (besides <I>IUnknown</I>) named <I>InterfaceSupportsErrorInfo</I>. This function gives the consumer of a thread's error object—for example, <I>ITypeInfo::Invoke </I>or a controller itself—a way to check whether the interface that's being called uses error objects to report exceptions. In other words, you can use this function to determine whether <I>GetErrorInfo</I> will return something meaningful or just plain trash—such as an exception raised long ago by something else in the same thread. <I>ITypeInfo::Invoke</I> should call <I>QueryInterface</I> for <I>IID</I><I>_</I><I>ISupportErrorInfo</I> through your custom interface pointer (the first argument to <I>ITypeInfo::Invoke</I>, remember?) and then call <I>InterfaceSupportsErrorInfo</I> with the dispinterface IID. If either step fails, <I>Invoke</I> should not call <I>GetErrorInfo</I>.12</P>
<P>In any case, Beeper3 implements this interface on its <I>CBeeper</I> object using the class <I>CImpISupportErrorInfo</I>—which is about as degenerate as you can get. The real core of this interface—its singular interesting member function—is very simple to implement:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpISupportErrorInfo::InterfaceSupportsErrorInfo<BR>    (REFIID riid)<BR>    {<BR>    if (DIID_DIBeeper==riid)<BR>        return NOERROR;<BR><BR>    return ResultFromScode(S_FALSE);<BR>    }</code></pre>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>11 Older documentation is <I>very</I> misleading on this point. It mentions that this interface is put on the same object as <I>IErrorInfo</I>, but you don't implement that interface on your automation object! It should say that the interface goes alongside <I>IDispatch</I>.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
