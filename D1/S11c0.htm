<HTML><HEAD><TITLE>Binding Optimizations I: The Running Object Table</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Binding Optimizations I: The Running Object Table</H3><P>Binding a moniker does not mean that the moniker must always run some object to get the object from the passive state into the running state. There are two scenarios in which we can avoid excess work (and time):</P>
<UL><LI>The object might be running when a client asks to bind to it. The moniker only needs to connect to that running object and query for the interface as requested by the client. </LI><LI>The client might want to connect to an object named by a moniker when that object enters the running state.</LI></UL><P>The running object table handles the first scenario. When the source of linked objects runs those objects (for example, when a server opens a file in response to some other action), that source registers those objects in the table as running. Composite monikers and file monikers routinely use this table to avoid redundant actions.</P>
<P>What is called the <I>alert object table</I> would handle the second scenario, notifying interested clients when objects appeared in the running object table. However, this service is not implemented at this time, although it is described in the original OLE design specification.</P>
<P>OLE provides the running object table through a single object that implements—surprise, surprise—an interface named <I>IRunningObjectTable.</I> Through this interface, servers register the monikers for their running objects, and clients (and monikers) check whether an object is running. What this table really does (which is not exactly a binding optimization) is distinguish between passive objects and running objects. The table holds only those objects that are running, and anything not in the table is considered passive.</P>
<P>Both clients and link-source servers access the table by calling <I>GetRunningObjectTable</I>, which returns an <I>IRunningObjectTable</I> pointer. Be sure to call <I>Release</I> through this pointer when you are finished with it. This interface has the following member functions:</P>
<P><BR></P>
<pre><code>interface IRunningObjectTable : IUnknown<BR>    {<BR>    HRESULT Register(DWORD grfFlags, IUnknown *pUnkObject<BR>        , IMoniker *pmkObject, DWORD *pdwRegister);<BR>    HRESULT Revoke(DWORD dwRegister);<BR>    HRESULT IsRunning(IMoniker *pmkObject);<BR>    HRESULT GetObject(IMoniker *pmkObject, IUnknown **ppUnkObject);<BR>    HRESULT NoteChangeTime(DWORD dwRegister, FILETIME *pft);<BR>    HRESULT GetTimeOfLastChange(IMoniker *pmkObject, FILETIME *pft);<BR>    HRESULT EnumRunning(IEnumMoniker **ppEnum);<BR>    };</code></pre>
<P>The <I>Register </I>function places an object's <I>IUnknown </I>pointer into the running object table along with a moniker to identify it. If you register the same moniker twice, the table will still keep the pointer in the table but will return MK_S_MONIKERALREADYREGISTERED to indicate that you've made a redundant call. If <I>Register </I>returns this code or NOERROR, it gives back a registration key that can then be passed either to <I>Revoke </I>to remove the object from the table or to <I>NoteChangeTime</I>.</P>
<P>The <I>grfFlags</I> argument passed to <I>Register </I>indicates the type of lock—strong or weak—that the running object table should make on <I>pUnkObject.</I> If this flag is 0, the lock is weak and the table will not call <I>AddRef </I>on the object. If this flag is ROTFLAGS_REGISTRATIONKEEPSALIVE, the table will call <I>AddRef</I>, as befits a strong lock. Remember from Chapter 6 that which sort of lock you need depends greatly on how this object will be used and how you will remove it from the table.</P>
<P><I>NoteChangeTime</I> is the function a server can use to store a time stamp with the object in the table. Clients that are interested can call <I>GetTimeOfLastChange </I>to retrieve that time stamp. In both cases, the time stamp is a 64-bit OLE structure named FILETIME:</P>
<P><BR></P>
<pre><code>typedef struct  _FILETIME<BR>    {<BR>    DWORD dwLowDateTime;<BR>    DWORD dwHighDateTime;<BR>    }   FILETIME;</code></pre>
<P>To assist the server in filling one of these structures, OLE provides the API function <I>CoFileTimeNow</I>, which takes a <I>FILETIME</I> * argument identifying the structure to fill. Because many applications, both servers and clients, still deal with 16-bit MS-DOS time stamps, OLE provides two functions to convert between them: <I>CoDosDateTimeToFileTime</I> and <I>CoFileTimeToDosDateTime</I>. See the <I>OLE Programmer</I><I>'</I><I>s Reference </I>for details about these functions.</P>
<P>Besides time changes, clients are usually interested in whether an object is currently running, and if so they may want to connect to it. The <I>IsRunning </I>and <I>GetObject </I>members of this interface serve these two needs, and both functions take a moniker to identify the object. In addition, clients might want to look at all running objects, in which case they can call <I>EnumRunning </I>to obtain an enumerator with <I>IEnumMoniker</I>. If you use this enumerator, be sure to call <I>Release </I>through every <I>IMoniker </I>pointer returned from <I>IEnumMoniker::Next</I>.</P>
<P>Obviously, the running object table is of great use to composite and file monikers in their binding processes and may also be of use to a custom moniker implementation. Monikers, however, inside their <I>BindToObject </I>and <I>BindToStorage </I>functions, are not allowed to call <I>GetRunningObjectTable</I>. Instead, they access the table through the bind context that flows throughout the entire binding process.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>Server Requirements for Running Objects and Wildcard Monikers</H4><P>The running object table is the sole place where objects are differentiated between passive and running states on a systemwide basis, so servers that bring possibly linked objects into memory are strongly recommended to register those objects as running. This is required only for objects in servers that supply link monikers and support binding to them; it is not necessary to register objects that are never named with any moniker.</P>
<P>This recommendation can seem complicated for something like a Microsoft Excel workbook that supports linking to individual cell ranges within it. Does the server need to register separate monikers for every possible combination of cell ranges in that spreadsheet?</P>
<P>Obviously there isn't enough memory to do this for a 16,384-by-16,384-by-256-cell workbook! Does this mean the server should try to remember what has possibly been linked? Not at all. OLE supports what is called a <I>wildcard</I> item moniker that you can compose with a file moniker to name "this file and everything in it." A wildcard item moniker has the text "\" (a single backslash). When the server opens a file, it can register a single File!Item moniker with a wildcard item. This ties into the item moniker's implementation of <I>IMoniker::IsRunning</I>, which checks whether Left·"\" (the moniker to its left with a \ item) is running. If it is, there is a wildcard match. The use of "\" in an item is peculiar to the standard item monikers. Custom monikers that support wildcards must define their own convention.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
