<HTML><HEAD><TITLE>Copy/Cut</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Copy/Cut</H3><P>A Copy or a Cut operation entails gaining access to the clipboard, copying the data renderings, and releasing the clipboard. (Cut deletes the data from the source afterward.) The OLE version of this process is a bit different because there are no analogs to opening or closing the clipboard. Instead, there's just <I>OleSetClipboard</I>:</P>
<P>Create a data object (such as DataTran), and store the appropriate data in it. This is similar to calling <I>OpenClipboard</I> followed by <I>SetClipboardData</I> as many times as needed. Calling <I>EmptyClipboard</I> is unnecessary here: OLE does it within <I>OleSe</I><I>tClipboard</I>.</P>
<P>Pass the data object to <I>OleSetClipboard</I>. This calls the object's <I>AddRef</I> followed by <I>IDataObject::EnumFormatEtc</I> to place each format on the Windows clipboard.</P>
<P>The source is now finished with its own data object and can release it if desired. The object remains alive until OLE calls its <I>Release. </I>This step is much like calling <I>CloseClipboard</I>.</P>
<P>For a Cut operation only, remove the affected data from the source.</P>
<P>Cosmo performs these steps in <I>CCosmoDoc::Clip</I> (DOCUMENT.CPP). At least half of the code and the <I>structure </I>of the function are unaffected by the changes. These deal primarily with creating a data object, stuffing it with data, and placing it on the clipboard. <I>CCosmoDoc::RenderFormat</I> creates the renderings to give to DataTran:</P>
<P><BR></P>
<pre><code>BOOL CCosmoDoc::Clip(HWND hWndFrame, BOOL fCut)<BR>    {<BR>    BOOL            fRet=TRUE;<BR>    HGLOBAL         hMem;<BR>    UINT            i;<BR>    static UINT     rgcf[3]={0, CF_METAFILEPICT, CF_BITMAP};<BR>    const UINT      cFormats=3;<BR>    static DWORD    rgtm[3]={TYMED_HGLOBAL, TYMED_MFPICT, TYMED_GDI};<BR>    LPDATAOBJECT    pIDataObject;<BR>    HRESULT         hr;<BR>    STGMEDIUM       stm;<BR>    FORMATETC       fe;<BR><BR>    hr=CoCreateInstance(CLSID_DataTransferObject<BR>        , NULL, CLSCTX_INPROC_SERVER<BR>        , IID_IDataObject, (PPVOID)&amp;pIDataObject);<BR><BR>    if (FAILED(hr))<BR>        return NULL;<BR><BR>    rgcf[0]=m_cf;<BR><BR>    for (i=0; i &lt; cFormats; i++)<BR>        {<BR>        //Copy private data first.<BR>        hMem=RenderFormat(rgcf[i]);<BR><BR>        if (NULL!=hMem)<BR>            {<BR>            stm.hGlobal=hMem;<BR>            stm.tymed=rgtm[i];<BR>            stm.pUnkForRelease=NULL;<BR><BR>            SETDefFormatEtc(fe, rgcf[i], rgtm[i]);<BR>            pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE);<BR>            }<BR>        }<BR><BR>    fRet=SUCCEEDED(OleSetClipboard(pIDataObject));<BR>    pIDataObject-&gt;Release();<BR><BR>    if (fRet &amp;&amp; fCut)<BR>        {<BR>        m_pPL-&gt;New();<BR>        FDirtySet(TRUE);<BR>        }<BR><BR>    return fRet;<BR>    }</code></pre>
<P>The order in which we store formats in a DataTran object is the same order in which it will enumerate those formats. This means we stuff formats with the highest integrity first.</P></font></body></HTML>
