<HTML><HEAD><TITLE>Where Does It All Start?</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Where Does It All Start?</H3><P>Now that we've seen the interfaces involved and where they are implemented, we can follow an in-place session from start to finish to see how these interfaces are used. Let's say we have a container—Patron, for example—in which we have opened a compound document containing an embedded graphic from a server such as Cosmo. This is shown in Figure 22-4. We now want to change that graphic, so we double-click on the graphic to activate it, at which time the container calls <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>PRIMARY) </I>as it always has. With the basic form of activation we've seen in previous chapters, the object would open in a separate window, in which we can make changes.1</P>
<P>    <img src="f22dd04p.gif"></P>
<P><B>Figure 22-4.</B></P>
<P><B>An example of a container with a compound document in which an embedded object lives.</B></P>
<P>In-place activation thus begins with a container's innocent call to <I>DoVerb. </I>At this point, we do not know whether in-place activation will actually happen. That is for the object to decide.</P>
<P>When an in-place–capable object receives a call to <I>DoVerb</I> (for verbs other than OLEIVERB_OPEN, which expressly means "activate in a separate window"),<I> </I>the object first checks whether the container is also in-place capable. It does this by asking the <I>IOl</I><I>eClientSite </I>pointer passed as an argument to <I>DoVerb </I>whether it supports <I>IOleInPlaceSite. </I>If the site fails this query, it is simply not in-place capable, and the object proceeds to activate normally. This shows again the power of <I>QueryInterface </I>to perform feature negotiation. Through this simple query, an in-place–capable object determines, at run time, whether it can use in-place activation. Thus, an in-place–capable object remains entirely compatible with in-place–capable containers that are not, but it's integrated better with in-place–capable ones.</P>
<P>Why, however, does the object query the <I>IOleClientSite </I>pointer passed to <I>IOleObject::DoVerb </I>rather than the pointer from <I>IOleObject::SetClientSite</I>? The former <I>IOleClientSite </I>pointer allows the container to activate an object in place in a different site from the one that manages the object otherwise. The container might want to activate an object in place in a specific location in its user interface outside the compound document itself. This alternative site is called the <I>active site,</I> and its <I>IOleClientSite </I>pointer is the one that shows up in <I>DoVerb </I>as the <I>pActiveSite </I>argument.</P>
<P>For whatever site is being used, the object will know that the container is in-place capable when the container returns an <I>IOleInPlaceSite </I>pointer. With this pointer, the object must now check whether in-place activation is allowed on this particular object at this particular time by calling <I>IOleInPlaceSite::CanInPlaceActivate.</I> This call separates the container's general in-place support for all objects—expressed by its support for <I>IOleInPlaceSite</I>—from its ability to activate a specific object in place. A container will, for example, refuse to activate the embedded object in place if the object is being displayed as an icon or if the object is linked and not embedded. If <I>CanInPlaceActivate </I>returns S_FALSE, the object is activated in a separate window.</P>
<P>If the container says that in-place activation is allowed, however, the object can start the full activation process by first calling <I>IOleI</I><I>nPlaceSite::OnInPlaceActivate</I>, which tells the container to allocate any necessary structure for handling the in-place process. This process generally involves three steps: moving the object's editing window to the container, merging container and server menus into one shared set of menus, and creating editing tools (toolbars and so on) for the object in the container window. To accomplish these things, the object needs the container frame's <I>IOleInPlaceFrame </I>interface and the container document's <I>IOleInPlac</I><I>eUIWindow </I>(if available). It retrieves these by calling <I>IOleInPlaceSite::GetWindowContext. </I>As interfaces on separate objects, they are not available through the site's <I>QueryInterface</I>!</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 The exceptions are video objects and the like, which can use the <I>hWnd</I> and RECT arguments passed to <I>DoVerb</I> to temporarily<I> </I>play inside the container window.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
