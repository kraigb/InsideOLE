<HTML><HEAD><TITLE>An Example</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>An Example</H3><P>Imagine that we have a client that wants to maintain a list of links to objects and that the code and data for those objects are located outside the client's own code and storage so that the client maintains only a link or a name in its own storage while the real data exists elsewhere. When an end user gives a command such as View Description, this client would like to:</P>
<UL><LI>Obtain an interface pointer to the object identified by a selected name—that is, bind the moniker.</LI><LI>Retrieve a piece of user-readable text from the object that describes the object and its purpose.</LI><LI>Display that text to the user in a little pop-up window. Each object implements a hypothetical interface, <I>IDescription</I>, with a single member function, <I>GetText</I>, for this purpose.</LI></UL><P>Let's say the client has in its list a <I>file</I> moniker that manages a simple filename such as C:\DATA\BOOKS\CHALICE.DOC. When the user selects View Description, the client calls <I>IMoniker::BindToObject</I>. The moniker, understanding that it has a filename, calls <I>GetClassFile </I>(as we saw in Chapter 7) to find the CLSID of the code related to this file type. The moniker then calls <I>CoCreateInstance</I>3 with that CLSID, requesting <I>IPersist</I><I>File</I>, and then passes its filename to <I>IPersistFile::Load</I>, bringing the file into memory. After this, the moniker calls <I>IPersistFile::QueryInterface(IID</I><I>_</I><I>IDescription)</I>, returning that <I>IDescription </I>pointer as an out-parameter from <I>IMoniker::BindToObject</I>. The client then calls <I>IDescription::GetText</I>, which returns a string such as "Notes from January 1995 reading of <I>The Chalice and the Blade,</I> by Riane Eisler," which is the sort of thing I might have typed into a Summary Information comments field.</P>
<P>In all of what went on, the client made only two calls in order to retrieve the descriptive text: <I>IMoniker::BindToObject</I> to get the named object's <I>IDescription </I>pointer and <I>IDescription::GetText</I> to get the text. Nowhere did the client know that the moniker actually referred to a file-based object that contained a document. Nowhere does the client actually do any work itself to resolve the name into an interface pointer. All of that is done inside the moniker itself—that's where the intelligence lies. (Keep in mind that the file object probably has more interfaces than the ones this client happens to use. The same moniker could be used by some other client that wanted to do something different with the same object!)</P>
<P>Now let's say the user selects View Description for another name in the client's list. This time it's a hypothetical network connection moniker that contains the name<I> http://www.gardens.com/bunnykins.carrotpatch!eatweeds</I>, where the ! delimiter separates the name of the World Wide Web page from the password needed to access that page. The client, of course, doesn't know this. It simply executes the same code as before, calling <I>IMoniker::BindToObject</I> to get <I>IDescription</I> and then calling <I>IDescription::GetText.</I> This moniker, however, does something completely different from the file moniker we saw before, calling <I>CoCreateInstance </I>with a hypothetical <I>CLSID</I><I>_</I><I>WWWBrowser</I>, asking for a hypothetical <I>IWWWPage </I>interface pointer in return. The object here represents the connection itself so that when released it will disconnect from that page. On return from <I>CoCreateInstance</I>, the moniker passes the share name and password to something like <I>IWWWPage::SetConnection</I>, which might store that information but not actually make the connection (until something like <I>IWWWPage::Connect </I>is called). </P>
<P>The moniker then queries the connection object for <I>IDescription </I>and returns to the client. When that client calls <I>IDescription::GetText</I>, the connection object calls functions in the Win32 WinSockets API to connect to the World Wide Web page. The object then grabs the first 512 characters found on the Web page and returns that text to the client as the descriptive text. This  might contain something like "Bunnykin's private garden of goodies—raptors not welcome."</P>
<P>It is important to see that in these examples the client, using exactly the same code, retrieved the descriptive text for radically different objects without any specific knowledge of those objects. All that knowledge is hidden in the moniker, encapsulated behind the <I>IMoniker</I> interface. The monikers themselves are not the objects of interest but merely symbols that wrap all the meaning and knowledge of those objects in interchangeable units. As such, monikers are extraordinarily powerful, capable of doing far more than you might think when you first work with them.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>3 <I>Moniker::BindToObject </I>calls <I>CoCreateInstance </I>with CLSCTX_ALL meaning that all server types are allowable for moniker binding.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
