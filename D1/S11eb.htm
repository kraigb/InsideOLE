<HTML><HEAD><TITLE>IViewObject2::Draw</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IViewObject2::Draw</I></H3><P>Because the <I>Draw</I> member function encompasses such rich functionality, it probably has the longest argument list in all of OLE. It allows a client to tell an object exactly what to draw (<I>dwAspect</I>, <I>lindex</I>, <I>pvAspect</I>), where to draw it (<I>hDC</I>, <I>prcBounds</I>, <I>prcWBounds)</I>, and how to draw it (<I>ptd</I>, <I>hicTargetDev</I>). In addition, a client can supply a callback function to break out of long repaints (<I>pfnContinue </I>and <I>dwContinue</I>). We'll first look at the basic form of <I>Draw</I> and then at the specific areas of handling a device, drawing into a metafile, and breaking out of long repaints.</P>
<P>The simplest way to call <I>Draw </I>is expressed in the following code:</P>
<P><BR></P>
<pre><code>pIViewObject2-&gt;Draw(DVASPECT_CONTENT, -1, NULL, NULL, 0, hDC, &amp;rcBounds<BR>    , NULL, NULL, 0);</code></pre>
<P>This statement says, "Draw the full rendering of the object (<I>DVASPECT</I><I>_</I><I>CONTENT, </I><FONT FACE="Symbol"><I>-</I></FONT><I>1</I>) in this rectangle (<I>rcBounds</I>) on this device context (<I>hDC</I>)." The object draws its full-content rendering (whatever it is) directly to <I>hDC</I>, scaled to fit into <I>rcBounds</I>. The rectangle must be expressed in the current mapping mode of <I>hDC</I>, which can be a screen, a printer, a metafile, or a memory device context. An object that typically generates bitmaps can implement this function with a simple <I>StretchBlt</I> call; if it normally uses a metafile, it can call <I>PlayMetafile</I> after setting the extents properly for the rectangle. The object is also required (as common sense would dictate) to leave <I>hDC</I> in the same state as it was received. If the object needs to change mapping modes or another state of <I>hDC</I>, it must call the Windows API <I>SaveDC</I> on entry to <I>Draw </I>and match it with <I>RestoreDC</I> on exit.</P>
<P>Again, the RECTL pointed to by <I>prcBounds </I>specifies the scaling rectangle in units appropriate to <I>hDC</I>. This is not a clipping rectangle: the object is required to draw its full presentation into this rectangle. Where the scaling percentage is the ratio of the <I>prcBounds </I>dimensions to the object's extents:</P>
<P><I>    </I><I>prcBounds</I> -&gt;<I>right</I> <FONT FACE="Symbol">- </FONT><I>prcBounds</I> -&gt;<I>left</I> </P>
<P><I>xScale</I> = -------------------------------------------------------------- * 100%</P>
<P>    <I>xExtent</I> </P>
<P><I>    </I><I>prcBounds</I> -&gt;<I>bottom</I> <FONT FACE="Symbol">- </FONT><I>prcBounds</I> -&gt;<I>top</I></P>
<P><I>yScale</I> = ----------------------------------------------------------------- * 100%</P>
<P>     <I>yExtent</I> </P>
<P>If the client actually wants a clipped rendering, it must create a clipping rectangle, select it into <I>hDC </I>before calling <I>Draw</I>, and specify <I>prcBounds </I>so that the intersection of the clipping rectangle and <I>prcBounds </I>results in the correct viewing window, as shown in Figure 11-1. In short, clipping is always the client's concern, never the viewable object's.</P>
<P>    <img src="f11dd01.gif"></P>
<P><B>Figure 11-1.</B></P>
<P><B>Clipping through <I>IViewObject2::Draw </I>is achieved through a combination of a <I>prcBounds </I>and a clipping rectangle selected into <I>hDC.</I></B></P>
<P>Because a client often wants no more than to specify the aspect, the device context, and the bounding rectangle for any drawing operation, OLE provides the API function <I>OleDraw</I>, whose implementation is as follows:</P>
<P><BR></P>
<pre><code>STDAPI OleDraw(LPUNKNOWN pIUnknown, DWORD dwAspect, HDC hDC<BR>    , LPCRECTL prcBounds);<BR>    {<BR>    HRESULT      hr;<BR>    LPVIEWOBJECT pIViewObject;<BR><BR>    if (NULL!=pIUnknown)<BR>        {<BR>        hr=pIUnknown-&gt;QueryInterface(IID_IViewObject<BR>            , (VOID **)&amp;pIViewObject);<BR><BR>        if (SUCCEEDED(hr))<BR>            {<BR>            pIViewObject2-&gt;Draw(dwAspect, -1, NULL, NULL, 0<BR>                , hDC, prcBounds, NULL, NULL, 0);<BR><BR>            pIViewObject2-&gt;Release();<BR>            }<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>This API function is a convenient wrapper because a client does not need to query for <I>IViewObject </I>or hold onto some <I>IViewObject </I>pointer for later drawing. But <I>OleDraw </I>doesn't help in cases in which you want more control over the exact rendering. In those cases—rendering for a specific device, drawing into a metafile, and stopping long repaints—you can always query for <I>IViewObject[2]</I> and call <I>Draw</I>.</P>
<H4><A NAME="sec0"></A>Rendering for a Specific Device</H4><P>Many applications, especially high-end graphics and desktop publishing packages, are concerned about getting both the highest quality and the fastest possible output on a printer. Two arguments to <I>Draw </I>allow applications to tell a viewable object about the intended device:</P>
<UL><LI><I>ptd (DVTARGETDEVICE </I>*<I>)</I>: Identical to the <I>ptd</I> field in a FORMATETC, which describes the exact device for which the object is to render its image. A NULL means the display.</LI><LI><I>hicTargetDev (hDC)</I>: An information context for a target device other than the screen. By using this context, the object can extract device metrics, test the device's capabilities, and retrieve any other relevant parameters. Objects ignore this argument if <I>ptd </I>is NULL; if <I>hicTargetDev</I> is non-NULL, it specifies the information context for a printer; if NULL, it means the client is drawing to the screen what would appear on the printer.</LI></UL><P>There are two primary cases in which a client might pass non-NULL values in these arguments. The first and most obvious occurs when <I>hDC</I> is a printer device context and you want the objects to render as accurately as possible for that printer. In this case, you can describe the printer device in <I>ptd</I> and pass either an information context you have on hand in <I>hicTargetDev </I>or pass your <I>hDC</I> as this argument. (A device context is an information context.) When <I>ptd </I>is non-NULL, a client must pass something in <I>hicTargetDev</I> to tell the object that the device context in <I>hDC </I>is for a printer. As an example of when you might use these arguments, consider printing to a PostScript printer for an object that understands PostScript directly. The object, knowing that <I>hDC</I> is a real printer device context, could send PostScript commands directly to the printer (through the Windows <I>Escape</I> function) instead of calling Windows GDI functions. The result is better performance and highly optimized output.</P>
<P>The second use of these arguments is for situations such as print preview, in which the client wants the object to draw to the screen what that object would draw to the printer. In this case, <I>ptd</I> points to a valid DVTARGETDEVICE, but <I>hicTargetDev</I> is NULL. This means that the object should call GDI functions on <I>hDC</I> to draw itself but should use colors and resolution appropriate for the device described by <I>ptd</I>. For example, an object that normally shows a magenta shading on the screen would print a dither pattern on a black-and-white printer. In this situation, the object creates its own information context according to <I>ptd</I> in order to know the color capability of that device and in order to modify its output to <I>hDC </I>accordingly.</P>
<H4><A NAME="sec1"></A>Drawing into a Metafile</H4><P>A metafile device context is a rather special beast when it comes to drawing the object at a specific location within that metafile. The object in this case needs to know both the window extents and the window origin of the <I>hDC</I> to draw itself in the correct location within the scope of the entire metafile. To do this, the <I>prcWBounds</I> argument to <I>Draw </I>contains the window extent and the window origin for the metafile, not a real rectangle. This argument will be non-NULL only if <I>hDC </I>is a metafile device context.</P>
<P>The origin is the point (<I>prcWBounds-&gt;left</I>, <I>prcWBounds-&gt;top</I>). The horizontal extent is <I>prcWBounds-&gt;right</I>, and the vertical extent is <I>prcWBounds-&gt;bottom</I>. To account for these values, a viewable object must offset its GDI calls into the metafile by the origin coordinates and must scale the points it passes to those GDI calls according to the ratio of the window extents to the object's own extents. Do not call the Windows API <I>SetWindowsOrgEx </I>or <I>SetWindowExtEx </I>for this purpose.</P>
<P>The <I>prcWBounds </I>argument really matters when an object plays another metafile as part of its own rendering. Usually each record in such a metafile will assume a certain origin and extent, so to account for those assumptions the object must enumerate the metafile and massage each record individually to modify the origin and scaling appropriately.</P>
<H4><A NAME="sec2"></A>Stopping Long Repaints</H4><P>The <I>pfnContinue </I>and <I>dwContinue </I>arguments to <I>IViewObject2::Draw</I> give a client the ability to terminate long repaints for complicated drawings:</P>
<UL><LI><I>pfnContinue (BOOL (CALLBACK </I><I>*</I><I>)(DWORD))</I>: A pointer to a callback function that the viewable object will call periodically during a lengthy drawing process. The callback function returns TRUE to continue drawing or FALSE to abort the operation (usually if the user hits Esc). If the drawing operation is canceled, <I>Draw</I> returns DRAW_E_ABORT.</LI><LI><I>dwContinue (DWORD)</I>: An extra 32-bit value to pass as the argument to <I>pfnContinue</I>. Typically, this value is a pointer to some client-defined structure needed inside the callback function.</LI></UL><P>A typical client implements the continue function to test the Esc key status:</P>
<P><BR></P>
<pre><code>BOOL CALLBACK ContinuePaint(DWORD dwContinue)<BR>    {<BR>    return !(GetAsyncKeyState(VK_ESCAPE) &lt; 0);<BR>    }</code></pre>
<P>How often this function is actually called depends on the object and how it draws itself. As a general guideline, an object should call the function once for every 16 operations, an operation being a GDI call or the playing of a metafile record. Obviously this will not work to break out of a single, time-consuming call to <I>StretchBlt</I>, but if the object draws more than one large bitmap, it should call the function after each <I>BitBlt</I> or <I>StretchBlt</I>. A really kind object might even try to draw a large bitmap in separate bands. In any case, call the continuation function if possible, and if the object draws quickly, you can ignore it altogether.</P></font></body></HTML>
