<HTML><HEAD><TITLE>Scrolling the Page</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Scrolling the Page</H3><P>I saved this topic for last because it involves a few tricks. To be honest, it took me about six working days to figure out Patron's scrolling code. I hope this experience can save you some time because, on the surface, scrolling seems simple enough. If the mouse is held in the inset region (inside the edge of the <I>window, </I>not the droppable region) for the right amount of time, the target starts combining DROPEFFECT_SCROLL with any other effect flag. (This tells the user that scrolling will begin shortly.) When the mouse has stayed in the inset region for the set time, the target starts scrolling its window in the appropriate direction, using the <I>DragOver </I>pulse to continue scrolling if the mouse doesn't move. Inside <I>DragOver</I>, you scroll only if the scroll repeat rate time has elapsed since the last time you scrolled.</P>
<P>Patron first reads the DragScrollInset value from WIN.INI in the <I>CPages </I>constructor:</P>
<P><BR></P>
<pre><code>m_uScrollInset=GetProfileInt(TEXT("windows"), TEXT("DragScrollInset")<BR>    , DD_DEFSCROLLINSET);</code></pre>
<P><I>CPages::U</I><I>TestDroppablePoint</I> uses <I>m</I><I>_</I><I>uScrollInset</I> to check whether the mouse coordinates are within the inset region of the pages window:</P>
<P><BR></P>
<pre><code>//In CPages::UTestDroppablePoint<BR>UINT    uRet;<BR>RECT    rcC;<BR><BR>GetClientRect(m_hWnd, &amp;rcC);<BR><BR>[Code to store UDROP_NONE or UDROP_CLIENT in uRet]<BR><BR>//Scroll checks happen on client area.<BR>if (PtInRect(&amp;rcC, pt))<BR>    {<BR>    //Check horizontal inset.<BR>    if (pt.x &lt;= rcC.left+(int)m_uScrollInset)<BR>        uRet œ= UDROP_INSETLEFT;<BR>    else if (pt.x &gt;= rcC.right-(int)m_uScrollInset)<BR>        uRet œ= UDROP_INSETRIGHT;<BR><BR>    //Check vertical inset.<BR>    if (pt.y &lt;= rcC.top+(int)m_uScrollInset)<BR>        uRet œ= UDROP_INSETTOP;<BR>    else if (pt.y &gt;= rcC.bottom-(int)m_uScrollInset)<BR>        uRet œ= UDROP_INSETBOTTOM;<BR>    }</code></pre>
<P>UDROP_INSETLEFT and UDROP_INSETRIGHT are inclusive with both UDROP_INSETTOP and UDROP_INSETBOTTOM, but LEFT is mutually exclusive with RIGHT and TOP is mutually exclusive with BOTTOM. This means that Patron can scroll horizontally and vertically at the same time if the mouse is within both the horizontal and vertical inset regions. Patron will not, however, attempt to scroll up and down or left and right at the same time. That would be an interesting sight!</P>
<P>As mentioned earlier, <I>UTestDroppablePoint</I> is called each time in <I>CDropTarget::DragEnter</I>, <I>CDropTarget::DragOver</I>, and <I>CDropTarget::Drop</I>. The important call is the one in <I>DragOver</I>, in which the variable <I>uRet</I> contains the current UDROP_* combination and <I>m</I><I>_</I><I>uLastTest</I> (in <I>CPages</I>) contains the code from the last cycle through <I>DragOver</I> (or from <I>DragEnter</I>). So in any pass through <I>DragOver</I>, we know whether the cursor was outside the inset region and moved in, whether it was in the inset region and moved out, or whether we haven't changed from the last pass in or out of the region.</P>
<P>But <I>CDropTarget </I>has to be sensitive to the initial scroll delay so as to allow the user to move the mouse over the edge of the window without causing a scroll. This value is first loaded in <I>CPages::CPages</I>:</P>
<P><BR></P>
<pre><code>m_uScrollDelay=GetProfileInt(TEXT("windows"), TEXT("DragScrollDelay")<BR>    , DD_DEFSCROLLDELAY);</code></pre>
<P>The default value for DD_DEFSCROLLDELAY is defined as 50 ms. Unfortunately, this is shorter than the 55-ms resolution of the Windows timer. It's a little hard to test a delay this short—create a <I>DragScrollDelay=300</I> in the [windows] section of WIN.INI for testing purposes; this lets you move through things more slowly and test your timer counting.</P>
<P>Now we have to count the time from the moment the mouse entered the inset region in each iteration through <I>DragO</I><I>ver</I>. The best way to do this is with <I>GetTickCount. </I>A Windows timer does work because a timer requires you to be in your message loop calling <I>GetMessage </I>and <I>DispatchMessage</I>. But <I>DoDragDrop </I>does this only for mouse and keyboard messages. I tried using timers for implementing scrolling, but because my message loop never had a chance to run and dispatch WM_TIMER (or have <I>DispatchMessage </I>call a timer callback function), I never saw the timer expire.</P>
<P>Instead, <I>DragOver </I>saves in <I>m</I><I>_</I><I>dwTimeLast </I>the value from <I>GetTick</I><I>Count </I>when the mouse first moved into the inset region. On every later call to <I>DragOver</I>,<I> GetTickCount </I>is called again and <I>m</I><I>_</I><I>dwTimeLast </I>is subtracted from it. If this difference is greater than the scroll rate, Patron scrolls a little and stores the current time in <I>m</I><I>_</I><I>dwTimeLast. </I>Through more calls to <I>DragOver</I>,<I> </I>Patron counts beyond the scroll rate again, scrolls a little more, resets as the base counter, and continues. If the mouse moves out of the region, Patron, of course, stops scrolling. To indicate this condition, <I>DragOver </I>sets <I>m</I><I>_</I><I>dwTimeLast </I>to 0(meaning "no scroll under any circumstances").</P>
<P>All of this is wrapped up in some repetitive-looking code in <I>DragOver</I>, in which <I>uLast</I> is the value in <I>m</I><I>_</I><I>uLastTest</I> and <I>ppg</I> is the current <I>CPages</I> pointer:</P>
<P><BR></P>
<pre><code>if ((UDROP_INSETHORZ &amp; uLast) &amp;&amp; !(UDROP_INSETHORZ &amp; uRet))<BR>    ppg-&gt;m_uHScrollCode=0xFFFF;<BR><BR>if (!(UDROP_INSETHORZ &amp; uLast) &amp;&amp; (UDROP_INSETHORZ &amp; uRet))<BR>    {<BR>    ppg-&gt;m_dwTimeLast=GetTickCount();<BR>    ppg-&gt;m_uHScrollCode=(0!=(UDROP_INSETLEFT &amp; uRet))<BR>        ? SB_LINELEFT : SB_LINERIGHT; //Same as UP and DOWN codes<BR>    }<BR><BR>if ((UDROP_INSETVERT &amp; uLast) &amp;&amp; !(UDROP_INSETVERT &amp; uRet))<BR>    ppg-&gt;m_uVScrollCode=0xFFFF;<BR><BR>if (!(UDROP_INSETVERT &amp; uLast) &amp;&amp; (UDROP_INSETVERT &amp; uRet))<BR>    {<BR>    ppg-&gt;m_dwTimeLast=GetTickCount();<BR>    ppg-&gt;m_uVScrollCode=(0!=(UDROP_INSETTOP &amp; uRet))<BR>        ? SB_LINEUP : SB_LINEDOWN;<BR>    }<BR><BR>if (0xFFFF==ppg-&gt;m_uHScrollCode &amp;&amp; 0xFFFF==ppg-&gt;m_uVScrollCode)<BR>    ppg-&gt;m_dwTimeLast=0L;<BR><BR>//Set the scroll effect on any inset hit.<BR>if ((UDROP_INSETHORZ œ UDROP_INSETVERT) &amp; uRet)<BR>    *pdwEffect œ= DROPEFFECT_SCROLL;</code></pre>
<P>This block of code checks for a change in the mouse's position relative to the inset region—in to out or out to in. It then sets up the <I>CPages</I> variables <I>m</I><I>_</I><I>uHScrollCode</I> and <I>m</I><I>_</I><I>uVScrollCode</I> with the codes to send with WM_HSCROLL and WM_VSCROLL messages, in which 0xFFFF is a flag that means "no scrolling."</P>
<P><I>DragOver</I> then checks for expiration of the scroll rate timer. If the timer has elapsed, <I>DragOver</I> sends the appropriate scroll messages as follows:</P>
<P><BR></P>
<pre><code>if (ppg-&gt;m_dwTimeLast!=0<BR>    &amp;&amp; (GetTickCount()-ppg-&gt;m_dwTimeLast) &gt; (DWORD)ppg-&gt;m_uScrollDelay)<BR>    {<BR>    if (0xFFFF!=ppg-&gt;m_uHScrollCode)<BR>        {<BR>        m_fPendingRepaint=TRUE;<BR>        SendMessage(ppg-&gt;m_hWnd, WM_HSCROLL, ppg-&gt;m_uHScrollCode, 0L);<BR>        }<BR><BR>    if (0xFFFF!=ppg-&gt;m_uVScrollCode)<BR>        {<BR>        m_fPendingRepaint=TRUE;<BR>        SendMessage(ppg-&gt;m_hWnd, WM_VSCROLL, ppg-&gt;m_uVScrollCode, 0L);<BR>        }<BR>    }</code></pre>
<P>This will send both WM_HSCROLL and WM_VSCROLL messages in the same pass through <I>DragOver</I> if necessary. This brings us to repainting. In Patron, drag-and-drop scrolling should be fast and should not require a repaint on every scroll. With many tenants on a page, especially tenants with bitmaps, each scroll would be painfully slow. To prevent the repaints, the <I>m</I><I>_</I><I>fPendingRepaint</I> flag is set to FALSE unless a scroll has occurred, in which case, it's set to TRUE. This flag is used in <I>DragOver</I>, <I>DragLeave</I>, and <I>Drop</I> to repaint the page when scrolling has stopped. The last two cases are obvious: moving out of the window or dropping stops scrolling. In <I>DragOver</I>, however, we have to determine whether the last <I>SendMessage</I> did, in fact, change the scroll position of the page. Therefore, before executing the preceding code, we save the current scroll positions in local variables:</P>
<P><BR></P>
<pre><code>xPos=ppg-&gt;m_xPos;<BR>yPos=ppg-&gt;m_yPos;</code></pre>
<P>After we have possibly sent WM_*SCROLL messages, we check the previous scroll positions against the new ones. If they are the same and a repaint is pending, we repaint:</P>
<P><BR></P>
<pre><code>if (xPos==ppg-&gt;m_xPos &amp;&amp; yPos==ppg-&gt;m_yPos &amp;&amp; m_fPendingRepaint)<BR>    {<BR>    UpdateWindow(ppg-&gt;m_hWnd);<BR>    m_fPendingRepaint=FALSE;<BR>    }</code></pre>
<P><I>DragLeave</I> and <I>Drop</I> always call <I>UpdateWindow</I> if the <I>m</I><I>_</I><I>fPendingRepaint</I> flag is TRUE.</P>
<P>One last consideration caused me much consternation. When I first implemented this scrolling business on a 16-bit platform, I tested it mostly by moving tenants around on the same page or among different documents. Everything worked great. Then I tried to drag something in from another application, such as Cosmo. Things fell apart because, with remote calls going on, my message loop had a chance to run. This didn't happen before because there's no yielding when both the source and the target are the same application!</P>
<P>The result was that Patron would occasionally receive WM_PAINT messages because scrolling, of course, invalidates regions of my client area. Normally this would not have been a problem except for my little end-user feedback rectangle. This is what happened: my <I>CDropTarget::DragOver</I> was called, I removed the previous feedback rectangle, I scrolled the page, and then I drew the new feedback rectangle over a possibly invalid region of the window. When WM_PAINT came along, it repainted that invalid region, erasing parts of my feedback rectangle. Then I came back into <I>DragOver</I> and attempted to erase the old feedback rectangle again. Because part of it was already gone and because my rectangle drawing is based on an XOR, I ended up with rectangle fragments on the screen. U-G-L-Y. I tried a number of things—ignoring the WM_PAINT messages, for example (which didn't work at all, as I should have known)—and finally arrived at a solution after a few more days of going nowhere. I maintain a flag in <I>CPages::m</I><I>_</I><I>fDragRectShown</I> that is modified only in <I>DrawDropTargetRect</I>: the flag is TRUE if the rectangle is visible, FALSE otherwise. If this flag is set when <I>PagesWn</I><I>dProc</I> in PAGEWIN.CPP is processing WM_PAINT, I call <I>DrawDropTargetRect</I> to erase the current rectangle, do the painting as usual, and then call <I>DrawDropTargetRect</I> again to reinstate the feedback. Finally everything came out clean. Yes, we all struggle at times with some aspects of programming for Windows!</P></font></body></HTML>
