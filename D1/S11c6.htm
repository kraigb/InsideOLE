<HTML><HEAD><TITLE>IMoniker: Composite Group</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IMoniker</I>: Composite Group</H3><P>A number of <I>IMoniker </I>members apply specifically to composites. This means that simple monikers can leave many of these functions unimplemented. We have seen the operation of <I>Enum </I>and <I>IsSystemMoniker</I>; all we need to add to our discussion of <I>Enum</I> is that <I>fForward </I>specifies the direction of enumeration, left to right (when <I>fForward</I> is TRUE) or right to left (when <I>fForward</I> is FALSE), depending on the needs of the caller.</P>
<P>The core member in the Composite group is <I>ComposeWith</I>. Even simple monikers (including the anti-moniker) implement it. The function is given a "suffix"—that is, a moniker to its right (<I>pmkRight)</I>—and is asked to create a composite containing itself and that suffix. <I>ComposeWith </I>basically gives a moniker the chance to control the type of composite used, generic or nongeneric. The moniker being asked to compose can call <I>pmkRight-&gt;GetClassID </I>(or use some other means, such as querying for a particular custom interface) to determine whether that type would be understood by a nongeneric composite. If not, the <I>fOnlyIfNotGeneric </I>flag controls what should happen. If this flag is TRUE, <I>ComposeWith </I>should return a NULL in *<I>ppmkComposite </I>and the result MK_E_NEEDGENERIC. This basically says that the moniker and <I>pmkRight </I>support only generic composition. If <I>fOnlyIfNotGeneric</I> is FALSE, the same two monikers could be combined generically with <I>CreateGenericComposite.</I></P>
<P>It is interesting that if <I>pmkRight</I> happens to be an anti-moniker or something that completely negates the moniker being called, <I>ComposeWith</I> returns a NULL in *<I>ppmkComposite</I> and the NOERROR result, regardless of the value of <I>fOnlyIfNotGeneric</I>.</P>
<P>The functionality of the <I>IMoniker::Inverse</I> function is closely related to this idea of negation. An inverse of a moniker (which can be written as ~moniker or moniker-1) is defined as a moniker such that a NULL composition results when that inverse is passed to the moniker's <I>ComposeWith</I> (moniker·inverse). Some monikers, such as the anti-moniker, have no inverse at all, and most inverse monikers have no inverses themselves. The reason is that an inverse of one specific moniker is usually the inverse of a certain superset of monikers with the same structure as the original one. For example, a file moniker with the path DATA\OLE\SLIDES has an inverse of ..\..\... Composing the two results in nothing at all. Well, ..\..\.. is also the inverse of \TEXT\2ND_ED\FIGURES as well as FOO\BAR\BAZ, literally anything in the form &lt;<I>x</I>&gt;\&lt;<I>y</I>&gt;\&lt;<I>z</I>&gt;.</P>
<P>The inverse of a composite moniker is basically a composite that contains the inverses of each contained moniker in reverse order. That is, the inverse of File!Item1!Item2 would be Item2-1!Item1-1!File-1, which may be nothing more than Anti!Anti!File-1. The anti-moniker is again the generic inverse of any simple moniker that has no internal structure.</P>
<H4><A NAME="sec0"></A><I>CommonPrefixWith</I> and <I>RelativePathTo</I></H4><P>The member functions <I>CommonPrefixWith</I> and<I> RelativePathTo</I> are related to inverses but exist primarily for dealing with composites that contain a file moniker. When a client maintains a link to some object in another file, it is useful for that client to retain two monikers for that link: one absolute, the other relative. This is exactly how a linked compound document object stores its link information, as we'll see in Chapter 20. <I>CommonPrefixWith </I>and <I>RelativePathTo </I>provide the means to create a relative moniker.</P>
<P><I>CommonPrefixWith</I> asks a moniker to determine how much it has in common with the moniker passed to it in <I>pmkOther</I>, returning the result (which can be a composite) in *<I>ppmkPrefix</I>. For example, a composite containing C:\DATA\OLE\SPEC.DOC!Page2!Table1 and a file moniker with C:\DATA\NOTES\1995.DOC would have the common prefix C:\DATA in a single file moniker. C:\DATA\OLE\SPEC.DOC!Page2!Table1 and C:\DATA\OLE\SPEC.DOC!Page2!Table7 would have the common prefix C:\DATA\OLE\SPEC.DOC!Page2 in a File!Item composite. A few return codes for this function indicate special relationships—for example, MK_S_NOPREFIX (no common prefix exists), MK_S_HIM (<I>pmkOther </I>is already the prefix of <I>this </I>moniker), and MK_S_US (<I>this </I>and <I>pmkOther </I>are equal).</P>
<P>The <I>RelativePathTo </I>function works along similar lines: the moniker is asked to return a relative moniker so that moniker·relative results in the moniker passed in <I>pmkOther</I>. So if we ask C:\DATA\OLE\SPEC.DOC!Page2!Table1 to return the relative that would result in C:\DATA\OLE\SPEC.DOC, it could return an Anti!Anti composite. Or if asked for the relative to produce C:\DATA, it would return Anti!Anti!File, in which the file moniker contains "..". If <I>RelativePathTo </I>returns a meaningful relative, it should return the NOERROR result; if <I>pmkOther </I>is the only relative form of the moniker called, it returns MK_S_HIM to say so.</P>
<P>In both of these functions, <I>pmkOther </I>is often the moniker for the container document (or file, spreadsheet, and so on) that manages the link. If I have a container document C:\DATA\OLE\SPEC.DOC in which is linked C:\DATA\PICTURES\PUFFINS.BMP, we can create a relative moniker that contains ..\PICTURES\PUFFINS.BMP. To do this, we call the absolute path moniker's <I>CommonPrefixWith </I>with the container's moniker to get C:\DATA and then call <I>RelativePathTo</I> on the container moniker passing the common prefix to get "..". We then strip the common prefix from the linked object's moniker and compose the remainder with the relative path moniker. The result is a moniker describing the linked object in relation to the document.</P>
<P>If all of this sounds like a lot of work for a moniker to implement, you're right. For that reason, OLE provides default implementations through the API functions <I>MonikerCommonPrefixWith </I>and <I>MonikerRelativePathTo</I>. A moniker should first check whether it has intimate knowledge of <I>pmkOther</I>—that is, whether the moniker knows that it can handle <I>pmkOther </I>in a special way. If not, the moniker should use these two API functions for its implementation in order to handle generic composites correctly. <I>MonikerRelativePathTo </I>can also be called from a client as a simple wrapper for <I>IMoniker::RelativePathTo</I>. This is not true of <I>MonikerCommonPrefixWith</I>; clients should call <I>IMoniker::CommonPrefixWith</I> directly.</P>
<H4><A NAME="sec1"></A><I>Reduce</I></H4><P>The final member of the composite group, <I>Reduce</I>, asks a moniker to rewrite itself into an equivalent but more efficient form, which has several uses:</P>
<UL><LI>It enables the construction of new moniker classes that act as user-defined macros or aliases. When these are reduced, the moniker evaluates the macro or alias returning a moniker to the real object. This evaluation would normally happen if the macro or alias moniker were asked to bind, so the reduction allows the caller to separate the work of evaluation from the actual binding and improve overall binding speed.</LI><LI>It enables the construction of a kind of moniker that tracks data as it moves about so that the reduction results in the current location. This is really a special case of an alias or a macro moniker.</LI><LI>It enables a file moniker created on one operating system to translate itself into a moniker suitable for a different operating system—for example, translating from an addressing scheme based on filenames to one based on identifiers.</LI></UL><P>A somewhat contrived example of reduction is shown in Figure 9-6. It may not look like a reduction, but it illustrates the evaluation of various sorts of alias monikers into their appropriate values in the host environment. The particular classes of monikers shown here are illustrative only—OLE does not implement such monikers. In any case, you can see that many monikers in this example reduce to something totally different, whereas others do not.</P>
<P>    <img src="f09dd06.gif"></P>
<P><B>Figure 9-6.</B></P>
<P><B>An example of moniker reduction.</B></P>
<P>In this example, the top moniker is essentially decompressed into its exact form. Other monikers might reduce to something that is actually smaller, performing garbage collection. For example, a composite that contains three file monikers (some relative, some absolute) can reduce a mess like \\BUNNYKINS\CDRIVE\DATA\OLE2\OLD\..\..\OLE\..\..\TEXT\2ND_ED\CH09.DOC to \\BUNNYKINS\CDRIVE\DATA\OLE\CH09.DOC.</P>
<P>Many monikers, especially simple ones, reduce to themselves, in which case <I>Reduce </I>returns MK_S_REDUCED_TO_SELF. Otherwise, <I>dwReduceHowFar</I>, taken from the MKRREDUCE enumeration, indicates to what extent the reduction should proceed:</P>
<P><BR></P>
<pre><code>typedef enum tagMKREDUCE<BR>    {<BR>    MKRREDUCE_ONE         = 3&lt;&lt;16,<BR>    MKRREDUCE_TOUSER      = 2&lt;&lt;16,<BR>    MKRREDUCE_THROUGHUSER = 1&lt;&lt;16,<BR>    MKRREDUCE_ALL         = 0<BR>    } MKRREDUCE;</code></pre>
<P>MKRREDUCE_ONE instructs the moniker to reduce "one step," which usually means the caller has intimate knowledge of what that step will accomplish. MKRREDUCE_TOUSER asks the moniker to reduce to something whose display name would be meaningful to an end user—that is, a display name that uses filenames, bookmarks, cell ranges, database queries, and other recognizable item names that appear in the link source's user interface. Internal names (like aliases) should not be part of such a display. Closely related is MKRREDUCE_THROUGHUSER, which tells the moniker to reduce to the point at which any further reduction would render an unrecognizable display name from the user's point of view. This is often the same thing that MKRREDUCE_TOUSER does. Finally, MKRREDUCE_ALL tells the moniker to reduce as far as possible so that any later requests to reduce return MK_S_REDUCED_TO_SELF. Monikers that have no user-readable display names treat all other flags except MKRREDUCE_ONE exactly as they would treat MKRREDUCE_ALL.</P></font></body></HTML>
