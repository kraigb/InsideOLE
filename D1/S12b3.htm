<HTML><HEAD><TITLE>Send Notifications</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Send Notifications</H3><P>In the context of OLE Documents, an object can send a number of notifications and requests to both the container's <I>IAdviseSink </I>and <I>IOleClientSite </I>interfaces. The only true asynchronous notifications are calls to <I>IAdviseSink</I>, whereas others are synchronous calls to <I>IOleClientSite::SaveObject</I>. Nevertheless, lumping these together as notifications in an embedded object implementation is quite convenient. It enables us to make one function for our object that will send the proper notification to the appropriate interface whenever asked. That function is <I>CFigure::SendAdvise</I>, which accepts any of these codes defined in COSMOLE.H:</P>
<P><BR></P>
<pre><code>//Codes for CFigure::SendAdvise<BR>//......Code.....................Method called in CFigureSendAdvise...<BR>#define OBJECTCODE_SAVED       0 //IOleAdviseHolder::SendOnSave<BR>#define OBJECTCODE_CLOSED      1 //IOleAdviseHolder::SendOnClose<BR>#define OBJECTCODE_RENAMED     2 //IOleAdviseHolder::SendOnRename<BR>#define OBJECTCODE_SAVEOBJECT  3 //IOleClientSite::SaveObject<BR>#define OBJECTCODE_DATACHANGED 4 //IDataAdviseHolder::SendOnDataChange<BR>#define OBJECTCODE_SHOWWINDOW  5 //IOleClientSite::OnShowWindow(TRUE)<BR>#define OBJECTCODE_HIDEWINDOW  6 //IOleClientSite::OnShowWindow(FALSE)<BR>#define OBJECTCODE_SHOWOBJECT  7 //IOleClientSite::ShowObject</code></pre>
<P>Each code is implemented using an appropriate site interface or advise holder:</P>
<P><BR></P>
<pre><code>//FIGURE.CPP<BR>void CFigure::SendAdvise(UINT uCode)<BR>    {<BR>    switch (uCode)<BR>        {<BR>        case OBJECTCODE_SAVED:<BR>            if (NULL!=m_pIOleAdviseHolder)<BR>                m_pIOleAdviseHolder-&gt;SendOnSave();<BR><BR>            break;<BR><BR>        case OBJECTCODE_CLOSED:<BR>            if (NULL!=m_pIOleAdviseHolder)<BR>                m_pIOleAdviseHolder-&gt;SendOnClose();<BR><BR>            break;<BR><BR>        case OBJECTCODE_RENAMED:<BR>            //Call IOleAdviseHolder::SendOnRename (later)<BR>            break;<BR><BR>        case OBJECTCODE_SAVEOBJECT:<BR>            if (FlsDirty() &amp;&amp; NULL!=m_pIOleClientSite)<BR>                m_pIOleClientSite-&gt;SaveObject();<BR><BR>            break;<BR><BR>        case OBJECTCODE_DATACHANGED:<BR>            //No flags are necessary here.<BR>            if (NULL!=m_pIDataAdviseHolder)<BR>                {<BR>                m_pIDataAdviseHolder-&gt;SendOnDataChange(m_pIDataObject<BR>                    , 0, 0);<BR>                }<BR><BR>             break;<BR><BR>        case OBJECTCODE_SHOWWINDOW:<BR>            if (NULL!=m_pIOleClientSite)<BR>                m_pIOleClientSite-&gt;OnShowWindow(TRUE);<BR><BR>            break;<BR><BR>        case OBJECTCODE_HIDEWINDOW:<BR>            if (NULL!=m_pIOleClientSite)<BR>                m_pIOleClientSite-&gt;OnShowWindow(FALSE);<BR><BR>            break;<BR><BR>        case OBJECTCODE_SHOWOBJECT:<BR>            if (NULL!=m_pIOleClientSite)<BR>                m_pIOleClientSite-&gt;ShowObject();<BR><BR>            break;<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>This function eliminates the need to check for NULL pointers anywhere else and distills all notifications down to one function and one argument. Then we don't have to remember which interface—<I>IAdviseSink</I>, <I>IOleClientSite</I>, <I>IOleAdviseHolder</I>, or <I>IDataAdviseHolder</I>—we used to send which notification to the container.</P>
<P>We've seen a number of places in this chapter to which we send various notifications. These are listed in Table 18-1. The only events we haven't covered so far are those for closing a document and for data changes.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="186pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Event</B></P></TD><TD VALIGN="TOP"><P><B>Notifications (in the Order Shown)</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Closing a document<BR>(CCosmoDoc::~CcosmoDoc)</P></TD><TD VALIGN="TOP"><P><I>IOleClientSite::SaveObject</I><I><BR></I>IOleClientSite::OnShowWindow(FALSE)<BR>IOleAdviseHolder::SendOnClose<BR>(all of this before CoDisconnectObject)</P></TD></TR><TR><TD VALIGN="TOP"><P>Data changes (CCosmoDoc::FDirtySet)</P></TD><TD VALIGN="TOP"><P>IDataAdviseHolder::SendOnDataChange</P></TD></TR><TR><TD VALIGN="TOP"><P>IOleObject::Close (if saving)</P></TD><TD VALIGN="TOP"><P>IOleClientSite::SaveObject<BR>IOleAdviseHolder::SendOnSave</P></TD></TR><TR><TD VALIGN="TOP"><P>IOleObject::DoVerb(HIDE)</P></TD><TD VALIGN="TOP"><P>IOleClientSite::OnShowWindow(FALSE)</P></TD></TR><TR><TD VALIGN="TOP"><P><I>IOleObject::DoVerb(SHOW)<BR></I>(includes any verb that shows)<I> </I></P></TD><TD VALIGN="TOP"><P><I>IOleClientSite::ShowObject</I><I><BR></I><I>IOleClientSite::OnShowWindow(TRUE)</I></P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 18-1.</B></P>
<P><B>When to send notifications from an embedded object.</B></P>
<P>You'll notice that we don't use or implement OBJECTCODE_RENAMED anywhere because it's used only for linking and requires a moniker, which we won't add until Chapter 21. In addition, you'll notice that the server never calls <I>IAdviseSink::OnViewChange</I> because a local server never implements <I>IViewObject2</I>. Instead, the data cache watches <I>IAdviseSink::OnDataChange</I> and generates <I>OnViewChange</I> notifications itself.</P>
<P>I should point out that you might need to optimize the code when you actually send <I>OnDataChange</I> to advise sinks. The preceding table describes this situation as any time data changes in your application. To reflect that in a container, OLE must call your <I>IDataObject::GetData</I> to request a new presentation. If your presentation is complex—perhaps a metafile with 5000 records—this operation will not be fast. In such cases, you might want to defer sending the notification for a specific time after the most recent change—maybe 1 or 2 seconds. This would allow end users to make rapid changes without having to continually wait for you to generate a new presentation. Only when they stop making changes will you actually send an <I>OnDataChange</I>. You can also consider making updates part of your idle time processing. If you do defer the <I>OnDataChange</I> notification in any way, send one immediately upon shutdown to ensure that OLE can get a final presentation from you.</P>
<P>And now, as the stork would say, "Congratulations! You're a mother!" Well, at least a mother of an embedded object server that is fully functional with a container application. At this point, you should be able to run Insert Object from a container to launch your server, make changes in the object, and see those changes reflected in a shaded object site. If changes are not being reflected in the container, either it's displaying a different aspect than the one you are changing, or, when your <I>IDataObject::GetData</I> is asked for CF_METAFILEPICT or CF_BITMAP, you're returning the wrong STGMEDIUM. In developing Cosmo, I tore my hair out trying to understand why the container was not reflecting changes. I discovered that the <I>tymed</I> I was storing in <I>G</I><I>etData</I>'s STGMEDIUM was TYMED_HGLOBAL instead of TYMED_MFPICT for the CF_METAFILEPICT format. Subtle, but ever so important.</P>
<P>If the container site is not shading itself, you might not be calling <I>IOleClientSite::OnShowWindow</I> at the appropriate times, or the container itself might be at fault. To determine whether you are doing it correctly, try your server with a dependable container, such as Chapter 17's version of Patron.</P>
<P>When you close your server, you should see no prompts asking to save unless you get OLECLOSE_PROMPTSAVE in <I>IOleObject::Close</I>. In this case and in the case in which you delete the running object from a container, your server should be completely purged from memory. If not, your shutdown conditions are not being met, and you are not closing your main window and exiting <I>WinMain</I>. If you are shutting down completely, you should see your object's presentation in the container's document. Double-clicking on that object should again launch your server, but this time you are asked to reload that saved object and edit that data instead.</P></font></body></HTML>
