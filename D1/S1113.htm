<HTML><HEAD><TITLE>Containment (KOALAC.CPP)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Containment (KOALAC.CPP)</H3><P>In containment, the outer object, KoalaC, creates an instance of the inner object, Animal, during KoalaC's initialization process and requests an <I>IAnimal </I>pointer in return. (<I>CKoalaC::Init </I>is called from <I>CreateKoalaContainment</I>, which is called from Reuse's window procedure.) KoalaC will request an <I>IAnimal </I>pointer in the process:</P>
<P><BR></P>
<pre><code>BOOL CKoalaC::Init(void)<BR>    {<BR>    HRESULT     hr;<BR><BR>    m_pImpIAnimal=new CImpIAnimal_K(this);<BR><BR>    if (NULL==m_pImpIAnimal)<BR>        return FALSE;<BR><BR>    m_pImpIKoala=new CImpIKoala_C(this);<BR><BR>    if (NULL==m_pImpIKoala)<BR>        return FALSE;<BR><BR>    hr=CreateAnimal(NULL, IID_IAnimal, (void **)&amp;m_pIAnimal);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>Inside KoalaC's implementation of the specific <I>IAnimal </I>member functions, KoalaC might choose to use—that is, reuse—the implementations of the same functions in the Animal object by calling them through <I>m</I><I>_</I><I>pIAnimal</I>, as any other client would. In this case, KoalaC is delegating all the calls after generating an output message to the debugger:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIAnimal_K::Eat(void)<BR>    {<BR>    ODS("KoalaC's IAnimal_K::Eat called");<BR>    m_pObj-&gt;m_pIAnimal-&gt;Eat();<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIAnimal_K::Sleep(void)<BR>    {<BR>    ODS("KoalaC's IAnimal_K::Sleep called");<BR>    m_pObj-&gt;m_pIAnimal-&gt;Sleep();<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIAnimal_K::Procreate(void)<BR>    {<BR>    ODS("KoalaC's IAnimal_K::Procreate called");<BR>    m_pObj-&gt;m_pIAnimal-&gt;Procreate();<BR>    return NOERROR;<BR>    }</code></pre>
<P>Animal's implementation of the interface also pumps out similar messages. (The ODS macro and others like it wrap calls to <I>OutputDebugString</I>; you can find these macros in INC\DBGOUT.H.)</P>
<P>When KoalaC is destroyed (from the Reuse client code calling its <I>Release</I>), the destructor calls <I>m</I><I>_</I><I>pIAnimal-&gt;Release</I> using the RELEASEINTERFACE macro we saw earlier. Animal's interface pointer never actually enters into KoalaC's implementation of <I>QueryInterface</I> because KoalaC has its own implementation. Everything KoalaC does with Animal's interface is exactly what any other client would do with Animal, which is the essence of containment.</P></font></body></HTML>
