<HTML><HEAD><TITLE>Contained Interface Classes (CObject2)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Contained Interface Classes (<I>CObject2</I>)</H3><P>One reason why interface implementations are rather verbose is that you end up defining a bunch of separate classes for each object. One way to combine the classes is to use <I>contained</I> or <I>nested</I> classes for each interface, as demonstrated in the <I>CObject2 </I>class in OBJECT2.H:</P>
<P><BR></P>
<pre><code>class CObject2 : public IUnknown<BR>    {<BR>    class CImpISampleOne : public ISampleOne<BR>        {<BR>        private:<BR>            DWORD       m_cRef;         //For debugging<BR>            CObject2   *m_pObj;         //Backpointer for delegation<BR><BR>        public:<BR>            CImpISampleOne(CObject2 *pObj)<BR>                { m_cRef=0; m_pObj=pObj; }<BR><BR>            ~CImpISampleOne(void)<BR>                { }<BR><BR>            //IUnknown members<BR>            STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>            STDMETHODIMP_(DWORD) AddRef(void);<BR>            STDMETHODIMP_(DWORD) Release(void);<BR><BR>            //ISampleOne members<BR>            STDMETHODIMP         GetMessage(LPTSTR, UINT);<BR>        };<BR><BR>    class CImpISampleTwo : public ISampleTwo<BR>        {<BR>        private:<BR>            DWORD       m_cRef;         //For debugging<BR>            CObject2   *m_pObj;         //Backpointer for delegation<BR><BR>        public:<BR>            CImpISampleTwo(CObject2 *pObj)<BR>                { m_cRef=0; m_pObj=pObj; }<BR>            ~CImpISampleTwo(void)<BR>                { }<BR><BR>            //IUnknown members<BR>            STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>            STDMETHODIMP_(DWORD) AddRef(void);<BR>            STDMETHODIMP_(DWORD) Release(void);<BR><BR>            //ISampleTwo members<BR>            STDMETHODIMP         GetString(LPTSTR, UINT);<BR>        };<BR><BR>    friend CImpISampleOne;<BR>    friend CImpISampleTwo;<BR><BR>    private:<BR>        DWORD           m_cRef;         //Object reference count<BR><BR>        CImpISampleOne  m_ImpISampleOne;<BR>        CImpISampleTwo  m_ImpISampleTwo;<BR><BR>    public:<BR>        CObject2(void);<BR>        ~CObject2(void);<BR><BR>        //IUnknown members<BR>        STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>        STDMETHODIMP_(DWORD) AddRef(void);<BR>        STDMETHODIMP_(DWORD) Release(void);<BR>    };<BR><BR>typedef CObject2 *PCObject2;</code></pre>
<P>The only real difference here is that instead of the object managing pointers to each interface, it directly manages the implementation objects themselves. This means that constructing an instance of <I>CObject2 </I>will automatically instantiate the interface classes; destruction is automatic as well. We don't need any extra <I>Init </I>function to complete the construction of the object, but we do have to play tricks with the object constructor, as shown in the code at the top of the following page.</P>
<P><BR></P>
<pre><code>CObject2::CObject2(void)<BR>    : m_ImpISampleOne(this), m_ImpISampleTwo(this)<BR>    {<BR>    m_cRef=0;<BR>    return;<BR>    }</code></pre>
<P>This is the only way I found to get the object's <I>this </I>pointer into the interface classes to serve as the backpointer.</P>
<P>The object's <I>QueryInterface</I> implementation looks much the same as in <I>CObject1</I> except that we have to return the address of the contained objects instead of pointers:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CObject2::QueryInterface(REFIID riid, PPVOID ppv)<BR>    {<BR>    *ppv=NULL;<BR><BR>    //IUnknown comes from CObject2.<BR>    if (IID_IUnknown==riid)<BR>        *ppv=this;<BR><BR>    //Other interfaces come from contained classes.<BR>    if (IID_ISampleOne==riid)<BR>        *ppv=&amp;m_ImpISampleOne;<BR><BR>    if (IID_ISampleTwo==riid)<BR>        *ppv=&amp;m_ImpISampleTwo;<BR><BR>    if (NULL==*ppv)<BR>        return ResultFromScode(E_NOINTERFACE);<BR><BR>    ((LPUNKNOWN)*ppv)-&gt;AddRef();<BR>    return NOERROR;<BR>    }</code></pre>
<P>Other than that, the implementations of the contained classes are exactly the same (you'll notice that the constructor and destructor are declared in line in this sample), even the delegation of <I>IUnknown </I>calls to <I>CObject2</I>.</P>
<P>Contained classes are a little more concise than interface implementations, and the technique automates the creation of interface classes. This makes the creation process harder to trace, but that's not a big issue. I find the class declarations harder to read, which is why I don't use this technique in this book. You might find it beneficial in your own projects to limit the scope of an interface class to the object that uses it—especially if you have  in the same source code multiple objects that implement the same interfaces but need those interface implementations to be different. This technique allows you to scope the interface class names within the object class name, whereas the interface implementations technique requires globally unique interface class names.</P></font></body></HTML>
