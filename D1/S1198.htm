<HTML><HEAD><TITLE>The LockBytes Object and ILockBytes</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The LockBytes Object and <I>ILockBytes</I></H3><P>The Structured Storage model doesn't make any stipulation about the storage device that is hidden behind the root storage object. OLE's compound files use an object named LockBytes to abstract any storage device into a generic byte array. This object implements <I>ILockBytes</I>, which supports operations such as "read so many bytes from this part of the array" and "write these bytes at this address." A LockBytes object doesn't know what information is being placed in the array; it simply makes any potentially noncontiguous storage medium appear as a long flat byte array, exactly the same way a file system presents a file and just the way a stream looks to its client. In short, a LockBytes object acts like a sort of device driver, isolating the rest of the compound files implementation from any specific knowledge about the device, as illustrated in Figure 7-7.</P>
<P>With compound files, OLE provides a default LockBytes implementation that works with a handle-based file from the local file system. The API functions that we'll discuss install this LockBytes object as part of their functionality, but you can implement your own object with <I>ILockBytes </I>and create a compound file on top of it. Or you can use a standard OLE-provided implementation that works on global memory. In both of these cases, an alternative LockBytes is a customization of OLE's service that gives you control over where the bits finally end up.</P>
<P>    <img src="f07dd07.gif"></P>
<P><B>Figure 7-7.</B></P>
<P><B>A LockBytes object sits on a device, a root storage builds on the LockBytes object, and streams and storages live below that root storage.</B></P>
<P>The global-memory LockBytes implementation is provided through the API function <I>CreateILockBytesOnHGlobal</I>, to which you can pass a section of global memory or let the function allocate the memory itself. You can tell the LockBytes object to free the memory automatically when the object itself is destroyed. The function <I>GetHGlobalFromILockBytes</I> then returns the global-memory handle underneath the object. This allows you to manage the LockBytes object as you would a memory stream obtained through <I>CreateStreamOnHGlobal</I>—you need only to maintain a pointer, retrieving the memory from the object if you need it. In the future, you can expect to see functions to create a LockBytes object on top of a traditional file, just like the APIs that would allow you to open a stream on top of a file.</P>
<P>Although an implementation of <I>ILockBytes </I>lets you control where the bits are stored, it does not give you the ability to determine what is contained in those bits. As we can see in Table 7-5 on the following page, the <I>ILockBytes</I> member functions <I>ReadAt </I>and <I>WriteAt </I>must blindly read or write blocks of data without any interpretation of what those blocks contain. These read and write mechanisms are similar to those in a stream, but a LockBytes object maintains no seek offset—it is always told where to read and where to write in every call. So although a LockBytes object controls the physical location of bits, which need not be contiguous (they might span multiple physical files, multiple global-memory allocations, multiple database fields, and so forth), OLE retains control of the compound file data structures. The LockBytes object isolates OLE from the physical aspects of the storage device, presenting that device as a contiguous byte array.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="95pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>ILockBytes<BR>Description</B></P></TD><TD VALIGN="TOP"><P><B>Member</B></P></TD></TR><TR><TD VALIGN="TOP"><P>ReadAt</P></TD><TD VALIGN="TOP"><P>Reads a number of bytes from a given location in the byte array. If there are not enough bytes on the device to satisfy the request, <I>ReadAt</I> returns as many bytes as can be read.</P></TD></TR><TR><TD VALIGN="TOP"><P>WriteAt</P></TD><TD VALIGN="TOP"><P>Writes a number of bytes to a given location in the byte array, expanding the allocations on the device to accommodate the request.</P></TD></TR><TR><TD VALIGN="TOP"><P>Flush</P></TD><TD VALIGN="TOP"><P>Ensures that any internal buffers are written to the device.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetSize</P></TD><TD VALIGN="TOP"><P>Preallocates a specific amount of space on the device.</P></TD></TR><TR><TD VALIGN="TOP"><P>LockRegion</P></TD><TD VALIGN="TOP"><P>Locks a range of bytes on the device for write access or exclusive access.</P></TD></TR><TR><TD VALIGN="TOP"><P>UnlockRegion</P></TD><TD VALIGN="TOP"><P>Reverses a <I>LockRegion</I> call.</P></TD></TR><TR><TD VALIGN="TOP"><P>Stat</P></TD><TD VALIGN="TOP"><P>Fills a STATSTG structure with information about the object, which in turn reflects information about the device.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 7-5.</B></P>
<P><B>The <I>ILockBytes</I> interface.</B></P></font></body></HTML>
