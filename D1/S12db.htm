<HTML><HEAD><TITLE>Server-Side Linked Objects</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Server-Side Linked Objects</H2><P>In Chapter 20, we saw that a container creates a linked content object using a moniker that it obtains either from the clipboard, from a drag-and-drop operation, from a filename, or through some other means not specified as part of OLE Documents itself. As far as the client is concerned, the linked object that wraps this moniker is almost the same as an embedded object, except that it also has the interfaces <I>IOleLink </I>and <I>IExternalConnection.</I> We also saw that activating a linked object basically means binding the moniker and asking for <I>IOleObject </I>in return.</P>
<P>This gives us the requirements for any local server that wants to support linking to its own objects:</P>
<UL><LI>The server must support binding for whatever moniker it provides through data transfer operations, following the details we discussed in Chapter 9. This usually involves at least file moniker support through <I>IPersistFile</I>.</LI><LI>The object named by the moniker must implement <I>IOleObject </I>and <I>IDataObject </I>to support OLE Documents. This differentiates a link-ing server for OLE Documents from a link source of any other kind. In this case, <I>IPersistStorage </I>is not necessary because the object saves its native data to its own storage by using whatever means it wants and does not need access to the object storage in the compound document.</LI></UL><P>The simplest linking scenario involves a single file moniker to describe the link. The version of Cosmo we'll create in this chapter supports this type of linking. A file moniker, if you remember, requires some implementation of <I>IPersistFil</I><I>e</I>, which must be implemented on the object named by that moniker. This file object must also implement <I>IOleObject </I>and <I>IDataObject</I>, as shown in Figure 21-1 on the following page. In Cosmo, the Figure object we implemented in Chapter 18 is already attached to the document and already supports most of these interfaces by virtue of its embedding support. Here we'll need to add <I>IPersistFile </I>and complete the implementation of <I>IOleObject::SetMoniker </I>and <I>IOleObject::GetMoniker. </I>In addition, we need to register the Figure object in the running object table, which is required for any link source.</P>
<P>    <img src="f21dd01.gif"></P>
<P><B>Figure 21-1.</B></P>
<P><B>A linked object in a local server named with a file moniker must implement both <I>IOleObject</I> and <I>IDataObject</I> to support OLE Documents and <I>IPersistFile</I> to support moniker binding.</B></P>
<P>Some servers might want to support linking to a specific portion of a file—for example, a paragraph in a document, a range of cells in a spreadsheet, or a small part of a larger drawing. In these cases, the server provides a File!Item moniker to name what we call <I>pseudo-objects</I> in that larger data set. When a container wants to talk to a specific pseudo-object, it will bind that File!Item moniker. The server's implementation of <I>IOleItemContainer::GetObject </I>will then create a structure for the pseudo-object and provide the container with <I>IOleObject </I>and <I>IDataObject </I>interfaces for that structure. Pseudo-objects don't exist as individual entities before that time, and they are not persistent individually because they are saved with the larger file. In addition, the data that makes up multiple pseudo-objects might overlap. For example, the cell ranges R1C5:R10C8 and R3C2:R12C10 overlap, as shown in Figure 21-2. This same spreadsheet is the source of a vast number of potential pseudo-objects. Wildcard monikers exist so that a server like this need not register every pseudo-object as individually running.</P>
<P>A server that supports linking to items in this way must implement <I>IPersistFile </I>and <I>IOl</I><I>eItemContainer </I>on the document, or file object, named by the File portion of the composite moniker. Whatever object is returned from <I>IOleItemContainer::GetObject </I>is the pseudo-object. This defines a server structure, as shown in Figure 21-3.</P>
<P>    <img src="f21dd02.gif"></P>
<P><B>Figure 21-2.</B></P>
<P><B>Pseudo-objects are named portions of a file to which a container can link with a File!Item moniker. In the source file, pseudo-objects can overlap.</B></P>
<P>    <img src="f21dd03.gif"></P>
<P><B>Figure 21-3.</B></P>
<P><B>The structure of a server that supports linking to pseudo-objects.</B></P>
<P>The implementation of the pseudo-object structure is the same as that for a file object in a simple server such as Cosmo. The server itself must register a wildcard moniker for the file and for all items within it after it has opened the file. It must also be sure to implement <I>IOleItemContainer::ParseDisplayName </I>to support the Change Source feature of the container's Links dialog box.</P>
<P>We won't see a sample of a pseudo-object server in this chapter because we can go one step further, using Patron to demonstrate linking to embeddings and a File!Item!Item linking case.</P></font></body></HTML>
