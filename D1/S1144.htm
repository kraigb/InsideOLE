<HTML><HEAD><TITLE>The Class Factory and IClassFactory</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Class Factory and <I>IClassFactory</I></H3><P>Telling COM where a server lives on the file system is one thing, but to make the component useful, that server has to provide a way for COM to request the creation of a new object. This mechanism has two parts. First, the server has to implement a class factory, which is a special type of object that literally manufactures another object of a particular CLSID, as "factory" implies. Second, the server has to expose this class factory to COM, and doing this differs between a DLL and an EXE, just as with the self-registration mechanisms.</P>
<P>The number one concept to understand is that a class factory, while itself an object, is not the root object of the component. Every instance of a class factory is associated with a single CLSID and exists strictly to facilitate the creation of the root object of a component of that CLSID, as illustrated in Figure 5-4. This is part of the COM standard. A single implementation of a class factory, such as a C++ object class, can be written to support any number of CLSIDs, but each instance of such an implementation can create objects for only one CLSID. The reasons for this will be clearer in a moment.</P>
<P>    <img src="f05dd04.gif"></P>
<P><B>Figure 5-4.</B></P>
<P><B>A class factory object exists to create other objects of a specific CLSID.</B></P>
<P>A class factory object gets its name because it must implement at least <I>IClassFactory</I> (and optionally <I>IClassFactory2</I>, which we'll see later).</P>
<P><BR></P>
<pre><code>interface IClassFactory : IUnknown<BR>    {<BR>    HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid<BR>        , void **ppv);<BR>    HRESULT LockServer(BOOL fLock);<BR>    };</code></pre>
<P>The <I>LockServer</I> function increments or decrements a <I>lock count,</I> which allows a client to keep a server in memory even when it is serving no objects; see "Unloading Mechanisms" later in this chapter for more details on this function. Note that you may run into the archaic belief that you need not implement this function, which is dead wrong. See the NOTE on page 242.</P>
<P><I>CreateInstance</I> does what it says: it creates an <I>uninitialized</I> instance of the object associated with the class factory, returning in *<I>ppv</I> a pointer to the interface identified with <I>riid</I>. (That is, a <I>QueryInterface</I> is built into <I>CreateInstance</I>.) The <I>pUnkOuter</I> argument is a pointer to the controlling unknown if the object is being created as part of an aggregation (as described in Chapter 2). This <I>pUnkOuter</I> is the standard means through which a new object from a custom component is given the controlling unknown pointer. If this pointer is non-NULL and the object doesn't support aggregation, <I>CreateInstance</I> should return CLASS_E_NOAGGREGATION. Otherwise the object should verify that the caller has requested <I>IID</I><I>_</I><I>IUnknown</I> according to the aggregation rules, returning E_NOINTERFACE if not. E_NOINTERFACE is also the return code when the requested interface is not otherwise available, and E_OUTOFMEMORY is a common error to indicate that the object could not be created.</P>
<P>Now you will notice that <I>CreateInstance</I> is not passed a CLSID because the association between CLSID and class factory happens elsewhere in the server. (See the section "Exposing the Class Factory" on page 237.) Other than that, the idea of a class factory and the <I>CreateInstance</I> function is like the C++ <I>ne</I><I>w</I> operator, and in fact, C++ implementations of class factories typically use <I>new</I> internally. For example, we've already seen code in the <I>CreateAnimal</I> function of the Chapter 2 REUSE sample that does exactly what is being described here:</P>
<P><BR></P>
<pre><code>HRESULT CreateAnimal(IUnknown *pUnkOuter, REFIID riid, void **ppv)<BR>    {<BR>    CAnimal    *pObj;<BR><BR>    if (NULL!=pUnkOuter &amp;&amp; riid!=IID_IUnknown)<BR>        return ResultFromScode(CLASS_E_NOAGGREGATION);<BR><BR>    pObj=new CAnimal(pUnkOuter);<BR><BR>    if (NULL==pObj)<BR>        return FALSE;<BR><BR>    if (!pObj-&gt;Init())<BR>        return FALSE;<BR><BR>    return SUCCEEDED(pObj-&gt;QueryInterface(riid, (PPVOID)ppv));<BR>    }</code></pre>
<P>This code is almost exactly like most <I>CreateInstance</I> implementations you'll see and write. What is special about the class factory object is that we can expose an <I>IClassFactory</I> pointer outside the server through a standard mechanism, whereas it's much harder to directly expose some arbitrarily named function like <I>CreateAnimal</I>. In fact, <I>IClassFactory</I> is precisely how you would encapsulate a function such as <I>CreateAnimal</I> behind a binary standard so that it can be used from outside the server. In such a case, <I>IClassFactory::CreateInstance</I> would do nothing more than call <I>CreateAnimal</I>, and it is the COM interface mechanism that allows the server to expose the pointer to this function in a standard way. This is how COM makes it simple to encapsulate legacy code in OLE objects.</P>
<P><I>IClassFactory</I>, therefore, eliminates the need for any client to know the exact name of the creation function for some type of component—the client need only know the CLSID, which can be retrieved from the registry. So we can now see that the only thing standing between the server pathname in the registry and the class factory itself is a way for COM to get hold of that factory's <I>IClassFactory</I> pointer. This is the subject of "Exposing the Class Factory" beginning on page 237.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>Uninitialized Objects and Initialization Interfaces</H4><P>The previous discussion describes <I>IClassFactory::Creat</I><I>eInstance</I> as creating an <I>uninitialized</I> object from the perspective of the client. This means that the client's first act should be to pass any additional information that will suitably initialize the object. Of course, some objects need no initialization, so that <I>CreateInstance </I>returns, in those cases, ready-to-use objects. Other objects, however, will support at least one interface that contains an initialization member function. <I>IPersistStorage::InitNew </I>and <I>IPersistStorage::Load</I> are interfaces of this kind; one tells an object to initialize with a new state (<I>InitNew</I>) while the other tells an object to initialize from a previously saved state (<I>Load</I>). Another example of an initialization interface is <I>IOleObject::SetClientSite, </I>through which a compound document object is given access to the functionality in the container site, which the object may need for initialization. In the course of this book, we'll see other examples of initialization interfaces.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
