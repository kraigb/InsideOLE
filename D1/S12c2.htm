<HTML><HEAD><TITLE>Implement IPersistStorage</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement <I>IPersistStorage</I></H3><P>We now have an exciting opportunity to start changing specific pieces of each interface to suit our purposes. <I>IPersistStorage</I> is once again the best place to start because it's always called first on an embedded object. As stated before, our reason for implementing this interface is to provide container-side storage handling capabilities. The container can use these to make copies of the object without the local server being present. HCosmo includes a complete implementation of this interface, which also delegates to the default handler for cache handling. Delegation occurs in all the functions as it does in <I>IPersistStorage::InitNew</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIPersistStorage::InitNew(LPSTORAGE pIStorage)<BR>    {<BR>    if (PSSTATE_UNINIT!=m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    if (NULL==pIStorage)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    //Good time to initialize our data<BR>    m_pObj-&gt;m_pl.wVerMaj=VERSIONMAJOR;<BR>    m_pObj-&gt;m_pl.wVerMin=VERSIONMINOR;<BR>    m_pObj-&gt;m_pl.cPoints=0;<BR>    m_pObj-&gt;m_pl.rgbBackground=GetSysColor(COLOR_WINDOW);<BR>    m_pObj-&gt;m_pl.rgbLine=GetSysColor(COLOR_WINDOWTEXT);<BR>    m_pObj-&gt;m_pl.iLineStyle=PS_SOLID;<BR><BR>    //Make sure these aren't filled with trash.<BR>    memcpy(&amp;m_pObj-&gt;m_plContent,   &amp;m_pObj-&gt;m_pl, CBPOLYLINEDATA);<BR>    memcpy(&amp;m_pObj-&gt;m_plThumbnail, &amp;m_pObj-&gt;m_pl, CBPOLYLINEDATA);<BR><BR>    m_pObj-&gt;m_pDefIPersistStorage-&gt;InitNew(pIStorage);<BR><BR>    m_psState=PSSTATE_SCRIBBLE;<BR>    return NOERROR;<BR>    }</code></pre>
<P>Here we're setting up the initial storage with default data, after which we tell the default handler to initialize itself and the cache by calling the same member function through <I>CFigure::m</I><I>_</I><I>pDefIPersistStorage. </I>We follow the same procedure with all the other <I>IPersistStorage </I>members but completely ignore the return values. We do this because what really matters is whether the operation succeeded on our own data. The default handler's return values describe whether the operation succeeded on the cache. If the cache fails, big deal—it's just a bonus in the first place. The object's own data is more important.</P>
<P>If a handler implements <I>IViewObject2::Draw</I> for any given aspect in such a way that it never delegates <I>Draw </I>to the default handler, the cache doesn't need to contain a presentation for that aspect. Your handler is entirely responsible for generating presentations for that aspect. If a compound document is taken to another machine, on which not even your handler is present, the object will appear blank in the container. Another good reason to license handlers for free distribution.</P>
<P>A last note about <I>IPersistStorage</I> is a call to <I>OleIsRunning</I> within <I>IPersistStorage::Save</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIPersistStorage::Save(LPSTORAGE pIStorage<BR>    , BOOL fSameAsLoad)<BR>    {<BR>    HRESULT         hr;<BR><BR>    §<BR><BR>    if (OleIsRunning(m_pObj-&gt;m_pDefIOleObject))<BR>        {<BR>        hr=m_pObj-&gt;m_pDefIPersistStorage-&gt;Save(pIStorage<BR>            , fSameAsLoad);<BR><BR>        if (SUCCEEDED(hr))<BR>            m_psState=PSSTATE_ZOMBIE;<BR><BR>        return hr;<BR>        }<BR>    §<BR>    }</code></pre>
<P><I>OleIsRunning</I> tells us whether the local object connected to this handler is running. If it is, HCosmo completely delegates to the default handler, which saves the cache and calls the local object's <I>IPersistStorage::Save</I>. This ensures that we don't wastefully save our data twice and that what we save in the handler does not conflict with what the local object decides to save. This is especially important if the local object is incrementally accessing the storage and has already written some changes there, changes that a call to <I>Save</I> in the handler might obliterate. We want to avoid conflicts with the running server, so <I>OleIsRunning</I> is just what we need here.</P></font></body></HTML>
