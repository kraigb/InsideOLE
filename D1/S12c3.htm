<HTML><HEAD><TITLE>Implement IViewObject2</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement <I>IViewObject2</I></H3><P>Now comes one of the most frequent uses for object handlers: optimizing drawing for particular devices. Your implementation of <I>IPersistStorage</I> loads the data to draw, and your <I>IViewObject2 </I>handles all the drawing and other visual aspects. If you implement <I>IViewObject2::Draw</I> for any given aspect, you also need to implement <I>Freeze</I>, <I>Unfreeze</I>, <I>Set</I><I>Advise</I>, and <I>GetAdvise</I> for the same aspect. This makes <I>IViewObject2</I> the most complicated interface in your handler, as you can see from the amount of code shown in Listing 19-1.</P>
<H4><A NAME="sec0"></A>IVIEWOBJ.CPP</H4><P><BR></P>
<pre><code>[Constructor, destructor, IUnknown members omitted]<BR><BR>STDMETHODIMP CImpIViewObject2::Draw(DWORD dwAspect, LONG lindex<BR>    , void *pvAspect, DVTARGETDEVICE *ptd, HDC hICDev<BR>    , HDC hDC, LPCRECTL pRectBounds, LPCRECTL pRectWBounds<BR>    , BOOL (CALLBACK * pfnContinue) (DWORD), DWORD dwContinue)<BR>    {<BR>    RECT            rc;<BR>    POLYLINEDATA    pl;<BR>    PPOLYLINEDATA   ppl=&amp;m_pObj-&gt;m_pl;<BR><BR>    RECTFROMRECTL(rc, *pRectBounds);<BR><BR>    //Delegate iconic and printed representations.<BR>    if (!((DVASPECT_CONTENT œ DVASPECT_THUMBNAIL) &amp; dwAspect))<BR>        {<BR>        return m_pObj-&gt;m_pDefIViewObject2-&gt;Draw(dwAspect<BR>            , lindex, pvAspect, ptd, hICDev, hDC, pRectBounds<BR>            , pRectWBounds, pfnContinue, dwContinue);<BR>        }<BR><BR>    /*<BR>     * If we're asked to draw a frozen aspect, use data from<BR>     * a copy we made in IViewObject2::Freeze. Otherwise, use <BR>     * current data.<BR>     */
    if (dwAspect &amp; m_pObj-&gt;m_dwFrozenAspects)<BR>        {<BR>        //Point to data to actually use.<BR>        if (DVASPECT_CONTENT==dwAspect)<BR>            ppl=&amp;m_pObj-&gt;m_plContent;<BR>        else<BR>            ppl=&amp;m_pObj-&gt;m_plThumbnail;<BR>        }<BR><BR>    //Make copy so we can modify it.<BR>    memcpy(&amp;pl, ppl, CBPOLYLINEDATA);<BR><BR>    /*<BR>     * If we're going to a printer, check if it's color capable.<BR>     * If not, use black on white for this figure.<BR>     */<BR>    if (NULL!=hICDev)<BR>        {<BR>        if (GetDeviceCaps(hICDev, NUMCOLORS) &lt;= 2)<BR>            {<BR>            pl.rgbBackground=RGB(255, 255, 255);<BR>            pl.rgbLine=RGB(0, 0, 0);<BR>            }<BR>        }<BR><BR>    m_pObj-&gt;Draw(hDC, &amp;rc, dwAspect, ptd, hICDev, &amp;pl);<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIViewObject2::GetColorSet(DWORD dwDrawAspect<BR>    , LONG lindex, LPVOID pvAspect, DVTARGETDEVICE *ptd<BR>    , HDC hICDev, LPLOGPALETTE *ppColorSet)<BR>    {<BR>    return ResultFromScode(S_FALSE);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIViewObject2::Freeze(DWORD dwAspect, LONG lindex<BR>    , LPVOID pvAspect, LPDWORD pdwFreeze)<BR>    {<BR>    //Delegate any aspect we don't handle.
    if (!((DVASPECT_CONTENT œ DVASPECT_THUMBNAIL) &amp; dwAspect))<BR>        {<BR>        return m_pObj-&gt;m_pDefIViewObject2-&gt;Freeze(dwAspect, lindex<BR>            , pvAspect, pdwFreeze);<BR>        }<BR><BR>    if (dwAspect &amp; m_pObj-&gt;m_dwFrozenAspects)<BR>        {<BR>        *pdwFreeze=dwAspect + FREEZE_KEY_OFFSET;<BR>        return ResultFromScode(VIEW_S_ALREADY_FROZEN);<BR>        }<BR><BR>    m_pObj-&gt;m_dwFrozenAspects œ= dwAspect;<BR><BR>    /*<BR>     * For whatever aspects become frozen, make a copy of the<BR>     * data. Later, when drawing, if such a frozen aspect is<BR>     * requested, we'll draw from this data rather than from<BR>     * our current data.<BR>     */<BR>    if (DVASPECT_CONTENT &amp; dwAspect)<BR>        {<BR>        memcpy(&amp;m_pObj-&gt;m_plContent, &amp;m_pObj-&gt;m_pl<BR>            , CBPOLYLINEDATA);<BR>        }<BR><BR>    if (DVASPECT_THUMBNAIL &amp; dwAspect)<BR>        {<BR>        memcpy(&amp;m_pObj-&gt;m_plThumbnail, &amp;m_pObj-&gt;m_pl<BR>            , CBPOLYLINEDATA);<BR>        }<BR><BR>    if (NULL!=pdwFreeze)<BR>        *pdwFreeze=dwAspect + FREEZE_KEY_OFFSET;<BR><BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIViewObject2::Unfreeze(DWORD dwFreeze)<BR>    {<BR>    DWORD       dwAspect=dwFreeze - FREEZE_KEY_OFFSET;
    //Delegate any aspect we don't handle.<BR>    if (!((DVASPECT_CONTENT œ DVASPECT_THUMBNAIL) &amp; dwAspect))<BR>        return m_pObj-&gt;m_pDefIViewObject2-&gt;Unfreeze(dwFreeze);<BR><BR>    //Aspect to unfreeze is in key.<BR>    m_pObj-&gt;m_dwFrozenAspects &amp;= ~(dwAspect);<BR><BR>    /*<BR>     * Since we always kept our current data up-to-date, we don't<BR>     * have to do anything here such as requesting data again.<BR>     * Because we removed dwAspect from m_dwFrozenAspects, Draw<BR>     * will again use current data.<BR>     */<BR><BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIViewObject2::SetAdvise(DWORD dwAspects<BR>    , DWORD dwAdvf, LPADVISESINK pIAdviseSink)<BR>    {<BR>    //Pass on through anything we don't support.<BR>    if (!((DVASPECT_CONTENT œ DVASPECT_THUMBNAIL) &amp; dwAspects))<BR>        {<BR>        return m_pObj-&gt;m_pDefIViewObject2-&gt;SetAdvise(dwAspects<BR>            , dwAdvf, pIAdviseSink);<BR>        }<BR><BR>    if (NULL!=m_pObj-&gt;m_pIAdvSinkView)<BR>        m_pObj-&gt;m_pIAdvSinkView-&gt;Release();<BR><BR>    m_pObj-&gt;m_dwAdviseAspects=dwAspects;<BR>    m_pObj-&gt;m_dwAdviseFlags=dwAdvf;<BR><BR>    m_pObj-&gt;m_pIAdvSinkView=pIAdviseSink;<BR><BR>    if (NULL!=m_pObj-&gt;m_pIAdvSinkView)<BR>        m_pObj-&gt;m_pIAdvSinkView-&gt;AddRef();<BR><BR>    return NOERROR;<BR>    }
STDMETHODIMP CImpIViewObject2::GetAdvise(LPDWORD pdwAspects<BR>    , LPDWORD pdwAdvf, LPADVISESINK *ppAdvSink)<BR>    {<BR>    if (NULL==m_pObj-&gt;m_pIAdvSinkView)<BR>        {<BR>        return m_pObj-&gt;m_pDefIViewObject2-&gt;GetAdvise(pdwAspects<BR>            , pdwAdvf, ppAdvSink);<BR>        }<BR><BR>    if (NULL==ppAdvSink)<BR>        return ResultFromScode(E_INVALIDARG);<BR>    else<BR>        {<BR>        *ppAdvSink=m_pObj-&gt;m_pIAdvSinkView;<BR>        m_pObj-&gt;m_pIAdvSinkView-&gt;AddRef();<BR>        }<BR><BR>    if (NULL!=pdwAspects)<BR>        *pdwAspects=m_pObj-&gt;m_dwAdviseAspects;<BR><BR>    if (NULL!=pdwAdvf)<BR>        *pdwAdvf=m_pObj-&gt;m_dwAdviseFlags;<BR><BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIViewObject2::GetExtent(DWORD dwAspect<BR>    , LONG lindex, DVTARGETDEVICE *ptd, LPSIZEL pszl)<BR>    {<BR>    HDC         hDC;<BR>    int         iXppli, iYppli;<BR>    RECT        rc;<BR><BR>    /*<BR>     * We can answer for CONTENT/THUMBNAIL, but try server for<BR>     * others. In addition, always delegate if server is running<BR>     * since it has a window to define the size.<BR>     */<BR>    if (!((DVASPECT_CONTENT œ DVASPECT_THUMBNAIL) &amp; dwAspect)<BR>        œœ OleIsRunning(m_pObj-&gt;m_pDefIOleObject))<BR>        return m_pObj-&gt;m_pDefIOleObject-&gt;GetExtent(dwAspect, pszl);
    /*<BR>     * The size is in rc field of POLYLINEDATA structure,<BR>     * which we now have to convert to HIMETRIC.<BR>     */<BR><BR>    hDC=GetDC(NULL);<BR>    iXppli=GetDeviceCaps(hDC, LOGPIXELSX);<BR>    iYppli=GetDeviceCaps(hDC, LOGPIXELSY);<BR><BR>    RECTSTORECT(m_pObj-&gt;m_pl.rc, rc);<BR>    pszl-&gt;cx=(long)MulDiv(HIMETRIC_PER_INCH<BR>        , (rc.right-rc.left), iXppli);<BR><BR>    pszl-&gt;cy=(long)MulDiv(HIMETRIC_PER_INCH<BR>        , (rc.bottom-rc.top), iYppli);<BR><BR>    ReleaseDC(NULL, hDC);<BR>    return NOERROR;<BR>    }</code></pre>
<P><B>Listing 19-1</B></P>
<P><B>Implementation of the <I>IViewObject2</I> interface in HCosmo.</B></P>
<P>Let's look at the simpler member functions before we jump into <I>Draw</I>. First, <I>GetColorSet</I> is unimportant for this handler (and for Cosmo as well), so we simply return S_FALSE to say we have nothing. Next, <I>SetAdvise</I> and <I>GetAdvise</I> handle a container's <I>IAdviseSink</I> to which we must send <I>OnViewChange</I> notifications when any data change occurs in our object that requires us to repaint. We delegate both of these calls to the default handler for DVASPECT_ICON and DVASPECT_DOCPRINT because we rely on the cache to handle those aspects for us in all other parts of the handler. That leaves us in <I>SetAdvise</I> to save the advise aspects, the flags, and the <I>IAdviseSink</I> pointer, to which we'll later send notifications, as described in "Synchronized Swimming with Your Local Server" later in this chapter. We need to hold all of these arguments so that we can return them through <I>GetAdvise,</I> as shown in the listing. Remember to call <I>AddRef</I> on the <I>IAdviseSink</I> pointer when you save a copy in <I>SetAdvise</I> (and release it before overwriting it) as well as to call <I>AddRef</I> on the pointer when returning a copy from <I>GetAdvise</I>.</P>
<P><B>Note:</B><B>  </B>A container can call SetAdvise with a NULL IAdviseSink pointer. This means that the container is terminating the connection. Be sure you don't attempt to call AddRef on this pointer without checking for NULL.</P>
<P><I>Freeze </I>and <I>Unfreeze</I> are a pair of functions that the container uses to control when a presentation is allowed to change. A change in the presentation, however, does not mean that you freeze underlying data; a freeze affects only one aspect. In HCosmo's case, a freeze on DVASPECT_CONTENT cannot freeze the data because DVASPECT_THUMBNAIL is drawn from the same data, and it is not frozen. Therefore, we must make a snapshot of the frozen data so that when we're asked to draw that aspect, we use the frozen copy instead of the current data. This allows the current data to change as needed. This also allows <I>IPersistStorage::Save</I> to write the current data without having to consider a frozen view aspect, which should not affect storage in any way.</P>
<P>Your implementation of <I>Freeze</I> must somehow remember that the aspect is frozen and make a snapshot of the data. HCosmo's code performs a bitwise OR operation to add a new aspect to the list of currently frozen aspects in <I>CFigure::m</I><I>_</I><I>dwFrozenAspects</I>. We then take a snapshot of the current data, putting it in either <I>CFigure</I>'s <I>m</I><I>_</I><I>plContent</I> or <I>m</I><I>_</I><I>plThumbnail</I> structure, depending on the aspect. <I>Draw</I> will later use all of this to determine exactly which data to use. In addition, <I>Freeze</I> must return some sort of key that can be passed later to <I>Unfreeze</I>. A good key is the aspect plus some random number to make the number meaningless to the caller. For example, I use FREEZE_KEY_OFFSET, which I define in HCOSMO.H as 0x0723.2 When this key is later passed to <I>Unfreeze</I>, we subtract the offset to yield an aspect and remove that aspect from <I>m</I><I>_</I><I>dwFrozenAspects</I>. When <I>Draw</I> is called subsequently, we see that the aspect is not frozen and will therefore draw from the current data. (We can assume <I>Draw</I> will be called because a container that thaws a view object will generally want to update immediately.)</P>
<P>Also, when working with <I>Freeze</I> you should first check to see whether the requested aspect is already frozen and return VIEW_S_ALREADY_FROZEN if it is. It must still return a key, however, which the caller can later pass to <I>Unfreeze</I>.</P>
<P>In the <I>GetExtent </I>member of <I>IViewObject2</I>,<I> </I>we delegate to the default handler for those aspects we do not support directly. In addition, we always delegate if the local object is running because that local object (we know) has a window to define its size accurately. Otherwise, we calculate the object's extents in HIMETRIC units and return.</P>
<P>This brings us to <I>Draw</I>, which generally calls either <I>CFigure::Draw</I> (FIGURE.CPP) for DVASPECT_CONTENT and DVASPECT_THUMBNAIL or the default handler's <I>IViewObject2::Draw</I> for any other aspect. The latter check happens first, so we can ignore those cases.</P>
<P>For content and thumbnail aspects, we now have to see whether they are frozen. If they are, we use the data we copied in <I>Freeze</I> instead of the current data. In Listing 19-1, <I>Draw</I> sets the pointer <I>ppl</I> initially to the current data. Later, if the aspect is frozen, <I>Draw</I> points <I>ppl</I> instead to the snapshot of that aspect. In this way, <I>Draw</I> can copy whatever <I>ppl</I> points to into a temporary POLYLINEDATA<I> </I>structure so that we can now do a few device optimizations. HCosmo doesn't do anything fancy with devices, but it does provide an example of how to render differently for a printer and for the screen. If the <I>hICDev </I>parameter in <I>Draw</I> is non-NULL, that means the data is going to a device other than the screen. If that is true, <I>Draw </I>checks for the number of colors the device supports. If it's a black-and-white device with only two colors, we force the background color of the rendering to be white and the line color to be black, which avoids potentially ugly dithering or large black blocks on the printer. (I can't say that this is the best thing to do, but it's just an example.)</P>
<P><I>IViewObject2::Draw</I> then calls <I>CFigure::Draw</I> with the temporary POLYLINEDATA<I> </I>structure, which might be a frozen aspect or data modified for a printer. In any case, <I>CFigure::Draw</I> draws the image with a bunch of GDI calls. While we don't need to see all the code here, I do want to point out one bug I encountered when writing it. This code was originally taken from the full Cosmo's WM_PAINT handling of the Polyline window. Because Polyline was always in its own window, its client area always started at (0,0). This meant that I did not have the code in place to handle cases in which the upper left corner was not (0,0). When I first compiled HCosmo with this <I>IViewObject2</I> implementation, it continually drew in the upper left corner of the container instead of in the container's site. Not good. I had to be sure that HCosmo's implementation of the drawing code would work for any rectangle.</P>
<P>After implementing <I>IViewObject2</I>, you now have a handler that can load, save, and display or print your object's data to a device without requiring a local server. After you have debugged your drawing code, you might want to create a compound document and copy it to another machine. Then you can open it again with and without your handler installed in the registry. This will give you an indication of what will happen in the absence of both a handler and a local server.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 If you can figure out where I got this number, I congratulate you on your resourcefulness. But don't expect any prizes; its meaning is entirely personal.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
