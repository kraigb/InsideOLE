<HTML><HEAD><TITLE>Collections</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Collections</H3><P>For the most part, the methods and properties you expose through an <I>IDispatch </I>interface are entirely your design. The <I>OLE Programmer</I><I>'</I><I>s Reference </I>describes some guidelines for objects such as those representing an application or a document, which we'll see later in this chapter in Table 14-4, under "Automation Object Hierarchy Design." While that section primarily covers design guidelines, there is one other standard for what are called <I>collections</I> or <I>collection objects</I>—objects that allow a controller to work with a set of similar things as a single group instead of as independent entities.</P>
<P>The simplest example of a collection is the group of open documents in an application. Although each document might have a <I>document object</I> to represent it alone, it would be grouped within a <I>documents collection</I>. If you are familiar with the Multiple Document Interface (MDI) for managing document windows, think of the MDI client window as the collection that holds all the MDI document windows. Collections, however, are not exclusively about documents: a document itself may have a <I>pages collection </I>that groups all the individual pages of a document. In the Patron sample, for example, the <I>CPages </I>class is essentially a collection of <I>CPage </I>objects. (These are C++ objects, mind you, but the concept still holds.) Each <I>CPage </I>is also a collection of <I>CTenant </I>objects.</P>
<P>A collection object itself is an automation object, with its own <I>IDispatch </I>interface and its own methods and properties. Usually it will have <I>Add </I>and <I>Remove </I>methods, as you would expect for managing any group of things. For example, a documents collection generally includes methods such as Add (File New) and Open (File Open) to create or open a document. Collections have a few stringent requirements, however, that allow controllers to iterate over the elements in the collection. The first is a standard property named <I>Count</I>, which returns a <I>long </I>describing the number of elements in the collection. The second is a standard method named <I>Item</I>. This takes an index4 as an argument and returns any type desired, whatever is appropriate for the element of that index in the collection. So, for example, if you have a collection of integers, you can perform a summation on that collection in Visual Basic with code such as the following:</P>
<P><BR></P>
<pre><code>sum = 0<BR>for I = 1 to NumberSet.Count<BR>    sum = sum + NumberSet.Item(I)<BR>next I</code></pre>
<P>Here <I>NumberSet </I>is the collection itself. If you have a collection of documents in which each document is an automation object with a <I>Visible </I>property, you can hide all the document windows in that collection with the same construct:</P>
<P><BR></P>
<pre><code>for I = 1 to DocumentCollection.Count<BR>    set doc = DocumentCollection.Item(I)<BR>    doc.Visible = False<BR>next I</code></pre>
<P>The problem with a construct such as this is that the collection itself may not necessarily support an index to the <I>Item </I>method, in which case the loop would fail. In addition, it is not necessarily true that all collections have items stored with sequential index values or that an item of a particular index will always have that same index. The unpredictability of an item's position is what distinguishes a collection from a simple array.</P>
<P>Visual Basic for Applications (VBA) and later versions of Visual Basic and other controllers support a collection without indexes through the <I>for</I>…<I>each </I>loop, which makes iteration of this sort more concise:5</P>
<P><BR></P>
<pre><code>for each doc in DocumentCollection<BR>    doc.Visible = False<BR>next doc</code></pre>
<P>The <I>for</I>…<I>each </I>construct doesn't require any intermediate variables. It also doesn't require that the controller know the number of elements in the collection or depend on the collection's support for an item index.</P>
<P>To support iteration over the collection in this manner, a collection object must support a third standard method (or property) named <I>_</I><I>NewEnum </I>(DISPID_NEWENUM). The leading underscore, according to OLE Automation, means that the method or property is hidden and should not be shown in any user interface that a controller might present. <I>_</I><I>NewEnum</I> takes no arguments (which is why it can be a property or a method) and returns an <I>IUnknown </I>pointer. But a pointer to what object? This return pointer does not give access to the collection object, but instead it points to an enumerator object with the interface <I>IEnumVARIANT</I>.6 As we know from other enumerator interfaces we've seen in earlier chapters, this interface is concerned with enumerating an array—or group—of VARIANT structures that can contain just about any kind of data, from an integer to a character string to even other objects referenced through their <I>IUnknown </I>or <I>IDispatch </I>pointers—exactly what we want to support an iteration construct. We'll see more details about this in the next section.</P>
<P>Any <I>for</I>…<I>each </I>language construct will call <I>_</I><I>NewEnum </I>internally to obtain the <I>IEnumVARIANT </I>pointer and then call <I>IEnumVARIANT::Next </I>to access the next element in the collection. It applies whatever code is in the body of the <I>for</I>…<I>each </I>statement to that element—for example, using a number in an expression or invoking another object's properties and methods—and continues looping until <I>IEnumVARIANT::Next </I>returns an error. When the loop is complete, Visual Basic calls <I>IEnumVARIANT::Release</I>.</P>
<P>The final standard for collections is naming: the name of a collection object should be the plural of the objects it collects. For example, a collection of Word objects should be called the Words collection; a collection of Vertex objects should be the Vertices collection; a collection of Mouse objects should be the Mice collection. So what if you have Moose objects? Append "Collection," as in MooseCollection.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>4 The index can be zero-based or one-based, depending on what sort of controllers you might target. A C/C++ controller prefers zero-based indexes; a Basic controller prefers one-based indexes. The choice is, unfortunately, left up to the object implementer. No standard exists at the time of writing.</P></TD></TR><TR><TD VALIGN="TOP"><P>5 DispTest and Visual Basic 3.0 do not support the for…each construct. To do the same operation from these controllers, you must use the more traditional approach to iteration as described earlier. This limitation is strictly a feature deficiency of these specific controllers and should in no way deter you from implementing a proper collection object and a proper enumerator.</P></TD></TR><TR><TD VALIGN="TOP"><P>6 Older versions of the <I>OLE Programmer</I><I>'</I><I>s Reference </I>are confusing about who implements what interface. The collection object itself implements <I>IDispatch </I>(which includes <I>IUnknown</I>) as well as any other interfaces it wants. However, <I>_</I><I>NewEnum </I>returns the <I>IUnknown </I>pointer for a separate </P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
