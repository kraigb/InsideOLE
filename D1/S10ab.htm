<HTML><HEAD><TITLE>What's New in the Second Edition</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>What's New in the Second Edition</H2><P>All of the material that was presented in the first edition still exists in some form in the second edition. Chapters 1, 2, and 5 of this edition provide an overview of OLE, the Component Object Model, and OLE objects and interfaces. They contain information from Chapters 1 through 4 of the first edition and cover topics that didn't exist at the time the first edition was written. Chapters 7 and 8 cover structured storage, compound files, and persistent objects, material included in the single Chapter 5 of the first edition. Chapters 10 and 11 present new information about data transfer mechanisms, viewable objects, and the data cache, building on the material in Chapter 6 from the first edition. Chapter 12 (about the OLE Clipboard) and Chapter 13 (about OLE Drag and Drop) are simple revisions of the first edition's Chapters 7 and 8. Chapters 17 through 23 treat all the elements of OLE Documents and are distillations of the first edition's Chapters 9 through 16. (Some of the old Chapter 16 found its way into the new Chapter 25 as well.) Whenever possible, I've corrected errors in the first edition while making these revisions and incorporated new insights I've had since <I>Inside OLE 2</I> was first published.</P>
<P>The remaining chapters are entirely new. Chapters 3, 14, and 15 cover topics typically grouped as OLE Automation: type information, in particular, is given high priority as the subject of Chapter 3. Chapter 4 discusses connectable objects, or what you might know as connection points, a new set of capabilities first created for OLE Controls. Chapter 6 covers Local/Remote Transparency, colloquially called marshaling. Chapter 9 provides full coverage of naming and binding, all the stuff that involves the objects called monikers. (Parts of this were buried in Chapter 12 in the first edition.) Chapter 16 describes ways of dealing with object properties that are not part of OLE Automation, namely property pages, property sets, and property change notifications. Chapter 24 discusses OLE Controls, and Chapter 25 offers a look at the future, detailing upcoming enhancements of the current state of OLE.</P>
<P>My goal in writing this book was to provide an organization in which each chapter depends solely on information in previous chapters, with no dependencies on later chapters (and few forward references). I present material a little at a time in order to help you solidify your understanding before moving on. I hope the book takes you on an evolutionary path so that the work you do early in the book will be reusable in the later stages. I've always found an incremental approach more productive and rewarding than trying to understand everything at once. By concentrating on the fundamentals first, I hope you can make rapid progress through the later chapters. Once you understand what "object" means in OLE, you will see that most of OLE is nothing more than different types of objects and different interfaces that are used to communicate with the objects. Most chapters are, in fact, about a particular set of object types and the interfaces through which those objects provide their services.</P>
<P>It is important to realize that there isn't just one thing you can do with OLE. As a basis for component software, OLE provides many means for integrating components. Your choice of specific OLE technologies to use in order to create and implement a client or an object depends on your goals for component integration. If you have code for some sort of service provider, you need to articulate the types of clients that you want to be capable of using your service. If you are a client of a type of service, you need to consider additional services that would be useful to that client. In this book, you'll see a clear separation between the responsibilities of a provider of a service (the object implementer) and the responsibilities of a client of such a service. When you understand the role of your own products and what integration means to those products, you'll understand how you might exploit each OLE technology to its fullest extent.</P>
<P>So most of this book is about what you can do with OLE and how you work with it. There's also a little bit about why, but most of that is left to you—why is the creative part!</P></font></body></HTML>
