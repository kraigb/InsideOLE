<HTML><HEAD><TITLE>IOleControl and IOleControlSite</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IOleControl</I> and <I>IOleControlSite</I></H3><P>These interfaces extend the communication that usually occurs between a container and an object in OLE Documents for the purpose of handling control mnemonics, ambient properties, and extended controls:</P>
<P><BR></P>
<pre><code>interface IOleControl : IUnknown<BR>    {<BR>    HRESULT    GetControlInfo(CONTROLINFO *pCtrlInfo);<BR>    HRESULT    OnMnemonic(LPMSG pMsg);<BR>    HRESULT    OnAmbientPropertyChange(DISPID dispID);<BR>    HRESULT    FreezeEvents(BOOL fFreeze);<BR>    }<BR><BR>interface IOleControlSite : public IUnknown<BR>    {<BR>    HRESULT    OnControlInfoChanged(void);<BR>    HRESULT    LockInPlaceActive(BOOL fLock);<BR>    HRESULT    GetExtendedControl(IDispatch **pIDispatch);<BR>    HRESULT    TransformCoords(POINTL *ptlHimetric<BR>                   , POINTF *ptlContainer, DWORD dwFlags);<BR>    HRESULT    TranslateAccelerator(LPMSG pMsg, DWORD grfModifiers);<BR>    HRESULT    OnFocus(BOOL fGotFocus);<BR>    HRESULT    ShowPropertyFrame(void);<BR>    }</code></pre>
<P>The <I>GetControlInfo</I> and <I>OnMnemonic</I> members of <I>IOleControl</I> and the <I>OnControlInfoChanged</I>, <I>TranslateAccelerator</I>, and <I>OnFocus</I> members of <I>IOleControlSite</I> are described later in this chapter under "Keyboard Handling, Mnemonics, and <I>ISimpleFrameSite</I>." We can mention that <I>IOleControlSite::OnFocus </I>notifies a site when its control either gains or loses the focus. <I>IOleControlSite::GetExtendedControl</I> gives a control a way to access a container's extended control and retrieve any properties it might have. (We'll cover this in more detail in the following section.)</P>
<P>That leaves only a few other methods to discuss briefly here. First is <I>IOleControl::OnAmbientPropertyChange</I>, which a container calls whenever it changes an ambient property. It passes the dispID of the property that changed (see the section "Standard dispIDs for Controls" later in this chapter for predefined dispIDs) or DISPID_UNKNOWN to indicate that multiple properties changed. In response, a control retrieves the new property (or properties) as necessary and updates itself. This notification mechanism doesn't involve connection points because there is little need for extensibility. Although control properties and events vary widely, the set of ambient properties is relatively small and varies little from container to container. And whereas a container needs notifications from many objects, a control needs notifications only from a single container. There's no need for overkill simply for ambient properties.</P>
<P>Whenever a control should display its property pages (for example, in response to OLEIVERB_PROPERTIES), it should first call <I>IOleControlSite::ShowPropertyFrame</I>. The reason for this is that the container might have an extended control built around the control that received the verb. Calling <I>ShowPropertyFrame </I>allows the container to include any of its own property pages along with those the control specifies through <I>ISpecifyPropertyPages::GetPages.</I> If the container returns an error from <I>ShowPropertyFrame</I>, however, the control should proceed to show its own property pages—do not expect the container to always implement the function.</P>
<P><I>IOleControl::FreezeEvents</I> allows the container to turn off (freeze) and turn on (thaw) a control's events. When the events are frozen, the control will not fire them—it might queue them or discard them, but it won't fire them. The choice is up to the control itself.</P>
<P>The other two members of <I>IOleControlSite</I>—<I>LockInPlaceActive</I> and <I>TransformCoords</I>—generally have to do with events as well. <I>LockInPlaceActive(TRUE) </I>tells the container that a control wants to stay in the active state until <I>LockInPlaceActive(FALSE) </I>is called. This is primarily to prevent crashing problems when an in-place window is destroyed and messages are still coming to that window. A control will often call <I>LockInPlaceActive</I> before and after an event is fired if destroying the in-place window would cause problems.</P>
<P><I>TransformCoords</I> handles the presentation of a uniform coordinate system to the container through all events, methods, and properties while allowing controls to choose whichever coordinate system they want. For example, if a MouseDown event is fired, the container should receive the coordinates in a system it understands instead of in whatever system the control is using. Windows programmers have always taken this for granted—any message or event coming from Windows had coordinates expressed in client-area units. But because events can come from any number of vastly different controls, all controls must take whatever coordinates they have in HIMETRIC and send them to <I>IOleControlSite::TransformCoords</I> to convert them to the container's units. Those units are then sent with the event itself.</P></font></body></HTML>
