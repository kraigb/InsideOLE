<HTML><HEAD><TITLE>Unloading Mechanisms</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Unloading Mechanisms</H3><P>Just as COM will load DLLs and launch EXEs programmatically without any user interaction, it must also have a way to unload those DLLs and terminate those EXEs. Otherwise, it would, over time fill, all available memory with servers that are no longer in use. The problem is a matter of how COM determines whether or not a server is currently servicing any objects.</P>
<P>The bottom line is that a server is no longer needed when there are no lock counts from <I>IClassFactory::LockServer</I> and there are no objects, excluding the class factory objects, currently being serviced. Typically, a server will maintain one or two global variables (an object count and a lock count, or one combined counter), and when both counts go to 0, the server isn't needed anymore. An EXE actually doesn't need COM to unload: it can detect the appropriate conditions and terminate itself by calling <I>PostQuitMessage</I> to exit its message loop. But DLLs have no idea of how to "quit" or unload themselves, so they must mark themselves as "unloadable" and wait for COM to ask for that condition. Let's look at each case in turn.</P>
<H4><A NAME="sec0"></A>In-Process Server</H4><P>Being rather passive, the DLL unloading mechanism is fairly trivial. Every now and then—primarily when a client calls the function <I>CoFreeUnusedLibraries</I>—COM attempts to call an exported function named <I>DllCanUnloadNow </I>in the same manner that it calls <I>DllGetClassObject.</I> This function takes no arguments and returns an HRESULT:</P>
<P><BR></P>
<pre><code>STDAPI DllCanUnloadNow(void)</code></pre>
<P>When COM calls this function, it is essentially asking "Can I unload you now?" <I>DllCanUnloadNow </I>returns S_FALSE if any objects or any locks exist, in which case COM doesn't do anything more. If there are no locks or objects, the function returns NOERROR (or S_OK), and COM follows by calling <I>CoFreeLibrary </I>to reverse the <I>CoLoadLibrary</I> function call that COM used to load the DLL in the first place.</P>
<P><B>Note:</B><B> </B> Early 16-bit versions of OLE did not implement the CoFreeUnusedLibraries, so DllCanUnloadNow was never called. This led to the belief that it was not necessary to implement this function or IClassFactory::LockServer because the DLL would stay in memory for the duration of the client process. This is no longer true because the COM function is fully functional and will call all DLLs in response. To support proper unloading, you must always implement IClassFactory::LockServer as well as DllCanUnloadNow.</P>
<P>A DLL's response to a <I>DllCanUnloadNow </I>call does not take into consideration the existence or reference counts on any class factory object. Such references are not sufficient to keep a server in memory, which is why <I>LockServer </I>exists. To be perfectly honest, an in-process server could include a count of class factories in its global object count if it wanted to, but this doesn't work with a local server, as the following section illustrates.</P>
<H4><A NAME="sec1"></A>Local Server</H4><P>Unlike a DLL server, which waits passively for COM to ask about unloading it, the EXE server must watch actively for the following conditions and terminate itself when those conditions are met:</P>
<UL><LI>The object count is currently 0 and the last lock is removed by a call to <I>IClassFactory::LockServer(FALSE)</I>.</LI><LI>The lock count is 0 and the last object is destroyed with a call to its <I>IUnknown::Release</I>.</LI></UL><P>If a single combined counter is used, the server need only detect when it is decremented to 0. All of these conditions imply active detection of a decrement event, not just a zero condition. The server terminates after the final decrement, not whenever a counter happens to be 0. Otherwise, the server would start up, detect a zero count, and terminate. That sort of code is about as useful as wearing dark sunglasses for stargazing.</P>
<P>In addition, if an EXE server involves any kind of user interface, it must also maintain a condition called <I>user control</I>. This Boolean flag is normally FALSE but is set to TRUE if an end user does anything that "takes control" of the server. For example, a server with a Multiple Document Interface (MDI) might be servicing a document object for the purposes of another client. The end user might come along and create a new document in that server as if it had been run stand-alone. In such a case, the server should most definitely not shut itself down when the original document object is released; otherwise, the end user's new document would be prematurely destroyed without any chance to save it. Bad idea. Automatic termination should not occur unless the user control flag is FALSE. If it is TRUE, only the end user can shut down that EXE.</P>
<P>When an end user forcibly closes a server, other running objects may still be in service. In such a case, the server has two choices: it can either hide its main window, giving the end user the illusion of closing by not actually terminating until all objects are released (essentially setting the user control flag back to FALSE), or disconnect each of its running objects by calling the COM API function <I>CoDisconnectObject</I>. This latter solution is rather rude because it will cause any external client's interface calls to return the error RPC_E_NOTCONNECTED—the client can still make the call because it still has a pointer to the interface proxy, but that proxy has been disconnected from its stub. In effect, <I>CoDisconnectObject</I> causes a controlled crash of the external connections to the object. Brutal as this may be, <I>CoDisconnectObject </I>gives a server control over external reference counts so it can properly free its objects on shutdown.</P>
<P>We can now examine why a reference count on a class factory object is not strong enough to keep an EXE server from terminating itself. Recall that you must create class factory objects during initialization and register them with <I>CoRegisterClassObject.</I> In the process of registration, there will be at least one, if not more, calls to that object's <I>AddRef </I>function. The matching calls to <I>Release</I> will not be made, however, until the server calls <I>CoRevokeClassObject </I>during shutdown. If a positive reference count could keep a class factory in memory, the EXE could not terminate until that object's reference count reached zero and it was destroyed. But the reference count will never reach zero unless we call <I>CoRevokeClassObject</I>, but we call <I>CoRevokeClassObject</I> only when we are in the shutdown process and are on the nonstop express to oblivion. We can't revoke until we're shutting down and we can't shut down until we revoke. Aaaugh! Fourth down and 100 yards to go…so we punt. Officially, a positive reference count on a class factory cannot be used to keep a server in memory. If a client wants to hold a class factory outside the scope of a function, it must rely on <I>LockServer</I> to prevent server shutdown. This is one of the few special cases of reference counting in all of OLE.</P></font></body></HTML>
