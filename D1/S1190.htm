<HTML><HEAD><TITLE>Transactioning</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Transactioning</H3><P>The most interesting and powerful access mode is STGM_TRANSACTED, which means that any changes made to that storage are not published to its own parent until the client calls <I>Commit</I>. (An element opened with STGM_DIRECT publishes changes immediately.) If that parent is a storage element itself, these changes are scoped by that parent's own access mode. If that parent is a disk file, changes are then written to disk. Changes include the creation, deletion, or modification of any of the elements in the storage, regardless of whether they are substorages, streams, or streams within the substorage of a substorage of a substorage.</P>
<P>In other words, transactioning is a relationship between the transactioned element and its parent element or file. When multiple levels of transactioning exist, changes at the lowest level are not permanent until they percolate upward to the root and the root is committed. In other words, a <I>Commit </I>only publishes changes to the next layer up. This is very important in File Save (and File Save As) operations because a client must be sure to commit every transacted element from the bottom up. If it doesn't, changes will be lost when the root storage is committed.</P>
<P>To illustrate this concept, let's say we have three element objects—A, B, and C—all opened with STGM_TRANSACTED: </P>
<P><img src="f07dd06b.gif"></P>
<P>If we modify information in C and call its <I>Commit</I>, only B becomes aware of those changes. B is now considered dirty in the eyes of A, so we must commit B in order to save its changes within the scope of A:</P>
<P><img src="f07dd06c.gif"></P>
<P>On the other hand, if B is opened in direct mode, it immediately publishes the changes in C up to A. If A is a direct mode root storage, those changes go directly to the underlying storage medium.</P>
<P>The whole trick with multilevel transactioning is to walk through the hierarchy and commit everything that has been changed, starting from the bottom and working your way up. The Patron sample we'll see later distributes a Save command from the document to each page, and each page distributes the command to each tenant. When each tenant has committed its storage, each page can commit its storage, and the document can perform the final commit.</P>
<P>An interesting feature of transactioning is that you can open an element as read-only transacted and manipulate it as if it were read/write. The only operation that will not succeed is <I>Commit.</I></P>
<H4><A NAME="sec0"></A>Commit Flags</H4><P>The <I>Commit </I>member functions in <I>IStorage </I>and <I>IStream </I>support a number of different semantics depending on a combination of the following flags passed as the only argument to <I>Commit</I>:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="132pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Flag</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>STGC_DEFAULT</P></TD><TD VALIGN="TOP"><P>No special semantics; simply commit changes.</P></TD></TR><TR><TD VALIGN="TOP"><P>STGC_ONLYIFCURRENT</P></TD><TD VALIGN="TOP"><P>When an element is shared between two threads (or processes), this flag prevents one thread from overwriting changes made by another thread or process that has already committed changes. <I>Commit </I>will return STG_E_NOTCURRENT when another commit has already happened. In this case, the calling thread has to reconcile its changes with the new contents of the element before calling <I>Commit </I>without the STGC_ONLYIFCURRENT flag. This flag allows a finer granularity of sharing to occur between end users on a network than was previously available through traditional files—multiple applications can open the same element as read/write as long as they don't specify exclusive access.</P></TD></TR><TR><TD VALIGN="TOP"><P>STGC_OVERWRITE</P></TD><TD VALIGN="TOP"><P>Allows new data to overwrite old data, resulting in smaller space requirements. This should be used only in a low-memory situation or when the storage medium is already full. It is risky because the status of the element is in limbo during the commit, so a failure to complete the operation (such as a power failure) would result in data corruption—the element would contain a mixture of old and new information.</P></TD></TR><TR><TD VALIGN="TOP"><P>STGC_DANGEROUSLY-<BR>COMMITMERELY-<BR>TODISKCACHE</P></TD><TD VALIGN="TOP"><P>OLE designers never said they couldn't be verbose. This flag specifies that the commit should not attempt to flush buffers after changes are written (which would ensure that the data ends up on the storage medium before <I>Commit </I>returns). Using this flag will make <I>Commit </I>faster but riskier because for a short time the data will exist only in whatever cache is being used on the underlying medium. Using this flag is not any riskier than using traditional file I/O today because such file I/O is always at the whim of the file- system caching.</P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec1"></A>Discarding Changes: <I>Revert</I></H4><P>Closely related to the <I>Commit </I>function and equally important in the scheme of transactioning is <I>Revert</I>. This function discards any changes that have been made to a transacted element since the last <I>Commit </I>(or open); it is a mere no-op when direct mode is in operation. It is very important to remember that calling a transacted element's <I>Release </I>without calling <I>Commit</I> first implicitly calls <I>Revert.</I></P>
<P>A <I>Revert </I>call on a storage object will effectively revert down the hierarchy all changes to everything within it, so a <I>Revert </I>call to a root storage would effectively reset everything to the last committed state. When that root storage is connected to a file, this makes for an easy implementation of a Revert To Last Save command and makes it simple to close a file without saving changes—just call <I>Release</I>.</P>
<P>When you revert a storage, all open substorages and streams underneath that storage in the hierarchy must be closed (you must call <I>Release</I>) and reopened; otherwise, subsequent calls to those objects will fail outright with an STG_E_REVERTED code.</P>
<H4><A NAME="sec2"></A>Transacted Streams as Memory Structures</H4><P>Transacted mode enables a new technique in application design. Because changes made to transacted storages and streams will be recorded in memory or in temporary files, making changes to a transacted element might be only slightly slower than writing directly to memory. Applications usually need to read structures out of a disk file into memory, modify them in memory, and then write them back to the disk file during a save. Transactioning allows these structures to remain in the file as a stream with little effect on overall performance. In using streams for such structures, you also gain a number of benefits:</P>
<UL><LI>Writing past the end of the stream automatically expands the stream instead of causing a crash.</LI><LI>Saving the data requires only a call to <I>Commit </I>instead of copying the data from memory into the stream before the commit.</LI><LI>An Undo operation is a simple call to <I>Revert</I>. An undo stack could be implemented by making temporary copies of the stream being modified in a temporary storage with all the individual changes recorded in separate streams. Before changing the current stream, simply call <I>IStream::CopyTo </I>to copy the data into a stream on the undo stack.</LI></UL><P>When a memory structure contains pointers, keeping the pointers in a stream makes committing the stream senseless. However, even for small structures that you will store persistently in a file, this technique can save you from keeping the same data in a memory structure. When you need it, load it from a stream. When you change it, write it to the stream. When you save, commit everything. Because you want the data in permanent storage anyway, why not leave it there?</P>
<P>Configuration structures, such as LOGFONT, and any structure that is likely to grow over time are great candidates for this technique. An application seldom reads and writes configuration data, but such data is always written to storage. Keeping things in the streams they occupy in the permanent file can greatly simplify or eliminate the tedious memory management code that we all hate to write ourselves.</P></font></body></HTML>
