<HTML><HEAD><TITLE>Create Objects from the Clipboard and Drag-and-Drop Transfers</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Create Objects from the Clipboard and Drag-and-Drop Transfers</H3><P>As you know, creating an object using the Insert Object dialog box is only one of the ways to get an object into a container. It is also possible to paste an object by using data from the clipboard or to accept an embedded object dropped on the container. In either case, we receive a data object's <I>IDataObject </I>pointer and pass it to <I>OleCreateFromData</I>,<I> </I>as occurs in <I>CTenant::Create</I>. To work with embedded object data, we need to register the OLE-specific clipboard formats with the Windows API <I>RegisterClipboardFormat</I>,<I> </I>which we do in the <I>CPatronDoc </I>constructor (DOCUMENT.CPP) and other places around Patron.</P>
<P>The three formats that concern us here are described in this table:</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="147pt" VALIGN="TOP"><COL WIDTH="122pt" VALIGN="TOP"><COL WIDTH="147pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Symbol</B></P></TD><TD VALIGN="TOP"><P><B>String</B></P></TD><TD VALIGN="TOP"><P><B>Format</B></P></TD></TR><TR><TD VALIGN="TOP"><P>CFSTR_EMBEDDEDOBJECT</P></TD><TD VALIGN="TOP"><P>"Embedded Object"</P></TD><TD VALIGN="TOP"><P>An <I>IStorage</I> containing the object's native data</P></TD></TR><TR><TD VALIGN="TOP"><P>CFSTR_EMBEDSOURCE</P></TD><TD VALIGN="TOP"><P>"Embed Source"</P></TD><TD VALIGN="TOP"><P>Same as CFSTR_EMBEDDEDOBJECT</P></TD></TR><TR><TD VALIGN="TOP"><P>CFSTR_OBJECTDESCRIPTOR</P></TD><TD VALIGN="TOP"><P>"Object Descriptor"</P></TD><TD VALIGN="TOP"><P>An OBJECTDESCRIPTOR structure in global memory that contains the object's size, aspect (iconic, content, and so on), class, and other information in which a potential consumer might be interested*</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>*    OBJECTDESCRIPTOR<I> </I>is meant to solve problems similar to those we solved with the PATRONOBJECT<I> </I>structure in Patron in Chapter 13, in which we wanted a graphic on the clipboard to be accompanied by data that indicates the size and placement of the object. In addition, we wanted to store the pick point of an object in drag and drop relative to its upper corner to show the feed-back rectangle in the right place. PATRONOBJECT<I> </I>contains all this data, whereas OBJECTDESCRIPTOR<I> </I>contains only extents (because placement data is generally meaningless between different applications). Patron still looks for its own format first using OBJECTDESCRIPTOR<I> </I>as a backup.</P>
<P>Now, given any data object pointer, you can determine whether an embedded object is available by calling <I>OleQueryCreateFromData</I>, passing the <I>IDataObject</I> pointer. This function basically checks for CFSTR_EMBEDDEDOBJECT and CFSTR_EMBEDSOURCE, returning S_OK if either is available or if OLE 1 embedded object data is available. Patron calls this function in <I>CPatronDoc::FQueryPasteFromData</I>, which we use not only to enable the Edit Paste menu item but also to determine whether we can accept an embedded object from a drag-and-drop operation. If we can paste such data, <I>FQueryPasteFromData </I>returns the exact information that we need in <I>CTenant::Create </I>to create an object from the data. When we create the object, we do not activate it initially as we do for new, uninitialized objects. This is because the object already has meaningful data in it, so the user might be fully satisfied with its contents.</P>
<P>You'll make very few changes to the rest of your clipboard and drag-and-drop code if you centralize format checks and object creation as I've done in Patron. With drag and drop, the only change I made was to use CFSTR_OBJECTDESCRIPTOR as a backup format with placement data; otherwise, the rest of the code stayed the same. This really shows the flexibility of drag and drop and how capable it is of working with any data formats that come along.</P>
<P>If you are using the Paste Special dialog box, you will need to add a new entry to the list of acceptable formats so that the dialog box shows an embedded object if one is available. This new entry should have the format CFSTR_EMBEDDEDOBJECT and the flag OLEUIPASTE_PASTE, which we include in <I>CPatronDoc::PasteSpecial:</I></P>
<P><BR></P>
<pre><code>SETDefFormatEtc(rgPaste[1].fmtetc, m_cfEmbeddedObject<BR>    , TYMED_ISTORAGE);<BR>rgPaste[1].lpstrFormatName="%s Object";<BR>rgPaste[1].lpstrResultText="%s Object";<BR>rgPaste[1].dwFlags=OLEUIPASTE_PASTE œ OLEUIPASTE_ENABLEICON;</code></pre>
<P>Be careful to use OLEUIPASTE_PASTE for this entry and not OLEUIPASTE_PASTEONLY. If you use the latter (as we did for other static formats), you will not see this entry in the dialog box at all. This can increase your job stress by a few orders of magnitude. Believe me. I took six hours to figure this out. Also, no matter where you put this entry in your array of pasteable formats, the Paste Special dialog box will always list embedded objects first. This is the user interface standard.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>IOleObject::InitFromData</H4><P>When a user chooses to paste with data already selected in a document, the usual behavior is to replace that selection with the new data. If the selection is an embedded object marked with OLEMISC_INSERTNOTREPLACE, the container should call <I>IOleObject::InitFromData </I>to perform the paste instead of replacing the selected object. This allows the object to incorporate that data into itself. Patron does not support this feature.</P>
<P>An alternative use of this function, differentiated by a flag named <I>fCreation</I>, is to use a data object to initialize a newly created embedding. After calling <I>OleCreate</I>, you can send initial data to the object with <I>InitFromData</I>. This data might be a selection of data in the container itself or some other data from the clipboard or from a drag-and-drop operation.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
