<HTML><HEAD><TITLE>Implementing Binding Support</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implementing Binding Support</H3><P>LinkSource as a server supports binding to File, File!Item, and File!Item!Item monikers. What is common in all of these names is that they each begin with a File moniker, so all binding in LinkSource starts with binding a file moniker. Any item binding happens relative to the object named by such a file moniker, so LinkSource needs to serve only a single CLSID. In other words, a LinkSource file is a component with three objects: File, Container Item, and Simple Item. The one CLSID, <I>CLSID</I><I>_</I><I>LinkedFile</I> identifies the file object, which is the root of the Linked File component.</P>
<P>Thus, LinkSource will create and register a class factory (using <I>CFileObjectFactory </I>in LINKSRC.CPP) and will include all the registry entries needed to list LINKSRC.EXE under <I>CLSID</I><I>_</I><I>LinkedFile.</I> There is nothing more to all of this class factory and registration business that we have not already learned from Chapter 5. The important point is that there is only one registered CLSID. Note also that LinkSource registers the class factory regardless of -<I>Embedding</I> on the command line; this enables you to run LinkSource in a debugger and trace through it easily when LinkUser attempts to bind a moniker or parse a display name, without having to otherwise struggle to get the server launched into a debugger.</P>
<H4><A NAME="sec0"></A>Binding Support for the File Moniker</H4><P>As we know, a file moniker's <I>BindToObject</I> will call <I>GetClassFile </I>to associate its filename with a CLSID, then call <I>CoCreateInstance(</I>…<I>, IID</I><I>_</I><I>IPersistFile)</I> with that CLSID, then call <I>IPersistFile::Load</I>,<I> </I>and finally call <I>IPersistFile::QueryInterface </I>to get the interface to return to the client. When LinkUser attempts to obtain the description for a stand-alone file moniker, this last <I>QueryInterface </I>will ask for <I>IDescription.</I></P>
<P>To support this binding, LinkSource must first associate its file with its CLSID, which is the reason why it calls <I>IStorage::SetC</I><I>lass </I>as described earlier. The object instantiated through this CLSID, <I>CFileObject</I>, supports <I>IPersistFile </I>(<I>CImpIPersistFile </I>in FILEOBJ.CPP). The implementation is quite simple: <I>GetClassID </I>returns <I>CLSID</I><I>_</I><I>LinkedFile</I>, <I>IsDirty </I>returns S_FALSE (LinkSource makes no changes), <I>Save </I>and <I>SaveCompleted </I>return NOERROR (no reason to save), and <I>GetCurFile </I>makes a copy of the filename.</P>
<P>The implementation of <I>IPersistFile::Load </I>is where most of the action takes place:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIPersistFile::Load(LPCOLESTR pszFile, DWORD grfMode)<BR>    {<BR>    const int   cch=512;<BR>    HRESULT     hr;<BR><BR>    if (NULL!=m_pObj-&gt;m_pmk)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    hr=StgOpenStorage(pszFile, NULL<BR>        , STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0<BR>        , &amp;m_pObj-&gt;m_pIStorage);<BR><BR>    if (FAILED(hr))<BR>        return hr;<BR><BR>    m_pObj-&gt;m_pImpIDescription-&gt;SetStorage(m_pObj-&gt;m_pIStorage);<BR>    lstrcpyn(m_pObj-&gt;m_szFile, pszFile, cch);<BR><BR>    if (SUCCEEDED(CreateFileMoniker(pszFile, &amp;m_pObj-&gt;m_pmk)))<BR>        {<BR>        IRunningObjectTable    *pROT;<BR><BR>        if (SUCCEEDED(GetRunningObjectTable(0, &amp;pROT)))<BR>            {<BR>            //Register as weak so clients can free us.<BR>            pROT-&gt;Register(0, m_pObj, m_pObj-&gt;m_pmk<BR>                , &amp;m_pObj-&gt;m_dwRegROT);<BR>            pROT-&gt;Release();<BR>            }<BR>        }<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>If <I>Load </I>successfully opens the file, it then hands that <I>IStorage </I>to its <I>IDescription </I>interface (which does not call <I>AddRef </I>because it's a contained class), saves the filename, and registers the file as running in the running object table. This last step is very important for servers to complete, especially those that potentially service links from any number of clients. For example, if you ran two instances of LinkUser against the same instance of LinkSource, the second attempt to bind any moniker would be faster because the file object is already running and is registered. Wherever the server creates the registered moniker, it generally holds onto that moniker for potential later uses. In LinkSource, we use the moniker to know whether or not <I>Load </I>has already been called so we can prevent reentrancy.</P>
<P>If we successfully return from <I>Load</I>, the file moniker will query the file object for whatever interface it wants, which in this scenario is <I>IDescription</I>. Thus, we've followed the map and found the treasure with only a little bit of code and a simple implementation of <I>IPersistFile.</I></P>
<H4><A NAME="sec1"></A>Binding Support for the File!Item Moniker</H4><P>When LinkUser binds a File!Item composite and asks for <I>IDescription</I>, the composite will specifically call the item's <I>BindToObject </I>and ask for that same interface. Item monikers know that they require the services of the moniker to their left, in this case the file moniker. So the item calls <I>pmkLeft-&gt;BindToObject(</I><I>…</I><I>, IID</I><I>_</I><I>IOleItemContainer, </I><I>…</I><I>)</I>. This <I>BindToObject </I>call appears to LinkSource's file object exactly as if LinkUser were binding a file moniker by itself except that the final <I>QueryInterface </I>will now ask for <I>IOleItemContainer.</I> Thus, the file object in LinkSource must also implement this interface, which is again a shared implementation in <I>CImpIOleItemContainer </I>(IOLECONT.CPP). In this case, the interface will know that it's part of the file object through its internal flag <I>m</I><I>_</I><I>fFileObj.</I></P>
<P>LinkSource implements all the member functions in this interface except for <I>EnumObjects</I>, which for binding purposes can return E_NOTIMPL. We need to implement <I>ParseDisplayName </I>and <I>LockContainer </I>specifically for parsing support, as we'll see a little later on. The other members, <I>GetObject</I>, <I>GetObjectStorage</I>, and <I>IsRunning</I>, are important to the binding process. In particular, <I>GetObject </I>has to create or access the correct object as specified by an item name:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleItemContainer::GetObject(LPOLESTR pszItem<BR>    , DWORD dwSpeed, LPBINDCTX pbc, REFIID riid, PPVOID ppv)<BR>    {<BR>    HRESULT         hr;<BR>    IStorage       *pIStorage;<BR>    PCContainerItem pCI;<BR>    PCSimpleItem    pSI;<BR>    BOOL            fSuccess;<BR>    IUnknown       *pUnk;<BR><BR>    *ppv=NULL;<BR><BR>    hr=GetRunning(pszItem, pbc, riid, ppv, FALSE);<BR><BR>    if (BINDSPEED_IMMEDIATE==dwSpeed &amp;&amp; NOERROR!=hr)<BR>        return ResultFromScode(MK_E_EXCEEDEDDEADLINE);<BR><BR>    //If object was running, we're done!<BR>    if (NOERROR==hr)<BR>        return NOERROR;<BR><BR>    //Otherwise, we need to get storage.<BR>    hr=GetObjectStorage(pszItem, pbc, IID_IStorage<BR>        , (void **)&amp;pIStorage);<BR><BR>    if (FAILED(hr))<BR>        return hr;<BR><BR>    fSuccess=FALSE;<BR><BR>    if (m_fFileObj)<BR>        {<BR>        pCI=new CContainerItem(m_pObjFile, m_pObjFile-&gt;m_pfnDestroy);<BR><BR>        pUnk=pCI;<BR><BR>        if (NULL!=pCI)<BR>            {<BR>            pUnk-&gt;AddRef();<BR>            fSuccess=pCI-&gt;Init(m_pObjFile-&gt;m_pmk, pbc, pszItem<BR>                , pIStorage);<BR>            }<BR>        }<BR>    else<BR>        {<BR>        pSI=new CSimpleItem(m_pObjCont, m_pObjCont-&gt;m_pfnDestroy);<BR><BR>        pUnk=pSI;<BR><BR>        if (NULL!=pSI)<BR>            {<BR>            pUnk-&gt;AddRef();<BR>            fSuccess=pSI-&gt;Init(m_pObjCont-&gt;m_pmk, pbc, pszItem<BR>                , pIStorage);<BR>            }<BR>        }<BR><BR>    if (!fSuccess)<BR>        {<BR>        if (NULL!=pUnk)<BR>            pUnk-&gt;Release();<BR><BR>        return ResultFromScode(E_OUTOFMEMORY);<BR>        }<BR><BR>    g_cObj++;<BR><BR>    //If QueryInterface fails, this Release destroys object.<BR>    hr=pUnk-&gt;QueryInterface(riid, ppv);<BR>    pUnk-&gt;Release();<BR><BR>    if (FAILED(hr))<BR>        return hr;<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>On entry to <I>GetObject</I>, you should always check whether the object is already running and return its pointer if so. The internal member <I>CImpIOleItemContainer::GetRunning</I> performs this step, which conveniently provides us with the implementation for <I>IsRunning </I>as well. <I>GetRunning</I> does nothing more than create an appropriate moniker and call <I>IRunningObjectTable::IsRunning </I>or <I>IRunningObjectTable::GetObject</I>, depending on a Boolean flag. The call we're making to <I>GetRunning </I>here within <I>GetObject </I>attempts the latter.</P>
<P>Now comes an important step: if the object is running, we can return successfully even if the bind context specified BINDSPEED_IMMEDIATE. If the object is not running, we have to return MK_E_EXCEEDEDDEADLINE—we should not attempt to load or run the object under such a time limitation.</P>
<P>If we can use more time, we check the existence of the particular object named in <I>pszItem </I>by calling our own <I>GetObjectStorage</I>. Our ability to do this stems from the fact that LinkSource's items are all contained within storage elements already—a server that handles objects whose data resides in other structures will, of course, take different steps here and potentially have to parse much more out of <I>pszItem</I>. The way you handle this string is entirely up to the nature of your server and the complexity of that string. With the binding speed being the only constraint, you can execute any code you want inside <I>GetObject </I>and <I>GetObjectStorage</I>.</P>
<P>Anyway, if <I>GetObjectStorage </I>is successful, we know the object exists, and we get back its <I>IStorage </I>pointer. We then hand the pointer to a new instantiation of <I>CContainerItem </I>or <I>CSimpleItem</I>, the choice of which is controlled by the interface's <I>m</I><I>_</I><I>fFileObj </I>flag. When the flag is FALSE, the interface is part of a <I>CContainerItem </I>object and is being used to bind a second item moniker. In our present example, this code will create a <I>CContainerItem.</I> (You can see how similar it is to <I>CSimpleItem </I>as well, because creation and initialization of both are nearly identical.)</P>
<P>The function <I>CContainerItem::Init </I>performs steps similar to the file object's <I>IPersistFile::Load</I>: it sets up the <I>IDescription </I>interface and registers the object as running. The code here looks just like the code shown earlier for <I>Load </I>with a slight change in variables. Nothing fancy.</P>
<P>That leaves us to glance quickly at <I>IOleItemContainer::GetObjectStorage</I>, which in our case can supply only an <I>IStorage </I>for the object:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleItemContainer::GetObjectStorage(LPOLESTR pszItem<BR>    , LPBINDCTX pbc, REFIID riid, PPVOID ppv)<BR>    {<BR>    IStorage       *pIStorageObj;<BR>    IStorage       *pIStorageNew;<BR>    HRESULT         hr;<BR><BR>    if (IID_IStorage!=riid)<BR>        return ResultFromScode(MK_E_NOSTORAGE);<BR><BR>    pIStorageObj=m_fFileObj ? m_pObjFile-&gt;m_pIStorage<BR>        : m_pObjCont-&gt;m_pIStorage;<BR><BR>    hr=pIStorageObj-&gt;OpenStorage(pszItem<BR>        , NULL, STGM_TRANSACTED | STGM_READ | STGM_SHARE_EXCLUSIVE<BR>        , NULL, 0, &amp;pIStorageNew);<BR><BR>    if (FAILED(hr))<BR>        {<BR>        IUnknown   *pUnk;<BR><BR>        if (STG_E_ACCESSDENIED!=GetScode(hr))<BR>            return hr;<BR><BR>        if (FAILED(pbc-&gt;GetObjectParam(SZOPENSTORAGE, &amp;pUnk)))<BR>            return ResultFromScode(STG_E_ACCESSDENIED);<BR><BR>        hr=pUnk-&gt;QueryInterface(IID_IStorage<BR>            , (void **)&amp;pIStorageNew);<BR>        pUnk-&gt;Release();<BR>        *ppv=pIStorageNew;<BR>        return hr;<BR>        }<BR><BR>    *ppv=pIStorageNew;<BR>    pbc-&gt;RegisterObjectParam(SZOPENSTORAGE, pIStorageNew);<BR>    return NOERROR;<BR>    }</code></pre>
<P>Here you can see an example of a use of <I>IBindCtx::RegisterObjectParam</I> and <I>IBindCtx::GetObject</I><I>Param</I>. When LinkScr is run in order to parse a name and bind the resulting moniker, LinkUser maintains the same bind context throughout the whole process. The problem we run into is that the first <I>CSimpleItem</I> object created for parsing is still alive in the bind context and is still holding the storage open using STGM_SHARE_EXCLUSIVE. So the <I>CSimpleItem</I> created during binding will not be able to open this storage itself. To solve this problem, we register the open storage as an object parameter during the parsing step so that we can access it again during the binding step. (Sharing is not a problem because this is all in the same server.)</P>
<P>With that, we have all the support necessary for File!Item moniker binding. If LinkUser were binding such a moniker, <I>IOleItemContainer::GetObject </I>would be followed by a <I>QueryInterface </I>to the new <I>CContainerItem</I> asking for <I>IDescription.</I></P>
<H4><A NAME="sec2"></A>Binding Support for the File!Item!Item Moniker</H4><P>When LinkUser now binds a File!Item!Item composite asking for <I>IDescription</I>, the composite once again asks the rightmost item to bind and return that interface. Once again, this item calls <I>pmkLeft-&gt;BindToObject(</I><I>…</I><I>, IID</I><I>_</I><I>IOleItemContainer, </I><I>…</I><I>)</I>, which in this case asks the first-level item moniker to bind as described in the previous section. However, the final <I>QueryInterface </I>to the <I>CContainerItem </I>object will ask for <I>IOleItemContainer</I>. Now <I>CContainerItem </I>uses exactly the same <I>IOleItemContainer </I>implementation that we've already seen except that it creates an instance of <I>CSimpleItem </I>as the object being named. <I>CSimpleItem </I>also sets up its <I>IDescription </I>implementation and registers itself as running.</P>
<P>Because <I>CSimpleItem </I>implements only <I>IDescription</I>, any attempt to bind a File!Item!Item!Item moniker through LinkSource will fail. If we added <I>IOleItemContainer </I>to this object, we would support that additional layer of items. In short, as long as each intermediate item supports <I>IOleItemContainer</I>, you can support arbitrarily long composite monikers, with many treasures along the way.</P></font></body></HTML>
