<HTML><HEAD><TITLE>IDispatch Performance and Restrictions</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IDispatch</I> Performance and Restrictions</H3><P>With all the argument handling, type coercion, localization support, and exceptions that are involved with a function such as <I>IDispatch::Invoke</I>, you've probably recognized at least once that accessing the functionality and content—that is, the methods and properties—of an object through a dispinterface is not exactly fast. Hence, the topic of performance.</P>
<P>If you compare Figure 14-3 with Figure 14-1, you'll notice that when a client accesses the functionality in, say, <I>CBeeper::Beep</I> through a dispinterface, both client and object are executing a lot more code than if the client were accessing it through a custom interface such as <I>IBeeper</I>. The client has more overhead because instead of calling the function directly, it has to push a fair number of parameters on the stack before calling <I>IDispatch::Invoke</I>. If the function itself took additional parameters (<I>Beep </I>takes none itself), the client would also have to create the appropriate DISPPARAMS and VARIANTARG structures first, then push pointers to those parameters on the stack, and then call <I>Invoke</I>. In contrast, making a direct call to a vtable interface function allows the client to push values on the stack instead of first stuffing them into other structures. In general, the client will always execute more instructions to set up the call, resulting in lower performance. While this may or may not be significant with respect to the execution time of the called function, it is the trade-off of late binding.</P>
<P>The object itself also incurs additional overhead because it receives its parameters through DISPPARAMS and VARIANTARG structures. It must not only unpack those parameters from the structures but also perform type checking on each parameter. When function calls are early-bound, the compiler does type checking. In late binding, the object has to enforce types at run time. So not only is there an extra function call to get from <I>IDispatch::Invoke </I>to, in this case, <I>CBeeper::Beep</I>, there is more overhead to manage the parameters and the return value.</P>
<P>In general, you will find that accessing a dispinterface that is implemented on an in-process object is anywhere from 5 percent to more than 90 percent slower—depending on the object—than accessing a custom vtable interface that implements the same features. When the object exists in a local server and marshaling is involved, a custom interface is still faster but not as much because the marshaling overhead comes into the picture. Still, is there any way to improve performance, especially for in-process objects?</P>
<H4><A NAME="sec0"></A>The Dual Interface</H4><P><img src="16bit.gif"></P>
<P>The way to improve performance for a dispinterface is somehow to cut down the per-call overhead for each property and method while still preserving the ability to perform late binding. In truth, however, you can't do much to speed up calls to <I>IDispatch::Invoke</I>: you still have to create the necessary structures for <I>Invoke </I>on the client side, and you still have to perform type checking on the object side.</P>
<P>What is called dual interface isn't as much an improvement on late binding to a dispinterface as it is a technique to combine a dispinterface, which has the <I>IDispatch </I>vtable, with the vtable for the equivalent custom interface, where the two share a common implementation of <I>IUnknown </I>members. A controller aware of dual interfaces can then choose to access the methods and properties either through <I>IDispatch::Invoke </I>or through direct calls to vtable entries, as illustrated in Figure 14-5. With a dual interface, a controller can choose to perform early binding or late binding to improve performance as it deems necessary, especially with in-process objects.</P>
<P>    <img src="f14dd05.gif"></P>
<P><B>Figure 14-5.</B></P>
<P><B>Dual interfaces combine the <I>IDispatch </I>vtable with a custom interface, allowing access to methods and properties through either route.</B></P>
<P>One benefit of implementing a set of functions as a dual interface for local objects is that OLE provides automatic marshaling of all the functions in the custom vtable portion of the interface. This can occur because OLE will have access to the type information for this interface, as it does for any other dispinterface. Tests show, however, that performance is about the same through the vtable portion of a dual interface as it is for the <I>IDispatch </I>portion—the reason is that generic marshaling code, which has to examine type details to determine how to actually marshal each parameter, takes a considerable amount of time. In fact, when making cross-process <I>IDispatch::Invoke </I>calls, most of the time is spent in the marshaling code, and OLE employs this same code for all parts of a dual interface. Therefore the performance is about equivalent.</P>
<P>Remember, a straightforward custom interface is still faster than a dispinterface across process boundaries. If performance in such cases is of prime importance to you, a dual interface is not necessarily the best option. The argument and return value types that you can use within a cross-process dispinterface and a dual interface also affect your decision here. These types are limited to what are called <I>automation-compatible</I> types, which means you cannot pass arbitrary data structures by reference through these interfaces because OLE's generic marshaling service can handle only a basic set of types. OLE doesn't handle pointers to structures that may contain pointers to other structures, ad infinitum. If you want to pass data structures in this fashion, you should use either custom marshaling or standard marshaling with a custom interface.</P>
<H4><A NAME="sec1"></A>Automation-Compatible Interfaces and Types</H4><P>When a client packages parameters in VARIANT[ARG] structures to pass to methods and properties through <I>IDispatch::Invoke</I>, some proxy and stub must marshal those parameters as well as the return value. Because OLE itself implements the proxy and stub for the <I>IDispatch </I>interface, OLE provides the generic marshaling code to handle any VARIANT structure. However, you can store only a limited number of data types in a VARIANT, and this limits the types you can employ through a dispinterface or a dual interface. These types are <I>int</I>, <I>short</I>, <I>long</I>, <I>boolean</I>, <I>char</I>, <I>wchar</I><I>_</I><I>t</I>, <I>float</I>, <I>double</I>, <I>IUnknown </I>*, <I>IDispatch </I>*, CY (currency), DATE, BSTR, VARIANT (containing a compatible type), NULL, SCODE, and a Safe Array of any of these types. You can also have a custom <I>typedef enum &lt;type&gt; </I>that is the same as an <I>int</I>, but the size is also system dependent.</P>
<P>When you limit methods and properties to these types, you have an automation-compatible interface. As we saw in Chapter 3, you can use the <I>oleautomation</I> attribute in an ODL to enforce the restrictions listed here.</P>
<H4><A NAME="sec2"></A>Passing Data Structures</H4><P>Certainly you can pass a lot of useful information when you follow the restrictions for an automation-compatible interface. However, you might want to pass some sort of data structure between processes through a dispinterface or a dual interface without having to provide your own custom interface.</P>
<P>You can accomplish the exchange of structured data through two methods. The first and most common method is to implement another object with <I>IDispatch</I> that wraps the data structure and turns each field into a property. For example, suppose I had a structure as follows:</P>
<P><BR></P>
<pre><code>typedef struct<BR>    {<BR>    int        Lengthcm;   //Length in centimeters<BR>    int        Radiuscm;   //Top radius in centimeters<BR>    int        Weightg;    //Weight in grams<BR>    COLORREF   Shade;      //Exact color shade<BR>    } PARSNIP;</code></pre>
<P>I could then create a dispinterface with each field described as a property:</P>
<P><BR></P>
<pre><code>dispinterface DIParsnip<BR>    {<BR>    properties:<BR>        [id(0)] int     Lengthcm;<BR>        [id(1)] int     Radiuscm;<BR>        [id(2)] int     Weightg;<BR>        [id(3)] long    Shade;<BR>    };</code></pre>
<P>Wherever I want to have a PARSNIP * argument7 to a method in my interface (or as a return value), I can use an <I>IDispatch</I> * instead. Whenever I need to access a field in the data structure, I can call <I>IDispatch::Invoke </I>with the dispID of the property associated with that field.</P>
<P>One obvious drawback to passing data structures in this manner—especially across process boundaries—is that it is <I>slow</I>. It potentially requires a cross-process call for each field in a data structure. For small structures, this generally isn't a problem, but for larger structures or when performance really matters, the faster alternative is to have your original automation object return structures as <I>IUnknown</I> pointers so that each pointer refers to an object that also implements <I>IDataObject </I>(which can be the automation object itself). Through <I>IDataObject</I>, you can provide data structures in their entirety with one call. You might also find it useful to implement a separate data structure object that has both an <I>IDataObject </I>implementation for fast access to data and an <I>IDispatch </I>implementation for flexible late-bound access to each field. To be really flexible, you could make your <I>IDispatch </I>implementation part of a dual interface for in-process objects or also provide a custom interface for local objects.</P></font></body></HTML>
