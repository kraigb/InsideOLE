<HTML><HEAD><TITLE>Managing Substorages</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Managing Substorages</H3><P>As mentioned earlier, Patron manages a substorage for each page in the overall document. This, of course, requires somewhat more complex code when pages are created or destroyed. Whenever Patron creates a new page in the document, it calls <I>IStorage::CreateStorage</I> using the name Page&lt;<I>ID</I>&gt;, where &lt;<I>ID</I>&gt; is the page identifier in ASCII. When Patron opens an existing page, it calls <I>IStorage::OpenStorage </I>with the appropriate name as well. Both operations occur in <I>CPage::Open</I>. The member <I>CPage::GetStorageName </I>simply generates the text name to use in both calls:</P>
<P><BR></P>
<pre><code>BOOL CPage::Open(LPSTORAGE pIStorage)<BR>    {<BR>    BOOL        fNULL=FALSE;<BR>    HRESULT     hr=NOERROR;<BR>    DWORD       dwMode=STGM_TRANSACTED | STGM_READWRITE<BR>                    | STGM_SHARE_EXCLUSIVE;<BR>    OLECHAR     szTemp[32];<BR><BR>    if (NULL==m_pIStorage)<BR>        {<BR>        fNULL=TRUE;<BR><BR>        if (NULL==pIStorage)<BR>            return FALSE;<BR><BR>        GetStorageName(szTemp);<BR><BR>        hr=pIStorage-&gt;OpenStorage(szTemp, NULL, dwMode, NULL, 0<BR>            , &amp;m_pIStorage);<BR><BR>        if (FAILED(hr))<BR>            {<BR>            hr=pIStorage-&gt;CreateStorage(szTemp, dwMode, 0, 0<BR>                , &amp;m_pIStorage);<BR>            }<BR>        }<BR><BR>   §<BR>   }<BR><BR><BR>UINT CPage::GetStorageName(LPOLESTR pszName)<BR>    {<BR>    return wsprintf(pszName, TEXT("Page %lu"), m_dwID);<BR>    }</code></pre>
<P>The <I>CPages </I>class assigns the page ID through the <I>CPage </I>constructor, which saves the value in <I>m</I><I>_</I><I>dwID. </I>The <I>CPages </I>class, once again, keeps a persistent DWORD counter for page IDs in the Page List stream. IDs are not recycled when a page is destroyed, but the DWORD counter would overflow only if you sat down and created (for example) one page every second until the year 2129. I desperately hope this software is obsolete by then!</P>
<P>Speaking of destroying a page, this operation requires a call to <I>IStorage::DestroyElement</I> to counter the <I>IStorage::CreateStorage</I> in the preceding code. The function <I>CPage::Destroy</I> takes care of this in Patron:</P>
<P><BR></P>
<pre><code>//pIStorage is document's root storage.<BR>void CPage::Destroy(LPSTORAGE pIStorage)<BR>    {<BR>    if (NULL!=pIStorage)<BR>        {<BR>        OLECHAR   szTemp[32];<BR><BR>        Close(FALSE);<BR>        GetStorageName(szTemp)<BR>        pIStorage-&gt;DestroyElement(szTemp);<BR>        }<BR><BR>    return;<BR>    }<BR><BR>void CPage::Close(BOOL fCommit)<BR>    {<BR>    if (NULL==m_pIStorage)<BR>        return;<BR><BR>    if (fCommit)<BR>        Update();<BR><BR>    if (0L==m_pIStorage-&gt;Release())<BR>        m_pIStorage=NULL;<BR><BR>    return;<BR>    }<BR><BR>BOOL CPage::Update(void)<BR>    {<BR>    if (NULL!=m_pIStorage)<BR>        m_pIStorage-&gt;Commit(STGC_DEFAULT);<BR><BR>    return TRUE;<BR>    }</code></pre></font></body></HTML>
