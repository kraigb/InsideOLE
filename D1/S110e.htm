<HTML><HEAD><TITLE>Implementing Multiple Interfaces</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Implementing Multiple Interfaces</H2><P>In the C++ RectEnumerator sample, I used single inheritance to bring the function signatures for the <I>IEnumRECT </I>interface into the <I>CEnumRect </I>object class. This technique works quite well for single-interface, nonaggregatable objects. However, when you want to implement multiple interfaces, which includes an explicit <I>IUnknown </I>for aggregation, you need to use one of three other techniques: interface implementations, contained interface classes, and multiple inheritance, each of which are each discussed in the following sections. The C++ Query sample in CHAP02\QUERY demonstrates each of these techniques through three equivalent object implementations (<I>CObject1</I>, <I>CObject2</I>, and <I>CObject3</I>). The Query code itself acts as a client for any of these objects, and it creates a small window with a menu through which you can select which object to create, invoke the member functions of their interfaces, and release them.</P>
<P>Each object in this demonstration implements two interfaces, <I>ISampleOne </I>and <I>ISampleTwo</I>, which are defined as follows in INTERFAC.H, using the macros that expand to the appropriate C++ interface declarations for different target platforms:</P>
<P><BR></P>
<pre><code>DECLARE_INTERFACE_(ISampleOne, IUnknown)<BR>    {<BR>    //IUnknown members<BR>    STDMETHOD(QueryInterface) (THIS_ REFIID, PPVOID) PURE;<BR>    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;<BR>    STDMETHOD_(ULONG,Release) (THIS) PURE;<BR><BR>    //ISampleOne members<BR>    STDMETHOD(GetMessage) (THIS_ LPTSTR, UINT) PURE;<BR>    };<BR><BR>typedef ISampleOne *PINTERFACEONE;<BR><BR>DECLARE_INTERFACE_(ISampleTwo, IUnknown)<BR>    {<BR>    //IUnknown members<BR>    STDMETHOD(QueryInterface) (THIS_ REFIID, PPVOID) PURE;<BR>    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;<BR>    STDMETHOD_(ULONG,Release) (THIS) PURE;<BR><BR>    //ISampleTwo members<BR>    STDMETHOD(GetString) (THIS_ LPTSTR, UINT) PURE;<BR>    };<BR><BR>typedef ISampleTwo *PINTERFACETWO;</code></pre>
<P>The IIDs for these interfaces are given in INC\BOOKGUID.H, as are all GUIDs defined for this book. Both <I>ISampleOne::GetMessage </I>and <I>ISampleTwo::GetString </I>fill a string buffer with some string that the client (QUERY.CPP) displays in its window to prove that it called the correct member function of the correct interface. It is instructive to run Query in a debugger and follow the path of execution through each object.</P></font></body></HTML>
