<HTML><HEAD><TITLE>Implement IOleObject</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement <I>IOleObject</I></H3><P>In some ways, <I>IOleObject</I> looks like the interface from hell, a dumping ground for every function that didn't seem to have any better home. Intimidating? You bet! Is it a problem? Not really. For the most part, the member functions in this interface have either trivial or optional implementations. Only about 15 of the 21 member functions, excluding those in <I>IUnknown</I>, require some implementation for embedded objects. Twelve of those 15 either are trivial to implement or use defaults from the registry. The remaining 6 (of the 21) functions either are optional or are not used for embedded objects themselves. (They will become more important later on.) The following table lists the implementation requirements for <I>IOleObject</I> members:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="137pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Group</B></P></TD><TD VALIGN="TOP"><P><B>Members</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Require real programming</P></TD><TD VALIGN="TOP"><P><I>SetHostNames</I>,<I> Close</I>,<I> DoVerb</I></P></TD></TR><TR><TD VALIGN="TOP"><P>Trivial implementations</P></TD><TD VALIGN="TOP"><P><I>SetClientSite</I>,<I> GetClientSite</I>,<I> Update</I>,<I> IsUpToDate</I>,<I> GetExtent</I>,<I> Advise</I>,<I> Unadvise</I>,<I> EnumAdvise</I>,<I> GetUserClassID</I></P></TD></TR><TR><TD VALIGN="TOP"><P>Implemented using registry</P></TD><TD VALIGN="TOP"><P><I>EnumVerbs</I>,<I> GetUserType</I>,<I> GetMiscStatus</I></P></TD></TR><TR><TD VALIGN="TOP"><P>Optional</P></TD><TD VALIGN="TOP"><P><I>SetExtent</I>,<I> InitFromDa</I><I>ta</I>,<I> GetClipboardData</I>,<I> SetColorScheme</I></P></TD></TR><TR><TD VALIGN="TOP"><P>Used for linking</P></TD><TD VALIGN="TOP"><P><I>SetMoniker</I>,<I> GetMoniker</I></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Members in the real programming group will be the focus of our discussion here. Those with trivial implementations will generally require only a few lines of code, and standard code at that. Those using the registry can simply return OLE_S_USEREG, as we did with <I>IDataObject::EnumFormatEtc</I>. OLE implements these using <I>OleRegEnumVerbs</I>,<I> OleRegGetUserType</I>,<I> </I>and <I>OleRegGetMiscStatus</I>, respectively. For the others, you can simply return E_NOTIMPL if you don't need them. Otherwise, functions such as <I>InitFromData </I>and <I>SetColorScheme </I>can easily require nontrivial code.</P>
<P>Cosmo implements <I>IOleObject</I> through the class <I>CImpIOleObject</I>,<I> </I>found in IOLEOBJ.CPP. So that you can see the varying complexity of these members, I've included the entire file in Listing 18-1 beginning on the following page. The next three sections cover the trivial, required, and optional members in more detail.</P>
<H4><A NAME="sec0"></A>IOLEOBJ.CPP</H4><P><BR></P>
<pre><code>/*<BR> * IOLEOBJ.CPP<BR> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved<BR> */<BR><BR>#include "cosmo.h"<BR><BR>[Constructor, destructor, IUnknown members omitted]<BR><BR>STDMETHODIMP CImpIOleObject::SetClientSite<BR>    (LPOLECLIENTSITE pIOleClientSite)<BR>    {<BR>    if (NULL!=m_pObj-&gt;m_pIOleClientSite)<BR>        m_pObj-&gt;m_pIOleClientSite-&gt;Release();<BR><BR>    m_pObj-&gt;m_pIOleClientSite=pIOleClientSite;<BR>    m_pObj-&gt;m_pIOleClientSite-&gt;AddRef();<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::GetClientSite(LPOLECLIENTSITE<BR>    *ppSite)<BR>    {<BR>    //Be sure to call AddRef on new pointer you are giving away.<BR>    *ppSite=m_pObj-&gt;m_pIOleClientSite;<BR>    m_pObj-&gt;m_pIOleClientSite-&gt;AddRef();<BR><BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::SetHostNames(LPCOLESTR pszApp<BR>    , LPCOLESTR pszObj)<BR>    {<BR>    m_pObj-&gt;m_fEmbedded=TRUE;<BR>    m_pObj-&gt;m_pFR-&gt;UpdateEmbeddingUI(TRUE, m_pObj-&gt;m_pDoc<BR>        , pszApp, pszObj);<BR>    return NOERROR;<BR>    }
STDMETHODIMP CImpIOleObject::Close(DWORD dwSaveOption)<BR>    {<BR>    HWND    hWnd;<BR>    BOOL    fSave=FALSE;<BR><BR>    hWnd=m_pObj-&gt;m_pDoc-&gt;Window();<BR><BR>    //If object is dirty and we're asked to save, save it and close.<BR>    if (OLECLOSE_SAVEIFDIRTY==dwSaveOption &amp;&amp; m_pObj-&gt;FIsDirty())<BR>        fSave=TRUE;<BR><BR>    /*<BR>     * If asked to prompt, do so only if dirty; if we get a<BR>     * YES, save as usual and close. On NO, just close. On<BR>     * CANCEL, return OLE_E_PROMPTSAVECANCELLED.<BR>     */<BR>    if (OLECLOSE_PROMPTSAVE==dwSaveOption &amp;&amp; m_pObj-&gt;FIsDirty())<BR>        {<BR>        UINT    uRet;<BR><BR>        uRet=MessageBox(hWnd, (*m_pObj-&gt;m_pST)[IDS_CLOSECAPTION]<BR>            , (*m_pObj-&gt;m_pST)[IDS_CLOSEPROMPT], MB_YESNOCANCEL);<BR><BR>        if (IDCANCEL==uRet)<BR>            return ResultFromScode(OLE_E_PROMPTSAVECANCELLED);<BR><BR>        if (IDYES==uRet)<BR>            fSave=TRUE;<BR>        }<BR><BR>    if (fSave)<BR>        {<BR>        m_pObj-&gt;SendAdvise(OBJECTCODE_SAVEOBJECT);<BR>        m_pObj-&gt;SendAdvise(OBJECTCODE_SAVED);<BR>        }<BR><BR>    //We get here directly on OLECLOSE_NOSAVE.<BR>    PostMessage(hWnd, WM_CLOSE, 0, 0L);<BR>    return NOERROR;<BR>    }
STDMETHODIMP CImpIOleObject::SetMoniker(DWORD dwWhich<BR>    , LPMONIKER pmk)<BR>    {<BR>    return ResultFromScode(E_NOTIMPL);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::GetMoniker(DWORD dwAssign<BR>    , DWORD dwWhich, LPMONIKER *ppmk)<BR>    {<BR>    return ResultFromScode(E_NOTIMPL);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::InitFromData(LPDATAOBJECT pIDataObject<BR>    , BOOL fCreation, DWORD dwReserved)<BR>    {<BR>    BOOL  fRet;<BR><BR>    fRet=m_pObj-&gt;m_pDoc-&gt;PasteFromData(pIDataObject);<BR>    return fRet ? NOERROR : ResultFromScode(E_FAIL);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::GetClipboardData(DWORD dwReserved<BR>    , LPDATAOBJECT *ppIDataObj)<BR>    {<BR>    *ppIDataObj=m_pObj-&gt;m_pDoc-&gt;TransferObjectCreate(FALSE);<BR>    return (NULL!=*ppIDataObj) ? NOERROR : ResultFromScode(E_FAIL);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::DoVerb(LONG iVerb, LPMSG pMSG<BR>    , LPOLECLIENTSITE pActiveSite, LONG lIndex, HWND hWndParent<BR>    , LPCRECT pRectPos)<BR>    {<BR>    HWND      hWnd, hWndT;<BR><BR>    //Find the uppermost window.<BR>    hWndT=GetParent(m_pObj-&gt;m_pDoc-&gt;Window());<BR><BR>    while (NULL!=hWndT)<BR>        {<BR>        hWnd=hWndT;<BR>        hWndT=GetParent(hWndT);<BR>        }
    switch (iVerb)<BR>        {<BR>        case OLEIVERB_HIDE:<BR>            ShowWindow(hWnd, SW_HIDE);<BR>            m_pObj-&gt;SendAdvise(OBJECTCODE_HIDEWINDOW);<BR>            break;<BR><BR>        case OLEIVERB_PRIMARY:<BR>        case OLEIVERB_OPEN:<BR>        case OLEIVERB_SHOW:<BR>            ShowWindow(hWnd, SW_SHOW);<BR>            SetForegroundWindow(hWnd);<BR>            SetFocus(hWnd);<BR><BR>            m_pObj-&gt;SendAdvise(OBJECTCODE_SHOWOBJECT);<BR>            m_pObj-&gt;SendAdvise(OBJECTCODE_SHOWWINDOW);<BR>            break;<BR><BR>        default:<BR>            return ResultFromScode(OLEOBJ_S_INVALIDVERB);<BR>        }<BR><BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::EnumVerbs(LPENUMOLEVERB *ppEnum)<BR>    {<BR>    return ResultFromScode(OLE_S_USEREG);<BR>    }<BR><BR>STDMETHODIMP CImpIOleObject::Update(void)<BR>    {<BR>    //We're always updated since we don't contain.<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIOleObject::IsUpToDate(void)<BR>    {<BR>    //We're always updated since we don't contain.<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIOleObject::GetUserClassID(LPCLSID pClsID)<BR>    {<BR>    *pClsID=m_pObj-&gt;m_clsID;<BR>    return NOERROR;<BR>    }
STDMETHODIMP CImpIOleObject::GetUserType(DWORD dwForm<BR>    , LPOLESTR *ppszType)<BR>    {<BR>    return ResultFromScode(OLE_S_USEREG);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::SetExtent(DWORD dwAspect, LPSIZEL pszl)<BR>    {<BR>    RECT      rc;<BR>    SIZEL     szl;<BR><BR>    if (!(DVASPECT_CONTENT &amp; dwAspect))<BR>        return ResultFromScode(E_FAIL);<BR><BR>    XformSizeInHimetricToPixels(NULL, pszl, &amp;szl);<BR><BR>    //This resizes the window to match the container's size.<BR>    SetRect(&amp;rc, 0, 0, (int)szl.cx, (int)szl.cy);<BR>    m_pObj-&gt;m_pPL-&gt;SizeSet(&amp;rc, TRUE);<BR><BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIOleObject::GetExtent(DWORD dwAspect, LPSIZEL pszl)<BR>    {<BR>    RECT      rc;<BR>    SIZEL     szl;<BR><BR>    if (!(DVASPECT_CONTENT &amp; dwAspect))<BR>        return ResultFromScode(E_FAIL);<BR><BR>    m_pObj-&gt;m_pPL-&gt;RectGet(&amp;rc);<BR>    szl.cx=rc.right-rc.left;<BR>    szl.cy=rc.bottom-rc.top;<BR><BR>    XformSizeInPixelsToHimetric(NULL, &amp;szl, pszl);<BR>    return NOERROR;<BR>    }
STDMETHODIMP CImpIOleObject::Advise(LPADVISESINK pIAdviseSink<BR>    , LPDWORD pdwConn)<BR>    {<BR>    if (NULL==m_pObj-&gt;m_pIOleAdviseHolder)<BR>        {<BR>        HRESULT   hr;<BR><BR>        hr=CreateOleAdviseHolder(&amp;m_pObj-&gt;m_pIOleAdviseHolder);<BR><BR>        if (FAILED(hr))<BR>            return hr;<BR>        }<BR><BR>    return m_pObj-&gt;m_pIOleAdviseHolder-&gt;Advise(pIAdviseSink<BR>        , pdwConn);<BR>    }<BR><BR>STDMETHODIMP CImpIOleObject::Unadvise(DWORD dwConn)<BR>    {<BR>    if (NULL!=m_pObj-&gt;m_pIOleAdviseHolder)<BR>        return m_pObj-&gt;m_pIOleAdviseHolder-&gt;Unadvise(dwConn);<BR><BR>    return ResultFromScode(E_FAIL);<BR>    }<BR><BR>STDMETHODIMP CImpIOleObject::EnumAdvise(LPENUMSTATDATA *ppEnum)<BR>    {<BR>    if (NULL!=m_pObj-&gt;m_pIOleAdviseHolder)<BR>        return m_pObj-&gt;m_pIOleAdviseHolder-&gt;EnumAdvise(ppEnum);<BR><BR>    return ResultFromScode(E_FAIL);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIOleObject::GetMiscStatus(DWORD dwAspect<BR>    , LPDWORD pdwStatus)<BR>    {<BR>    return ResultFromScode(OLE_S_USEREG);<BR>    }<BR><BR>STDMETHODIMP CImpIOleObject::SetColorScheme(LPLOGPALETTE pLP)<BR>    {<BR>    return ResultFromScode(E_NOTIMPL);<BR>    }</code></pre>
<P><B>Listing 18-1</B></P>
<P><B>Cosmo's implementation of <I>IOleObject</I>.</B></P>
<H4><A NAME="sec1"></A>Trivial Functions</H4><P>Let's look at the simple implementations first because we'll need some of the information from these functions to implement the more complex ones. The functions in this set are <I>SetClientSite</I>, <I>GetClientSite</I>, <I>Update</I>, <I>IsUpToDate</I>, <I>GetExtent</I>, <I>GetUserClassID</I>, and the triumvirate <I>Advise</I>, <I>Unadvise</I>, and <I>EnumAdvise</I>.</P>
<P><I>SetClientSite</I> is the only way through which the embedded object gets an <I>IOleClientSite</I> pointer to the container's site object. You must hold on to this pointer for the lifetime of your object, saving it in a variable and calling <I>AddRef </I>on it, of course. In the rare case that your object receives multiple calls to <I>SetClientSite</I>, release whatever pointer you are currently holding before overwriting it with the new one.</P>
<P><I>GetClientSite</I> is the direct sibling of <I>SetClientSite</I>. It simply needs to copy the last <I>IOleClientSite</I> pointer seen in <I>SetClientSite</I> to the out-parameter **<I>ppSite</I>. <I>GetClientSite</I> is a function that returns a new copy of a pointer, so be sure to call <I>AddRef</I> on the <I>IOleClientSite</I> pointer again.</P>
<P><I>Update</I> and <I>IsUpToDate</I> are a pair of functions that a container can use to be sure that the presentation in its cache matches the current state of the object. <I>IsUpToDate</I> asks, "Are you current?" whereas <I>Update</I> tells your application, "Make yourself current." I mentioned before that embedded objects are always up-to-date unless they actually contain other objects themselves (especially links). This is because singular embedded objects always call <I>IAdviseSink::OnViewChange </I>when a change occurs, so the cache and the container are visibly updated. If the object is a container itself, however, it has to recursively call <I>Update </I>or <I>IsUpToDate </I>on its contained objects to implement these members.</P>
<P><I>GetExtent</I> asks the object, "How big is this aspect?" by asking the object to fill a SIZEL<I> </I>structure with the horizontal and vertical dimensions of the object in HIMETRIC units that are sensitive to the requested aspect. These extents are in absolute units—that is, the vertical value is not negative, as it would be if you were dealing in the MM_HIMETRIC mapping<I> </I>mode. Because no <I>hDC</I> is anywhere in sight, there is no conception of a mapping mode in this function. Cosmo implements a mapping mode by retrieving the rectangle of the current Polyline window (in pixels) and using the helper function <I>XformSizeInPixelsToHimetric</I> (which is in INOLE.DLL, file INOLE\XFORM.CPP) to convert the values before returning.</P>
<P><I>GetUserClassID</I> has to return the emulated CLSID—just as <I>IPersistStorage::GetClassID </I>does—if the present object is being used in this capacity. In Cosmo, <I>IPersistStorage::Load </I>stores the emulated CLSID in <I>CFigure::m</I><I>_</I><I>clsID</I>,<I> </I>so that's what we return here. In emulation scenarios, the CLSID that users think they are working with is not the CLSID of your object itself. This means <I>GetUserClassID </I>gives the container (and OLE) a way of knowing what the object actually is.</P>
<P>You can implement the three advise functions using an advise holder created with <I>CreateOleAdviseHolder</I>. This advise holder implements the interface <I>IOleAdviseHolder</I>,<I> </I>through which we can multicast the <I>OnSave</I>,<I> OnRename</I>,<I> </I>and <I>OnClose </I>calls to <I>IAdviseSink </I>interfaces. We create the advise holder in <I>Advise </I>and release it in the <I>CFigure </I>destructor. <I>Advise</I>,<I> Unadvise</I>,<I> </I>and <I>EnumAdvise </I>then delegate to this holder. When we need to send notifications, we call members such as <I>IOleAdviseHolder::SendOnSave </I>and others, as we'll see later.</P>
<H4><A NAME="sec2"></A>Required Functions</H4><P>In this set, we find <I>DoVerb</I>, <I>Close</I>, and <I>SetHostNames</I>,<I> </I>the three most important members (in that order) of <I>IOleObject.</I> <I>DoVerb</I> asks an object to execute one of its verbs. If <I>DoVerb</I> didn't exist, activation wouldn't exist, so it is really the crux of OLE Documents. The whole process of in-place activation begins with this function, as we'll see in Chapters 22 and 23.</P>
<P>As discussed in Chapter 17, the <I>DoVerb</I> function takes an object from the loaded or running state to the active state, or from the active state to the running state. This function receives a number of arguments, the first of which, <I>iVerb</I>, is the number of the verb to execute. This will be either OLEIVERB_PRIMARY (value 0), one of the object's custom verbs as selected from the verb menu created for this object in the container (a positive value), or one of the following standard verbs:3</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="138pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>OLEIVERB_SHOW (<FONT FACE="Symbol">-</FONT>1)</P></TD><TD VALIGN="TOP"><P>"Make the object visible." The object calls <I>ShowWindow(hWnd, SW</I><I>_</I><I>SHOW)</I>, in which <I>hWnd</I> is the topmost window that is necessary to show to make this object visible. After <I>ShowWindow</I>, the object calls <I>SetFocus(hWnd)</I> followed by calls to <I>IOleClientSite::ShowObject</I> and <I>IOleClientSite::OnShowWindow(TRUE)</I>. <I>IOleClientSite</I> is the client site returned from <I>SetClientSite</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_OPEN (<FONT FACE="Symbol">-</FONT>2)</P></TD><TD VALIGN="TOP"><P>"Open the object for editing." Outside of in-place activation, this has the same semantics as OLEIVERB_SHOW.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_HIDE (<FONT FACE="Symbol">-</FONT>3)</P></TD><TD VALIGN="TOP"><P>"Hide the object." The object calls <I>ShowWindow(hWnd, SW</I><I>_</I><I>HIDE</I>), in which <I>hWnd</I> is the topmost window that is suitable for hiding the object's user interface, such as the main application window (for a single-object server) or a document window (when multiple objects or documents are open). The object also calls <I>IOleClientSite::OnShowWindow(FALSE)</I>. <I>IOleClientSite</I> is the client site returned from <I>SetClientSite</I>.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>All embedded objects should support at least these three verbs along with OLEIVERB_PRIMARY. Any other unsupported verb should cause <I>DoVerb </I>to return OLE_E_INVALIDVERB. The exact meaning of any positive verb, as well as OLEIVERB_PRIMARY, is something known only to the object and the end user. Cosmo's single (and primary) verb is Edit. Invoking Edit shows Cosmo's window, as with OLEIVERB_SHOW and OLEIVERB_OPEN. Another type of object, for example a sound object that has a Play verb, would only play the sound and not actually show any windows, nor would it call anything in <I>IOleClientSite</I>.</P>
<P>The other arguments to <I>DoVerb</I> provide the object with information that it can use to modify its behavior. The argument <I>lpMsg</I> tells the object what message (for example, WM_LBUTTONDBLCLK) actually caused the <I>DoVerb</I> call from the container. This information is important mostly for a type of in-place object called <I>inside-out,</I> which is covered in Chapters 22 and 23. The <I>IOleClientSite</I> pointer <I>pActiveSite</I> is used in other special cases that are not yet important in our discussion. The argument <I>lindex</I> is always 0 and is reserved for future use. Finally, <I>hWndParent</I> and <I>pRectPos</I> are useful to objects such as video clips, which temporarily play in the context of the container without having to implement full in-place activation. An object is allowed to temporarily create a window inside <I>hWndParent</I> in which to play or to call <I>GetDC(hWndParent)</I>. It is also allowed to draw directly onto the container's window. The <I>pRectPos</I> parameter provides you with the position of your object (that is, the container's site) in <I>hWndParent</I>. Although you can create a window that is larger than this rectangle, you should never draw outside the rectangle on the container's <I>hDC</I>. Also, it is important to know that anything you do with these two parameters must be done entirely within <I>DoVerb. </I>If you need any other type of in-place capabilities, you need to implement in-place activation.</P>
<P>The next most important member of <I>IOleObject</I> is <I>Close</I>, which moves an object from the running or active state to the loaded state. <I>Close</I> is also called either when the container closes the compound document that contains the object or when the user deletes the object from that document altogether. In any case, the object generally closes its user interface, calls <I>IOleClientSite::OnShowWindow(FALSE</I>),<I> </I>and starts server shutdown as necessary.</P>
<P>I said that the object "generally" does these things because the <I>dwSaveOption</I> argument can modify this behavior:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="141pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Value</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>OLECLOSE_SAVEIFDIRTY</P></TD><TD VALIGN="TOP"><P>If the object is dirty, it should save itself before closing.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLECLOSE_NOSAVE</P></TD><TD VALIGN="TOP"><P>Close the object without saving.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLECLOSE_PROMPTSAVE</P></TD><TD VALIGN="TOP"><P>Display a message box with a message something like, "This object has been changed. Do you want to update <I>&lt;container document&gt;</I> before closing?"* and Yes, No, and Cancel buttons. If the user chooses Yes, save the object and close. If the user chooses No, simply close. On Cancel, return OLE_E_PROMPTSAVECANCELLED without doing anything else. The <I>&lt;container document&gt;</I> string is obtained through <I>IOleObject::SetHostNames</I>, as we'll see shortly.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>*    I could find no standard for this message, so I'm making an educated guess based on an old OLE 1 standard.</P>
<P>The process of saving, when necessary, has two steps:</P>
<P>If the object has been modified, call <I>IOleClientSite::SaveObject </I>using the most recent pointer seen in <I>SetClientSite</I>. In Cosmo, this is accomplished by calling <I>CFigure::SendAdvise</I> with OBJECTCODE_SAVEDOBJECT.</P>
<P>Call <I>IAdviseSink::OnSave</I> through your advise holder's <I>IOleAdviseHolder::SendOnSave</I>. Again, Cosmo handles this through <I>CFigure::SendAdvise</I> with OBJECTCODE_SAVED.</P>
<P>The final required function in <I>IOleObject</I> with a sizable implementation is <I>SetHostNames</I>. This function informs the object that it's being embedded in a container and is a signal to the server to show the appropriate user interface for embedding. At this point in our discussion, it's not necessary to fully implement this function, so we'll come back to it later in this chapter in "Modify the Server's User Interface."</P>
<H4><A NAME="sec3"></A>Optional Functions</H4><P>The four functions in this group—<I>SetExtent</I>, <I>InitFromData</I>, <I>GetClipboardData</I>, and <I>SetColorScheme</I>—are not required for standard operation of compound documents, so you can implement them as suits your fancy.</P>
<P><I>SetExtent</I> adds a nice touch to the interaction between a container and a server, so I do recommend that you implement it. A container will call this function when it resizes an object in one of its documents if your object is running or if you have marked it with OLEMISC_RECOMPOSEONRESIZE. Handling <I>SetExtent </I>ensures that your object always looks good in the container—no matter what the scale—because you can render the object as appropriate for that scale. When the object is active in its own user interface, this call can also be used to reduce or enlarge the object in its editing window as the user resizes it in the container. Cosmo, for example, scales the Polyline window (and the document window in which it lives) in such a way that it's as close to the size of the container's site as possible (and within reason). <I>SetExtent</I> works best for graphical objects; it does not work as well for text or table objects for which scale is much less important than the textual or numeric data. <I>SetExtent</I> is also sensitive to the display aspect that is passed in the <I>dwAspect</I> parameter.</P>
<P><I>InitFromData</I> allows a container to either paste into your object directly or provide initial data during creation. This function is passed an <I>IDataObject</I> pointer, which you can use to retrieve the data, and the flag <I>fCreation</I>, which indicates the scenario in which this function is being called. If <I>fCreation</I> is FALSE, you should integrate the data in the data object with your current data, as if Edit Paste had been performed in the server itself. If <I>fCreation</I> is TRUE, the container is attempting to create a new instance of your object on the basis of a selection in the container that is described by the data object. Cosmo happens to treat both cases identically by passing the data object to <I>CCosmoDoc::PasteFromData</I>. Again, I highly recommend that you make a function that pastes data from any arbitrary data object, such as those you can get from the clipboard, from drag and drop, or from a function such as <I>InitFromData</I>.</P>
<P><I>GetClipboardData</I>, on the other hand, asks the object for an <I>IDataObject</I> pointer that is identical to the one the server would place on the clipboard if the user performed an Edit Copy operation. This allows a caller to get a snapshot of the object—as opposed to the <I>IDataObject</I> interface on the object itself—that always reflects the most recent data. If you implement this function, you have to return an <I>IDataObject</I> pointer for an object whose data will not change. Cosmo has the handy function <I>CCosmoDoc::TransferObjectCreate</I>, which does the job for us.</P>
<P>Finally, <I>SetColorScheme</I> provides the object with the container's recommended palette. The object might choose to ignore this without any dire consequences, but if you can, try to use the colors provided. Now, the colors provided in the LOGPALETTE structure are not actually colors in a GDI palette. The first palette entry in the structure actually specifies the foreground color recommended by the container. The second palette entry specifies the background color. The first half of the remaining palette entries are fill colors, and the second half are colors for the lines and text. Container applications typically specify an even number of palette entries. When there is an uneven number of entries, the server should round up to the fill colors. In other words, if there are five entries, the first three should be interpreted as fill colors and the last two as line and text colors.</P>
<H4><A NAME="sec4"></A>But It Still Doesn't Work</H4><P>After implementing and compiling this mammoth interface, you have most of the server side complete. Now, when you use Insert Object from a container, it will launch your application, obtain your class factory, create an object, and fire off calls such as <I>IPersistStorage::InitNew</I>, <I>IOleObject::SetClientSite</I>, <I>IOleObject::GetExtent</I>, <I>IOleObject::SetHostNames</I>, and <I>IOleObject::DoVerb</I>. Your window will appear ready for editing. If you have implemented <I>IOleObject::Close</I> along with a call to <I>IOleClientSite::SaveObject</I>, you see a call to <I>IPersistStorage::Save </I>when you close your application. When you activate the object from the container (with a quick double click), you see a call to <I>IPersistStorage::Load</I>, followed by the same calls to <I>IOleObject</I> as before. Your application should at this point be visible again, with the previously saved data ready for editing.</P>
<P>The container, however, has no presentation, or whatever presentation there is is not being updated as it should be when you make changes to the object. In addition, when you close your application, you probably get a prompt that says, "Document has changed; do you want to save?" If you answer "Yes," you get a File Save dialog box. Well, that's not part of the OLE user interface for embedded object servers. In fact, there's nothing else to tell you that you are working with an embedded object (as opposed to an untitled file). To solve both these problems, we have to modify the server to show a user interface that is appropriate for an embedded object and to complete the notifications we send to the container.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>3 We'll see other standard verbs in the context of in-place activation.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
