<HTML><HEAD><TITLE>Implementing IExternalConnection</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Implementing <I>IExternalConnection</I></H2><P>From the look of the preceding pages, you can probably guess that there's a lot we can talk about as far as implementation is concerned: concurrency management, custom interfaces, and custom marshaling. To ease us into those topics, however, let's first look at the simple implementation of the <I>IExternalConnection </I>interface, which we can use to demonstrate when COM adds and removes strong locks on objects, especially the effect of calling <I>CoLockObjectExternal</I>.</P>
<P>The basis for our discussion, as well as for the section about concurrency management, is the EKoala3 sample (CHAP06\EKOALA3). This is basically the EKoala1 sample from Chapter 5 with the following changes (marked with //CHAPTER6MOD and //End CHAPTER6MOD comments in the sources):</P>
<UL><LI><I>IExternalConnection </I>is implemented on and exposed from both the <I>CKoala </I>and <I>CKoalaClassFactory </I>objects, exposed through their <I>QueryInterface </I>functions, of course. Both <I>AddConnection </I>and <I>ReleaseConnection </I>display a message box with the current number of strong and weak locks.</LI><LI>The function <I>CApp::Init </I>(EKOALA3.CPP), which creates and registers the class factory with <I>CoRegisterClassObject</I>, also calls <I>CoLockObjectExternal(..., TRUE, TRUE) </I>followed by <I>CoLockObjectExternal(..., TRUE, FALSE)</I> on the class factory to show the effects of a strong lock in the class factory's <I>IExternalConnection</I>.</LI><LI>The EKoala3 server (EKOALA3.CPP) displays a main window with a menu through which you can affect incoming calls (by using the menu items Block and Delay) to demonstrate concurrency management. These menu items simply toggle the variables <I>m</I><I>_</I><I>fBlock </I>and <I>m</I><I>_</I><I>fDelay</I> in the EKoala3 application structure <I>CApp.</I></LI><LI>The EKoala3 server creates and registers a message filter using the class <I>CMessageFilter </I>(MSGFILT.CPP). This filter will reject or delay calls inside <I>IMessageFilter::HandleInComingCall </I>depending on <I>CApp::m</I><I>_</I><I>fBlock </I>and <I>CApp::m</I><I>_</I><I>fDelay.</I></LI><LI>Because the main window is visible, EKoala3 ignores WM_CLOSE messages to its main window unless the proper shutdown conditions are met. This prevents the end user from closing the server too soon.</LI><LI>The Koala object (KOALA.CPP), besides implementing <I>IExternalConnection</I>, also implements <I>IPersist</I> simply because standard marshaling exists for that interface, allowing us to demonstrate concurrency management.</LI></UL><P>For our discussion of <I>IExternalConnection</I>, only the first two changes are important. We cover the rest in the section "Implementing Concurrency Management and the Busy Dialog Box" later in this chapter.</P>
<P>To see how <I>IExternalConnection </I>works, be sure that EKoala3's registry entries are current (using its REG file—EKoala3 is not self-registering), and run the ObjectUser sample from Chapter 5. In ObjectUser, choose Use EXE Server followed by either of the Create commands. This executes the following sequence in both the client and server processes, where a number of message boxes will appear from within EKoala3:</P>
<P>ObjectUser calls <I>CoGetClassObject. </I>(COM launches server.)</P>
<P>EKoala3 calls <I>CoRegisterClassObject</I>, which registers the class factory in the object table with a strong lock. COM calls the class factory's <I>IExternalConnection::AddConnection(EXTCONN</I><I>_</I><I>STRONG)</I>.</P>
<P>EKoala3 displays a message for <I>AddConnection</I>, where the strong count is 1.</P>
<P>EKoala3 calls <I>CoLockObjectExternal(class factory, TRUE, TRUE)</I>, which generates another call to <I>AddConnection(EXTCONN</I><I>_</I><I>STRONG)</I>.</P>
<P>EKoala3 displays a message for <I>AddConnection</I>, where the strong count is 2. EKoala3 is blocked until you close the message box; however, the message box is sitting in a message loop, so <I>CoGetClassObject </I>will return the <I>IClassFactory </I>pointer to ObjectUser.</P>
<P>ObjectUser calls <I>IClassFactory::CreateInstance</I>, which creates the object in EKoala3. COM's <I>IClassFactory </I>stublet creates a new stub for the new object using <I>CoMarshalInterface.</I></P>
<P>The new stub registers the object in the object table, which generates a call to the Koala's <I>IExternalConnection::AddConne</I><I>ction(EXTCONN</I><I>_</I><I>STRONG)</I>.</P>
<P>EKoala3 displays an <I>AddConnection </I>from within the Koala object, where its strong count is now 1. Close the message box to continue.</P>
<P>EKoala3 returns from its first <I>CoLockObjectExternal</I> call (step 4) and calls <I>CoLockObjectExternal(class factory, TRUE, FALSE)</I>, which generates a call to <I>ReleaseConnection(EXTCONN</I><I>_</I><I>STRONG)</I>.</P>
<P>EKoala3 displays a message for <I>ReleaseConnection</I>, where the strong count is 1. Close the message box to continue.</P>
<P>ObjectUser calls <I>IClassFactory::Release</I>, which releases the external connection to the class factory, resulting in a call to the class factory's <I>ReleaseConnection(EXTCONN</I><I>_</I><I>STRONG)</I>.</P>
<P>EKoala3 displays a message for <I>ReleaseConnection</I>, where the strong count is 0. Close the message box to continue.</P>
<P>When you now choose Release in ObjectUser to free the object, COM will call the Koala object's <I>ReleaseConnection</I>, which will display a message that its count is 0. After you close the message box, the EKoala3 server will terminate, removing its window from the screen.</P>
<P>This whole demonstration is somewhat contrived because neither the class factory nor the Koala object really have a reason to implement <I>IExternalConnection </I>other than to demonstrate when calls are made to its member functions. The class factory's implementation of <I>AddConnection </I>is fairly representative of <I>ReleaseConnection</I> as well as of the same functions in the Koala object (which have the same implementation but a different title on the message box):</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(DWORD) CImpIExternalConnection::AddConnection<BR>    (DWORD dwConn, DWORD dwReserved)<BR>    {<BR>    DWORD       dwRet;<BR>    TCHAR       szTemp[80];<BR><BR>    if (EXTCONN_STRONG &amp; dwConn)<BR>        {<BR>        dwRet=++m_cStrong;<BR>        wsprintf(szTemp<BR>            , TEXT("AddConnection cStrong=%lu"), m_cStrong);<BR>        }<BR><BR>    if (EXTCONN_WEAK &amp; dwConn)<BR>        {<BR>        dwRet=++m_cWeak;<BR>        wsprintf(szTemp<BR>            , TEXT("ReleaseConnection cWeak=%lu"), m_cWeak);<BR>        }<BR><BR>    MessageBox(NULL, szTemp<BR>        , TEXT("EKoala3: CKoalaClassFactory::IExternalConnection")<BR>        , MB_OK);<BR><BR>    return dwRet;<BR>    }</code></pre>
<P>The implementation picks up both strong and weak locks, counting both and displaying a message for both. However, you won't see any calls with EXTCONN_WEAK when running ObjectUser and EKoala3—the code is included to illustrate the different flags in the <I>dwConn </I>argument.</P>
<P>Later in this book, we'll see some cases for which an in-process object really must implement <I>IExternalConnection</I> so it can lock its client in memory as well as tell the client when to shut down. There are, of course, other uses for this interface anytime you need to control an object's lifetime according to external connections, as described earlier in this chapter.</P></font></body></HTML>
