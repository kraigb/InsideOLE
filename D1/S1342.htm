<HTML><HEAD><TITLE>Event UI and the Events IDispatch</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Event UI and the Events <I>IDispatch</I></H3><P>Now that we have an event map, we need a way to assign actions to be stored in the map and an implementation of <I>IDispatch </I>to trigger those actions when events occur. This is the point at which a container implementer should think about the possible uses of <I>IOleControl::FreezeEvents</I>, wrapping any risky nonreentrant event handling code with calls to <I>FreezeEvents(TRUE) </I>and <I>FreezeEvents(FALSE)</I>.</P>
<P>As I said earlier, each tenant that contains a control manages an instance of <I>CEventMap.</I> When you select the Events menu item, Patron invokes the Control Events dialog box, passing a pointer to the event map owned by the currently selected tenant. This pointer shows up in the dialog procedure <I>EventsDlgProc</I>,<I> </I>found in EVENTS.CPP. The dialog is really a user interface for working with the contents of an event map, which is used initially to fill the dialog's list box. Whenever you select an event in the list, the dialog procedure calls <I>CEventMap::Get </I>to retrieve the action assigned to that event's dispID and uses that action to check the correct radio button. When you change the selected sound assignment, the dialog calls <I>CEventMap::Set </I>to store it in the map for the event's dispID. Obviously, this user interface is simplistic, but it gives you an idea of how action assignment happens.</P>
<P>Given a populated event map, a tenant's implementation of <I>IDispatch </I>has something to work with. To receive events, of course, we first have to connect this <I>IDispatch </I>to the control as an outgoing interface. This involves retrieving the IID of the event set, going through the control's <I>IConnectionPointContainer </I>to find a connection point for that IID, and then passing our event sink interface to <I>IConnectionPointContainer::Advise</I>. All this happens with the functions <I>ObjectEventsIID </I>and <I>InterfaceConnect</I>, both of which are found in CONNECT.CPP. (The <I>InterfaceDisconnect</I> function is also used for terminating the connection.) Both functions are straightforward uses of their respective interfaces.</P>
<P>A tenant's event sink is implemented by using the class <I>CDispatchEvents</I>. A tenant will create an instance of this class as necessary. (See <I>CTenant::ControlInitialize.</I>) <I>CDispatchEvents</I> is derived from <I>IDispatch</I>, so it receives interface calls directly. Now, because an events interface is defined by the control itself, we have no need to implement any of the <I>IDispatch</I> members except <I>Invoke</I>. It would be crazy for a control that already knows the type information for its own outgoing interfaces to call <I>IDispatch::GetTypeInfo</I>, which would, if implemented, only turn around and ask the object for its type information. So Patron simply returns E_NOTIMPL from this function as well as for <I>GetTypeInfoCount </I>and <I>GetIDsOfNames</I>.</P>
<P><I>Invoke </I>is where the fun happens. All we need to do is scan the event mappings held in whatever tenant is attached to the instance of <I>CDispatchEvents </I>that is called. If we find a match, we execute the action, which in our case means calling <I>MessageBeep</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CDispatchEvents::Invoke(DISPID dispIDMember, REFIID riid<BR>    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams<BR>    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)<BR>    {<BR>    HRESULT     hr;<BR>    VARIANT     varResult;<BR>    EVENTACTION iAction;<BR>    UINT        i;<BR>    PEVENTMAP   pEM;<BR><BR>    if (IID_NULL!=riid)<BR>        return ResultFromScode(E_INVALIDARG);<BR><BR>    if(NULL==pVarResult)<BR>        pVarResult=&amp;varResult;<BR><BR>    VariantInit(pVarResult);<BR>    V_VT(pVarResult)=VT_EMPTY;<BR><BR>    //Only method calls are valid.<BR>    if (!(DISPATCH_METHOD &amp; wFlags))<BR>        return ResultFromScode(DISP_E_MEMBERNOTFOUND);<BR><BR>    iAction=ACTION_NONE;<BR>    pEM=m_pTen-&gt;m_pEventMap-&gt;m_pEventMap;<BR><BR>    for (i=0; i &lt; m_pTen-&gt;m_pEventMap-&gt;m_cEvents; i++)<BR>        {<BR>        if (dispIDMember==pEM[i].id)<BR>            {<BR>            iAction=pEM[i].iAction;<BR>            break;<BR>            }<BR>        }<BR><BR>    if (ACTION_NONE==iAction)<BR>        hr=ResultFromScode(DISP_E_MEMBERNOTFOUND);<BR>    else<BR>        {<BR>        MessageBeep((UINT)iAction);<BR>        hr=NOERROR;<BR>        }<BR><BR>    return hr;<BR>    }</code></pre>
<P>I suspect that most event handling code for <I>Invoke</I> will look a lot like this. What you do after you find a matching dispID, however, and how you then execute the action will be a lot more complicated. This is especially true if you handle arguments that accompany the event, which a sophisticated container will do, as well as event return values. Such a container would be more interesting (and marketable) than a container that doesn't do anything more than beep, tweak, ding, and frazzle when you twiddle controls.</P></font></body></HTML>
