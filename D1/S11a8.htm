<HTML><HEAD><TITLE>IPersistStream and IPersistStreamInit</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IPersistStream</I> and <I>IPersistStreamInit</I></H3><P>The simplest persistence model for an object is for it to read and write its information from a single stream. A moniker is an example of such an object (as we'll see in Chapter 9), as are a variety of OLE controls. The <I>IPersi</I><I>stStream </I>interface describes the semantics of simple load and save operations, and <I>IPersistStreamInit </I>improves on this idea slightly by adding the extra <I>InitNew </I>initialization function:</P>
<P><BR></P>
<pre><code>interface IPersistStream : IPersist<BR>    {<BR>    //IUnknown members and GetClassID from IPersist<BR>    HRESULT IsDirty(void);<BR>    HRESULT Load(IStream *pStm);<BR>    HRESULT Save(IStream *pStm, BOOL fClearDirty);<BR>    HRESULT GetSizeMax(ULARGE_INTEGER *pcbSize);<BR>    };
interface IPersistStreamInit : IPersist<BR>    {<BR>    [All other functions identical to IPersistStream]<BR>    HRESULT InitNew(void);<BR>    };</code></pre>
<P>These functions behave as follows:4</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="104pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Member Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>IsDirty</P></TD><TD VALIGN="TOP"><P>Indicates whether the object considers itself dirty. If the object is dirty, the client should call <I>Save </I>before releasing the object.</P></TD></TR><TR><TD VALIGN="TOP"><P>Load</P></TD><TD VALIGN="TOP"><P>Instructs the object to load its persistent data from the current seek offset of the given stream. Clients are allowed to serialize the data from multiple objects into a single stream. The object must read its data and return, and it cannot hold the <I>IStream</I> pointer outside this function.</P></TD></TR><TR><TD VALIGN="TOP"><P>Save</P></TD><TD VALIGN="TOP"><P>Instructs the object to save its persistent data at the current seek offset of the given stream. The object must save its data and return without holding the <I>IStream</I> pointer. The <I>fClearDirty</I> argument tells the object whether it should consider itself clean after this call—a client may be making a copy of the object as opposed to saving its data permanently, and this flag distinguishes the cases.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetSizeMax</P></TD><TD VALIGN="TOP"><P>Asks the object to return the maximum amount of information it would possibly write through a call to <I>Save</I>. This allows a calling client to preset the size of a stream (<I>IStream::SetSize</I>), especially if it is saving the data of multiple objects in the same stream or is otherwise planning to provide an <I>IStream</I> that cannot enlarge itself automatically. For this reason, the implementation of <I>GetSizeMax</I> should return the maximum upper boundary of the object's storage requirements.</P></TD></TR><TR><TD VALIGN="TOP"><P>InitNew</P></TD><TD VALIGN="TOP"><P>Initializes the object after creation, giving one object </P></TD></TR><TR><TD VALIGN="TOP"><P>(IPersistStreamInit)</P></TD><TD VALIGN="TOP"><P>an opportunity to set its initial state.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><I>IPersistStream </I>and <I>IPersistStreamInit </I>can both act as initialization interfaces. The <I>Load </I>function of either interface and the <I>InitNew </I>function of <I>IPersistStreamInit</I> are the specific initialization functions. <I>IPersistStreamInit </I>was specially created to provide a stream-based object with a way to know that it has been newly created and has no persistent data as yet, a requirement for certain OLE controls.</P>
<P>It is important to understand the locality of <I>Load </I>and <I>Save </I>calls. First, the object cannot hold a copy of the <I>IStream </I>pointer outside the scope of these functions, and second, the object is allowed to work only with the stream between the current seek offset on entry to the function and that offset plus whatever the object returns from <I>GetSizeMax. </I>In short, these rules mean that the calling client has ultimate control over which object's data is stored in what parts of the stream. As mentioned in Chapter 7, a stream in a compound file is allocated on a 512-byte granularity, so clients generally try to utilize all those bytes if they can. The locality of <I>Load </I>and <I>Save </I>enables clients to do this even with multiple stream-based objects, each of which may need only a few dozen bytes of the overall stream. These rules also work well with functions such as <I>ReadClassStm </I>and <I>WriteClassStm</I>, so a client can associate CLSIDs for each object's data, anywhere in the stream. In addition, the client can write its own CLSID at the beginning of the stream, identifying itself as the code that understands the layout of information in the rest of the stream.</P>
<P>OLE provides two API functions that wrap these various sequences. <I>OleSaveToStream</I> calls <I>WriteClassStm</I> followed by <I>IPersistStream::Save</I> on a given object. <I>OleLoadFromStream</I> will call <I>ReadClassStm</I> on a given stream, instantiate an object of that class with <I>CoCreateInstance</I>, then have that new object initialize itself through <I>IPersistStream::Load</I>. A client can use both these API functions to save and load sequential objects in a single stream.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>4 While <I>IPersistStreamInit</I> is not derived directly from <I>IPersistStream </I>it has exactly the same member function signatures as the members of <I>IPersistStream</I>. Therefore <I>IPersistStreamInit </I>is polymorphic with <I>IPersistStream</I>. A pointer to <I>IPersistStreamInit </I>can be used as a pointer to <I>IPersistStream</I>.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
