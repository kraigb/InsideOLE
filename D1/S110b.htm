<HTML><HEAD><TITLE>The EnumRect Sample</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The EnumRect Sample</H3><P>As additional proof that OLE has a language-independent binary standard, the EnumRect sample (CHAP02\ENUMRECT) implements identical enumerators for RECT structures in C and C++ but uses both of them from exactly the same C++ client code. The enumerators themselves implement an interface named <I>IEnumRECT</I>,<I> </I>which is defined for this sample and is not a standard OLE interface. The sample file IENUM.H contains the C and C++ definitions, using the STDMETHOD macros that expand to the appropriate calling conversion:</P>
<P><BR></P>
<pre><code>//C++ definition of an interface<BR>#ifdef __cplusplus<BR><BR>typedef struct IEnumRECT IEnumRECT;<BR>typedef IEnumRECT *PENUMRECT;<BR><BR>struct IEnumRECT<BR>    {<BR>    STDMETHOD(QueryInterface)(REFIID, PPVOID)=0;<BR>    STDMETHOD_(ULONG,AddRef)(void)=0;<BR>    STDMETHOD_(ULONG,Release)(void)=0;<BR>    STDMETHOD(Next)(DWORD, LPRECT, LPDWORD)=0;<BR>    STDMETHOD(Skip)(DWORD)=0;<BR>    STDMETHOD(Reset)(void)=0;<BR>    STDMETHOD(Clone)(PENUMRECT *)=0;<BR>    };<BR><BR>#else   //!__cplusplus<BR><BR>typedef struct<BR>    {<BR>    struct IEnumRECTVtbl FAR *lpVtbl;<BR>    } IEnumRECT, *PENUMRECT;<BR><BR>typedef struct IEnumRECTVtbl IEnumRECTVtbl;<BR><BR>struct IEnumRECTVtbl<BR>    {<BR>    STDMETHOD(QueryInterface)(PENUMRECT, REFIID, PPVOID);<BR>    STDMETHOD_(ULONG, AddRef)(PENUMRECT);<BR>    STDMETHOD_(ULONG, Release)(PENUMRECT);<BR>    STDMETHOD(Next)(PENUMRECT, DWORD, LPRECT, LPDWORD);<BR>    STDMETHOD(Skip)(PENUMRECT, DWORD);<BR>    STDMETHOD(Reset)(PENUMRECT);<BR>    STDMETHOD(Clone)(PENUMRECT, PENUMRECT *);<BR>    };<BR><BR>#endif  //!__cplusplus</code></pre>
<P>For convenience, we'll call the object that implements this interface a <I>RectEnumerator</I>. The part of EnumRect that is the client displays a small window with a menu that allows you to create either a C or a C++ object. There are two API-type functions that EnumRect calls to create the objects: <I>CreateRectEnumeratorC </I>and <I>CreateRectEnumeratorCPP</I>. These are typical functions that create an object and return an interface pointer that must later be released, as usual. Regardless of which object you create, you can use the other menu items in EnumRect to call the various <I>IEnumRECT </I>member functions. EnumRect displays only the mundane results of the function (success or failure) in its client area, so it's most enlightening to run this sample in a debugger to step through the code and watch what happens when calls are made.</P>
<P>Note that IID_IEnumRECT is defined in INC\BOOKGUID.H, which is pulled in through EnumRect's inclusion of INC\INOLE.H. The ENUMRECT.CPP file defines the INITGUIDS symbol to include this IID in the compilation.</P></font></body></HTML>
