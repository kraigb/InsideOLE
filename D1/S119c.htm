<HTML><HEAD><TITLE>Associating Code with Storage</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Associating Code with Storage</H2><P>Being the experienced Windows user that you are, you know that Windows allows you to associate an application with a file so that when you double-click the filename in the system shell, you automatically launch the associated application and it opens the file. OLE, in fact, takes file association a little further, allowing you to assign to a file the CLSID of some code that can work with that file. In addition, OLE provides essentially the same association capabilities for storage and stream elements within a hierarchy (including the root storage). This again associates some CLSID with those elements to identify the code that can read and write the data.</P>
<P>When some client (or the system shell) wants to run code that knows how to work with the information in that element, it can take the CLSID and call <I>CoCreateInstance. </I>The interfaces this caller might request are the topic of Chapter 8. They will be from among <I>IPersistFile</I>, <I>IPersistStorage</I>, <I>IPersistStrea</I><I>m</I>, and <I>IPersistStreamInit. </I>Through these interfaces, the client can make the object aware of the filename, storage element, or stream element in which the data resides.</P>
<P>To this end, OLE provides a few API functions to assign and retrieve the CLSID associated with some type of storage:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>API Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>WriteClassStg</P></TD><TD VALIGN="TOP"><P>Serializes a CLSID into an OLE-controlled stream within a given storage, associating that CLSID with the storage.<I> </I>This API calls <I>IStorage::SetClass</I>, which creates a stream named "\001CompObj", in which it writes the CLSID.<I> </I>Calling <I>WriteClassStg </I>for a root storage associates the entire compound file with that CLSID.</P></TD></TR><TR><TD VALIGN="TOP"><P>ReadClassStg</P></TD><TD VALIGN="TOP"><P>Reads the CLSID from the stream created through <I>WriteClassStg</I>.<I> </I>This API calls <I>IStorage::Stat</I> and returns the <I>clsid</I> field of the STATSTG structure.</P></TD></TR><TR><TD VALIGN="TOP"><P>WriteClassStm</P></TD><TD VALIGN="TOP"><P>Serializes a CLSID into a stream starting at the current seek offset.<I> </I>By convention, a CLSID must appear before any application or component-specific data within a stream.*</P></TD></TR><TR><TD VALIGN="TOP"><P>ReadClassStm</P></TD><TD VALIGN="TOP"><P>Reads a CLSID from the current seek offset in a stream, expecting the format written by <I>WriteClassStm</I>.<I> </I>Again, by convention the CLSID appears before any custom information does.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetClassFile</P></TD><TD VALIGN="TOP"><P>Returns a CLSID associated with a particular filename. (See the discussion that follows.)</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>*  As we'll see in Chapter 8, a client can have multiple components write their persistent data into the same stream, writing a CLSID before each object's private data. The first CLSID in the entire stream should identify the client that understands the remaining stream contents.</P>
<P>In addition, OLE offers two other API functions for writing and reading format information into a storage object.<I> </I>This information consists of a clipboard format value (a CF_* value or a registered one) and a "user type," which is a user-readable string describing the data type as the end user understands it—for example, "Rich Text". Such information is quite useful for servers that want to emulate others because it describes the internal format of information in streams. We'll see where these functions become important in the samples of later chapters.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="126pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><I>WriteFmtUserTypeStg</I></P></TD><TD VALIGN="TOP"><P>Serializes a clipboard format and a user-readable name describing the format of the contents of the storage. If the clipboard format is a registered one, this function stores the registered string instead of the value.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>Read</I><I>FmtUserTypeStg</I></P></TD><TD VALIGN="TOP"><P>Reads the clipboard format and the string previously written by <I>WriteFmtUserTypeStg</I>. If the clipboard format is a string, it registers the format and returns the value.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The matter of associating a CLSID with a storage or stream object is entirely handled through <I>[Read </I><I>|</I><I> Write]Class[Stg </I><I>|</I><I> Stm]</I>.<I> </I>Associating a CLSID with a file presents a few additional concerns.<I> </I>First of all, if the file is a compound file, <I>[Read </I><I>|</I><I> Write]ClassStg</I> apply perfectly well to the root storage in that file, as they do to any other storage element.<I> </I>But what if the file is not a compound file?<I> </I>OLE still allows you to create an association in two other ways, using additional registry entries.</P>
<P>The first method is to create a registry entry for the file's extension of the form:</P>
<P><BR></P>
<pre><code>\<BR>    .&lt;ext&gt; = &lt;ProgID&gt;<BR><BR>    &lt;ProgID&gt; = &lt;Name of class&gt;<BR>        CLSID = {&lt;CLSID in hex&gt;}<BR><BR>    CLSID<BR>        {&lt;CLSID in hex&gt;}<BR>            [Inproc | Local]Server32 = &lt;path to server module&gt;</code></pre>
<P>The first entry in this list is a file extension with a period. (The string ".doc" is an example.) The value of this key is the ProgID under which OLE can locate the CLSID associated with this file type. The .&lt;<I>ext</I>&gt; entry is the same one that Windows itself uses to associate extensions with applications. What differs with OLE is the entries under the &lt;<I>ProgID</I>&gt; entry. Whereas Windows stores varied information under a shell subkey, OLE needs only the CLSID entry.</P>
<P>The second method of association is a little more involved. OLE defines a root registry key named <I>FileType</I>, under which appear entries in the following form:</P>
<P><BR></P>
<pre><code>\<BR>    FileType<BR>        {&lt;CLSID in hex&gt;}<BR>            &lt;type id&gt; = &lt;offset&gt;,&lt;cb&gt;,&lt;mask&gt;,&lt;value&gt;<BR>            &lt;type id&gt; = &lt;offset&gt;,&lt;cb&gt;,&lt;mask&gt;,&lt;value&gt;<BR>            &lt;type id&gt; = &lt;offset&gt;,&lt;cb&gt;,&lt;mask&gt;,&lt;value&gt;<BR>            §</code></pre>
<P>Each &lt;<I>type id</I>&gt; key, which is some integer unique for the CLSID, describes a byte pattern <I>&lt;value&gt; </I>that will match &lt;<I>cb</I>&gt; bytes in an associated file found at &lt;<I>offset</I>&gt; (from the beginning of that file) when a bitwise AND operation has been performed on those file bytes with &lt;<I>mask</I>&gt; (which may be omitted to indicate that no mask is necessary). Here are the patterns for Microsoft Word 6.0 as an example:</P>
<P><BR></P>
<pre><code>\<BR>    FileType<BR>        {00020900-0000-0000-C000-000000000046}<BR>            0 = 0,2,FFFF,DBA5<BR>            1 = 0,2,FFFF,9BA5</code></pre>
<P>The <I>GetClassFile </I>function will use these byte patterns in their registered order if the given file is not a compound file with a CLSID in it already. If <I>GetClassFile </I>cannot match these byte patterns, it will attempt to associate the file by extension; otherwise, it fails with MK_E_INVALIDEXTENSION.</P></font></body></HTML>
