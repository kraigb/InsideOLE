<HTML><HEAD><TITLE>The ITypeInfo Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The <I>ITypeInfo </I>Interface</H3><P>As you can probably expect from the plethora of structures you can get from <I>ITypeInfo</I>, shown in Table 3-7, there are a good number of member functions, shown in Table 3-9. As with <I>ITypeLib</I>, each of these functions relates to specific parts of an ODL file, as illustrated in Figure 3-5 on page 182.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="129pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Member Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>GetContainingTypeLib</P></TD><TD VALIGN="TOP"><P>Retrieves the <I>ITypeLib</I> pointer for the library that contains this type information as well as the index of this type information in the library.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetDocumentation</P></TD><TD VALIGN="TOP"><P>Given an index, allocates and returns a BSTR with the item name and allocates and returns BSTR copies of the <I>helpstring</I>, <I>helpfile</I>, and <I>helpcontext</I> attributes of the item. The caller must free the BSTRs with <I>SysFreeString</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetFuncDesc</P></TD><TD VALIGN="TOP"><P>Allocates, fills, and returns the FUNCDESC structure for a method with a given index in an interface. This must be freed with <I>ReleaseFuncDesc</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>ReleaseFuncDesc</P></TD><TD VALIGN="TOP"><P>Frees the FUNCDESC from <I>GetFuncDesc</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetNames</P></TD><TD VALIGN="TOP"><P>Retrieves the names of properties, types, variables, methods, method arguments, and so forth in BSTR variables, which the caller frees with <I>SysFreeString</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetIDsOfNames</P></TD><TD VALIGN="TOP"><P>Maps text names of a dispinterface to dispIDs and argument IDs.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetRefTypeInfo</P></TD><TD VALIGN="TOP"><P>Returns the <I>ITypeInfo</I> of a given HREFTYPE.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetTypeAttr</P></TD><TD VALIGN="TOP"><P>Allocates, fills, and returns the TYPEATTR structure for this <I>ITypeInfo</I>. This must be freed with <I>ReleaseTypeAttr</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>ReleaseTypeAttr</P></TD><TD VALIGN="TOP"><P>Frees the TYPEATTR from <I>GetTypeAttr</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetRefTypeOfImplType</P></TD><TD VALIGN="TOP"><P>Returns the HREFTYPE for an <I>interface</I> or <I>dispinterface</I> in a <I>coclass</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetImplTypeFlags</P></TD><TD VALIGN="TOP"><P>Returns the IMPLTYPE flags of an <I>interface</I> or <I>dispinterface</I> item if it's in a <I>coclass</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetVarDesc</P></TD><TD VALIGN="TOP"><P>Allocates, fills, and returns a VARDESC structure describing the specified variable. This must be freed with <I>ReleaseVarDesc</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>ReleaseVarDesc</P></TD><TD VALIGN="TOP"><P>Frees the VARDESC from <I>GetVarDesc</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>Invoke</P></TD><TD VALIGN="TOP"><P>Invokes a method or accesses a property of an object that implements the interface described by this <I>ITypeInfo</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>CreateInstance</P></TD><TD VALIGN="TOP"><P>Attempts to create a new instance of a <I>c</I><I>oclass</I> using <I>CoCreateInstance</I> for the <I>uuid</I> attribute, using the process described in Chapter 5. </P></TD></TR><TR><TD VALIGN="TOP"><P>AddressOfMember</P></TD><TD VALIGN="TOP"><P>Retrieves the addresses of static functions or variables defined in a DLL as well as the INVOKEKIND flag.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetDllEntry</P></TD><TD VALIGN="TOP"><P>Retrieves the DLL module name and function name (or ordinal) of an exported DLL function as well as its INVOKEKIND flag.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetMops</P></TD><TD VALIGN="TOP"><P>Retrieves marshaling information for an argument.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetTypeComp</P></TD><TD VALIGN="TOP"><P>Returns the <I>ITypeComp</I> interface for this <I>ITypeInfo</I>. See "The <I>ITypeComp</I> Interface" later in this chapter.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 3-9.</B></P>
<P><B>The <I>ITypeInfo</I> interface.</B></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>Alternative <I>ITypeLib</I> and <I>ITypeInfo</I> Implementations</H4><P>There is nothing sacred about OLE's type information services that provide the standard implementations of type library and type information objects. You are perfectly free to implement your own objects with these interfaces that sit on top of a type library. Such custom implementations might be used to extend the available information for the purposes of a particular client. For example, if you want to extend the properties available on an object with a set of client-supplied properties and to use type information consistently throughout the controller, you can implement wrapper interfaces that filter out the specific client types before passing the calls on to OLE's standard implementations.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>With <I>ITypeLib</I> and <I>ITypeInfo</I>, you can see how a client could load a type library using registry information, obtain an <I>ITypeLib</I> pointer, and then call <I>ITypeLib::GetTypeInfoOfGuid</I> to retrieve an <I>ITypeInfo</I> pointer for a <I>coclass.</I> Through <I>ITypeInfo::GetRefTypeOfImplType</I>, you then obtain the HREFTYPE for each interface or dispinterface in that class and can pass that HREFTYPE to <I>ITypeInfo::GetRefTypeInfo</I> to retrieve the <I>ITypeInfo</I> pointer for each particular interface. From there you can call, with this new pointer, <I>ITypeInfo::GetTypeAttr</I> to retrieve the TYPEATTR structure, which contains the interface IID. This is how you retrieve the IIDs of all of an object's incoming and outgoing interfaces directly from type information. This does involve a number of iterations and is a little convoluted, I must admit, but it is the only way to retrieve this information without otherwise instantiating the object itself.</P>
<P>    <img src="bob5.gif"></P>
<P><B>Figure 3-5.</B></P>
<P><B>How <I>ITypeInfo</I> members relate to ODL entries. Although not drawn in this figure (to keep it readable), <I>AddressOfMember</I> and <I>GetDllEntry</I> work with <I>module</I> entries and the <I>appobject</I> coclass, and <I>GetMops</I> works with structures as well as arguments.</B></P></font></body></HTML>
