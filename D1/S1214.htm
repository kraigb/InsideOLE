<HTML><HEAD><TITLE>Implement a Drop Target Object with IDropTarget</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement a Drop Target Object with <I>IDropTarget</I></H3><P>The next step for a target implementation is to implement the drop target object. In Cosmo, this is <I>CDropTarget</I>,<I> </I>found in COSMO.H and DROPTGT.CPP. This object maintains a backpointer to the <I>CCosmoDoc</I> object because this object will be associated with the document window. In addition, <I>CDropTarget</I> maintains an <I>IDataObject </I>pointer, specifically the one it receives in <I>IDropTarget::DragEnter</I>. This lets Cosmo examine the data object during calls to <I>DragOver</I>, which do not include a data object as an argument. Thus, we need to remember the data object in <I>DragEnter.</I></P>
<H4><A NAME="sec0"></A><I>IDropTarget::DragEnter</I></H4><P>This function is called whenever the mouse moves into a registered target window. It receives the following arguments:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Argument</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>pIDataSource</P></TD><TD VALIGN="TOP"><P>(<I>IDataObject</I> *): A pointer to the source's data object (marshaled as necessary).</P></TD></TR><TR><TD VALIGN="TOP"><P>grfKeyState</P></TD><TD VALIGN="TOP"><P>(DWORD):  MK_* flags describing the current state of the Ctrl, Alt, and Shift keys as well as each mouse button (as with <I>IDropSource::QueryContinueDrag</I>).</P></TD></TR><TR><TD VALIGN="TOP"><P>pt</P></TD><TD VALIGN="TOP"><P>(POINTL): The current location of the mouse, in screen coordinates.</P></TD></TR><TR><TD VALIGN="TOP"><P>pdwEffect</P></TD><TD VALIGN="TOP"><P>(DWORD *): A pointer to a DWORD containing the allowable effects as specified by the source. On output, the target stores the effect a drop would have with the mouse at the current position in <I>pt.</I></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>With these arguments, you implement <I>DragEnter</I> as follows:</P>
<P>Call <I>pIDataSource-&gt;EnumFormatEtc</I> and <I>pIDataSource-&gt;QueryGetData</I> to determine whether the source has usable data, generally the same data that the target would be able to paste from the clipboard. If no usable data is found, store DROPEFFECT_NONE in *<I>pdwEffect </I>and return NOERROR.</P>
<P>Determine whether <I>pt </I>is a suitable drop point. If not, store DROPEFFECT_NONE in *<I>pdwEffect</I> and return NOERROR.</P>
<P>If <I>pt</I> is a suitable drop point, determine what effect will occur and store that flag in *<I>pdwEffect</I>.</P>
<P>If you want to access <I>pIDataSource</I> in <I>DragOver</I>, save the pointer and call its <I>AddRef.</I></P>
<P>Provide user feedback and return NOERROR.</P>
<P>You'll notice that <I>DragEnter </I>generally returns NOERROR, even for unusable data. OLE will always call <I>DragEnter </I>when the mouse moves into your window and will continue to call <I>DragOver </I>and eventually <I>DragLeave</I>,<I> </I>even if you continually return DROPEFFECT_NONE in *<I>pdwEffect</I>. Saying "no drop" doesn't prevent additional <I>DragOver</I> calls. Here is Cosmo's <I>DragEnter</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CDropTarget::DragEnter(LPDATAOBJECT pIDataSource<BR>    , DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)<BR>    {<BR>    HWND        hWnd;<BR><BR>    m_pIDataObject=NULL;<BR><BR>    if (!m_pDoc-&gt;FQueryPasteFromData(pIDataSource))<BR>        {<BR>        *pdwEffect=DROPEFFECT_NONE;<BR>        return NOERROR;<BR>        }<BR><BR>    *pdwEffect=DROPEFFECT_MOVE;<BR><BR>    if (grfKeyState &amp; MK_CONTROL)<BR>        *pdwEffect=DROPEFFECT_COPY;<BR><BR>    m_pIDataObject=pIDataSource;<BR>    m_pIDataObject-&gt;AddRef();<BR><BR>    hWnd=m_pDoc-&gt;Window();<BR>    BringWindowToTop(hWnd);<BR>    UpdateWindow(hWnd);<BR>    m_pDoc-&gt;DropSelectTargetWindow();<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>In Chapter 12, we gave Cosmo a suitable "query paste from data" function:  <I>CCosmoDoc::FQueryPasteFromData. </I>Again, a function such as this is very useful and centralizes clipboard, drag-and-drop, and compound document data transfers. We can see that step 1 in the preceding code calls this function and returns DROPEFFECT_NONE if it fails. If there is usable data, Cosmo continues at step 3 by storing DROPEFFECT_MOVE or DROPEFFECT_COPY, depending on the state of the Ctrl key. If Cosmo supported linking (which it does not), it would check the state of the Shift and Ctrl keys and store DROPEFFECT_LINK if the Shift key were pressed.</P>
<P>But why did we skip step 2?  Well, Cosmo accepts a drop anywhere in its document window—including the Polyline window—so it's not picky about the drop point. Also note that <I>DoDragDrop </I>calls the Windows API function <I>WindowFromPoint </I>to find the drop target. If the window is a child window but is not registered for drag and drop, OLE checks its parent window to see whether the parent is a target. If not, it will continue up the chain, checking each parent window.</P>
<P>That leaves us with step 4, in which we simply store the <I>pIDataSource </I>pointer in the drop target object (calling its <I>AddRef </I>like a good citizen), and then step 5, in which we give some visual feedback about what might happen if a drop occurred. We designed <I>CCosmoDoc::DropSelec</I><I>tTargetWindow </I>for this purpose in Cosmo, so we call that function here.</P>
<P>Before this, however, the calls to <I>BringWindowToTop </I>and <I>UpdateWindow </I>ensure that the target window is fully visible. Using <I>BringWindowToTop</I> has a nice effect: when you drag across document windows, Cosmo will bring the current target window to the foreground. This means that the end user can effectively switch document windows during this operation using only the mouse. Of course, if the intended target window is not visible, none of this helps—the user has to rearrange windows before the operation.</P>
<H4><A NAME="sec1"></A><I>IDropTarget::DragOver</I></H4><P><I>DoDragDrop </I>calls this function frequently:  whenever the mouse moves, a key or button changes state, or a pulse timer elapses. Again, the "pulsing" is necessary to support scrolling in a target document, as we'll see later in Patron.</P>
<P><I>DragOver</I> should be optimized to avoid costly operations, keeping the user interface crisp instead of sluggish. In general, you should perform hit-testing on the mouse location, determine a new effect flag, and update your user feedback similar to the way you did in <I>DragEnter. </I>OLE passes only three arguments to this function—<I>grfKeyState</I>, <I>pt</I>, and <I>pdwEffect</I>—with the same types and meanings as for <I>DragEnter</I>.<I> </I>(Again, <I>pt</I> is in screen coordinates.) If you need to access the source's data object, perhaps to check a format, you must save that pointer in <I>DragEnter</I>. If you only need to check a format again, you can just as well check it with <I>DragEnter </I>and save a flag, avoiding another call to <I>IDataObj</I><I>ect::QueryGetData</I>. If you need a rendering of the data for any reason, ask for it in <I>DragEnter</I>; doing so in <I>DragOver </I>will perform a lot of unnecessary work.</P>
<P>In any case, there are three steps to perform in <I>DragOver</I>:</P>
<P>Check whether <I>pt </I>is an allowable drop point given the effect defined by <I>grfKeyState</I> and the availability of data from the source. If no drop is allowed, return DROPEFFECT_NONE and NOERROR.</P>
<P>If a drop is allowed, determine the effect as in <I>DragEnter </I>and store it in *<I>pdwEffect. </I>If you allow scrolling, check those conditions and add DROPEFFECT_SCROLL to the effects.</P>
<P>Update your user feedback (if any) appropriate for the effect and return NOERROR.</P>
<P>Cosmo's implementation is quite simple:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CDropTarget::DragOver(DWORD grfKeyState, POINTL pt<BR>    , LPDWORD pdwEffect)<BR>    {<BR>    if (NULL==m_pIDataObject)<BR>        {<BR>        *pdwEffect=DROPEFFECT_NONE;<BR>        return NOERROR;<BR>        }<BR><BR>    //We can always drop; return effect flags based on keys.<BR>    *pdwEffect=DROPEFFECT_MOVE;<BR><BR>    if (grfKeyState &amp; MK_CONTROL)<BR>        *pdwEffect=DROPEFFECT_COPY;<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>If Cosmo returned DROPEFFECT_NONE in <I>DragEnter</I>, the <I>IDataObject </I>pointer we might have saved is NULL. If that pointer is NULL, we know that no usable formats were in the data object, so we immediately return from <I>DragOver </I>with DROPEFFECT_NONE again. This is a fast means to check whether there is usable data. Otherwise, Cosmo simply updates the effect flags and returns. And because we don't care where the mouse is inside the document window, we leave the inverted border created in <I>DragEnter </I>where it stands, doing nothing else in <I>DragOver</I>.</P>
<H4><A NAME="sec2"></A><I>IDropTarget::DragLeave</I></H4><P>All good things come to an end; so too with drag and drop, in which a call to <I>DragLeave </I>tells a target the disappointing news that no drop will occur in it this time. The target must then clean up whatever state it has from <I>DragEnter </I>and <I>DragOver. DragLeave </I>itself takes no arguments, so you need to do only three things:</P>
<P>Remove any UI feedback in the target window.</P>
<P>Release any <I>IDataObject</I> held from <I>DragEnter</I>.</P>
<P>Return NOERROR.</P>
<P>Cosmo performs step 1 by calling <I>CCosmoDoc::DropSelectTargetWindow</I> again. This reverses the inversion done in <I>DragEnter</I>,<I> </I>leaving no visual feedback in the document. Cosmo then calls <I>Release </I>on the data object pointer and returns. The implementation of this is straightforward:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CDropTarget::DragLeave(void)<BR>    {<BR>    if (NULL!=m_pIDataObject)<BR>        {<BR>        m_pDoc-&gt;DropSelectTargetWindow();<BR>        ReleaseInterface(m_pIDataObject));<BR>        }<BR><BR>    return NOERROR;<BR>    }</code></pre>
<H4><A NAME="sec3"></A><I>IDropTarget::Drop</I></H4><P>This must be the target's lucky day!  It's been chosen to accept a drop when <I>IDropTarget::Drop</I> is called, and for the most part, all it needs to do is perform a paste and then clean up its state, as occurs in <I>DragLeave</I>. <I>Drop</I> is called with the same arguments as <I>DragEnter. </I>(Once again, <I>pt</I> is in screen coordinates.)  The value of <I>pIDataSource</I> is the same as in <I>DragEnter</I>, but the values of the other parameters will likely change (unless the mouse did not move). Following are the steps that the target should perform in <I>Drop</I>:</P>
<P>Remove any end-user feedback in the target window and release any held pointer, as described for <I>DragLeave</I>. (You can simply call <I>DragLeave</I> if appropriate.)</P>
<P>Validate that a drop can occur at the location of the mouse (<I>pt</I>) and whether the source has the right data. If not, store DROPEFFECT_NONE in *<I>pdwEffect </I>but then return E_FAIL from the function.</P>
<P>Perform a Paste operation from the data object, returning DROPEFFECT_NONE and E_FAIL on error. Otherwise, store the effect flag according to <I>grfKeyState</I> and return NOERROR.</P>
<P>Cosmo's code is once again simple, exploiting the existing <I>CCosmoDoc::PasteFromData </I>to perform most of step 3:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CDropTarget::Drop(LPDATAOBJECT pIDataSource<BR>    , DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)<BR>    {<BR>    BOOL        fRet=TRUE;<BR><BR>    *pdwEffect=DROPEFFECT_NONE;<BR><BR>    if (NULL==m_pIDataObject)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    DragLeave();<BR>    <BR>    //No point in drag and drop to oneself (for Cosmo, at least)<BR>    if (m_pDoc-&gt;m_fDragSource)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    fRet=m_pDoc-&gt;PasteFromData(pIDataSource);<BR><BR>    if (!fRet)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    *pdwEffect=DROPEFFECT_MOVE;<BR><BR>    if (grfKeyState &amp; MK_CONTROL)<BR>        *pdwEffect=DROPEFFECT_COPY;<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>Cosmo's implementation of <I>Drop</I> also has one other oddity—checking the document's <I>m</I><I>_</I><I>fDragSource </I>flag. If Cosmo detects that the end user dropped the data into the same window that it came from, there's nothing to do. We can simply return a failure code. For an application such as Patron, dragging data in the same document is useful for moving the data within a page—but Cosmo has no need for such a feature.</P></font></body></HTML>
