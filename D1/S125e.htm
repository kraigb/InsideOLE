<HTML><HEAD><TITLE>Summary</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Summary</H2><P>OLE Automation is a technology through which a component or an entire application can expose the functionality (methods) and content (individual properties) of any automation objects within it in a late-bound, programmatic manner. Late binding means that method and property names are resolved into dispatch identifiers (dispIDs) at run time and then passed to a function that will invoke the appropriate code for any given dispID. This allows interpreted macro-programming languages and other tools running a script of some sort to access and manipulate objects without having compile-time knowledge of vtable layouts. Such tools, called <I>automation controllers,</I> can create objects from any components or applications as necessary, thus enabling end users or developers to write cross-application macros, a longtime user demand.</P>
<P>The core of automation is the dispatch interface, or dispinterface for short, which is a specific implementation of the interface named <I>IDispatch</I>, which responds only to certain dispIDs. Through <I>IDispatch</I>,<I> </I>a controller can retrieve the object's type information for the dispinterface, map names to dispIDs, and invoke methods and properties. The latter happens through <I>IDispatch::Invoke</I>. This function has a fixed compile-time signature by which it can accept any number of arguments for the invocation of a method call, including named and optional arguments. In return, <I>Invoke </I>can provide any type of return value as well as rich error information. This chapter explores the nuances of the various arguments of <I>IDispatch::Invoke </I>and describes how it works internally.</P>
<P>Arguments and return values handled through <I>Invoke </I>use the types VARIANTARG and VARIANT. Both types, which are structurally identical, contain a type identifier (VARTYPE) and a value appropriate to that type, whether it is a pointer, an integer, a string pointer, a date or currency value, and so on. The value is stored in one field of a large union of types within the VARIANT. Two of these types are used frequently in OLE Automation—the BSTR (Basic string) and the Safe Array (an array that carries its bounds with it). OLE provides services to coerce a VARIANT of one type into another, compatible, type if the conversion is at all possible.</P>
<P>An important class of automation object is called a <I>collection,</I> which is a grouping of other objects. Collections implement specific methods and properties to navigate their contained elements, including the interface <I>IEnumVARIANT</I>, which enumerates those elements.</P>
<P>Making a method call or accessing a property through <I>IDispatch::Invoke </I>is a process with a good deal of overhead, which results in much slower performance than the same functionality expressed through a vtable interface. For this reason, OLE Automation defines what is called a <I>dual in</I><I>terface,</I> which is a custom vtable interface that derives from <I>IDispatch</I>. A dual interface allows a client that can perform vtable binding to call functions in the interface efficiently without losing compatibility with automation controllers that can call only <I>IDispatch </I>members. A dual interface comes with the added bene-fit that OLE Automation provides its own marshaling for both <I>IDispatch </I>and custom portions of the interface as long as the interface uses only a limited number of automation-compatible types.</P>
<P>This chapter also examines five different techniques for implementing an automation object: a straight manual implementation of <I>IDispatch</I>; an implementation using the service of <I>ITypeInfo</I>; one using error objects for rich error reporting; one with a dual interface; and one that employs OLE's standard dispatch object, eliminating the need to have any of your own explicit <I>IDispatch </I>entry points.</P>
<P>This is all topped off with a discussion of fully automated applications, including a review of a few design principles, standards, and guidelines for methods and properties. These are applied in a demonstration of how to automate Chapter 12's version of the Cosmo sample.</P></font></body></HTML>
