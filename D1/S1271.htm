<HTML><HEAD><TITLE>Summary</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Summary</H2><P>An OLE Automation controller is simply a client of automation objects—that is, a client that uses an object's services by calling the member functions of <I>IDispatch</I>, particularly <I>IDispatch::Invoke</I>. A general purpose controller, which might be a development tool such as Microsoft Visual Basic, will have some sort of integrated programming language. Different syntax structures of this programming language each correspond to a method call, a property get, or a property put operation, where method calls might include optional and named arguments as well. The general syntax structures work in conjunction with an object's type information, which the controller can use to ensure that methods and properties exist and that the types involved are compatible with those types specified in type information.</P>
<P>A general controller such as this also needs syntax structures for object creation and object destruction. Creation of objects can include user interfaces for browsing available objects as well as their type information. A controller can, of course, load an object's type information without having to instantiate the object itself.</P>
<P>A controller, or any client of <I>IDispatch</I>,<I> </I>does not necessarily have to involve a complex programming environment. Any code that calls <I>IDispatch </I>members in any capacity is a simple controller. For example, OLE controls typically use dispinterfaces for their event sets, so in order to fire events, such controls have to know how to call <I>IDispatch::Invoke</I>. This chapter examines how to call <I>Invoke </I>from a client's perspective for the various operations: property put, property get, and method calls with fixed, optional, and named arguments. All these constructs are demonstrated using a sample named AutoCli, which works with any of the Beeper objects from Chapter 14. AutoCli also demonstrates a controller's handling of exceptions, displaying the necessary information to the user and invoking the object's help file if necessary.</P>
<P>This chapter also spends a few pages examining the relationship between an automation object and a controller, which raises a number of important questions to do with design. How much should an object do? How much work can a controller do? Is a feature best implemented as an object service or as part of a controller? Pondering such questions can lead to valuable insights and more robust designs, creating an optimal partnership of controllers and objects.</P></font></body></HTML>
