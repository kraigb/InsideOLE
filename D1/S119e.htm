<HTML><HEAD><TITLE>Simple Storage: Cosmo</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Simple Storage: Cosmo</H3><P>Cosmo (CHAP07\COSMO) requires only a few changes to use compound files instead of traditional files as the Chapter 1 version does (or as does Chapter 5's Component Cosmo). The changes are simple. Instead of opening a regular file with which to read or write data, we open a root storage. Instead of using file I/O functions such as <I>_</I><I>lread</I> and <I>_</I><I>lwrite</I>, we obtain a stream pointer and use <I>IStream</I> member functions. These changes affect the functions <I>CCosmoDoc::Load </I>and <I>CCosmoDoc::Save </I>in DOCUMENT.CPP as well as new functions we add to the Polyline object, <I>CPolyline::ReadFromStorage </I>and <I>CPolyline::WriteToStorage</I> (POLYLINE.CPP). These latter functions are similar to the existing <I>CPolyline </I>members of <I>ReadFromFile </I>and <I>WriteToFile</I>.</P>
<P>To write a simple file with a single stream, Cosmo makes the following calls, in which steps 1, 2, and 6 occur in <I>CCosmoDoc::Save</I>, and steps 3, 4, and 5 occur in <I>CPolyline::WriteToStorage</I>:</P>
<P><I>StgCreateDocfile</I>, using STGM_DIRECT ¦ STGM_CREATE, creates a new compound file, overwriting any file that already exists. This returns an <I>IStorage</I> pointer for this new file. Because we use STGM_DIRECT, there is no need to call <I>IStorage::Commit</I> later.</P>
<P><I>WriteClassStg</I> and <I>WriteFmtUserTypeStg</I> set various flags on the storage and save standard class information.</P>
<P><I>IStorage::CreateStream</I>, using the name "CONTENTS", returns an <I>IStream</I> pointer.</P>
<P><I>IStream::Write</I> saves the data, passing a pointer to the data and the size of the data to go into the stream.</P>
<P><I>IStream::Release</I> closes the stream, matching <I>IStorage::CreateStream</I>.</P>
<P><I>IStorage::Release</I> closes the storage, matching <I>StgCreateDocfile</I>.</P>
<P>We can see these steps in the following code. You'll see that Cosmo handles multiple versions of its data (it has a legacy of an OLE 1 version as well as its file-based version of Chapter 1), but the specific code to handle the different cases has been omitted here for brevity:</P>
<P><BR></P>
<pre><code>UINT CCosmoDoc::Save(UINT uType, LPTSTR pszFile)<BR>    {<BR>    LONG        lVer, lRet;<BR>    UINT        uTemp;<BR>    BOOL        fRename=TRUE;<BR>    HRESULT     hr;<BR>    LPSTORAGE   pIStorage;<BR><BR>    if (NULL==pszFile)<BR>        {<BR>        fRename=FALSE;<BR>        pszFile=m_szFile;<BR>        }<BR><BR>    [Determine version of data to write in lVer.]<BR>    [Ask whether user wants to change versions if necessary.]<BR><BR><BR>    /*<BR>     * Use old WriteToFile code for version 1 data; otherwise,<BR>     * use Structured Storage through WriteToStorage.<BR>     */<BR>    if (lVer==MAKELONG(0, 1))<BR>        lRet=m_pPL-&gt;WriteToFile(pszFile, lVer);<BR>    else<BR>        {<BR>        hr=StgCreateDocfile(pszFile, STGM_DIRECT | STGM_READWRITE<BR>            | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage);<BR><BR>        if (FAILED(hr))<BR>            return DOCERR_COULDNOTOPEN;<BR><BR>        //Mark this as one of our class.<BR>        WriteClassStg(pIStorage, CLSID_CosmoFigure);<BR><BR>        //Write user-readable class information.<BR>        WriteFmtUserTypeStg(pIStorage, m_cf<BR>            , PSZ(IDS_CLIPBOARDFORMAT));<BR><BR>        lRet=m_pPL-&gt;WriteToStorage(pIStorage, lVer);<BR>        pIStorage-&gt;Release();<BR>        }<BR><BR>    if (POLYLINE_E_NONE!=lRet)<BR>        return DOCERR_WRITEFAILURE;<BR><BR>    FDirtySet(FALSE);<BR>    m_lVer=lVer;<BR><BR>    if (fRename)<BR>        Rename(pszFile);<BR><BR>    return DOCERR_NONE;<BR>    }<BR><BR>LONG CPolyline::WriteToStorage(LPSTORAGE pIStorage, LONG lVer)<BR>    {<BR>    ULONG           cb;<BR>    ULONG           cbExpect=0;<BR>    WORD            wVerMaj=HIWORD(lVer);<BR>    WORD            wVerMin=LOWORD(lVer);<BR>    POLYLINEDATA    pl;<BR>    LPSTREAM        pIStream;<BR>    HRESULT         hr;<BR><BR>    if (NULL==pIStorage)<BR>        return POLYLINE_E_READFAILURE;<BR><BR>    //Get copy of our data in version we're going to save.<BR>    DataGet(&amp;pl, lVer);<BR><BR>    [Set cbExpect to size of appropriate version.]<BR><BR>    hr=pIStorage-&gt;CreateStream(SZSTREAM, STGM_DIRECT | STGM_CREATE<BR>        | STGM_WRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &amp;pIStream);<BR><BR>    if (FAILED(hr))<BR>        return POLYLINE_E_WRITEFAILURE;<BR><BR>    hr=pIStream-&gt;Write(&amp;pl, cbExpect, &amp;cb);<BR>    pIStream-&gt;Release();<BR><BR>    if (FAILED(hr) || cbExpect!=cb)<BR>        return POLYLINE_E_WRITEFAILURE;<BR><BR>    return POLYLINE_E_NONE;<BR>    }</code></pre>
<P>In a similar fashion, Cosmo makes the following calls to open and read the data saved previously during a File Open operation. Steps 1, 2, and 7 occur in <I>CCosmoDoc::Load</I>; and steps 4, 5, and 6 occur in <I>CPolyline::ReadFromStorage</I>:</P>
<P><I>StgIsStorageFile</I> determines whether the filename refers to a compound file by looking for a specific OLE-generated signature at the beginning of the disk file.</P>
<P>If the file is a compound file, <I>StgOpenStorage</I> opens the storage for reading and returns an <I>IStorage</I> pointer. Otherwise, <I>StgCreateDocfile</I>, using STGM_TRANSACTED ¦ STGM_CONVERT, opens a noncompound file as a storage object and returns an <I>IStorage</I> pointer.</P>
<P>At the application's option, <I>ReadClassStg</I> loads the CLSID previously saved from <I>WriteClassStg</I>, and <I>IsEqualCLSID</I> compares the expected class to the one in the file. If the two don't match, you didn't write this file, and you can read the data any way you want. Cosmo does not perform this step.</P>
<P><I>IStorage::OpenStream</I> is passed the name "CONTENTS" and returns an <I>IStream</I> pointer to the data.</P>
<P><I>IStream::Read</I> loads the data from the file into the memory structures.</P>
<P><I>IStream::Release</I> closes the stream, matching <I>IStorage::OpenStream</I>.</P>
<P><I>IStorage::Release</I> closes the storage, matching the <I>StgOpenStorage</I> or <I>StgCreateDocfile</I> call.</P>
<P>These steps are apparent in the following code:</P>
<P><BR></P>
<pre><code>UINT CCosmoDoc::Load(BOOL fChangeFile, LPTSTR pszFile)<BR>    {<BR>    HRESULT         hr;<BR>    LPSTORAGE       pIStorage;<BR><BR>    if (NULL==pszFile)<BR>        {<BR>        //For new untitled document, just rename ourselves.<BR>        Rename(NULL);<BR>        m_lVer=VERSIONCURRENT;<BR>        return DOCERR_NONE;<BR>        }<BR><BR>    pIStorage=NULL;<BR><BR>    if (NOERROR!=StgIsStorageFile(pszFile))<BR>        {<BR>        hr=StgCreateDocfile(pszFile,STGM_TRANSACTED | STGM_READWRITE<BR>            | STGM_CONVERT | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage);<BR><BR>        if (FAILED(hr))<BR>            {<BR>            //If denied write access, try to load the old way.<BR>            if (STG_E_ACCESSDENIED==GetScode(hr))<BR>                m_lVer=m_pPL-&gt;ReadFromFile(pszFile);<BR>            else<BR>                return DOCERR_COULDNOTOPEN;<BR>            }<BR>        }<BR>    else<BR>        {<BR>        hr=StgOpenStorage(pszFile, NULL, STGM_DIRECT | STGM_READ<BR>            | STGM_SHARE_EXCLUSIVE, NULL, 0, &amp;pIStorage);<BR><BR>        if (FAILED(hr))<BR>            return DOCERR_COULDNOTOPEN;<BR>        }<BR><BR>    if (NULL!=pIStorage)<BR>        {<BR>        m_lVer=m_pPL-&gt;ReadFromStorage(pIStorage);<BR>        pIStorage-&gt;Release();<BR>        }<BR><BR>    if (POLYLINE_E_READFAILURE==m_lVer)<BR>        return DOCERR_READFAILURE;<BR><BR>    if (POLYLINE_E_UNSUPPORTEDVERSION==m_lVer)<BR>        return DOCERR_UNSUPPORTEDVERSION;<BR><BR>    if (fChangeFile)<BR>        Rename(pszFile);<BR><BR>    //Importing a file makes things dirty.<BR>    FDirtySet(!fChangeFile);<BR><BR>    return DOCERR_NONE;<BR>    }<BR><BR><BR>LONG CPolyline::ReadFromStorage(LPSTORAGE pIStorage)<BR>    {<BR>    POLYLINEDATA    pl;<BR>    ULONG           cb=(ULONG)-1;<BR>    ULONG           cbExpect=0;<BR>    LPSTREAM        pIStream;<BR>    HRESULT         hr;<BR>    LARGE_INTEGER   li;<BR><BR>    if (NULL==pIStorage)<BR>        return POLYLINE_E_READFAILURE;<BR><BR>    //Open CONTENTS stream.<BR>    hr=pIStorage-&gt;OpenStream(SZSTREAM, 0, STGM_DIRECT | STGM_READ<BR>        | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream);<BR><BR>    if (FAILED(hr))<BR>        return POLYLINE_E_READFAILURE;<BR><BR>    //Read version numbers and seek back to file beginning.<BR>    hr=pIStream-&gt;Read(&amp;pl, 2*sizeof(WORD), &amp;cb);<BR><BR>    LISet32(li, 0);<BR>    pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL);<BR><BR>    if (FAILED(hr) || 2*sizeof(WORD)!=cb)<BR>        {<BR>        pIStream-&gt;Release();<BR>        return POLYLINE_E_READFAILURE;<BR>        }<BR><BR>    [Code to set cbExpect according to version omitted.]<BR><BR>    if (0==cbExpect)<BR>        {<BR>        pIStream-&gt;Release();<BR>        return POLYLINE_E_UNSUPPORTEDVERSION;<BR>        }<BR><BR>    hr=pIStream-&gt;Read(&amp;pl, cbExpect, &amp;cb);<BR>    pIStream-&gt;Release();<BR><BR>    if (cbExpect!=cb)<BR>        return POLYLINE_E_READFAILURE;<BR><BR>    DataSet(&amp;pl, TRUE, TRUE);<BR>    return MAKELONG(pl.wVerMin, pl.wVerMaj);<BR>    }</code></pre>
<P>The most interesting aspects of this code are the correspondence between stream operations and traditional file operations and the use of STGM_CONVERT to deal with an old file format. We'll cover these topics in the next two sections. Although Cosmo writes a CLSID to the storage, it does not check it during File Open using <I>ReadClassStg</I>. I do this so Cosmo and Component Cosmo (CoCosmo, modified for storage objects a little later) retain file compatibility. Because the two applications write different CLSIDs into their storages, we skip the <I>ReadClassStg</I> step. Using <I>ReadClassStg</I> is an extra check that you can perform to validate a file before loading potentially large amounts of data.</P></font></body></HTML>
