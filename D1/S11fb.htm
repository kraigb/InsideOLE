<HTML><HEAD><TITLE>But All I Want to Do Is Copy Some Simple Data!</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>But All I Want to Do Is Copy Some Simple Data!</H2><P>I imagine that at this point you are screaming or cursing that OLE makes the clipboard far too complex.<I> </I>To copy even the simplest piece of data—maybe a short, but passionate, string such as "Why is Microsoft doing this to me?"—requires an implementation of a data object, a FORMATETC enumerator that supports cloning, and the complexity of taking a snapshot of the data involved so as to support delayed rendering.<I> </I>Ouch!<I> </I>Whatever happened to <I>OpenClipboard</I>, <I>SetClipboardData</I>, and <I>CloseClipboard</I>?</P>
<P>Well, in reality, the Windows API has never been quite that simple because somewhere along the way you have to allocate global memory and copy your data into it.<I> </I>Before calling <I>SetClipboardData</I> with a string, for example, you usually call some function to make a copy of it:</P>
<P><BR></P>
<pre><code>HGLOBAL CopyStringToHGlobal(LPTSTR psz)<BR>    {<BR>    HGLOBAL    hMem;<BR>    LPTSTR     pszDst;<BR><BR>    hMem=GlobalAlloc(GHND, (DWORD)(lstrlen(psz)+1));<BR><BR>    if (NULL!=hMem)<BR>        {<BR>        pszDst=GlobalLock(hMem);<BR>        lstrcpy(pszDst, psz);<BR>        GlobalUnlock(hMem);<BR>        }<BR><BR>    return hMem;<BR>    }</code></pre>
<P>With this function, the code to copy the text to the clipboard would appear as follows:</P>
<P><BR></P>
<pre><code>HGLOBAL    hMem;<BR><BR>hMem=CopyStringToHGlobal(TEXT("Why is Microsoft doing this to me?"));<BR><BR>if (NULL!=hMem)<BR>    {<BR>    if (OpenClipboard(hWndMain))<BR>        {<BR>        SetClipboardData(CF_TEXT, hMem);<BR>        CloseClipboard();<BR>        }<BR>    else<BR>        GlobalFree(hMem);  //We must clean up.<BR>    }</code></pre>
<P>Under OLE, however, we would like to write simple code that takes advantage of data objects:</P>
<P><BR></P>
<pre><code>IDataObject    *pIDataObject;<BR>HRESULT         hr;<BR>FORMATETC       fe;<BR>STGMEDIUM       stm;<BR><BR>stm.tymed=TYMED_HGLOBAL;<BR>stm.hGlobal=<BR>    CopyStringToHGlobal(TEXT("Why is Microsoft doing this to me?"));<BR><BR>if (NULL!=stm.hGlobal)<BR>    {<BR>    hr=FunctionToCreateADataObject(&amp;pIDataObject)<BR><BR>    if (SUCCEEDED(hr))<BR>        {<BR>        SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);<BR>        pIDataObject-&gt;SetData(&amp;fe, &amp;stm);<BR>        OleSetClipboard(pIDataObject);<BR>        pIDataObject-&gt;Release();<BR>        }<BR>    else<BR>        GlobalFree(stm.hGlobal);<BR>    }</code></pre>
<P>This code shows how we would <I>like</I> to translate existing Windows API code into OLE-based code. <I>SetClipboardData(cf, hMem) </I>becomes <I>IDataObject::SetData(</I><I>&amp;</I><I>fe, </I><I>&amp;</I><I>stm)</I>,<I> </I>followed by <I>OleSetClipboard</I>. <I>CloseClipboard</I> turns into <I>IDataObject::Release</I>. But what about <I>FunctionToCreateADataObject</I>? Where does this come from? Certainly something like this would be quite convenient, but alas, my friends, OLE does not supply such an implementation. You could cheat and use <I>CreateDataCache </I>for this purpose, except for the small problem that the data cache does not implement <I>IDataObject::EnumFormatEtc</I>. Bummer.</P>
<P>What we need is a function to create a data object that we can stuff through <I>IDataObject::SetData</I>, and then we need to throw that data object on the clipboard. The data object would maintain all the data until the object was released, and then it would free all that data automatically. So I wrote such a component, named DataTran, found in CHAP12\DATATRAN.</P></font></body></HTML>
