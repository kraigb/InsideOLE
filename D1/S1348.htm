<HTML><HEAD><TITLE>Future Enhancements and Additions to OLE</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Future Enhancements and Additions to OLE</H2><P>With everything OLE already does, it can, of course, always do more. As I mentioned earlier, an evolutionary technology such as OLE keeps changing. When I wrote the first edition of this book during the first half of 1993, OLE 2 had just been released, and many of the technologies we've seen, such as Connectable Objects, Property Pages, and OLE Controls, did not yet exist. In 1994, Microsoft made a number of improvements to OLE Automation, implementing dual interfaces, for example, and also added the capabilities for OLE Controls. Incremental enhancements of this nature will continue well into the future.</P>
<P>For the short term (the next two years or so), I can offer a brief list of the enhancements that you can expect. Of course, I cannot guarantee the timing of any of this—these are simply the features that Microsoft considers a priority:</P>
<UL><LI>COM will support <I>distributed services,</I> which provide the ability to communicate with components and objects across network boundaries. In this book, we've already seen how some of this will work, but the details are not entirely available. Using RPC over a network is the easy part of working with remote objects. The tough parts have to do with security (restricting access to services), naming remote objects and their locations uniquely, providing for load balancing when the same service exists on multiple remote machines, and doing all of this as transparently as possible so that existing objects and clients can be deployed in a distributed manner without any code modifications whatsoever.</LI><LI>Marshaling interfaces across process or machine boundaries may happen automatically at run time based only on an IDL or ODL description. This would eliminate the need to create your own proxies and stubs with the MIDL compiler. Closely related to this is the intention to merge the IDL and ODL specifications to have one description language for all type information and marshaling needs.</LI><LI>There will be a richer classification of object types and their capabilities. Current specifications only classify objects using the Insertable and Control registry keys. As we've seen, there are no other standards for classifying an object, even as an object that supports OLE Automation, which is why I suggested the Programmable key in Chapters 14 and 15. You can well understand the future need to classify objects much more precisely—according to their capabilities—and the need for additional user interface standards that help users browse objects of a certain classification.</LI><LI>The structured storage model implemented today in Compound Files will eventually become the basis of a new object file system for Windows. This means that working with storage and stream elements will be exceptionally fast, that these elements will support reconciliation, and that a computer's entire namespace will be browsable as a uniform hierarchy through OLE interfaces. The entire network simply becomes an enormous root storage (with interfaces above and beyond <I>IStorage</I>), with substorages for each machine on that network, substorages for disk volumes and partitions—all the way down to individual substorages inside today's compound files. Streams may appear at any point in the hierarchy to store extra information, including user-definable properties. Literally everything is browsable through the system shell, which will work with full-content filters in order to allow end users to quickly and easily search for information across the entire namespace no matter how deeply buried that information might be inside a file.</LI><LI>There will be an OLE-provided service for dealing with property sets more conveniently. Specific objects will encapsulate portions of a property set behind appropriate interfaces.</LI><LI>OLE Documents will be greatly enhanced to support even richer content than is possible today. First is the capability to create irregularly shaped content objects, be they in-place capable or not. Windows 95 and Windows NT 3.51 have built-in support for regional windows for this purpose. Second is the capability of container and content objects to negotiate menus and in-place tools to a much finer degree—down to the level of merging individual menu items and short segments of toolbars. Next is the capability to break objects into multiple pieces, whether rectangles or irregular regions. Thus, objects can span multiple pages or perform word wrapping as appropriate for the content. The latter allows content such as an equation to act like any other text in a word processor, even though the content is being managed by an entirely separate component. Along the same lines is the capability to display multiple views for an object. And finally, you'll see container-level search and replace and spell checking of an object's text without requiring the container to know where an object stores such text within itself.</LI></UL><P>These items are only those enhancements that Microsoft will make to the technologies we've already seen. Microsoft is also working on new systems technologies that will push OLE into even more areas than it exists in today.</P>
<P>One of the first places you will see (or have already seen) this expansion is the shell extensions to Windows 95, which are all based on COM objects of some sort that implement specific interfaces. For example, a Windows 95 "file viewer" is a simple COM object (with a CLSID and a server) that implements interfaces such as <I>IPersistFile </I>and <I>IFileViewer</I>. Other types of objects provide for extensions to object context menus, hooks for copy and move operations for directories and files, control over system icons, and custom extensions to object property sheets.</P>
<P>The way Windows 95 employs simple COM objects illustrates how useful such objects can be. Eventually you'll even see device drivers take advantage of COM's benefits for negotiating features through interfaces. Most device drivers today are simply DLLs that export specific functions—you can achieve the same end in COM with an in-process object for which all those functions are factored into meaningful interfaces. Over time, enhancements to device drivers will mean new interfaces to implement alongside existing interfaces. The ability to do this robustly is a tremendous improvement over current device driver models because most drivers have to be updated whenever a new version of the operating system is released. With an interface model, driver updates could happen incrementally.</P>
<P>Microsoft is also creating a specification for working with databases through OLE technologies, intended to augment and work with the Open Database Connectivity (ODBC) standard (which will, of course, continue to be fully supported). You can expect to see interfaces that can be used for purposes such as connecting to and managing databases, creating database schema, handling transactioning models, generating and executing queries, working with rows and columns (sorting, filtering, notifying), and so on.</P>
<P>Developers are working as well to create OLE-based multimedia technology for dealing with special content types and other needs unique to multimedia. And work is also going on related to accessibility, or providing ways for computers to work better with people who have various disabilities.</P>
<P>Of course, Microsoft cannot do everything by itself, and many areas of technology concern only a certain segment of the computer industry. For example, the WOSA/XRT specification we saw in Chapter 10 was the work of the Open Market Data Council, which involved representatives of more than 80 companies. Microsoft played only a supporting role in that effort, helping to guide the design to make appropriate use of OLE. But such a gathering of different companies with a common interest doesn't need Microsoft at all! Because COM already allows anyone to create his or her own custom interfaces with standard or custom marshaling, any group of people can get together, find solutions to their common problems, define interfaces to implement those solutions, and then use those interfaces to have their applications communicate and integrate with one another.</P>
<P>Indeed, a key design goal of OLE was the capability for any programmer to create, extend, or evolve an existing design without central coordination of his or her activity while still maintaining a true guarantee of robustness in the system. (In particular, the widespread use of GUIDs as a fundamental data type ensures that no two pieces of code will work together unless programmers intend that they do so.) What's important is that no changes to OLE or to the operating system are necessary. This means that no one needs to approach Microsoft and coerce them to add new APIs to the system or dedicate any other sort of resources. OLE empowers individuals in a partnership to create new designs for integration and interoperability. No one company dominates such a relationship because everyone involved is working for the common interest: integrating applications and components to solve customer problems.</P>
<P>For the longer term, it's hard to know what new additions and changes Microsoft will make and what sorts of technologies other groups might create themselves. There are so many interesting and exciting directions to pursue! In any case, Microsoft doesn't want to work in a vacuum, so they do welcome your ideas and requests. Let Microsoft know what your priorities are and what new features you would like to see. You can send electronic mail to <I>oleidea@microsoft.</I><I>com</I>, or you can write a letter or send a fax to the attention of OLE Program Management. If you are involved in a third-party initiative and would like Microsoft's involvement in the effort, contact Microsoft through the OLESOLN forum on CompuServe or by e-mail at <I>i-stds@microsoft.com</I>.</P></font></body></HTML>
