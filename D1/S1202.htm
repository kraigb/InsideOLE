<HTML><HEAD><TITLE>Enabling Edit/Paste</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Enabling Edit/Paste</H3><P>Any programmer who has ever implemented Paste functionality in an application has gone through the rite of processing WM_INITMENUPOPUP and deciding whether to enable the Paste menu item depending on the formats available on the clipboard. This user interface does not change with OLE; what does change is the way you can implement it using data objects.</P>
<P>I want to stress the phrase "can implement" because OLE does not force you to use data objects for enabling paste or for performing a paste. OLE is simply a convenient way of doing it. The big advantage is that once you write a piece of code to enable pasting or to paste from a data object, that same code can be used in OLE Drag and Drop, which we'll cover in Chapter 13. By adding support for additional formats to your code, you expand the capabilities of both protocols to enable the pasting of things such as compound document objects and controls.</P>
<P>As you can see in the following code, the OLE method is only a matter of asking the data object to go through this sequence:</P>
<P>Call <I>OleGetClipboard</I> to retrieve an <I>IDataObject</I> pointer for the clipboard.</P>
<P>Call <I>IDataObject::QueryGetData</I> for each format you would pass to the Windows function <I>IsClipboardFormatAvailable</I>. If successful, enable the Edit/Paste menu item.<I> </I>If no formats are available, disable the item.</P>
<P>Call <I>IDataObject::Release</I> when finished.</P>
<P><BR></P>
<pre><code>BOOL CCosmoDoc::FQueryPaste(void)<BR>    {<BR>    LPDATAOBJECT    pIDataObject;<BR>    BOOL            fRet;<BR><BR>    if (FAILED(OleGetClipboard(&amp;pIDataObject)))<BR>        return FALSE;<BR><BR>    fRet=FQueryPasteFromData(pIDataObject);<BR>    pIDataObject-&gt;Release();<BR>    return fRet;<BR>    }<BR><BR>BOOL CCosmoDoc::FQueryPasteFromData(LPDATAOBJECT pIDataObject)<BR>    {<BR>    FORMATETC       fe;<BR><BR>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL);<BR>    return (NOERROR==pIDataObject-&gt;QueryGetData(&amp;fe));<BR>    }</code></pre>
<P>Cosmo's <I>CCosmoDoc::FQueryPaste</I> function, which used to call <I>IsClipboardFormatAvai</I><I>lable</I>, now retrieves the clipboard's <I>IDataObject</I> and sends it to <I>CCosmoDoc::FQueryPasteFromData</I>, which determines whether it can be pasted with <I>IDataObject::QueryGetData </I>before releasing the pointer. I strongly encourage you to implement a function like <I>FQueryPasteFromData. </I>With such a function in place, you can pass any data object to it, whether you get the pointer from <I>OleGetClipboard</I>, from a drag-and-drop operation, or from some <I>QueryInterface</I>. A function like this gives you a single place to add new formats that you might support with additional OLE work.</P></font></body></HTML>
