<HTML><HEAD><TITLE>Interface Implementations (CObject1)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Interface Implementations (<I>CObject1)</I></H3><P>This technique employs only single inheritance, where the object class itself inherits from <I>IUnknown </I>and implements those functions to control the object as a whole. Each additional interface is implemented as a separate C++ <I>interface implementation</I> class that singly inherits from the appropriate interface. Each separate class holds a backpointer to the full object class (with no <I>AddRef </I>because this is a case of nested lifetimes) and delegates all <I>IUnknown </I>calls from its interface to those of the actual object. Thus, reference counting and <I>QueryInterface </I>are centralized in the full object class, as should be the case. In general, the interface implementation classes use the backpointer to get at centralized object variables, so they are commonly declared as <I>friend </I>classes to the object class.</P>
<P>To implement an object with <I>ISampleOne </I>and <I>ISampleTwo</I>, we would declare classes as found in OBJECT1.H:</P>
<P><BR></P>
<pre><code>class CImpISampleOne;<BR>typedef CImpISampleOne *PCImpISampleOne;<BR><BR>class CImpISampleTwo;<BR>typedef CImpISampleTwo *PCImpISampleTwo;<BR><BR>//The C++ class that manages the actual object<BR>class CObject1 : public IUnknown<BR>    {<BR>    friend CImpISampleOne;<BR>    friend CImpISampleTwo;<BR><BR>    private:<BR>        DWORD           m_cRef;         //Object reference count<BR><BR>        PCImpISampleOne  m_pImpISampleOne;<BR>        PCImpISampleTwo  m_pImpISampleTwo;<BR><BR>    public:<BR>        CObject1(void);<BR>        ~CObject1(void);<BR><BR>        BOOL Init(void);<BR><BR>        //IUnknown members<BR>        STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>        STDMETHODIMP_(DWORD) AddRef(void);<BR>        STDMETHODIMP_(DWORD) Release(void);<BR>    };<BR><BR>typedef CObject1 *PCObject1;<BR><BR>class CImpISampleOne : public ISampleOne<BR>    {<BR>    private:<BR>        DWORD       m_cRef;         //For debugging<BR>        PCObject1   m_pObj;         //Backpointer for delegation<BR><BR>    public:<BR>        CImpISampleOne(PCObject1);<BR>        ~CImpISampleOne(void);<BR><BR>        //IUnknown members<BR>        STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>        STDMETHODIMP_(DWORD) AddRef(void);<BR>        STDMETHODIMP_(DWORD) Release(void);<BR><BR>        //ISampleOne members<BR>        STDMETHODIMP         GetMessage(LPTSTR, UINT);<BR>    };<BR><BR>class CImpISampleTwo : public ISampleTwo<BR>    {<BR>    private:<BR>        DWORD       m_cRef;         //For debugging<BR>        PCObject1   m_pObj;         //Backpointer for delegation<BR><BR>    public:<BR>        CImpISampleTwo(PCObject1);<BR>        ~CImpISampleTwo(void);<BR><BR>        //IUnknown members<BR>        STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>        STDMETHODIMP_(DWORD) AddRef(void);<BR>        STDMETHODIMP_(DWORD) Release(void);<BR><BR>        //ISampleTwo members<BR>        STDMETHODIMP         GetString(LPTSTR, UINT);<BR>    };</code></pre>
<P>My personal convention is to name the interface classes with <I>CImp&lt;Interface&gt;</I> and the variables in the object that hold pointers to these classes with <I>m</I><I>_</I><I>pImp&lt;Interface&gt;</I>. This variable naming distinguishes interface implementations that the object manages from other interface pointers that it might store as well, which I name with <I>m</I><I>_</I><I>p&lt;Interface&gt;</I>. These are my conventions: use whatever you like because OLE itself doesn't care about such implementation details.</P>
<P>The Query client creates this object through the <I>CreateObject1</I> function, which looks a lot like <I>CreateRectEnumeratorCPP</I>. One addition is that after creating an instance of <I>CObject1 </I>with the <I>new </I>operator, the Query client calls <I>CObject1::Init</I>, which explicitly instantiates the interface implementations:</P>
<P><BR></P>
<pre><code>CObject1::CObject1(void)<BR>    {<BR>    m_cRef=0;<BR><BR>    m_pImpISampleOne=NULL;<BR>    m_pImpISampleTwo=NULL;<BR><BR>    return;<BR>    }<BR><BR>§<BR><BR>BOOL CObject1::Init(void)<BR>    {<BR>    m_pImpISampleOne=new CImpISampleOne(this);<BR><BR>    if (NULL==m_pImpISampleOne)<BR>        return FALSE;<BR><BR>    m_pImpISampleTwo=new CImpISampleTwo(this);<BR><BR>    if (NULL==m_pImpISampleTwo)<BR>        return FALSE;<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>The <I>this </I>pointer passed to the interface implementation constructors becomes the backpointer to the object, through which the interface implementations delegate <I>IUnknown</I> calls. Again, the interface implementations do not call <I>AddRef </I>on this pointer because their lifetimes are nested within <I>CObject1</I>'s. Thus, the object can simply call <I>delete </I>on its <I>m</I><I>_</I><I>pImp</I>*<I> </I>pointers in its destructor to clean up the allocations made inside <I>Init</I>, as shown on the following page.</P>
<P><BR></P>
<pre><code>CObject1::~CObject1(void)<BR>    {<BR>    DeleteInterfaceImp(m_pImpISampleTwo);<BR>    DeleteInterfaceImp(m_pImpISampleOne);<BR>    return;<BR>    }</code></pre>
<P>The destructor is called from within <I>Release</I>, which calls <I>delete this</I>, as we saw before. In the destructor, the macro DELETEINTERFACEIMP is my own creation. (You'll find it in INC\INOLE.H.) This macro calls <I>delete </I>on the given pointer and sets that pointer to NULL. I have also defined a macro, RELEASEINTERFACE, that calls <I>Release </I>on a pointer and sets it to NULL:</P>
<P><BR></P>
<pre><code>#define DeleteInterfaceImp(p)\<BR>            {\<BR>            if (NULL!=p)\<BR>                {\<BR>                delete p;\<BR>                p=NULL;\<BR>                }\<BR>            }<BR><BR>#define ReleaseInterface(p)\<BR>            {\<BR>            if (NULL!=p)\<BR>                {\<BR>                p-&gt;Release();\<BR>                p=NULL;\<BR>                }\<BR>            }</code></pre>
<P>I have found that setting a pointer to NULL after you believe you have deleted it or released it for the last time is very useful for debugging, as it easily exposes interface calls after the interface becomes invalid. I recommend that you use this technique in your own work as well: it will save you some head banging.</P>
<P>Now to the real purpose of our discussion—the implementation of <I>QueryInterface</I>. <I>CObject1</I> effectively supports three interfaces: <I>IUnknown</I>, <I>ISampleOne</I>, and <I>ISampleTwo</I>. Each interface pointer comes from a different source:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CObject1::QueryInterface(REFIID riid, PPVOID ppv)<BR>    {<BR>    *ppv=NULL;<BR><BR>     //IUnknown comes from CObject1.<BR>    if (IID_IUnknown==riid)<BR>        *ppv=this;<BR><BR>    //Other interfaces come from interface implementations.<BR>    if (IID_ISampleOne==riid)<BR>        *ppv=m_pImpISampleOne;<BR><BR>    if (IID_ISampleTwo==riid)<BR>        *ppv=m_pImpISampleTwo;<BR><BR>    if (NULL==*ppv)<BR>        return ResultFromScode(E_NOINTERFACE);<BR><BR>    ((LPUNKNOWN)*ppv)-&gt;AddRef();<BR>    return NOERROR;<BR>    }</code></pre>
<P>In other words, <I>this </I>is the <I>IUnknown</I> pointer, whereas <I>m</I><I>_</I><I>pImpISampleOne </I>and <I>m</I><I>_</I><I>pImpISampleTwo</I> are the others. If the client calls any <I>IUnknown </I>function through these latter two interface pointers, the calls are delegated to <I>CObject1</I>'s implementation:</P>
<P><BR></P>
<pre><code>CImpISampleOne::CImpISampleOne(PCObject1 pObj)<BR>    {<BR>    m_cRef=0;<BR>    m_pObj=pObj;<BR>    return;<BR>    }<BR><BR>STDMETHODIMP CImpISampleOne::QueryInterface(REFIID riid, PPVOID ppv)<BR>    {<BR>    return m_pObj-&gt;QueryInterface(riid, ppv);<BR>    }<BR><BR>DWORD CImpISampleOne::AddRef(void)<BR>    {<BR>    ++m_cRef;<BR>    return m_pObj-&gt;AddRef();<BR>    }<BR><BR>DWORD CImpISampleOne::Release(void)<BR>    {<BR>    --m_cRef;<BR>    return m_pObj-&gt;Release();<BR>    }</code></pre>
<P>The same thing happens in <I>CImpISampleTwo</I>. Do note that these implementations maintain their own interface reference counts simply for debugging. If you wanted to—and you are not supporting aggregation—you could have <I>CObject1::QueryInterface </I>create the interface implementations when necessary and have those implementations destroy themselves in <I>Release</I>. The technique is not allowed in aggregation, however, because there you have to ensure validity of all interface pointers until the object as a whole is destroyed, as we'll see shortly.</P>
<P>The primary advantage of this technique is that everything is explicit: you can trace when and where interfaces are instantiated, and you can watch everything that happens. For this reason, and because it is more readily understood by a C++ neophyte, I've used this technique in almost every multiple-interface sample in this book. Its biggest drawback is that it's rather verbose; the other techniques don't require as much source code. The extra step of <I>IUnknown </I>delegation is also a minor but usually insignificant performance degradation, and this technique generally uses more memory than others do.</P></font></body></HTML>
