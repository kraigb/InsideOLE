<HTML><HEAD><TITLE>Streams vs. Files</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Streams vs. Files</H3><P>Earlier in this chapter, I mentioned that a strong parallel exists between traditional file I/O functions (in both the Windows API and the C run-time library) and the member functions of the <I>IStream</I> interface. In the implementation of Cosmo's <I>CPolyline </I>class, we can see these similarities by comparing its <I>ReadFromFile</I> member used in the Chapter 1 version of Cosmo to the <I>ReadFromStorage</I> member used here. The two functions, <I>ReadFromFile</I> and <I>ReadFromStora</I><I>ge</I>, are shown side by side here to illustrate the similarities between the two implementations:</P>
<P><BR></P>
<pre><code>LONG CPolyline::ReadFromFile         LONG CPolyline::ReadFromStorage<BR>    (LPSTR pszFile)                      (LPSTORAGE pIStorage)<BR>    {                                    {<BR>    OFSTRUCT        of;                  HRESULT         hr;<BR>    HFILE           hFile;               LPSTREAM        pIStream;<BR>    POLYLINEDATA    pl;                  POLYLINEDATA    pl;<BR>    UINT            cb=-1;               ULONG           cb=-1;<BR>    UINT            cbExpect=0;          ULONG           cbExpect=0;<BR>    LARGE_INTEGER   li;<BR><BR>    if (NULL==pszFile)                   if (NULL==pIStorage)<BR>        return POLYLINE_E_READFAILURE;        return POLYLINE_E_READFAILURE;<BR><BR>    hFile=OpenFile(pszFile, &amp;of          hr=pIStorage-&gt;OpenStream("CONTENTS", 0<BR>        , OF_READ);                          , STGM_DIRECT | STGM_READ<BR>                                             | STGM_SHARE_EXCLUSIVE, 0<BR>                                             , &amp;pIStream);<BR><BR>    if (HFILE_ERROR==hFile)              if (FAILED(hr))<BR>        return POLYLINE_E_READFAILURE;       return POLYLINE_E_READFAILURE;<BR><BR>    cb=_lread(hFile, (LPSTR)&amp;pl          hr=pIStream-&gt;Read((LPVOID)&amp;pl<BR>        , 2*sizeof(WORD));                   , 2*sizeof(WORD), &amp;cb);<BR><BR>    _llseek(hFile, 0L, 0);            LISet32(li, 0);<BR>                                      pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL);<BR><BR>    if (2*sizeof(WORD)!=cb)              if (FAILED(hr) || 2*sizeof(WORD)!=cb)<BR>        {                                    {<BR>        _lclose(hFile);                      pIStream-&gt;Release();<BR>        return POLYLINE_E_READFAILURE;       return POLYLINE_E_READFAILURE;<BR>        }                                    }<BR><BR>    [Code here to calculate cbExpect     [Code here to calculate cbExpect<BR>     based on version number]             based on version number]<BR><BR>    cb=_lread(hFile, (LPSTR)&amp;pl          hr=pIStream-&gt;Read((LPVOID)&amp;pl<BR>        , cbExpect);                         , cbExpect, &amp;cb);<BR>    _lclose(hFile);                      pIStream-&gt;Release();<BR><BR>    if (cbExpect!=cb)                    if (cbExpect!=cb)<BR>        return POLYLINE_E_READFAILURE;       return POLYLINE_E_READFAILURE;<BR><BR>    DataSet(&amp;pl, TRUE, TRUE);            DataSet(&amp;pl, TRUE, TRUE);<BR>    return MAKELONG(pl.wVerMin           return MAKELONG(pl.wVerMin<BR>        , pl.wVerMaj);                       , pl.wVerMaj);<BR>    }                                    }</code></pre>
<P>We can see how a call to <I>OpenFile </I>maps to a call to <I>IStorage::OpenStream</I>; we treat the storage object as we'd treat the file system. Then all of the old file I/O functions called with the file handle map to <I>IStream </I>calls; in this case, the standard return type of HRESULT means that we have to pass pointers to out-parameters of <I>IStream </I>functions that are generally the straight return values of traditional file I/O calls (such as the <I>cb </I>returned from <I>_</I><I>lread</I>).</P>
<P>One glaring difference between traditional files and streams is seeking. Because the Structured Storage definition of <I>IStr</I><I>eam</I> allows a stream to contain up to 264 addressable bytes of data, we can't just use a DWORD to indicate the new seek offset. For this reason, OLE defines the type LARGE_INTEGER, a 64-bit value of two LONGs, together with the macro LISet32, which fills such a structure with a 32-bit value:</P>
<P><BR></P>
<pre><code>LARGE_INTEGER   li;<BR><BR>LISet32(li, 0);<BR>pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL);</code></pre>
<P>There is also a ULARGE_INTEGER, composed of two (unsigned) DWORDs, with the associated macro ULISet32. The third parameter to <I>IStream::Seek</I> could be a ULARGE_INTEGER, which would receive the prior seek offset before the call. In the code shown above, the NULL means that we're not interested in this information.</P></font></body></HTML>
