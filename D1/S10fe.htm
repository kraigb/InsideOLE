<HTML><HEAD><TITLE>Polymorphism</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Polymorphism</H3><P>Polymorphism is many things in object-oriented programming. It is the capability to treat objects from multiple classes identically because they all share one or more interfaces in common. Polymorphism means that heterogeneous objects can respond to the same interface calls from the same client, allowing that client to be written according to a prototype instead of for specific object classes. In addition, polymorphism means that you create more instances (types) of a prototype so existing clients that understand the prototype can immediately use those new classes. In OLE, objects whose classes have a common set of interfaces are polymorphic with one another, as we saw with the recent example concerning the evolution of file rendering objects.</P>
<P>In OLE, <I>QueryInterface </I>and the idea of multiple interfaces provide polymorphism. In C++, you would define basic characteristics in a base class and add characteristics by creating a derived class from that base class. You can derive further specific classes from the first derived class, creating a deep object hierarchy in which a derived class is polymorphic with all classes above it, all the way to the base class. In OLE, however, basic characteristics are expressed in one interface, and additional and more specific sets of characteristics are expressed through additional interfaces. Two object classes that support the same interfaces are like each other—polymorphic—across those interfaces. The classes are instances of the same prototype.</P>
<P>When you start designing interfaces for different sets of characteristics, you have two choices: you can actually use inheritance to derive the more specific interfaces from the more generic ones, or you can define completely separate interfaces for each set of characteristics. Which approach is better?</P>
<P>As an example, let's say I want to model some animals as objects, specifically rabbits and koalas. Since both are animals, I could make a base interface to represent the characteristics of a general animal (which, of course, includes <I>IUnknown </I>members).</P>
<P><BR></P>
<pre><code>interface IAnimal : IUnknown<BR>    {<BR>    HRESULT Eat(...);<BR>    HRESULT Sleep(...);<BR>    HRESULT Procreate(...);<BR>    }</code></pre>
<P>Here I'm saying that all animals, including humans, share the basic characteristics of eating, sleeping, and procreation. (Arguments to these functions are irrelevant to this discussion.) Now I need to create my <I>IRabbit </I>and <I>IKoala </I>interfaces. (Ideally you'd probably make <I>IRodent </I>and <I>IMarsupial </I>interfaces as well, but we'll keep things simple here.) One way to create these new interfaces would be to use C++ inheritance to derive each new interface from <I>IAnimal</I>:</P>
<P><BR></P>
<pre><code>interface IRabbit : IAnimal<BR>    {<BR>    HRESULT RaidGardens(...);<BR>    HRESULT Hop(...);<BR>    HRESULT DigWarrens(...);<BR>    }<BR><BR>interface IKoala : IAnimal<BR>    {<BR>    HRESULT ClimbEucalyptusTrees(...);<BR>    HRESULT PouchOpensDown(...);<BR>    HRESULT SleepForHoursAfterEating(...);<BR>    }</code></pre>
<P>This technique is entirely workable, but it has a significant drawback. If for some reason a new interface, <I>IAnimal2</I>, is created (to add the function <I>Locomotion </I>or some such), it would force the creation of <I>IRabbit2 </I>and <I>IKoala2</I> if we wanted to update objects to also support <I>IAnimal2</I>. In other words, the change to the base has to propagate to derived interfaces. While this is not a big deal for a two-level inheritance tree, it becomes an utter nightmare with a deep inheritance tree—a change in a base interface might force changes in hundreds of other interfaces! The additional impact of such sweeping changes is that clients and objects using these interfaces would then have to make much more sweeping changes as well.6</P>
<P>The preferred technique is to simply define each additional interface separately, deriving only from <I>IUnknown</I>:</P>
<P><BR></P>
<pre><code>interface IRabbit : IUnknown<BR>    {<BR>    HRESULT RaidGardens(...);<BR>    HRESULT Hop(...);<BR>    HRESULT DigWarrens(...);<BR>    }<BR><BR>interface IKoala : IUnknown<BR>    {<BR>    HRESULT ClimbEucalyptusTrees(...);<BR>    HRESULT PouchOpensDown(...);<BR>    HRESULT SleepForHoursAfterEating(...);<BR>    }</code></pre>
<P>An object that implements <I>IAnimal</I> and <I>IRabbit </I>separately, as would be required in this technique, is functionally equivalent to one that implements a single <I>IRabbit</I> derived from <I>IAnimal</I>.7 However, if <I>IAnimal2 </I>comes out, this Rabbit object needs to amend only one of its interface implementations, leaving all others as is. This is beneficial when the object has a large number of interfaces. A client can also rest easy: to exploit <I>IAnimal2</I>, it needs only to modify its code that handles <I>IAnimal</I> to work with <I>IAnimal2</I>, and it can leave all <I>IRabbit </I>calling code unmodified.</P>
<P>I will point out here as well that a deep inheritance tree would be absolutely required if an object could not support multiple interfaces. It is due entirely to <I>QueryInterface </I>that we can avoid the complexity and difficulties associated with deep inheritance. A shallow interface inheritance tree is much easier to work with over time, for objects as well as for clients. Functionally it is identical to a deep inheritance tree but far more practical.</P>
<P>Another drawback to a deep inheritance tree is that it is less efficient to reuse some other component's implementation of base interfaces. But that requires us to look at the reusability of interface implementations.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>6 There are only a few cases in OLE in which interface inheritance goes deeper than one level a few of which the original OLE designers acknowledge as less than optimal choices.</P></TD></TR><TR><TD VALIGN="TOP"><P>7 Note that the derived <I>IRabbit </I>and the independent <I>IRabbit </I>are not the same interface because they have different vtable layouts and therefore must have different IIDs. <I>Functionally equivalent</I> means that the same features are available in both interfaces.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
