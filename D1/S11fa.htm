<HTML><HEAD><TITLE>The OLE Clipboard Protocol</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>The OLE Clipboard Protocol</H2><P>A transfer protocol in the OLE sense is a mechanism for communicating an <I>IDataObject </I>pointer from a source to a consumer. The OLE Clipboard is one such protocol, supported through four OLE API functions:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="126pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>OLE API Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>OleSetClipboard</P></TD><TD VALIGN="TOP"><P>Places a data object on the clipboard; that data object wraps all the data to copy or cut. OLE calls <I>AddRef</I> on this object and asks it to enumerate its formats. OLE makes these formats available to potential consumers.</P></TD></TR><TR><TD VALIGN="TOP"><P>OleGetClipboard</P></TD><TD VALIGN="TOP"><P>Retrieves a data object that represents the data available on the clipboard, calling <I>A</I><I>ddRef</I> on the <I>IDataObject</I> pointer returned.<I> </I>The consumer must call <I>Release</I> when it is done with the object.</P></TD></TR><TR><TD VALIGN="TOP"><P>OleFlushClipboard</P></TD><TD VALIGN="TOP"><P>Clears the clipboard, calling <I>Release</I> on the data object passed to <I>OleSetClipboard</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>OleIsCurrentClipboard</P></TD><TD VALIGN="TOP"><P>Answers whether a given data object is the one currently on the clipboard.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The overall mechanism of a clipboard data transfer in OLE is shown in Figure 12-1. The source creates a data object (including its FORMATETC enumerator) and calls <I>OleSetClipboard</I>.<I> </I>OLE calls the Windows function <I>OpenClipboard</I>,<I> </I>followed by <I>IDataObject::AddRef</I> and <I>IDataObject::EnumFormatEtc</I>.<I> </I>For each enumerated format that uses TYMED_HGLOBAL, OLE calls the Windows function <I>SetClipboardData(formatetc.cfFormat, NULL)</I> to make the format available using delayed rendering.<I> </I>OLE finishes by calling the Windows function <I>CloseClipboard</I>.<I> </I>When any consumer, aware of OLE or not, calls the Windows function <I>GetClipboardData</I> for any of these formats, Windows, according to delayed rendering, sends a WM_RENDERFORMAT message.</P>
<P>    <img src="f12dd01.gif"></P>
<P><B>Figure 12-1.</B></P>
<P><B>The OLE Clipboard involves <I>OleGetClipboard</I>,<I> OleSetClipboard</I>, and a data object.</B></P>
<P>But to which window is the message sent?<I> </I>It is sent to one inside OLE itself, the handle to which OLE passes in its call to <I>OpenClipboard. </I>This window is always hidden and is created inside <I>OleInitialize</I>. If you plan to use the OLE Clipboard, you must use <I>OleInitialize</I> instead of <I>CoInitialize</I>.<I> </I>Failure to do this will cause clipboard operations to fail.</P>
<P>When this window receives WM_RENDERFORMAT, OLE generates calls to <I>IDataObject::QueryGetData</I> (to validate the format) and to <I>IDataObject::GetData</I>.<I> </I>In other words, OLE provides delayed clipboard rendering by means of data objects. Delayed rendering, however, means that the source must make a snapshot of the data it places on the clipboard so that the data object placed there is not tied to changing information. (I'll treat this subject in more detail momentarily.)</P>
<P>The consumer that pastes data from the clipboard doesn't have to care about complications like this: it just calls <I>OleGetClipboard </I>to obtain an <I>IDataObject </I>pointer for the clipboard.<I> </I>This pointer is not the one the source might have provided; instead, it is an OLE-provided data object made especially for the clipboard.<I> </I>The reason for this is that OLE allows consumers to access clipboard data through this data object regardless of whether the data was copied to the clipboard using OLE.<I> </I>OLE's data object reflects the conceptual state of the Windows clipboard, not the state of any source's data object.</P>
<P>With the data object, the consumer can call the <I>IDataObject </I>members <I>EnumFormatEtc</I>, <I>QueryGetData</I>, and <I>GetData</I>, as it would call the <I>EnumClipboardFormats</I>, <I>IsClipboardFormatAvailable</I>, and <I>GetClipboardData </I>functions in Windows. Through the <I>IDataObject </I>interface, a consumer can access not only the TYMED_HGLOBAL-based data on the Windows clipboard but also any other data based on other mediums that the data source provides itself. When the consumer asks for data through <I>IDataObject::GetData</I>, OLE will either access data from the Windows clipboard itself or simply forward the call to the source's <I>IDataObject</I> interface. So the consumer has access to all the possible data on the clipboard, regardless of whether that data came from an OLE data object or from a non-OLE Windows application. The effort needed to obtain clipboard data through OLE is minimal.</P>
<P>I should mention that OLE's clipboard data object does not implement <I>IDataObject::SetData </I>or any of the advise-related members. Also, its <I>GetDat</I><I>aHere </I>will work only with limited formats.<I> </I>The data object itself exposes only <I>IDataObject </I>and <I>IUnknown</I>, so don't expect anything fancy.</P></font></body></HTML>
