<HTML><HEAD><TITLE>Objects with Multiple Persistence Models</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Objects with Multiple Persistence Models</H2><P>Any object can, as it sees fit, implement multiple persistence models by implementing a combination of the four <I>IPersist</I>*<I> </I>interfaces. However, each of these interfaces is considered mutually exclusive in that a client will use only one of them, depending on the client's prioritization of each model.</P>
<P>Generally speaking, <I>IPersistStorage </I>is the most powerful of the four interfaces, so a client might ask for it first when attempting to save or reload an object. However, storage-based persistence is expensive, so a client might request <I>IPersistStreamInit</I> or <I>IPersistStream</I>, and then <I>IPersistStorage.</I> Or it can give <I>IPersistFile </I>preference over the others.</P>
<P>Regardless of the client's prioritization, it must use only one of the interfaces with any given instance of an object, although it is allowed to use a different interface with different instances. The object must enforce this rule by remembering which interface was used to initialize it. If <I>IPersistStorage::InitNew </I>or <I>IPersistStorage::Load </I>has been called, the object must fail any calls to <I>IPersistStream[Init] </I>and <I>IPersistFile. </I>If <I>IPersistStream[Init]::Load </I>or <I>IPersistStreamInit::InitNew </I>has been called, the object fails calls to <I>IPersistStorage </I>and <I>IPersistFile</I>, and so on.</P>
<P>Remember that an object implementing all of these interfaces can use them to implement each other regardless of what the client does. For example, an implementation of <I>IPersistFile </I>can open a compound file and pass the <I>IStorage</I> pointer to its own <I>IPersistStorage </I>implementation, which may in turn do little more than open streams and pass them to <I>IPersistStream.</I> In this way, objects can support as many persistence models as they like without having a lot of redundant code.</P>
<P>Furthermore, an object's implementations of <I>IPersistStorage </I>and <I>IPersistStream[Init] </I>are completely independent of how the client obtains <I>IStorage </I>and <I>IStream </I>pointers. The client might be passing pieces of a storage hierarchy created on an <I>ILockBytes</I>, or it might pass an <I>IStream </I>implemented on a piece of global memory or some other medium. The object cannot assume that the storage and stream elements refer to a portion of a compound file in which a stream is at least 512 bytes. A stream implemented on a database field may be only 10 bytes by default, so writing 500 bytes of information to it can potentially fail if there is no more memory or no more space in the storage medium. This is why <I>IPersistStorage::InitNew </I>should call <I>IStream::SetSize </I>after opening the stream. This is not necessary with <I>IPersistStream[Init]</I>, however, because the client is responsible for preallocating any streams based on what objects return from <I>IPersistStream::GetSizeMax.</I></P></font></body></HTML>
