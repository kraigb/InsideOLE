<HTML><HEAD><TITLE>Memory Management</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Memory Management</H3><P>Earlier in this chapter, we defined rules for handling out-parameters and in/out-parameters that deal with memory allocation. We learned that OLE specifies that the caller of a function become responsible for the memory involved with those parameters. We also learned that in order to make this work, there has to be a standard allocation mechanism accessible to both object and client so that memory can pass freely between them, even across processes. This mechanism is COM's <I>task memory allocation</I> service, based on the memory management APIs of the underlying system.</P>
<P>The service is provided through an <I>allocator object</I> that supports the single interface <I>IMalloc</I> (which includes <I>IUnknown</I> functions, of course). All components are required to use this service whenever there is a need to exchange allocated memory between components, even across process boundaries.9 Any code in a task accesses this service by calling the API function <I>CoGetMalloc </I>as follows:</P>
<P><BR></P>
<pre><code>HRESULT    hr;<BR>IMalloc   *pIMalloc;<BR><BR>hr=CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc);<BR>//Use IMalloc functions through pIMalloc.<BR>pIMalloc-<I> &gt;</I>Release();</code></pre>
<P><img src="16bit.gif"></P>
<P><I>CoGetMalloc</I> is a function that returns a new interface pointer, so <I>pIMalloc </I>has a reference count on it when you get the pointer back; therefore, remember to call <I>Release </I>when you finish. (You must always pass MEMCTX_TASK as the first argument.)</P>
<P>So what can you do with an allocator? Everything is represented through the <I>IMalloc </I>interface, which is defined as follows:</P>
<P><BR></P>
<pre><code>interface IMalloc : IUnknown<BR>    {<BR>    void * Alloc(ULONG cb);<BR>    void * Realloc(void *pv, ULONG cb);<BR>    void   Free(void *pv);<BR>    ULONG  GetSize(void *pv);<BR>    int    DidAlloc(void *pv);<BR>    void   HeapMinimize(void);<BR>    };</code></pre>
<P>I'll leave it to your intelligence to guess what <I>Alloc</I>, <I>Realloc</I>, <I>Free</I>, <I>GetSize</I>, and <I>HeapMinimize </I>do, mentioning only that all allocations are referred to with a pointer, just as with the C run-time <I>malloc </I>functions. The one function to describe a little further is <I>DidAlloc</I>, which returns 1 if the memory was allocated by the allocator in question, 0 if the memory was not, and <FONT FACE="Symbol">-</FONT>1 if the allocator simply doesn't know.</P>
<P><img src="16bit.gif"></P>
<P>With this service, any piece of code can, at any time, get the task allocator's <I>IMalloc </I>pointer, allocate or free memory, and call <I>IMalloc::Release</I>. You may be required to free out-parameters and in/out-parameters in this way as a client. Usually this can be something of a pain to code, having to call three functions to perform a simple operation. For this reason, OLE includes three helper functions, <I>CoTaskMemAlloc</I>,<I> CoTaskMemFree</I>,<I> </I>and <I>CoTaskMemRealloc</I>, which take the same parameters as the interface functions and internally call <I>CoGetMalloc</I>, the appropriate <I>IMalloc</I> function, and then <I>IMalloc::Release</I>.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>9 When cross-process allocations are involved the marshaling layer in COM takes care of copying object-task allocations into client-task allocations.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
