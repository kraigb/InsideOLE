<HTML><HEAD><TITLE>Implementing an Object Handler</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Implementing an Object Handler</H2><P>Let's now look at a basic handler implementation using HCosmo (Cosmo Handler, found in CHAP19\MCOSMO) as an example. This handler is structured the same as any other in-process module, with <I>DllGetClassObject</I>,<I> DllCanUnloadNow</I>,<I> </I>a class factory (these three items are in HCOSMO.CPP), and an object that implements the correct interfaces (FIGURE.CPP). Its REG file contains only two entries; these are meant to modify the entries of Cosmo in Chapter 18. Specifically, HCosmo changes Cosmo's InprocHandler32 key and removes OLEMISC_RECOMPOSEONRESIZE from Cosmo's MiscStatus bits. With a handler we can recompose directly without having to run the local server at all.</P>
<P>HCosmo implements the handler object by using its own version of the class <I>CFigure</I>,<I> </I>matching the class name we used in Chapter 18's Cosmo. This object creates an instance of the default handler during initialization and obtains <I>IOleObject</I>, <I>IViewObject2</I>, <I>IDataObject</I>, and <I>IPersistStorage </I>pointers from it. HCosmo delegates many function calls to these interfaces and directly exposes the default handler's <I>IOleCache2</I>,<I> IOleCacheControl</I>,<I> </I>and <I>IRunnableObject </I>interfaces (from within <I>CFigure::</I><I>QueryInterface</I>).</P>
<P>HCosmo's purpose in being a handler is to optimize output through <I>IViewObject2::Draw </I>in a minimal sort of way—but in a way that demonstrates the idea nonetheless. To that end, we implement most of <I>IViewObject2 </I>for DVASPECT_CONTENT and DVASPECT_THUMBNAIL, leaving DVASPECT_ICON to the default handler. We implement <I>IOleObject::GetExtent </I>(to call <I>IViewObject2::GetExtent</I>) and <I>IOleObject::DoVerb </I>(to show a message), delegating the remainder of <I>IOleObject</I> to the default handler. We fully implement <I>IPersistStorage </I>as well so we can make copies of the object. In addition, all of the member functions in this interface call the default handler so it can maintain the cache properly. This implementation of <I>IPersistStorage </I>also handles conversion and emulation for Polyline figure data.1</P>
<P>The other interesting part of the <I>CFigure </I>class in HCosmo is that it implements <I>IAdviseSink </I>so that it can receive notifications from Cosmo itself. This interface is not exposed to the container but is connected explicitly to the local object when it becomes a running object. We'll see later why this is important.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 It does not implement OLE 1 conversion and emulation support, however.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
