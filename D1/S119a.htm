<HTML><HEAD><TITLE>Low-Memory Save As and IRootStorage</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Low-Memory Save As and <I>IRoo</I><I>tStorage</I></H3><P>A typical Save operation with a compound file is usually a matter of committing changes and writing memory information into the necessary streams. OLE's implementation of compound files is quite robust under low-memory conditions in that <I>Commit </I>uses no extra memory. Microsoft went to great lengths to make <I>Commit </I>this robust because the only thing an end user really cares about when memory is full is saving data.</P>
<P>Although there's no trouble with a Save operation, a low-memory Save As presents a different problem. When using a transacted compound file, the user's data is split between the original storage contents and a bunch of uncommitted changes being held in a temporary file. To save this information in another storage, the application must call <I>IStorage::CopyTo</I>, which copies the current state of the original storage to the new one, including uncommitted changes. However, <I>CopyTo </I>could not be written to use no extra memory, so there is the possibility that <I>CopyTo </I>will fail, leaving you with a bunch of uncommitted changes to the file you originally opened.</P>
<P><img src="f07dd07b.gif"></P>
<P>In such a situation, you want to be able to take all uncommitted changes that live in memory and all unchanged parts of the storage that still live on disk and write them all to a new storage without taking up any more memory. In other words, you want to make a copy of the original disk file to the new file and then commit the changes into that new file.</P>
<P><img src="f07dd07c.gif"></P>
<P>You can do this by using the <I>IRootStorage</I> interface, which OLE provides alongside <I>IStorage </I>on a root storage object (the one connected to the file underneath). You can obtain a pointer to this interface by calling <I>IStorage::QueryInterface</I>, with <I>IID</I><I>_</I><I>IRootStorage</I> on a storage object from <I>StgOpenStorage</I> or <I>StgCreateDocfile. IRootStorage</I> has one member function, <I>SwitchToFile(pszNewFile)</I>, in which <I>pszNewFile</I> is the name of the new file to associate with the storage object. This function effectively makes a disk copy of the original file and associates your <I>IStorage</I> object internally with that new file. This uses no extra memory and requires no new file handles—hence the reason for the third handle allocated for a transacted compound file. So after <I>SwitchToFile </I>returns, you can call <I>IStorage::Commit</I> to save changes to that new file, again using no extra memory, and perform a successful Save As even under zero memory conditions.</P>
<P><img src="f07dd07d.gif"></P></font></body></HTML>
