<HTML><HEAD><TITLE>Handle Exceptions</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Handle Exceptions</H3><P>Now that you understand the different scenarios for making calls to <I>IDispatch::Invoke</I>, we can look at what happens after <I>Invoke </I>returns. If a call returns NOERROR, everything worked, and you can use the contents of the VARIANT that contains the value of a property get or the return value of a method call. In addition, you can use whatever values might be contained in out-parameters.</P>
<P><I>Invoke</I>,<I> </I>of course, can return many different errors, for example, DISP_E_TYPEMISMATCH. For any error other than DISP_E_EXCEPTION, you should have the controller display meaningful error messages and give the user guidance as to how to fix the problem.</P>
<P>If a call returns DISP_E_EXCEPTION, the object itself has chosen to provide you with the necessary information about the problem in the EXCEPINFO<I> </I>structure you passed it. (Of course, if you didn't pass this structure, you cannot obtain exception information.) A controller that receives this information and wants to display it to the user should perform the following steps; each field mentioned is part of EXCEPINFO:</P>
<P>Check whether the <I>pfnDeferredFillIn</I> is non-NULL. If so, call that function passing your EXCEPINFO<I> </I>structure again.3</P>
<P>Format a message string containing the source of the error (the value of the ProgID in <I>bstrSource</I>), the error code (either <I>wCode </I>or <I>scode</I>), and the description of the exception (<I>bstrDescription</I>). A typical format is "Error &lt;code&gt; in &lt;source name&gt;: &lt;description&gt;". The <I>scode </I>field is valid only when <I>wCode </I>is 0, and it is best to format <I>wCode </I>in decimal but <I>scode </I>in hexademical. As you probably know by now, SCODEs are far easier to read in hex.</P>
<P>Display the message in a message box with at least the MB_OK and MB_ICONEXCLAMATION styles, as shown in Figure 15-2. If the <I>bstrHelpFile </I>field is non-NULL, however, also include a Help button. Under Windows 3.1 and Windows NT 3.5, doing this requires that you make your own dialog box template. Blech!  Under Windows 95 and later versions of Windows NT, you can use a new style, MB_HELP, which gets <I>MessageBox </I>to include the Help button.</P>
<P>If the user clicks the Help button, you must launch <I>WinHelp</I> with the full pathname for <I>bstrHelpFile </I>along with the context ID <I>dwHelpContext. </I>This is where the HELPDIR<B> </B>we read from the registry earlier in this chapter comes into play. If we are able to read a help directory, we can assume that the object does not put a full path in the <I>bstrHelpFile </I>field. Therefore, we must prepend HELPDIR<B> </B>to <I>bstrHelpFile </I>to form the path to send to <I>WinHelp</I>. If we were not able to read a directory name earlier, we can only assume that the object has put the full path in <I>bstrHelpFile </I>and should send it unmodified to <I>WinHelp</I>.</P>
<P>Free <I>bstrSource</I>, <I>bstrDescription</I>, and <I>bstrHelpFile</I> with calls to <I>SysFreeString</I>.</P>
<P>        <img src="f15dd02p.gif"></P>
<P><B>    Figure 15-2.</B></P>
<P><B>    A typical controller display of an exception.</B></P>
<P>In AutoCli, most of the code in the helper function <I>CApp::Invoke </I>is for the single purpose of handling exceptions. You can see in the following code that AutoCli implements each of the steps mentioned previously:</P>
<P><BR></P>
<pre><code>HRESULT CApp::Invoke(DISPID dispID, WORD wFlags, DISPPARAMS *pdp<BR>    , VARIANT *pva, EXCEPINFO *pExInfo, UINT *puErr)<BR>    {<BR>    HRESULT     hr;<BR>    LPTSTR      pszMsg=NULL;<BR>    LPTSTR      pszFmt=NULL;<BR>    UINT        uRet;<BR>    UINT        uStyle;<BR>    TCHAR       szSource[80];<BR><BR>    if (NULL==m_pIDispatch)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    hr=m_pIDispatch-&gt;Invoke(dispID, IID_NULL, m_lcid, wFlags<BR>        , pdp, pva, pExInfo, puErr);<BR><BR>    if (DISP_E_EXCEPTION!=GetScode(hr))<BR>        return hr;<BR><BR>    //If we're given a deferred filling function, fill now.<BR>    if (NULL!=pExInfo-&gt;pfnDeferredFillIn)<BR>        (*pExInfo-&gt;pfnDeferredFillIn)(pExInfo);<BR><BR>    //Go get the real source name from ProgID.<BR>    lstrcpy(szSource, TEXT("Unknown"));<BR><BR>    if (NULL!=pExInfo-&gt;bstrSource)<BR>        {<BR>        LONG    lRet;<BR><BR>        //If this doesn't work, we'll have "Unknown" anyway.<BR>        RegQueryValue(HKEY_CLASSES_ROOT, pExInfo-&gt;bstrSource<BR>            , szSource, &amp;lRet);<BR><BR>        SysFreeString(pExInfo-&gt;bstrSource);<BR>        }<BR><BR>    if (NULL!=pExInfo-&gt;bstrDescription)<BR>        {<BR>        pszFmt=(LPTSTR)malloc(CCHSTRINGMAX*sizeof(TCHAR));<BR>        pszMsg=(LPTSTR)malloc((CCHSTRINGMAX+lstrlen(szSource)<BR>            +lstrlen(pExInfo-&gt;bstrDescription))*sizeof(TCHAR));<BR><BR>        if (0==pExInfo-&gt;wCode)<BR>            {<BR>            //Formatting for SCODE errors<BR>            LoadString(m_hInst, IDS_MESSAGEEXCEPTIONSCODE, pszFmt<BR>                , CCHSTRINGMAX);<BR>            wsprintf(pszMsg, pszFmt, (long)pExInfo-&gt;scode<BR>                , (LPTSTR)szSource<BR>                , (LPTSTR)pExInfo-&gt;bstrDescription);<BR>            }<BR>        else<BR>            {<BR>            //Formatting for wCode errors<BR>            LoadString(m_hInst, IDS_MESSAGEEXCEPTION, pszFmt<BR>                , CCHSTRINGMAX);<BR>            wsprintf(pszMsg, pszFmt, (UINT)pExInfo-&gt;wCode<BR>                , (LPTSTR)szSource<BR>                , (LPTSTR)pExInfo-&gt;bstrDescription);<BR>            }<BR><BR>        free(pszFmt);<BR>        }<BR>    else<BR>        {<BR>        pszMsg=(LPTSTR)malloc(CCHSTRINGMAX*sizeof(TCHAR));<BR>        LoadString(m_hInst, IDS_MESSAGEUNKNOWNEXCEPTION, pszMsg<BR>            , CCHSTRINGMAX);<BR>        }<BR><BR>    uStyle=MB_OK œ MB_ICONEXCLAMATION;<BR><BR>   #ifdef MB_HELP<BR>    uStyle œ=(NULL!=pExInfo-&gt;bstrHelpFile) ? MB_HELP : 0;<BR>   #else<BR>    uStyle œ=(NULL!=pExInfo-&gt;bstrHelpFile) ? MB_OKCANCEL : 0;<BR>   #endif<BR><BR>    //CApp::Message(string, style) displays message box.<BR>    uRet=Message(pszMsg, uStyle);<BR><BR>    if (NULL!=pszMsg)<BR>        free(pszMsg);<BR><BR>   #ifdef MB_HELP<BR>    if (IDHELP==uRet)<BR>   #else<BR>    if (IDCANCEL==uRet)<BR>   #endif<BR>        {<BR>        TCHAR       szHelp[512];<BR><BR>        if ((TCHAR)0!=m_szHelpDir[0])<BR>            {<BR>            wsprintf(szHelp, TEXT("%s\\%s"), m_szHelpDir<BR>                , pExInfo-&gt;bstrHelpFile);<BR>            }<BR>        else<BR>            lstrcpy(szHelp, pExInfo-&gt;bstrHelpFile);<BR><BR>        WinHelp(NULL, szHelp, HELP_CONTEXT, pExInfo-&gt;dwHelpContext);<BR>        }<BR><BR>    SysFreeString(pExInfo-&gt;bstrDescription);<BR>    SysFreeString(pExInfo-&gt;bstrHelpFile);<BR><BR>    return ResultFromScode(DISP_E_EXCEPTION);<BR>    }</code></pre>
<P>This code conditionally compiles use of the MB_HELP style for versions of Windows that support the flag (Windows 95 and Windows NT 3.51). If you compile for earlier versions of Windows, cheat and use a Cancel button instead of a Help button because you do not want to complicate this sample with a custom dialog box that would have to dynamically resize itself based on the message length, something <I>MessageBox</I> does automatically.4 </P>
<P>The two strings used to format the messages are defined in an AUTOCLI.RC stringtable as "Error %u in %s: %s" (for <I>wCode </I>errors) and "Error %lX in %s: %s" (for <I>scode </I>errors). If there isn't a <I>bstrDescription </I>string, AutoCli uses a generic error message—"An unspecified error occurred in the automation object." This is generic because we have only one object: a more complete controller would probably have another name for the object (instead of "automation object") that it could put in such a message.</P>
<P><B>Note:</B><B> </B> If you run AutoCli with Beeper 2, 3, 4, or 5 and then try to run AutoCli with Beeper1, viewing the help file will not work. The reason is that AutoCli uses the presence of HELPDIR in the registry to determine whether it should prepend a path to bstrHelpFile before calling WinHelp. If you register the entries for any of the later Beeper samples, you will create the necessary TypeLib entries, including HELPDIR. If you then register Beeper1 again, those entries will still exist, causing AutoCli to attempt to prepend a path to the full help file path already specified in bstrHelpFile. Swapping registry versions for objects will not happen like this in real practice. If you run into this, you'll have to hack out the TypeLib entries for Beeper by hand.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>3 If the controller supports error objects, it can query the automation object for <I>ISupportErrorInfo</I> and call <I>ISupportErrorInfo::InterfaceSupportsErrorInfo </I>to check for available error information in an error object. If any is, the controller can then call <I>GetErrorInfo </I>and various <I>IErrorInfo </I>members to retrieve that exception information. Note that AutoCli does not demonstrate this process.</P></TD></TR><TR><TD VALIGN="TOP"><P>4 If you've ever hit a general protection fault under Windows NT, you'll see a similar use of the Cancel button, which starts WinDebug to look at the location of the fault.  The message in the dialog box says that Cancel starts the debugger, but I've always found that a little confusing. A Debug button would be better. But <I>MessageBox </I>is designed to work under very low memory con-ditions, whereas a custom dialog box is not. Therefore, it is in the best interest of the system to display the message even under the worst possible conditions, and because Windows NT 3.5 doesn't have the MB_HELP style, MB_CANCEL is the next best thing. If you really want to, you can probably get away with using Cancel in the same way, but you should put some sort of message in the message box indicating that clicking Cancel will bring up the appropriate help. It's best, however, to make a real Help button if you can.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
