<HTML><HEAD><TITLE>The Decaffeinated Alternative</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Decaffeinated Alternative</H3><P>If we had the luxury of designing Patron for a closed system (one in which no one ever copies files off the system), we would save an enormous amount of trouble by writing all our data structures into various files in a directory tree:</P>
<UL><LI>The "document" would be a base directory, named as any other document would be, and all the information in that directory would be considered part of the document. In this directory are files that contain the "file header" information: the count of pages, the name (subdirectory of the first page), and printer configuration.</LI><LI>Each page is itself a subdirectory named PAGE<I>nnnn.nnn </I>(under the "document" directory), which would allow up to 10 million pages per document. No problem. Each page directory contains files with the page information, such as the names of tenants. (This eliminates the need to manage the offsets to them.)</LI><LI>Each tenant is itself a subdirectory named TEN<I>nnnnn.n</I><I>nn </I>(100 million per page), which allows the tenant to create any files it wants and to store any information within that directory. This would even make it easy for other applications to manage the tenants because those other applications could easily write information into this directory.</LI></UL><P>Overall, this promising scheme would look like the layout shown in Figure 7-5. To add a page or a tenant, we create another subdirectory off the appropriate directory and write its specific files. Deleting a page or a tenant is as simple as deleting a directory. In both cases, we let the file system worry about free space, garbage collection, and defragmentation. We inherently let the end users control overall performance by their choice of underlying file system and defragmentation tools. More power to them!</P>
<P>    <img src="f07dd05.gif"></P>
<P><B>Figure 7-5.</B></P>
<P><B>A possible Patron storage scheme using directories.</B></P>
<P>And, even better, incremental access, for saving <I>and </I>loading information, is always the primary mode of operation. Changing the contents of one tenant means rewriting a part of a single file without bothering anything else in the entire "document." Reading in the contents of a tenant, or retrieving the count of pages in the document, requires us to access only a few relevant files in the right place in the hierarchy, all of which can be done very fast. Overall, this incremental capability means that we probably never have to rewrite the entire file, even to change its name. (We can just rename the base directory.)</P>
<P>But there is a snag: someone kindly points out that this design assumes a closed system, a far cry from anything our customers are using. Reality check! End users will despise having the information for a single "document," as they understand it, be spread around a bunch of directories, meaning that they have to do complicated backup procedures to simply copy a document to a network location or send it to a colleague in a piece of e-mail. We're reminded that an application implemented this way will sell about as well as Double Tall Macho Grande <I>Decaffeinated </I>Latte in downtown Seattle. That is, not at all. So now what?</P></font></body></HTML>
