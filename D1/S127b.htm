<HTML><HEAD><TITLE>The General Property Set Layout</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The General Property Set Layout</H3><P>At the highest level, a property set is composed of three major pieces, illustrated in Figure 16-5. These pieces are a property set header, a list of FMTID/Offset pairs identifying sections (each offset points to the location of a separate section from the beginning of the stream), and the serialized sections themselves. When a property set has only a single format, as Summary Information does, there is only one FMTID/Offset pair and only one section.</P>
<P>    <img src="f16dd05.gif"></P>
<P><B>Figure 16-5.</B></P>
<P><B>The top-level property set layout.</B></P>
<P>A property set structure is thus defined generically as follows. (This is not an actual structure but simply a model of the property set layout.)</P>
<P><BR></P>
<pre><code>struct<BR>    {<BR>    PROPHEADER        ph;<BR>    FORMATIDOFFSET    rgFIDO[cSections];<BR>    PROPERTYSECTION   rgSections[cSections];<BR>    };</code></pre>
<P>You can see that a property set is a header followed by an array of FMTID/Offset pairs followed by an array of sections. Both arrays have the same number of elements. The PROPHEADER structure itself is defined as follows:3</P>
<P><BR></P>
<pre><code>typedef struct<BR>    {<BR>    WORD    wByteOrder ; // Always 0xFFFE<BR>    WORD    wFormat ;    // Always 0<BR>    DWORD   dwOSVer ;    // System version<BR>    CLSID   clsID ;      // Source CLSID<BR>    DWORD   cSections ;  // Number of sections (must be at least 1)<BR>    } PROPHEADER;</code></pre>
<P>The <I>wByteOrder </I>field indicates whether the property set is written in big endian or little endian. The OLE specifications state that all property sets must be written in little-endian (Intel) ordering. This means that the value 0xFFFE appears in the stream as 0xFE and 0xFF—in that exact order—regardless of the originating operating system stored in <I>dwOSVer</I>. Currently this can be 0 for 16-bit Windows, 1 for the Macintosh, or 2 for 32-bit Windows. (Other system codes will be added as necessary.)</P>
<P>As indicated in the structure, the <I>wFormat </I>version number is always 0 for the specification of property sets defined here. If someone creates a new general property set layout that is different from the one described here, <I>wFormat </I>will contain another value. Code that reads a property set must always check this value to read the rest of the stream robustly. Either the CLSID field identifies the code that knows how to read and display the information in this property set, or it contains the FMTID of the property set itself if only one format is contained within it. For example, because Summary Information is defined to be generic across many applications, its FMTID will always appear here.</P>
<P>Finally, the <I>cSections </I>field defines how many FMTID/Offset pairs exist following this header, and this defines the number of overall sections. Each pair is a structure of the following sort:</P>
<P><BR></P>
<pre><code>typedef struct<BR>    {<BR>    GUID        formatID;<BR>    DWORD       dwOffset;<BR>    } FORMATIDOFFSET;</code></pre>
<P>Again, the offset in each pair is a seek offset from the beginning of the entire property set stream to the beginning of a section. We can see why a piece of code attempting to read a property set can safely ignore sections it doesn't understand—for example, new extensions to an existing property set. If the reader doesn't recognize the FMTID in a given pair, it can simply read the next pair to see whether that one makes sense. Whenever this code finds a format it does understand, it can seek to the offset of that section and read its contents.</P>
<H4><A NAME="sec0"></A>The Section Layout</H4><P>At any given section offset, you'll find a header and PID/Offset pairs. Each offset points to a property in the bytes that follow. Furthermore, each property is a type/value pair in which the real data is stored. This structure is similar to the property set structure itself, as shown in Figure 16-6.</P>
<P>    <img src="f16dd06.gif"></P>
<P><B>Figure 16-6.</B></P>
<P><B>The section layout nested within a property set.</B></P>
<P>You can look at a section through a generic structure, as we did for the entire property set:</P>
<P><BR></P>
<pre><code>struct<BR>    {<BR>    SECTIONHEADER     sh;<BR>    PROPERTYIDOFFSET  rgPIDO[cProperties];<BR>    PROPERTY          rgProperties[cProperties];<BR>    };</code></pre>
<P>The SECTIONHEADER structure has only two fields. One describes the size of the section as a whole, and the second describes the number of properties within it. Together they describe the size of the PID/Offset list that follows it in the stream:</P>
<P><BR></P>
<pre><code>typedef struct<BR>    {<BR>    DWORD       cbSection ;<BR>    DWORD       cProperties ;<BR>    } SECTIONHEADER;</code></pre>
<P>Having the size of the section first allows anyone either to skip over this section entirely or to copy it wholesale from the stream without having to know anything more about the contents of the section. When someone is interested in the internals of the section, he or she can look at the properties it contains by using the list of PROPERTYIDOFFSET structures:</P>
<P><BR></P>
<pre><code>typedef struct<BR>    {<BR>    DWORD       propertyID;<BR>    DWORD       dwOffset;<BR>    } PROPERTYIDOFFSET;</code></pre>
<P>Just as code that is reading a property set can skip unrecognized FMTIDs in the property set structure, code can skip unrecognized PIDs contained in this list in the section structure. Once again, if the reading code doesn't recognize the PID, it simply reads the next one. The code attempts to extract information for a property only when it understands the PID in the context of the FMTID. It then seeks to the offset written after the PID and at the offset finds information that it can use. Note that all properties must begin on a 32-bit boundary within the stream; extra zeros pad the leftover bytes.</P>
<H4><A NAME="sec1"></A>The Property Type/Value Layout</H4><P>When you get to the bottom of a property set, you're faced with a variable length structure that contains the data type of the property and the bytes that make up its value:</P>
<P><BR></P>
<pre><code>struct<BR>    {<BR>    DWORD      dwType;     //From VARTYPE<BR>    BYTE       rgbValue[cbValue];<BR>    };</code></pre>
<P>The type is always described with some VT_* value from the VARTYPE enumeration that we saw in Chapter 14. This type is followed by the number of bytes appropriate for the type. If <I>dwType </I>is VT_I2, the next 2 bytes contain the value. If the type is VT_BSTR, the bytes contain a character count followed by the characters. Other types, such as VT_BLOB and VT_STORAGE_OBJECT, also have a specific format of the bytes that follow. Any type combined with VT_VECTOR specifies that an array of that type follows, in which the first DWORD specifies the number of elements and the bytes that follow contain the elements themselves. (Each element is aligned to a DWORD boundary, which matters only for VT_I2 and VT_BOOL because all other types are naturally DWORD aligned.) The list of available types and their data formats, taken from the <I>OLE Programmer</I><I>'</I><I>s Reference,</I> is given in Table 16-1 beginning on the following page.</P>
<P>For various reasons, there is no provision for adding new VT_* values to define new types—that is, new data structures. Say you want to store a structure such as PARSNIP, as shown in the following:</P>
<P><BR></P>
<pre><code>typedef struct<BR>    {<BR>    short      Lengthcm;   //Length in centimeters<BR>    short      Radiuscm;   //Top radius in centimeters<BR>    short      Weightg;    //Weight in grams<BR>    COLORREF   Shade;      //Exact color shade<BR>    } PARSNIP;</code></pre>
<P>To do this, you would need to write each field as a separate VARIANT structure and define the entire structure as VT_VARIANT œ VT_VECTOR. In the stream, you would have the following:</P>
<P><BR></P>
<pre><code>DWORD = VT_VARIANT œ VT_VECTOR11<BR>DWORD = 4 (Count of elements)<BR>DWORD = VT_I2  (Element 1)<BR>WORD  = Lengthcm value<BR>DWORD = VT_I2  (Element 2)<BR>WORD  = Radiuscm value<BR>DWORD = VT_I2  (Element 3)<BR>WORD  = Weightg value<BR>DWORD = VT_I4  (Element 4)<BR>DWORD = Shade value (32-bit COLORREF)<BR>WORD  = 0 (padding to DWORD align)</code></pre>
<P>Two special properties always have the same PID regardless of the property set. PID 0 is defined as a dictionary that maps other PID values to user-readable strings, as described in the next section. PID 1 is a code page indicator (VT_I2) identifying the character set in which strings are stored, depending on the originating operating system.4 Programs that don't understand the code page should not attempt to read any string-oriented data in the section. Modifying a code page property means that you must also modify all other string properties in the section according to the new code page. If no code page is present, the program must assume the system default code page.</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="147pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="147pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Type</B></P></TD><TD VALIGN="TOP"><P><B>Value</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>VT_EMPTY</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>None. A property set with a type indicator of VT_EMPTY has no data associated with it. The size of the value is 0. </P></TD></TR><TR><TD VALIGN="TOP"><P>VT_NULL</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>None. This is like a pointer to NULL.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_I2</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2-byte signed integer value zero-padded to a 32-bit boundary.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_I4</P></TD><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>4-byte signed integer value.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_R4</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>4-byte 32-bit IEEE floating-point value.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_R8</P></TD><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>8-byte 64-bit IEEE floating-point value.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_CY</P></TD><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>8-byte two's complement integer (scaled by 10,000) as commonly used for  currency amounts.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_DATE</P></TD><TD VALIGN="TOP"><P>7</P></TD><TD VALIGN="TOP"><P>64-bit time format, a floating-point number representing seconds since January 1, 1900. This is stored in the same representation as VT_R8.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_BSTR</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>Counted, zero-terminated binary string; represented as a DWORD byte count (including the terminating null character) followed by the bytes of data.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_BOOL</P></TD><TD VALIGN="TOP"><P>11</P></TD><TD VALIGN="TOP"><P>2 bytes representing a Boolean (WORD) value containing 0 (FALSE) or <FONT FACE="Symbol">-</FONT>1 (TRUE), zero-padded to a 32-bit boundary.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_VARIANT (only with VT_VECTOR)</P></TD><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>DWORD type indicator followed by the corresponding value.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_I8</P></TD><TD VALIGN="TOP"><P>20</P></TD><TD VALIGN="TOP"><P>8-byte signed integer.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_LPSTR</P></TD><TD VALIGN="TOP"><P>30</P></TD><TD VALIGN="TOP"><P>Same as VT_BSTR; used for most strings.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_LPWSTR</P></TD><TD VALIGN="TOP"><P>31</P></TD><TD VALIGN="TOP"><P>A counted and zero-terminated Unicode string; a DWORD character count (in which the count includes the terminating null character) followed by the same number of Unicode (16-bit) characters. The count is not a byte count but a WORD count.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_FILETIME</P></TD><TD VALIGN="TOP"><P>64</P></TD><TD VALIGN="TOP"><P>64-bit FILETIME structure as defined in Win32.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_BLOB</P></TD><TD VALIGN="TOP"><P>65</P></TD><TD VALIGN="TOP"><P>DWORD count of bytes, followed by the same number of bytes of data. The byte count does not include the 4 bytes for the length of the count itself; an empty BLOB would have a count of 0, followed by 0 bytes. This is similar to VT_BSTR, but it does not guarantee a null byte at the end of the data.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_STREAM</P></TD><TD VALIGN="TOP"><P>66</P></TD><TD VALIGN="TOP"><P>A VT_LPSTR (DWORD count of bytes followed by a zero-terminated string of the same number of bytes); it names a stream containing the actual property value. The stream is a sibling of the stream holding this type indicator; this stream must be named "CONTENTS".</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_STORAGE</P></TD><TD VALIGN="TOP"><P>67</P></TD><TD VALIGN="TOP"><P>A VT_LPSTR (DWORD count of bytes followed by a zero-terminated string of the same number of bytes); it names a substorage that contains the real property value. The substorage is a sibling of the stream containing this type. The stream itself must be named "CONTENTS".</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_STREAMED_OBJECT</P></TD><TD VALIGN="TOP"><P>68</P></TD><TD VALIGN="TOP"><P>Same as VT_STREAM (same requirements) but indicates that the named stream contains a serialized object, which is a CLSID followed by initialization data for the class. The object can be instantiated with <I>OleLoadFromStream.</I></P></TD></TR><TR><TD VALIGN="TOP"><P>VT_STORED_OBJECT</P></TD><TD VALIGN="TOP"><P>69</P></TD><TD VALIGN="TOP"><P>Same as VT_STORAGE (same requirements) but indicates that the named substorage contains an object that can be loaded through <I>OleLoad</I> or <I>Read-ClassStg </I>and <I>IPersistStorage::Load.</I></P></TD></TR><TR><TD VALIGN="TOP"><P>VT_BLOB_OBJECT</P></TD><TD VALIGN="TOP"><P>70</P></TD><TD VALIGN="TOP"><P>An array of bytes containing a serial-ized object in the same representation as would appear in a VT_STREAMED_OBJECT (VT_LPSTR). The only significant difference between this type and VT_STREAMED_OBJECT is that VT_BLOB_OBJECT does not have the system-level storage overhead that VT_STREAMED_OBJECT has. VT_BLOB_OBJECT is more suitable for scenarios involving numerous small objects.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_CF</P></TD><TD VALIGN="TOP"><P>71</P></TD><TD VALIGN="TOP"><P>An array of bytes containing a clipboard format identifier followed by the data in that format. In other words, following the VT_CF identifier is the data in the format of a VT_BLOB. This is a DWORD count of bytes followed by the indicated number of bytes of data. A LONG followed by an appropriate clipboard identifier and a property whose value is plain text should use VT_LPSTR, not VT_CF, to represent the text. Also, an application should choose a single clipboard format for a property's value when using VT_CF.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_CLSID</P></TD><TD VALIGN="TOP"><P>72</P></TD><TD VALIGN="TOP"><P>A CLSID, which is a DWORD, two WORDs, and 8 bytes.</P></TD></TR><TR><TD VALIGN="TOP"><P>VT_VECTOR</P></TD><TD VALIGN="TOP"><P>0x1000</P></TD><TD VALIGN="TOP"><P>If the type indicator is one of the previous values in addition to this bit being set, the value is a DWORD count of elements followed by the indicated number of repetitions of the value. When VT_VECTOR is combined with VT_VARIANT (VT_VARIANT must be combined with VT_VECTOR), the value contains a DWORD element count, a DWORD type indicator, the first value, a DWORD type indicator, the second value, and so on. Examples: VT_LPSTR œ VT_VECTOR has a DWORD element count, a DWORD byte count, the first string data, a DWORD byte count, the second string data, and so on. VT_I2 œ VT_VECTOR has a DWORD element count followed by a sequence of 2-byte integers, with no padding between them.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 16-1</B></P>
<P><B>OLE property types that can appear in property sets.</B></P>
<H4><A NAME="sec2"></A>Dictionaries</H4><P>As mentioned earlier, the property with PID 0 is always an optional dictionary that is generically defined as the following structure:</P>
<P><BR></P>
<pre><code>struct<BR>    {<BR>    DWORD    cEntries;<BR>    ENTRY    rgEntry[cEntries];<BR>    };</code></pre>
<P>Each entry is a structure containing the PID along with what is essentially a BSTR:</P>
<P><BR></P>
<pre><code>struct<BR>    {<BR>    DWORD    propertyID;<BR>    DWORD    cbName;          //Includes the null terminator<BR>    char     szName[cbName];<BR>    };</code></pre>
<P>The count of entries in a dictionary is the one exception to the usual property structure of a type/value pair. The count of entries in the dictionary sits in the place of the type indicator. In addition, if a dictionary exists, it must contain at least one entry describing PID 0 with the name of the property set itself. Other than that, a dictionary can contain any entries it wants, and it doesn't need to include entries for every last property in the rest of the set. Some PIDs are implicitly understood by any other code that knows how to read the set in the first place.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>3 This structure and those that follow are (unless noted otherwise) taken from the source code for the OLE Control Development Kit (CDK) shipped with Visual C++ 2.0. You won't find this structure and the others in any standard OLE header file, only in places that implement a property set. The CDK happens to be one of those places; it also includes some convenient classes for working with property sets.</P></TD></TR><TR><TD VALIGN="TOP"><P>4 See the Win32 <I>GetACP </I>function for legal values for Windows-originated properties. For the Macintosh, see <I>Inside Macintosh Volume VI </I><I>§</I><I>14-111,</I> Addison-Wesley, 1991.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
