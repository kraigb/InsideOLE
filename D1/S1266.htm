<HTML><HEAD><TITLE>Initialization</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Initialization</H3><P>At some point in executing a script, a controller will have to create the automation object that it wants to drive. This usually happens through <I>CoCreateInstance</I>, but it might occur through other means, such as binding a file moniker. For whatever reason, the controller will want to obtain information about the object and its environment for use when invoking methods and properties.</P>
<P>AutoCli instantiates the currently installed Beeper object during startup (after calling <I>CoInitialize</I>, of course). This example is somewhat contrived—AutoCli runs one script, which creates the object on startup, invokes methods and properties based on menu selections, and then destroys the object on shutdown. Controllers that are programming tools will generally create, manipulate, and destroy objects while running a script. Other controllers might perform the same action in response to various user commands. No matter how the controller is designed, it must create the object at some point, as AutoCli does in <I>CApp::Init </I>(AUTOCLI.CPP):</P>
<P><BR></P>
<pre><code>hr=CoCreateInstance(CLSID_Beeper, NULL, CLSCTX_INPROC_SERVER<BR>    , IID_IDispatch, (PPVOID)&amp;m_pIDispatch);</code></pre>
<P>If this call fails, AutoCli displays a message and terminates. Obviously, this isn't the most friendly way for an application to behave, but because AutoCli cannot continue without a Beeper, it is appropriate here. A more general purpose controller would encounter this sort of error only when trying to execute a script, in which case it would inform the user of the error and perhaps give possible solutions to the problem.</P>
<P>After successfully creating the object, AutoCli loads the object's HELPDIR<B> </B>value from its TypeLib registry entries. (This is the directory in which the object installed any help files that might be named in an exception.) The <I>HelpDirFromCLSID</I> function accomplishes this; it is written to be a stand-alone piece of code that you can cut and paste.</P>
<P><BR></P>
<pre><code>void HelpDirFromCLSID(CLSID clsID, LPTSTR pszPath)<BR>    {<BR>    TCHAR       szCLSID[80];<BR>    TCHAR       szKey[512];<BR>    UINT        cch;<BR>    long        lRet;<BR><BR>    if (NULL==pszPath)<BR>        return;<BR><BR>    *pszPath=0;<BR><BR>    cch=sizeof(szCLSID)/sizeof(TCHAR);<BR>    StringFromGUID2(clsID, szCLSID, cch);<BR>    wsprintf(szKey, TEXT("CLSID\\%s\\TypeLib"), szCLSID);<BR><BR>    //Get LIBID from under CLSID.<BR>    if (ERROR_SUCCESS==RegQueryValue(HKEY_CLASSES_ROOT, szKey<BR>        , szCLSID, &amp;lRet))<BR>        {<BR>        //Get HELPDIR from under TypeLib.<BR>        wsprintf(szKey, TEXT("TypeLib\\%s\\HELPDIR"), szCLSID);<BR>        RegQueryValue(HKEY_CLASSES_ROOT, szKey, pszPath, &amp;lRet);<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>In your own code, you'll probably want the object's type information, at least for its dispinterface. Although AutoCli doesn't demonstrate this, a quick call to <I>IDispatch </I>will get you the <I>ITypeInfo </I>you want:</P>
<P><BR></P>
<pre><code>ITypeInfo *pITypeInfoDispInt;<BR>UINT       cTypeInfo;<BR><BR>if (SUCCEEDED(pIDispatch-&gt;GetTypeInfoCount(&amp;cTypeInfo)))<BR>    pIDispatch-&gt;GetTypeInfo(0, lcid, &amp;pITypeInfoDispInt);</code></pre>
<P>If you want to get the object's type information for the purpose of looking at both its incoming and outgoing interfaces, you can try using the <I>IProvideClassInfo</I> interface:</P>
<P><BR></P>
<pre><code>IProvideClassInfo   *pIPCI;<BR>ITypeInfo           *pITypeInfoObject;<BR><BR>if (SUCCEEDED(pIDispatch-&gt;QueryInterface(IID_IProvideClassInfo<BR>    , (void**)&amp;pIPCI)))<BR>    {<BR>    pIPCI-&gt;GetClassInfo(&amp;pITypeInfoObject);<BR>    pIPCI-&gt;Release();<BR>    }</code></pre>
<P>Another alternative is to use <I>ITypeInfo::GetContainingTypeLib </I>and <I>ITypeInfo::GetTypeInfoOfGUID</I>,<I> </I>which would look like the following, assuming you have <I>pITypeInfoDispInt</I> from the code above:</P>
<P><BR></P>
<pre><code>ITypeLib     *pITypeLib;<BR>ITypeInfo    *pITypeInfoObject;<BR><BR>if (SUCCEEDED(pITypeInfoDispInt-&gt;GetContainingTypeLib(&amp;pITypeLib, 0)))<BR>    {<BR>    pITypeLib-&gt;GetTypeInfoOfGUID(CLSID_Beeper, &amp;pITypeInfoObject);<BR>    pITypeLib-&gt;Release();<BR>    }</code></pre>
<P>There is one more little snag: in the previous call to <I>IDispatch::GetTypeInfo</I> is that little <I>lcid</I> parameter. We need a locale to pass to most of the <I>IDispatch</I> functions, especially <I>GetIDsOfNames</I>. With AutoCli, we always use basic English with LANGID_ENGLISH and SUBLANGID_NEUTRAL. The LCID<I> </I>for this is stored in the variable <I>m</I><I>_</I><I>lcid</I> in the application's constructor, <I>CApp::CApp</I>, and is passed later to <I>IDispatch</I> members.</P>
<P>AutoCli uses English because the method and property names that it employs elsewhere are hard-coded for English. Obviously, this isn't the best solution for a general purpose controller.</P>
<P>A better solution is to load the current user language with <I>GetUserDefaultLCID</I>. This is best for creating new scripts for the controllers; the user probably wants to work in his or her national language whenever possible. You might also want to allow some way for the user—who may be a developer—to specify the use of a neutral language, especially if that person is writing a script that is expected to be executed in different countries using different languages.</P>
<P>In either case, when a controller saves a script, it should also save the LCID under which a script was written because it is likely that the names of methods and properties saved in that script are also expressed in that language. This would allow the controller running under a different language to check whether type information for the original language is available when the script is loaded—a much better solution than telling the user that a name cannot be resolved at run time because it's in the wrong language (which isn't necessarily known at run time).</P>
<P>Now that we have the information necessary for driving an object, we can invoke the object's methods and properties. When we're finished with the object, we simply call <I>IDispatch::Release</I>, and the object takes care of deleting itself and shutting down its application or unloading its DLL as necessary. And when our program shuts down, it calls <I>CoUninitialize </I>as usual.</P></font></body></HTML>
