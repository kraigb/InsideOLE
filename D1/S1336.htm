<HTML><HEAD><TITLE>The Structure of OLE Controls and Containers</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Structure of OLE Controls and Containers</H3><P>Nearly all of the requirements for both controls and control containers are fulfilled using OLE technologies that we've seen in this book. You can guess that properties are most likely handled through OLE Automation and that events are handled through connection points. The complete list of which technologies satisfy which requirements is shown in Table 24-1.</P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Requirement</B></P></TD><TD VALIGN="TOP"><P><B>OLE Technologies Applied</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Control properties</P></TD><TD VALIGN="TOP"><P>OLE Automation, Property Change Notifications, Property Pages, Connectable Objects (for change notification)</P></TD></TR><TR><TD VALIGN="TOP"><P>Control events</P></TD><TD VALIGN="TOP"><P>OLE Automation, Connectable Objects</P></TD></TR><TR><TD VALIGN="TOP"><P>Control visuals</P></TD><TD VALIGN="TOP"><P>OLE Documents (including in-place activation)</P></TD></TR><TR><TD VALIGN="TOP"><P>Control mnemonics</P></TD><TD VALIGN="TOP"><P>OLE Controls (in-place activation handles accelerators for the UI-active control that has the focus)</P></TD></TR><TR><TD VALIGN="TOP"><P>Control persistence</P></TD><TD VALIGN="TOP"><P>Structured Storage, Object Persistence (any persistence model)</P></TD></TR><TR><TD VALIGN="TOP"><P>Container layout</P></TD><TD VALIGN="TOP"><P>OLE Documents, OLE Drag and Drop</P></TD></TR><TR><TD VALIGN="TOP"><P>Container form persistence</P></TD><TD VALIGN="TOP"><P>Structured Storage, Object Persistence</P></TD></TR><TR><TD VALIGN="TOP"><P>Container ambient properties</P></TD><TD VALIGN="TOP"><P>OLE Automation, OLE Controls</P></TD></TR><TR><TD VALIGN="TOP"><P>Container event handlers</P></TD><TD VALIGN="TOP"><P>OLE Automation, Connectable Objects</P></TD></TR><TR><TD VALIGN="TOP"><P>Container extended objects</P></TD><TD VALIGN="TOP"><P>OLE Controls</P></TD></TR><TR><TD VALIGN="TOP"><P>Container keyboard</P></TD><TD VALIGN="TOP"><P>OLE Controls</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 24-1</B></P>
<P><B>OLE technologies used to create OLE Controls.</B></P>
<P>The entries in Table 24-1 marked "OLE Controls" refer to the specific interfaces and protocols involved only with OLE Controls. The interfaces in question are <I>IOleControl</I>, <I>IOleControlSite</I>, and <I>ISimpleFrameSite.</I></P>
<P>Structurally, an OLE control is a COM object, housed inside a server (as we saw in Chapter 5), that implements the following interfaces in addition to <I>IUnknown</I>:4 <I>IOleObject</I>, <I>IOleIn</I><I>PlaceObject</I>, <I>IOleInPlaceActiveObject </I>(on a subobject if necessary), <I>IOleControl</I>, <I>IDataObject</I>, <I>IViewObject2</I>, <I>IRunnableObject</I>, <I>IExternalConnection </I>(if linking to embeddings is allowed), <I>IOleCache2</I>, <I>IDispatch</I>, <I>IConnectionPointContainer</I>, <I>ISpecifyPropertyPages</I>, <I>IProvideClassInfo</I>, and one or more of <I>IPersistStorage</I>, <I>IPersistStream</I>, or <I>IPersistStreamInit </I>(depending on the necessary persistence models)<I>. </I>Besides implementing these interfaces, a control should also self-register and can optionally support licensing through <I>IClassFactory2</I>. Controls are usually marked with OLEMISC_ACTIVATEWHENVISIBLE, and each must include type information that describes its incoming and outgoing dispinterfaces. In addition, a control's coclass entry in its type information should also be marked with "control." Finally, a control must also support a connection point for each outgoing interface by virtue of implementing <I>IConnectionPointContainer.</I></P>
<P>To the outside world, then, an OLE control appears as shown in Figure 24-1. It should be obvious that implementing an object with this many interfaces, along with type information, self-registration, licensing, and so on, is not exactly a trivial task. Although Microsoft chose to use existing technologies as a base and to provide maximum flexibility, it is up to tools like the CDK to make implementation less complex.</P>
<P>    <img src="f24dd01.gif"></P>
<P><B>Figure 24-1.</B></P>
<P><B>The structure of an in-process OLE control.</B></P>
<P>Much of the implementation of an OLE control is to support OLE Automation and OLE Documents. The same applies to a control container, which, in addition to all of those site interfaces for an in-place–capable container that we've seen up to Chapter 22, implements <I>IOleControlSite</I>, <I>ISimpleFrameSite</I>, and <I>IDispatch </I>on the control site as well. (<I>IDispatch </I>exposes the container's ambient properties.) In addition, a site provides sink objects for however many event sets a control has, as well as a sink that implements <I>IPropertyNotifySink</I>. All of this is illustrated on the next page in Figure 24-2, which doesn't show that a container usually supports some of its own user interface for manipulating control properties and events.</P>
<P>    <img src="f24dd02.gif"></P>
<P><B>Figure 24-2.</B></P>
<P><B>The structure of an OLE control container.</B></P>
<P>As you might have noticed in several places in this book, many of the interfaces for both control and container were first defined expressly for OLE Controls. Controls were the first such components to really require licensing, general connection points, property pages, and so forth.</P>
<P>Because we've already explored the majority of these interfaces in previous chapters, we need to look at only the specific points that are relevant to OLE Controls, many of which are involved with the <I>IOleControl </I>and <I>IOleControlSite </I>interfaces. But before we do this, there are a number of other fine points to cover about control architecture, so the following sections discuss each in detail.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>4 This list of interfaces assumes an in-process control. An in-process control can choose not to support caching by not exposing <I>IOleCache2.</I> At the time of writing, some of these interfaces did not support marshaling, so implementing controls in local servers was not possible. Typically, controls are in-process, which is why such support wasn't provided in the first place.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
