<HTML><HEAD><TITLE>The Mechanics of OLE Automation</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>The Mechanics of OLE Automation</H2><P>OLE Automation involves a controller, usually an application with a programming environment of some kind (either language or graphics based; it doesn't matter), and one or more automation objects. Because these objects can be driven from an external programming environment, they are also called <I>programmable</I> objects. When an entire application is structured in a way that a controller can drive it through Automation, the application is also programmable. This terminology simply means that the mechanics of Automation are involved.1</P>
<P>A controller is a client of one or more automation objects, for which the most important interface is <I>IDispatch</I>. Any object that implements this interface is said to support Automation, regardless of whether that object is packaged in a server and has a CLSID. Many automation objects are structured this way, but it is not required. Our focus here is specifically on objects with <I>IDispatch</I>, which is simply another mechanism through which an object shares its functionality and content but by using a <I>late-bound </I>mechanism. You can also use an early-bound mechanism or use type information when compiling. The capability of cross-application macro programming is an intentionally higher-level result of this mechanism.</P>
<P>We've seen how objects have functionality (both incoming and outgoing interfaces) and content. So far, however, we've seen only how to access an object's content as formatted data structures by using <I>IDataObject</I>. With <I>IDispatch</I>,<I> </I>we now have a formalized notion of <I>individual properties</I><I>—</I>small pieces of information that work like single data members of an object. Instead of our having to ask an object for a structure of a particular format through <I>IDataObject::GetData</I>, we can ask for a property by name—for example, we can specify BackColor or Caption. Properties are an equivalent expression of get and put functions for data members, and they can be read-only, write-only, or read/write.</P>
<P>By now you know that you can easily write a custom interface that can expose an object's methods (incoming and outgoing functions) and properties in any way you like. Later in this chapter, we'll see cases in which this knowledge is useful. However, custom interfaces work best in an early-bound or compile-time manner, although they can be used in a late-bound manner with more work. The better late-bound mechanism uses the <I>dispatch interface, </I>or <I>dispinterface</I> (pronounced dis-pin-ter-face)<I> </I>for short.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 If you have an early version of the <I>OLE Programmer</I><I>'</I><I>s Reference </I>for Windows 3.1 or Windows NT 3.5, you'll find apparent contradictions between this text and that reference. Believe this text; the original version of the reference was written when OLE and Automation were not well understood. Later versions of the reference, such as that for Windows 95, are much more solid.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
