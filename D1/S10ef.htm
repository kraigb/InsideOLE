<HTML><HEAD><TITLE>Interface Definitions</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Interface Definitions</H3><P>There are a number of ways to define an interface. Regardless of the technique, an interface definition always reduces to either a C++ abstract base class (a class with nothing but pure virtual function signatures) or a C structure containing pointers to the interface member functions (the vtable) and a second structure containing a pointer to that vtable. The two are entirely equivalent. As examples, here are the entries for the <I>IUnknown </I>interface as taken from the Win32 SDK header file OBJBASE.H:</P>
<P><img src="16bit.gif"></P>
<P><BR></P>
<pre><code>//This is a convenience for documentation.<BR>#define interface struct<BR><BR>typedef /* [unique] */ IUnknown __RPC_FAR *LPUNKNOWN;<BR>EXTERN_C const IID IID_IUnknown;<BR><BR>#if defined(__cplusplus) &amp;&amp; !defined(CINTERFACE)<BR>interface IUnknown<BR>    {<BR>    public:<BR>        virtual HRESULT __stdcall QueryInterface(<BR>            /* [in] */ REFIID riid,<BR>            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;<BR>        virtual ULONG __stdcall AddRef(void) = 0;<BR>        virtual ULONG __stdcall Release(void) = 0;<BR>    };<BR><BR>#else   /* C style interface */<BR><BR>typedef struct IUnknownVtbl<BR>    {<BR>    HRESULT ( __stdcall __RPC_FAR *QueryInterface )(<BR>        IUnknown __RPC_FAR * This,<BR>        /* [in] */ REFIID riid,<BR>        /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);<BR><BR>    ULONG ( __stdcall __RPC_FAR *AddRef )(<BR>        IUnknown __RPC_FAR * This);<BR><BR>    ULONG ( __stdcall __RPC_FAR *Release )(<BR>        IUnknown __RPC_FAR * This);<BR><BR>    } IUnknownVtbl;<BR><BR>interface IUnknown<BR>    {<BR>    CONST_VTBL struct IUnknownVtbl __RPC_FAR *lpVtbl;<BR>    };<BR><BR>#endif  /* C style interface */</code></pre>
<P>The text in this book, as well as the original OLE specifications, uses a clean C++ style syntax—without all the platform-specific embellishments and "virtual" keywords—to illustrate an interface's member functions. (Note that the IID to <I>QueryInterface </I>is passed by reference in C++ and passed as a <I>const</I> pointer in C.)</P>
<P><BR></P>
<pre><code>interface IUnknown<BR>    {<BR>    HRESULT QueryInterface(IID&amp; iid, void **ppv);<BR>    ULONG   AddRef(void);<BR>    ULONG   Release(void);<BR>    };</code></pre>
<P>When you're working in C++, you can derive one interface definition from another by using C++ inheritance, illustrated in the following syntax example. This is the only place where OLE makes use of such inheritance. Different mechanisms are employed in achieving reusability, as we'll see in "Object Polymorphism and Reusability" later in this chapter.</P>
<P><BR></P>
<pre><code>interface IProvideClassInfo : IUnknown<BR>    {<BR>    HRESULT GetClassInfo(ITypeInfo **ppTI)<BR>    };</code></pre>
<P>From the puzzled look on your face, I know you have a few questions. What is all that extra junk in the Win32 definition about? What is an HRESULT?</P></font></body></HTML>
