<HTML><HEAD><TITLE>Modify the Server's User Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Modify the Server's User Interface</H3><P>I admit that I seriously loathe writing user interface code because it's the one place that you cannot be the least bit wrong without someone noticing. In addition, user interface specifications seldom identify who is responsible for doing what, and sometimes the specs don't articulate all possible cases. I guess that's why they're called <I>guidelines</I>. The situation in which you execute <I>IOleObject::DoVerb</I> and show a server window is one such case that is not exactly well defined. User interface guidelines for OLE Documents typically devote all their discussion to in-place activation. Such is life for us in the trenches, shooting in the dark at an unknown and unseen target.</P>
<P>So what I'm describing here is not official. It is pieced together from what I've seen other applications do. (That's how we get standards in the first place, isn't it?)</P>
<P>All the following changes to the user interface should take place when <I>IOleObject::SetHostNames</I> is called. That function tells you that your application is an embedded object, as well as the names of the container application and the container document for which you need to make these changes. <I>SetHostNames</I> is always called before <I>DoVerb</I>, so these changes should be in effect before you show an editing window:</P>
<P>Remove the New, Open, Close, and Save commands from your File menu. (Remove any toolbar buttons that invoke the same commands as well.)</P>
<P>Change the name of the Save As command on the File menu to Save Copy As. You can usually keep the same command identifier for this modified item. You might also want to remove any toolbar button for this function, but that's up to you. Save Copy As essentially creates an export function that does not remember the filename after the copy is written. In addition, if you have an import function, as Cosmo does, you can leave that on the menu and the toolbar. If you have a status line, you might also want to change the message displayed for this item (which Cosmo does not do).</P>
<P>Change the Exit command on the File menu to Exit And Return To <I>&lt;container document&gt;</I>; the string <I>&lt;container document&gt;</I> is pointed to by the <I>pszObj</I> argument of <I>SetHostNames</I>. Again, you might want to change any toolbar and status line UI to accommodate this. (I know it seems silly that the argument containing the document name is called <I>pszObj</I>,<I> </I>but, hey, it's only software—call it anything you like.)</P>
<P>Change your caption bar to read "<I>&lt;object type&gt;</I> in <I>&lt;container document&gt;</I>"; <I>&lt;object type&gt;</I> is the user-readable name of your object, such as "Cosmo Figure", and <I>&lt;container document&gt;</I> is the <I>pszObj</I> argument from <I>SetHostNames</I>. If your application is an SDI application or if it is MDI but the document is maximized, this string appears in the main application window's title bar prefixed with "<I>&lt;application name&gt; -</I>"<I>.</I> If your application is an MDI application without a maximized document window, the frame caption remains the same, and this string appears in the document's title bar. (MDI automatically handles the maximized document case by concatenating the frame window's caption with the <I>-</I> character and the document's caption.)</P>
<P>Cosmo makes these changes from within <I>IOleObject::SetHostNames </I>by calling <I>CCosmoFrame::UpdateEmbeddingUI</I> because the frame controls the menus and the toolbar. <I>UpdateEmbeddingUI</I> is actually capable of switching between an embedding state and a nonembedding state in case I ever decide to allow Cosmo to service multiple objects as well as other nonobject documents, as described in "(Optional) MDI Servers, User Interface, and Shutdown" near the end of this chapter.</P>
<P><BR></P>
<pre><code>void CCosmoFrame::UpdateEmbeddingUI(BOOL fEmbedding<BR>    , PCDocument pDoc, LPCTSTR pszApp, LPCTSTR pszObj)<BR>    {<BR>    HMENU      hMenu;<BR>    TCHAR      szTemp[256];<BR><BR>    //First let's play with File menu.<BR>    hMenu=m_phMenu[0];<BR><BR>    //Remove or add File New, Open, and Save items.<BR>    if (fEmbedding)<BR>        {<BR>        DeleteMenu(m_phMenu[0], IDM_FILENEW,   MF_BYCOMMAND);<BR>        DeleteMenu(m_phMenu[0], IDM_FILEOPEN,  MF_BYCOMMAND);<BR>        DeleteMenu(m_phMenu[0], IDM_FILECLOSE, MF_BYCOMMAND);<BR>        DeleteMenu(m_phMenu[0], IDM_FILESAVE,  MF_BYCOMMAND);<BR><BR>        //Save As-&gt;Save Copy As<BR>        ModifyMenu(m_phMenu[0], IDM_FILESAVEAS, MF_BYCOMMAND<BR>            , IDM_FILESAVEAS, PSZ(IDS_SAVECOPYAS));<BR>        }<BR>    else<BR>        {<BR>        InsertMenu(m_phMenu[0], 0, MF_BYPOSITION, IDM_FILENEW<BR>            , PSZ(IDS_NEW));<BR>        InsertMenu(m_phMenu[0], 1, MF_BYPOSITION, IDM_FILEOPEN<BR>            , PSZ(IDS_OPEN));<BR>        InsertMenu(m_phMenu[0], 2, MF_BYPOSITION, IDM_FILESAVE<BR>            , PSZ(IDS_SAVE));<BR>        InsertMenu(m_phMenu[0], 3, MF_BYPOSITION, IDM_FILECLOSE<BR>            , PSZ(IDS_SAVE));<BR><BR>        //Save Copy As-&gt;Save As<BR>        ModifyMenu(m_phMenu[0], IDM_FILESAVEAS, MF_BYCOMMAND<BR>            , IDM_FILESAVEAS, PSZ(IDS_SAVEAS));<BR>        }<BR><BR>    //Change Exit to Exit &amp; Return to xx or vice versa for SDI.<BR>    if (fEmbedding)<BR>        wsprintf(szTemp, PSZ(IDS_EXITANDRETURN), (LPSTR)pszObj);<BR>    else<BR>        lstrcpy(szTemp, PSZ(IDS_EXIT));<BR><BR>    ModifyMenu(m_phMenu[0], IDM_FILEEXIT, MF_STRING, IDM_FILEEXIT<BR>        , szTemp);<BR>    DrawMenuBar(m_hWnd);<BR><BR>    //Now let's play with toolbar.<BR>    m_pTB-&gt;Show(IDM_FILENEW,   !fEmbedding);<BR>    m_pTB-&gt;Show(IDM_FILEOPEN,  !fEmbedding);<BR>    m_pTB-&gt;Show(IDM_FILECLOSE, !fEmbedding);<BR>    m_pTB-&gt;Show(IDM_FILESAVE,  !fEmbedding);<BR><BR>    //Enable what's left appropriately.<BR>    UpdateToolbar();<BR><BR>    //Now let's play with title bar.<BR><BR>    //IDS_EMBEDDINGCAPTION is MDI/SDI sensitive in COSMO.RC.<BR>    wsprintf(szTemp, PSZ(IDS_EMBEDDINGCAPTION), pszObj);<BR><BR>    /*<BR>     * Remember that in MDI situations, Windows takes care of<BR>     * frame window caption bar when document is maximized.<BR>     */<BR>   #ifdef MDI<BR>       SetWindowText(pDoc-&gt;Window(), szTemp);<BR>   #else<BR>       SetWindowText(m_hWnd, szTemp);<BR>   #endif<BR><BR>    return;<BR>    }</code></pre>
<P>When Cosmo is in the embedding state, it appears as shown in Figure 18-2. You'll see that the Import command is still on the File menu and the toolbar.</P>
<P>    <img src="f18dd02p.gif"></P>
<P><B>Figure 18-2.</B></P>
<P><B>Cosmo, sporting its embedded object user interface.</B></P>
<P>Because we modified the appearance of certain menu items, we also need to modify the behavior of those commands. First, to change Save As to Save Copy As, you can either implement a new function or modify your existing save function. In either case, Save Copy As performs the same operation as Save As except that you don't use the filename as the active document or anything to that effect. In other words, you write the file and forget the filename, without changing any other part of your user interface to reflect the filename. It's simply a way for the user to make a disk copy of the object.</P>
<P>In Cosmo, we modify <I>CCosmoDoc::Save</I> so that performing a Save Copy As does not make the document clean, as a typical Save As would. We also do this so that we don't store the filename in the document's structure or change the caption bar. <I>Save</I> determines that we're in an embedding state by calling <I>CFigure::FIsEmbedded</I> (which returns the value of <I>CFigure</I>'s <I>m</I><I>_</I><I>fEmbedded</I> flag, set to TRUE in <I>IOleObject::SetHostNames</I>). You can see these changes in COSMO\DOCUMENT.CPP.</P>
<P>We also change Exit to Exit And Return To <I>&lt;container document&gt;</I>. There's no big change to the actual process of closing a document and closing the application. But when running normally, Cosmo always checks to see whether the document is dirty when it closes the document before exiting the application. If it is dirty, Cosmo asks the user to save the document to a file.</P>
<P>Because saving the object to a file makes no sense in the case of embedding (we removed File Save altogether), we need to prevent this prompt. So we modify <I>CCosmoDoc::FDirtyGet</I> to return FALSE if we're in the embedded state, which effectively prevents prompting:</P>
<P><BR></P>
<pre><code>BOOL CCosmoDoc::FDirtyGet(void)<BR>    {<BR>    if (m_pFigure-&gt;FIsEmbedded())<BR>        return FALSE;<BR><BR>    return m_fDirty;<BR>    }</code></pre>
<P>Now you are probably asking, "What if the object really is dirty? How do we ensure that the container saves the object before we destroy it?" We need to tell the container to save the object when we're closing the document holding the object by calling <I>IOleClientSite::SaveObject</I>, which is done in the <I>CCosmoDoc</I> destructor:</P>
<P><BR></P>
<pre><code>CCosmoDoc::~CCosmoDoc(void)<BR>    {<BR>    m_pFigure-&gt;SendAdvise(OBJECTCODE_SAVEOBJECT);<BR><BR>    §<BR>    }</code></pre>
<P>And because I know you're getting sick of seeing this <I>CFigure::SendAdvise</I> function without knowing what it does, it's about time we looked at it and its notifications in general.</P></font></body></HTML>
