<HTML><HEAD><TITLE>Aggregation: Outer Object (KOALAA.CPP)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Aggregation: Outer Object (KOALAA.CPP)</H3><P>You may have noticed that KoalaC passed a mysterious NULL pointer as the first argument to the <I>CreateAnimal </I>function. This argument is the means by which an outer object passes its outer unknown pointer to Animal to inform the object that it is being created as part of an aggregate. We'll see shortly what Animal does with this pointer. From KoalaA's perspective, it must pass its own <I>IUnknown </I>pointer to this function in order to create an aggregatable Animal object, and in compliance with the other aggregation rule, KoalaA must request an <I>IUnknown </I>pointer in return. Compare this with KoalaC, which asked for an <I>IAnimal </I>in return; remember that KoalaA cannot do this because Animal's <I>IUnknown </I>pointer is the only way to control Animal's lifetime properly.</P>
<P>Here, then, is KoalaA's code to create the aggregated Animal object in KoalaA's initialization:</P>
<P><BR></P>
<pre><code>BOOL CKoalaA::Init(void)<BR>    {<BR>    HRESULT     hr;<BR><BR>    m_pImpIKoala=new CImpIKoala_A(this);<BR><BR>    if (NULL==m_pImpIKoala)<BR>        return FALSE;<BR><BR>    hr=CreateAnimal(this, IID_IUnknown, (void **)&amp;m_pIUnknown);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    hr=m_pIUnknown-&gt;QueryInterface(IID_IAnimal, (void **)&amp;m_pIAnimal);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    m_cRef--;<BR>    return TRUE;<BR>    }</code></pre>
<P><img src="16bit.gif"></P>
<P>This initialization procedure shows not only KoalaA passing its <I>IUnknown </I>to Animal (the <I>this </I>sent to <I>CreateAnimal</I>) but also the way in which a 32-bit aggregate has to fix its reference count. In this sample, the <I>QueryInterface </I>call to retrieve <I>IAnimal </I>will bump KoalaC's reference count to 1, but it has to be 0 because we still have to provide any external pointers. Therefore, we simply decrement <I>m</I><I>_</I><I>cRef </I>without calling our own <I>Release</I>, which would destroy the object. If we had to call <I>Release </I>here for some reason, you would have to wrap that call in <I>m</I><I>_</I><I>cRef</I><I>++</I><I> </I>and <I>m</I><I>_</I><I>cRef</I><FONT FACE="Symbol"><I>--</I></FONT>.</P>
<P>We must also use <I>m</I><I>_</I><I>pIAnimal-&gt;Release </I>in our destructor in the following manner, as stipulated by the rules, as well as safeguard <I>CKoalaA::Release</I>:</P>
<P><BR></P>
<pre><code>CKoalaA::~CKoalaA(void)<BR>    {<BR>    AddRef();<BR>    ReleaseInterface(m_pIAnimal);<BR>    m_pIAnimal=NULL;    //Already released<BR><BR>    ReleaseInterface(m_pIUnknown);<BR>    DeleteInterfaceImp(m_pImpIKoala);<BR>    return;<BR>    }<BR><BR>DWORD CKoalaA::Release(void)<BR>    {<BR>    if (0!=--m_cRef)<BR>        return m_cRef;<BR><BR>    m_cRef++;       //Artificial count preventing reentrancy<BR>    delete this;<BR>    return 0;<BR>    }</code></pre>
<P>Because we're doing aggregation, KoalaA doesn't implement <I>IAnimal </I>itself; however, it does need to return its <I>IAnimal </I>pointer when asked for it in <I>QueryInterface</I>. This can be done in two ways: either return a cached pointer or pass the call to Animal's <I>IUnknown::QueryInterface </I>(which does not delegate). KoalaA demonstrates the latter:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CKoalaA::QueryInterface(REFIID riid, PPVOID ppv)<BR>    {<BR>    §<BR><BR>    //Alternatively, *ppv=m_pIAnimal; works for this case.<BR>    if (IID_IAnimal==riid)<BR>        return m_pIUnknown-&gt;QueryInterface(riid, ppv);<BR><BR>    §<BR>    }</code></pre>
<P>Both ways implement the proper <I>QueryInterface </I>behavior for KoalaA. KoalaA's only other concern is releasing the Animal object during KoalaA's own destruction, which simply involves a call to Animal's <I>IUnknown::Release</I>. This is, again, why KoalaA must ask for Animal's <I>IUnknown</I> during creation because a <I>Release </I>call to any other interface would be routed to KoalaA's <I>IUnknown</I>, leaving no way to free Animal to the wild open spaces.</P></font></body></HTML>
