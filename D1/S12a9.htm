<HTML><HEAD><TITLE>Implement the Basic Object Class</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement the Basic Object Class</H3><P>If you're following through this chapter to add server support to an application, you should start here after you've dealt with the initialization, registry, and class factory issues in steps 1, 2, and 3. Now, having a class factory by itself and no objects to create is useful, for example, only for testing what happens when <I>IClassFactory::CreateInstance </I>fails. You can use this to ensure that your server unloads itself from memory on such an error.</P>
<P>The next step is to begin implementing your embedded object. I say "begin implementing" because implementing the object in pieces is a little less painful than attempting to implement the entire thing at once. So let's start by implementing an object with only the <I>IUnknown</I> interface.</P>
<P>Cosmo's embedded object is a class named <I>CFigure</I>,<I> </I>which is a wrapper for the rest of Cosmo's internals. In other words, <I>CFigure </I>is noninvasive, requiring few changes to most of the other parts of Cosmo. <I>CFigure </I>is defined in COSMOLE.H to implement <I>IOleObject</I>,<I> IDataObject</I>,<I> </I>and <I>IPersistStorage</I> using interface implementation classes as usual. It includes an <I>IStorage </I>pointer and an <I>IStream </I>pointer for the purposes of implementing <I>IPersistStorage</I>,<I> </I>an <I>IDataAdviseHolder </I>variable and FORMATETC<I> </I>arrays for dealing with <I>IDataObject</I>,<I> </I>and <I>IOleAdviseHolder </I>and <I>IOleClientSite </I>pointers for dealing with <I>IOleObject </I>and the container.</P>
<P>The base implementation of <I>CFigure </I>is found in FIGURE.CPP, including its constructor, destructor, <I>IUnknown </I>members, and a few other utility functions. One interesting facet of this implementation is that its <I>Release </I>function does not delete the object itself. When the reference count is 0, it does call the <I>ObjectDestroyed </I>function in COSMO.CPP to start shutdown, but the object itself is deleted in the destructor of <I>CCosmoDoc. </I>This occurs because Cosmo's class factory actually creates a document that in turn creates an instance of <I>CFigure</I>,<I> </I>but the object holds no reference count. Instead, an external reference count is kept.<I> </I>When the figure is released to a zero reference count, it starts server shutdown. This destroys the document and deletes the figure in turn. In this way, the document maintains precise control over the lifetime of <I>CFigure</I> because it needs some of the figure's variables during destruction.</P>
<P>It doesn't necessarily take a zero reference count to start shutdown. If the user closes the document through Cosmo's user interface, the container will still have references to it. In this case, the document is destroyed first. In its destructor, it does the following:</P>
<P><BR></P>
<pre><code>//In CCosmoDoc::~CCosmoDoc<BR>if (NULL!=m_pFigure)<BR>    {<BR>    m_pFigure-&gt;AddRef();<BR>    CoDisconnectObject((LPUNKNOWN)m_pFigure, 0L);<BR>    m_pFigure-&gt;Release();  //Starts shutdown if necessary<BR>    delete m_pFigure;<BR>    }</code></pre>
<P>The <I>AddRef </I>call on the figure will initially safeguard the object. We then call <I>CoDisconnectObject </I>to remove all external connections. As a result, the figure will have a reference count of 1. When we call <I>Release</I>, the figure will start server shutdown through <I>ObjectDestroyed</I>. The document then deletes the figure and completes its destruction. As shutdown of the server is already under way, the server itself will eventually terminate completely.</P>
<P>This little game that I play inside Cosmo with the <I>CFigure </I>pointer—as opposed to its external reference count—allows me to keep the figure valid until the document is entirely done with it, regardless of whether the user closes the Cosmo document directly or deletes the figure object in the container. In the latter case, server shutdown begins with a zero reference count on the figure object itself. We don't want to delete the figure at this time because the document still expects it to be of value. This is nothing but an internal design choice for Cosmo and has no external bearing on Cosmo's integration with containers.</P></font></body></HTML>
