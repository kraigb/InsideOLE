<HTML><HEAD><TITLE>The IConnectionPoint Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The <I>IConnectionPoint</I> Interface</H3><P>Plugging a pair of headphones into a jack is a nice analog to passing an interface pointer on a sink object to a connection point. The connection point will call <I>AddRef </I>on that pointer in order to maintain the connection as long as it needs it. Unplugging the headphones means asking the connection point to release its hold on that pointer.1 These two operations are the purpose of two of the <I>IConnectionPoint </I>member functions, as described in Table 4-2.</P>
<P><BR></P>
<pre><code>interface IConnectionPoint : IUnknown<BR>    {<BR>    HRESULT GetConnectionInterface(IID *);<BR>    HRESULT GetConnectionPointContainer(IConnectionPointContainer **);<BR>    HRESULT Advise(IUnknown *, DWORD *);<BR>    HRESULT Unadvise(DWORD);<BR>    HRESULT EnumConnections(IEnumConnections **);<BR>    }</code></pre>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="149pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Member Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Advise</P></TD><TD VALIGN="TOP"><P>Establishes a connection with an outgoing interface and returns a <I>key</I> (or <I>cookie</I>) to identify the connection. A connection point can support any number of connections, whatever is appropriate for the design of the connectable object.</P></TD></TR><TR><TD VALIGN="TOP"><P>Unadvise</P></TD><TD VALIGN="TOP"><P>Terminates a connection given a <I>key</I> or <I>cookie</I> from <I>Advise</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>EnumConnections</P></TD><TD VALIGN="TOP"><P>Creates and returns an enumerator with the <I>IEnumConnections</I> interface, through which the caller can iterate over every connection established through <I>Advise</I>. </P></TD></TR><TR><TD VALIGN="TOP"><P>GetConnectionPointContainer</P></TD><TD VALIGN="TOP"><P>Returns the <I>IConnectionPointContainer</I> pointer for the connectable object that manages this connection point. This is highly useful for clients that have an <I>IConnectionPoint</I> pointer and want to navigate up to the full object.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetConnectionInterface</P></TD><TD VALIGN="TOP"><P>Returns the IID of the single outgoing interface that this connection point supports. This is needed when a client calls <I>IConnectionPointContainer::EnumConnectionPoints</I> and needs to know the IID of each connection point therein.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 4-2.</B></P>
<P><B>Member functions for <I>IConnectionPoint</I>.</B></P>
<P><I>GetConnectionPointContainer </I>and <I>GetConnectionInterf</I><I>ace </I>exist because of the relationship between the connectable object and its contained connection points. Given one or the other, you can find all the information you need about which outgoing interfaces an object supports.</P>
<P>With both the <I>IConnectionPoint </I>and <I>IConnectionPointContainer </I>interfaces spelled out, we can see the exact sequence of steps taken by a client in order to establish a connection. For the sake of discussion, let's assume that there's an event interface named <I>IDuckEvents </I>with the members <I>Q</I><I>uack</I>, <I>Flap</I>, and <I>Paddle</I> and that a client would like to connect a sink with this interface to some connectable object for which it has an <I>IUnknown </I>pointer. Here are the steps the client would follow:</P>
<P>Call<I> IUnknown::QueryInterface(IID</I><I>_</I><I>IConnectionPointContainer, </I><I>&amp;</I><I>pCPC)</I>. If this fails, no connections are possible.</P>
<P>Call <I>pCPC-&gt;FindConnectionPoint(IID</I><I>_</I><I>IDuckEvents, </I><I>&amp;</I><I>pConnPt)</I>. If this fails, the object doesn't support this outgoing interface. Regardless of the success or failure of this call, the client should always call <I>pCPC-&gt;Release</I>: if the call succeeds, the connectable object will still be alive because one of its contained connection points is alive.</P>
<P>Call <I>pConnPt-&gt;Advise(pIDuckEvents, </I><I>&amp;</I><I>dwCookie)</I> to establish the connection to the instance of the sink identified by the <I>pIDuckEvents</I> pointer. The connection key is returned in <I>dwCookie</I>. Now, whenever appropriate events occur in the source, or the source has reason to make a request to the client, it will call some member function in <I>pIDuckEvents</I>.</P>
<P>When the client wants to terminate the connection, it calls <I>pConnPt-&gt; Unadvise(dwCookie)</I>, passing the same connection key that was returned from <I>Advise</I>. This is followed by <I>pConnPt-&gt;Release</I>.</P>
<P>The last three steps of this process are illustrated in Figure 4-4. The complete process is repeated for every connection that a client wants to make with whatever sources it's dealing with. For example, an OLE Control container will connect to the custom event sets for each control placed in a document or form.</P>
<P>    <img src="f04dd04.gif"></P>
<P><B>Figure 4-4.</B></P>
<P><B>The process of connecting a sink through a connection point.</B></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>Why the Complexity?</H4><P>You might be thinking that this connection mechanism seems unreasonably complicated for a reasonably simple operation. Wouldn't it be simpler to get rid of the connection point business altogether? Couldn't we simply put <I>Advise</I>, <I>Unadvise</I>, and <I>EnumConnections </I>into <I>IConnectionPointContainer</I> and add an IID argument to <I>Advise</I>? That would let us eliminate all the other junk, making everything quite a bit simpler. The primary reason for this mechanism is extensibility: the design as it stands allows the nature of the connectable object to change, perhaps with new interfaces, independently of the connection points, and allows the connection points to change without bothering the connectable object. This is intended to keep the design free of constraints in the future when this technology serves larger purposes. Such extensibility is a key part of working with OLE because evolution over time is so fundamental. A little added complication here, which isn't tremendous, saves a lot of complication years down the road. The Connectable Object technology is meant to be generic and flexible.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 Can you imagine rather temperamental headphone jacks that you must politely ask to let go of your headphones? Fortunately objects aren't moody and they comply with any <I>Release </I>call.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
