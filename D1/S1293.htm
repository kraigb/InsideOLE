<HTML><HEAD><TITLE>Implement Site Interfaces and Add Site Variables</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement Site Interfaces and Add Site Variables</H3><P>We first add to whatever we decide is a suitable site the necessary variables to manage an embedded object and implement the <I>IOleClientSite </I>and <I>IAdviseSink </I>interfaces. In Patron, I already have the <I>CTenant </I>class, which I've converted here to an object with a reference count and so on, but because this object is only a site, it needs no CLSID, no class factory support, and no registry entries: it's only a simple object with some interfaces. One effect of this change is that I had a few places around my code that called the C++ <I>delete </I>operator directly on a tenant. Now that the tenant object has a reference count and an <I>IUnknown </I>implementation, these <I>delete </I>calls are replaced with <I>Release</I>.</P>
<P>I added a few variables to the <I>CTen</I><I>ant </I>class to maintain the reference count (<I>m</I><I>_</I><I>cRef</I>), the interface implementations (<I>m</I><I>_</I><I>pImpIOleClientSite </I>and <I>m</I><I>_</I><I>pImpIAdviseSink</I>), and various interfaces we hold on the embedded object (<I>m</I><I>_</I><I>pIOleObject </I>and <I>m</I><I>_</I><I>pIViewObject2</I>). The other new variable is <I>m</I><I>_</I><I>tType </I>of type TENANTTYPE, an enumeration that identifies the type of embedded content object in this site:</P>
<P><BR></P>
<pre><code>typedef enum<BR>    {<BR>    TENANTTYPE_NULL=0,<BR>    TENANTTYPE_STATIC,<BR>    TENANTTYPE_EMBEDDEDOBJECT,<BR>    TENANTTYPE_EMBEDDEDFILE,<BR>    TENANTTYPE_EMBEDDEDOBJECTFROMDATA<BR>    } TENANTTYPE, *PTENANTTYPE;</code></pre>
<P>In later chapters, we'll add more flags to this set to identify linked objects as well. In any case, Patron initializes these variables to 0 or NULL in <I>CTenant::CTenant</I>. In <I>CTenant::Open</I>, Patron creates the site's interfaces, deleting them in its destructor. The object's pointers themselves are initialized when we create an object (as we'll see later) and released in <I>CTenant::Close</I>.</P>
<P>I also added a number of new member functions to <I>CTena</I><I>nt</I>: <I>StorageGet</I>, <I>ShowAsOpen</I>, <I>ShowYourself</I>, <I>AddVerbMenu</I>, <I>TypeGet</I>, <I>CopyEmbeddedObject</I>, <I>NotifyOfRename</I>, <I>ObjectClassFormatAndIcon</I>, <I>SwitchOrUpdateDisplayAspect</I>, and <I>EnableRepaint</I>. Several of them are used from within the implementations of the site interfaces that are found in <I>CImpIOleClientSite</I> (ICLISITE.CPP) and <I>CImpIAdviseSink</I> (IADVSINK.CPP).</P>
<P>Patron makes use of only two members of <I>IAdviseSink</I>: <I>OnViewChange </I>and <I>OnClose. </I>When a site receives <I>OnViewChange </I>for the aspect that you display (content, icon, and so on), you only need to repaint the site (thus, redraw the object) and set your document's dirty flag, in whatever way you do that:</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(void) CImpIAdviseSink::OnViewChange(DWORD dwAspect<BR>    , LONG lindex)<BR>    {<BR>    //Repaint only if this is the right aspect.<BR>    if (dwAspect==m_pTen-&gt;m_fe.dwAspect)<BR>        {<BR>        m_pTen-&gt;m_pPG-&gt;m_fDirty=TRUE;<BR>        m_pTen-&gt;Repaint();<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>As pointed out in Chapter 11, <I>OnViewChange </I>tells the site that the object's presentation as opposed to its data has changed. Because a container shows an object's presentation in the site, we want to watch view changes, not data changes, in order to keep the image in the site current. In Patron, <I>CTenant::Repaint </I>invalidates the site's area in the container's client area and forces a redraw. This calls the embedded object's <I>IViewObject2::Draw</I>, as we'll see later. Then, when an object is running and sending us these notifications, we'll immediately redraw the object's image as changes happen to it. In that way, the site image keeps up-to-date with the object's own user interface.5</P>
<P>In <I>IAdviseSink::OnClose</I>, I've included a single call to <I>CTenant::ShowYourself(FALSE) </I>to deal with some potentially misbehaving OLE 1 servers as described on OLE1.WRI on the companion CD:</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(void) CImpIAdviseSink::OnClose(void)<BR>    {<BR>    m_pTen-&gt;ShowAsOpen(FALSE);<BR>    return;<BR>    }</code></pre>
<P>The other <I>IAdviseSink </I>members, <I>OnDataChange</I>,<I> OnSave, </I>and <I>OnRename</I>, are not important to a container, but they are important to an object handler and the data cache being used in the container's process. Such notifications are used to update the handler's internal state, but we don't need to take an interest in them ourselves.</P>
<P>The behavior of <I>IAdviseSink::OnClose </I>is similar to that of <I>IOleClientSite::OnShowWindow</I>, which is one of the members we need to implement in that interface. In Patron, we also implement <I>SaveObject </I>and<I> ShowObject</I>, leaving <I>GetMoniker</I>, <I>GetContainer</I>, and <I>RequestNewObjectLayout </I>unimplemented for now (returning E_NOTIMPL). We will return to these functions in later chapters as we make further enhancements to Patron.</P>
<P>As described earlier in this chapter, <I>OnShowWindow </I>tells the container to draw a hatch pattern across the site after repainting the object. The function <I>CTenant::ShowAsOpen </I>toggles this state and repaints the object with a hatch pattern across it, as described in the next section. So <I>IOleClientSite::OnShowWindow </I>simply delegates to this function in the tenant, as does <I>IAdviseSink::OnClose</I>, discussed earlier:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleClientSite::OnShowWindow(BOOL fShow)<BR>    {<BR>    m_pTen-&gt;ShowAsOpen(fShow);<BR>    return NOERROR;<BR>    }</code></pre>
<P>The implementation of <I>IOleClientSite::SaveObject </I>also delegates to a function in <I>CTenant</I>,<I> </I>that function being <I>Update</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleClientSite::SaveObject(void)<BR>    {<BR>    m_pTen-&gt;Update();<BR>    return NOERROR;<BR>    }</code></pre>
<P><I>CTenant::Update </I>ensures that the object in this site is fully saved by querying for <I>IPersistStorag</I><I>e</I> and<I> </I>calling <I>OleSave</I>,<I> </I>then <I>IPersistStorage::SaveCompleted</I>,<I> </I>and then <I>IPersistStorage::Release</I>. Patron has been doing this since Chapter 12, and the code requires no modification:</P>
<P><BR></P>
<pre><code>BOOL CTenant::Update(void)<BR>    {<BR>    LPPERSISTSTORAGE    pIPS;<BR><BR>    if (NULL!=m_pIStorage)<BR>        {<BR>        m_pObj-&gt;QueryInterface(IID_IPersistStorage, (PPVOID)&amp;pIPS);<BR><BR>        //This fails for static objects, so improvise if that happens.<BR>        if (FAILED(OleSave(pIPS, m_pIStorage, TRUE)))<BR>            {<BR>            //This is essentially what OleSave does.<BR>            WriteClassStg(m_pIStorage, m_clsID);<BR>            pIPS-&gt;Save(m_pIStorage, TRUE);<BR>            }<BR><BR>        pIPS-&gt;SaveCompleted(NULL);<BR>        pIPS-&gt;Release();<BR><BR>        m_pIStorage-&gt;Commit(STGC_DEFAULT);<BR>        }<BR><BR>    return FALSE;<BR>    }</code></pre>
<P><I>OleSave </I>can fail, but because all it does is call <I>WriteClassStg </I>and <I>IPersistStorage::Save</I>,<I> </I>we can duplicate its behavior here as needed.</P>
<P>Finally, <I>ShowObject</I> tells the container to bring the object (that is, the site) into view if at all possible, scrolling only if necessary. An object calls this function before it calls <I>OnShowWindow</I> when it's activated in a separate window. Bringing the site into view ensures that the user can see the changes reflected in the site as they happen in the object's window. Of course, because <I>ShowObject</I> concerns only the user interface, it's not truly necessary for the actual embedding operation. If it's too much trouble or not applicable to your container, feel free to ignore it altogether. Patron doesn't see scrolling as a problem, so it implements this feature through <I>CTenant::ShowYourself</I>, to which <I>ShowObject</I> delegates:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleClientSite::ShowObject(void)<BR>    {<BR>    m_pTen-&gt;ShowYourself();<BR>    return NOERROR;<BR>    }<BR><BR>void CTenant::ShowYourself(void)<BR>    {<BR>    RECTL       rcl;<BR>    RECT        rc;<BR>    POINT       pt1, pt2;<BR><BR>    //Scrolling deals in device units; get our rectangle in those.<BR>    RectGet(&amp;rcl, TRUE);<BR><BR>    //Get window rectangle offset for current scroll position.<BR>    GetClientRect(m_hWnd, &amp;rc);<BR>    OffsetRect(&amp;rc, m_pPG-&gt;m_xPos, m_pPG-&gt;m_yPos);<BR><BR>    //Check whether object is already visible. (Macro in bookguid.h.)<BR>    SETPOINT(pt1, (int)rcl.left,  (int)rcl.top);<BR>    SETPOINT(pt2, (int)rcl.right, (int)rcl.bottom);<BR><BR>    if (PtInRect(&amp;rc, pt1) &amp;&amp; PtInRect(&amp;rc, pt2))<BR>        return;<BR><BR>    //Check whether upper left is within upper left quadrant.<BR>    if (((int)rcl.left &gt; rc.left<BR>        &amp;&amp; (int)rcl.left &lt; ((rc.right+rc.left)/2))<BR>        &amp;&amp; ((int)rcl.top &gt; rc.top<BR>        &amp;&amp; (int)rcl.top &lt; ((rc.bottom+rc.top)/2)))<BR>        return;<BR><BR>    //These are macros in INC\BOOK1632.H.<BR>    SendScrollPosition(m_hWnd, WM_HSCROLL, rcl.left-8);<BR>    SendScrollPosition(m_hWnd, WM_VSCROLL, rcl.top-8);<BR>    return;<BR>    }</code></pre>
<P>A good rule of thumb here is to avoid scrolling if at all possible, so <I>ShowYourself</I> first checks to see whether the site's rectangle (which is the same as the object's rectangle in the container) is already visible—that is, whether both upper left and lower right corners are already visible in the page window. If so, nothing needs to happen and we can exit the routine. If this first check fails, either the site is not visible at all or the site is too big to be entirely shown in the window. If the upper left corner of the site is in the upper left quadrant of the window, it must be true that the site is not completely visible but that enough of it is visible that we would still want to avoid scrolling. If this second check fails, <I>ShowYourself</I> capitulates and scrolls the window so that the upper left corner of the site is visible just below the upper left corner of the window. The <I>SendScrollPosition</I> macros (defined in INC\BOOK1632.H) send WM_*SCROLL messages with SB_THUMBPOSITION messages, which are processed in <I>PagesWndProc</I> of PAGEWIN.CPP.</P>
<P>At this point, you'll have completed the site interfaces for a container—which is the simple part—with the exception of shading the site when necessary. That is our next task.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>5 An OLE 1 server does not send notifications for every modification, so in this case, you won't see updates as frequently.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
