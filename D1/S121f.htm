<HTML><HEAD><TITLE>More Advanced Drop Target Hit-Testing</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>More Advanced Drop Target Hit-Testing</H3><P>In Cosmo, every point in a document window is a valid drop point. However, in a Patron document (the<I> CPages </I>window, to be exact), a page has unusable margins and is also surrounded by a border. We don't want to allow drops to happen in these areas, so <I>CPages::UTestDroppablePoint</I> (DRAGDROP.CPP) handles this more complex hit-testing. It returns a code from the UDROP_* values Patron defines in PAGES.H. The two most important values are UDROP_NONE (can't drop here) and UDROP_CLIENT (drop is allowed). Other values are for scrolling. (See "Scrolling the Page" later in this chapter.) Basically, <I>UTestDroppablePoint</I> returns UDROP_CLIENT if the mouse is within the intersection of the document's client area and the client-relative rectangle of the usable page regions. Otherwise, it returns UDROP_NONE.</P>
<P><BR></P>
<pre><code>UINT CPages::UTestDroppablePoint(LPPOINTL pptl)<BR>    {<BR>    POINT       pt;<BR>    RECT        rc, rcT, rcC;<BR>    UINT        uRet;<BR><BR>    POINTFROMPOINTL(pt, *pptl);<BR>    ScreenToClient(m_hWnd, &amp;pt);<BR><BR>    CalcBoundingRect(&amp;rc, FALSE);<BR><BR>    GetClientRect(m_hWnd, &amp;rcC);<BR>    IntersectRect(&amp;rcT, &amp;rc, &amp;rcC);<BR><BR>    //Check for at least a client area hit.<BR>    if (!PtInRect(&amp;rcT, pt))<BR>        return UDROP_NONE;<BR><BR>    uRet=UDROP_CLIENT;<BR><BR>    [Code here for scrolling considerations]<BR><BR>    return uRet;<BR>    }</code></pre>
<P><I>UTestDroppablePoint</I> is first called from <I>IDropTarget::DragEnter</I> to set the initial effect. It's then called on entry into <I>IDropTarget::DragOver</I> to set the effect as well as to determine whether further checks for feedback and scrolling are necessary. (See the next sections.) Finally, it's called again from <I>IDropTarget::Drop</I> to ensure that our application doesn't attempt to perform a Paste operation on an invalid drop point. (Note that a POINTL structure, like the RECTL and SIZEL structures described in Chapter 12, is made of 32-bit fields.) Other Windows API functions use the POINT type (which varies with the operating system), so the POINTFROMPOINTL macro (INC\INOLE.H) converts a POINTL to a POINT. The same header file also has POINTLFROMPOINT to go the other way.</P></font></body></HTML>
