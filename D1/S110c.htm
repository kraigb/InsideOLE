<HTML><HEAD><TITLE>RectEnumerator in C: ENUMC.C</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>RectEnumerator in C: ENUMC.C</H3><P>Let's look first at how we would implement a RectEnumerator object in straight C. To start, we need to define a data structure that will comprise the object, in which, according to the binary interface standard, the first 32 bits of this structure must be a pointer to the interface vtable. You can find this definition in the file ENUMRECT.H:</P>
<P><BR></P>
<pre><code>typedef struct tagRECTENUMERATOR<BR>    {<BR>    IEnumRECTVtbl  *lpVtbl;<BR>    DWORD           m_cRef;         //Reference count<BR>    DWORD           m_iCur;         //Current enum position<BR>    RECT            m_rgrc[CRECTS]; //RECTS we enumerate<BR>    } RECTENUMERATOR, *PRECTENUMERATOR;</code></pre>
<P>This enumerator maintains a reference count, as expected, along with the current index of the enumeration (for implementing <I>Next</I>,<I> Skip</I>,<I> </I>and <I>Reset</I>) and a static array that holds the RECT structures to enumerate. This sample is somewhat contrived in that the number of structures is arbitrarily fixed at 15 (the constant <I>CRECTS</I>) and each structure contains bogus values, but it demonstrates the principles.</P>
<P>In addition to the object structure, we need to declare the member functions that will provide the implementation of the interface. Because we don't have the convenience of declaring member functions as we would in C++, we have to declare each one as an individually named global function:</P>
<P><BR></P>
<pre><code>PRECTENUMERATOR RECTENUM_Constructor(void);<BR>void            RECTENUM_Destructor(PRECTENUMERATOR);<BR><BR>STDMETHODIMP    RECTENUM_QueryInterface(PENUMRECT, REFIID, PPVOID);<BR>STDMETHODIMP_(ULONG) RECTENUM_AddRef(PENUMRECT);<BR>STDMETHODIMP_(ULONG) RECTENUM_Release(PENUMRECT);<BR>STDMETHODIMP    RECTENUM_Next(PENUMRECT, DWORD, LPRECT, LPDWORD);<BR>STDMETHODIMP    RECTENUM_Skip(PENUMRECT, DWORD);<BR>STDMETHODIMP    RECTENUM_Reset(PENUMRECT);<BR>STDMETHODIMP    RECTENUM_Clone(PENUMRECT, PENUMRECT *);</code></pre>
<P>The use of a constructor function and a destructor function is included to closely mimic the structure of the C++ version of this sample (shown below). The constructor is called from within the creation function <I>CreateRectEnumeratorC</I>, which you'll find in ENUMC.C (along with all the other C functions):</P>
<P><BR></P>
<pre><code>BOOL CreateRECTEnumeratorC(PENUMRECT *ppEnum)<BR>    {<BR>    PRECTENUMERATOR     pRE;<BR>    HRESULT             hr;<BR><BR>    if (NULL==ppEnum)<BR>        return FALSE;<BR><BR>    //Create object.<BR>    pRE=RECTENUM_Constructor();<BR><BR>    if (NULL==pRE)<BR>        return FALSE;<BR><BR>    //Get interface, which calls AddRef.<BR>    hr=pRE-&gt;lpVtbl-&gt;QueryInterface(pRE, &amp;IID_IEnumRECT<BR>        , (void **)ppEnum);<BR>    return SUCCEEDED(hr);<BR>    }</code></pre>
<P><I>RECTENUM</I><I>_</I><I>Constructor </I>has most of the interesting stuff regarding a C implementation. This function has to manually create a vtable for the object's interfaces (of which there is only one) and then allocate the object structure and store a pointer to that vtable as the first field:</P>
<P><BR></P>
<pre><code>static IEnumRECTVtbl  vtEnumRect;<BR>static BOOL           g_fVtblInitialized=FALSE;<BR><BR>PRECTENUMERATOR RECTENUM_Constructor(void)<BR>    {<BR>    PRECTENUMERATOR     pRE;<BR>    UINT                i;<BR><BR>    if (!fVtblInitialized)<BR>        {<BR>        vtEnumRect.QueryInterface=RECTENUM_QueryInterface;<BR>        vtEnumRect.AddRef        =RECTENUM_AddRef;<BR>        vtEnumRect.Release       =RECTENUM_Release;<BR>        vtEnumRect.Next          =RECTENUM_Next;<BR>        vtEnumRect.Skip          =RECTENUM_Skip;<BR>        vtEnumRect.Reset         =RECTENUM_Reset;<BR>        vtEnumRect.Clone         =RECTENUM_Clone;<BR><BR>        fVtblInitialized=TRUE;<BR>        }<BR><BR>    pRE=(PRECTENUMERATOR)malloc(sizeof(RECTENUMERATOR));<BR><BR>    if (NULL==pRE)<BR>        return NULL;<BR><BR>    //Initialize function table pointer.<BR>    pRE-&gt;lpVtbl=&amp;vtEnumRect;<BR><BR>    //Initialize array of rectangles.<BR>    for (i=0; i &lt; CRECTS; i++)<BR>        SetRect(&amp;pRE-&gt;m_rgrc[i], i, i*2, i*3, i*4);<BR><BR>    //Ref counts always start at 0.<BR>    pRE-&gt;m_cRef=0;<BR><BR>    //Current pointer is first element.<BR>    pRE-&gt;m_iCur=0;<BR><BR>    return pRE;<BR>    }</code></pre>
<P>The vtable itself needs initialization only once in this program to cover all possible instances of the object, so this structure is stored as the global variable <I>vtEnumRect</I>,<I> </I>with the flag <I>g</I><I>_</I><I>fVtblInitialized </I>indicating whether initialization has yet occurred. There is nothing sacred about filling the vtable explicitly like this; you could also declare the global variable along with the names of the functions that fill the table at compile time.</P>
<P>Notice that the reference count from the constructor is set initially to 0. This is because no pointer to the object's interfaces actually exists at this point. So after the constructor returns, <I>CreateRectEnumeratorC</I> will call the object's <I>QueryInterface </I>to obtain its <I>I</I><I>EnumRECT </I>pointer, which in turn calls <I>AddRef.</I> This query step will call <I>AddRef</I> before returning the pointer, thereby transferring control of the object's lifetime from the creation function to the calling client:</P>
<P><BR></P>
<pre><code>STDMETHODIMP RECTENUM_QueryInterface(PENUMRECT pEnum<BR>    , REFIID riid, PPVOID ppv)<BR>    {<BR>    //Always NULL the out-parameters.<BR>    *ppv=NULL;<BR><BR>    if (IsEqualIID(riid, &amp;IID_IUnknown)<BR>        || IsEqualIID(riid, &amp;IID_IEnumRECT))<BR>        *ppv=pEnum;<BR><BR>    if (NULL==*ppv)<BR>        return ResultFromScode(E_NOINTERFACE);<BR><BR>    //AddRef any interface we'll return.<BR>    ((LPUNKNOWN)*ppv)-&gt;lpVtbl-&gt;AddRef((LPUNKNOWN)*ppv);<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP_(ULONG) RECTENUM_AddRef(PENUMRECT pEnum)<BR>    {<BR>    PRECTENUMERATOR       pRE=(PRECTENUMERATOR)pEnum;<BR><BR>    return ++pRE-&gt;m_cRef;<BR>    }</code></pre>
<P>You can see here that <I>QueryInterface </I>returns the same pointer for both <I>IUnknown </I>and <I>IEnumRECT </I>requests, which is perfectly normal because <I>IEnumRECT </I>is polymorphic with <I>IUnknown.</I> This shows how you don't need to implement <I>IUnknown </I>explicitly (unless you're supporting aggregation, as we'll see later). Again, the <I>AddRef </I>call made at the end of <I>QueryInterface </I>will increment the object's reference count initially to 1. The client's later <I>Release </I>call through the interface pointer will then destroy the object:</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(ULONG) RECTENUM_Release(PENUMRECT pEnum)<BR>    {<BR>    PRECTENUMERATOR       pRE=(PRECTENUMERATOR)pEnum;<BR><BR>    if (0!=--pRE-&gt;m_cRef)<BR>        return pRE-&gt;m_cRef;<BR><BR>    RECTENUM_Destructor(pRE);<BR>    return 0;<BR>    }</code></pre>
<P>This interface member function, like all others, has to know what object is being used through this interface. In C, the first parameter to a member function is the interface pointer through which the client makes the call. Because we know internally that this pointer actually points to our RECTENUMERATOR structure, we can typecast it into our object pointer and access our data members, such as <I>m</I><I>_</I><I>cRef</I>. Here in <I>Release</I>, we decrement the reference count (which is trivially incremented in <I>A</I><I>ddRef</I>) and return the new value. If the value is 0, we call our own destructor, which simply deallocates the structure:</P>
<P><BR></P>
<pre><code>void RECTENUM_Destructor(PRECTENUMERATOR pRE)<BR>    {<BR>    if (NULL==pRE)<BR>        return;<BR><BR>    free(pRE);<BR>    return;<BR>    }</code></pre>
<P>There is no need to unravel the global vtable because we initialize it only once per task.</P>
<P>I will leave it to you to examine the implementation of the specific <I>IEnumRECT </I>member functions, which are pretty standard as far as enumerators are concerned. The <I>Clone </I>function, for example, simply calls our own <I>CreateRectEnumeratorC</I> again. This is a little simpler than a working enumerator because normally a cloning process can involve the duplication of the list itself. In cloning, it's important that the clone have the same state as the current enumerator. In our <I>Clone </I>implementation, this means copying the current index pointer.</P></font></body></HTML>
