<HTML><HEAD><TITLE>Implement IOleObject::SetMoniker and IOleObject::GetMoniker</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement <I>IOleObject::SetMoniker</I> and <I>IOleObject::GetMoniker</I></H3><P>The last step for making a complete linking server is to fill in the implementation of <I>IOleObject::SetMoniker </I>and <I>IOleObject::GetMoniker. </I>Implementing <I>SetMoniker </I>is important if you want to support linking to embeddings—that is, when your object doesn't include OLEMISC_CANTLINKINSIDE. This function is not called for one of Cosmo's linked objects but rather for an embedded object that is being linked to inside its container. <I>SetMoniker </I>tells us to register as running the full moniker naming this object in the container:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleObject::SetMoniker(DWORD dwWhich<BR>    , LPMONIKER pmk)<BR>    {<BR>    LPMONIKER       pmkFull;<BR>    HRESULT         hr=ResultFromScode(E_FAIL);<BR><BR>    if (NULL!=m_pObj-&gt;m_pIOleClientSite)<BR>        {<BR>        hr=m_pObj-&gt;m_pIOleClientSite-&gt;GetMoniker<BR>            (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL<BR>            , &amp;pmkFull);<BR>        }<BR><BR>    if (SUCCEEDED(hr))<BR>        {<BR>        if (NOERROR==pmkFull-&gt;IsRunning(NULL, NULL, NULL))<BR>            {<BR>            pmkFull-&gt;Release();<BR>            return NOERROR;<BR>            }<BR><BR>        //This will revoke the old moniker if m_dwRegROT is nonzero.<BR>        INOLE_RegisterAsRunning(m_pObj, pmkFull<BR>            , 0, &amp;m_pObj-&gt;m_dwRegROT);<BR><BR>        //Inform clients of new moniker.<BR>        if (NULL!=m_pObj-&gt;m_pIOleAdviseHolder)<BR>            m_pObj-&gt;m_pIOleAdviseHolder-&gt;SendOnRename(pmkFull);<BR><BR>        pmkFull-&gt;Release();<BR>        }<BR><BR>    return hr;<BR>    }</code></pre>
<P>This code works in conjunction with our call to <I>INOLE</I><I>_</I><I>NoteChangeTime </I>earlier. Cosmo maintains two registration keys (<I>m</I><I>_</I><I>dwRegROT</I>)<I> </I>from <I>IRunningObjectTable::Register</I>: one in <I>CCosmoDoc </I>and<I> </I>the other in <I>CFigure.</I> The former is used when Comso is handling a linked object. In that case, the variable in <I>CFigure </I>has a copy of the variable in <I>CCosmoDoc.</I> If we're embedded and <I>SetMoniker </I>is called, the document variable is 0 and the <I>CFigure </I>variable is the one from the registration shown in the preceding code. In either case, we'll always call <I>IRunningObjectTable::NoteChangeTime </I>for the right moniker in the right circumstances.</P>
<P><I>IOleObject::GetMoniker </I>is used when Cosmo is servicing a linked or an embedded object, and it returns the full moniker to the object in either case. For linking, this is the document moniker; for embedding, this is the moniker we can get from the container:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleObject::GetMoniker(DWORD dwAssign<BR>    , DWORD dwWhich, LPMONIKER *ppmk)<BR>    {<BR>    HRESULT         hr=ResultFromScode(E_FAIL);<BR><BR>    *ppmk=NULL;<BR><BR>    if (NULL!=m_pObj-&gt;m_pMoniker)<BR>        {<BR>        *ppmk=m_pObj-&gt;m_pMoniker;       //Document file moniker<BR>        m_pObj-&gt;m_pMoniker-&gt;AddRef();<BR>        }<BR>    else<BR>        {<BR>        //Get full container:object moniker if we're embedded.<BR>        if (NULL!=m_pObj-&gt;m_pIOleClientSite)<BR>            {<BR>            hr=m_pObj-&gt;m_pIOleClientSite-&gt;GetMoniker<BR>                (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL<BR>                , ppmk);<BR>            }<BR>        }<BR><BR>    return (NULL!=*ppmk) ? NOERROR : hr;<BR>    }</code></pre>
<P>And with that, we have completed the implementation of a simple link-source server.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>Closing a Linked Document Without Saving</H4><P>When a user activates a linked object in a container, changes made to the object in the server are immediately reflected in the object image in the container site. Users usually save their file and then close the server when they have finished making changes. It is possible that a user can close the file and <I>not</I> save changes, in which case the image of the object in the container does not reflect what is actually in the source data. This is in fact the expected<I> </I>behavior of such linked objects, and it is a very difficult problem to handle in another way. It requires the server to reload its original data and update clients again before closing, which might not be all that easy. Furthermore, the same problem exists when links are broken—that is, when the site image in the container does not match the actual source data. So the container—and the cache in OLE—try to maintain an updated presentation within reasonable bounds. To deal with this, a container can try to detect this situation and revert its cache to some previous state, but that too is difficult. This is one update problem that simply doesn't have a good solution today.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
