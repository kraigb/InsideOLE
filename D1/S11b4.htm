<HTML><HEAD><TITLE>So, Monikers</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>So, Monikers</H3><P>In light of this problem, it makes sense that new names are themselves components that play by the same rules as all other components. Instead of these names being mere repositories for persistent data (the name data), they must also encapsulate the intelligence to work with that name behind a standard interface. Thus, all clients only need to include code to work with the standard name interface, not with each particular type of name. The solution is a persistent, intelligent name—a moniker.</P>
<P>A moniker encapsulates all of its capabilities behind the <I>IMoniker </I>interface, which includes both binding methods and persistence methods (from <I>IPersistStream</I>). Clients only need to know how to use the <I>IMoniker </I>member functions, and because all objects that implement the same interface are polymorphic, all monikers are polymorphic as well. Clients that know how to use one moniker know how to use all monikers.</P>
<P>Let this sink in for just a moment. Yes, I mean lift your eyes from this page and stare at the wall while you think about what this encapsulation means. You're still reading, aren't you? I'll stop writing for a minute.</P>
<P>Again, the problem with unintelligent names is that adding a new type of unintelligent name into a system means that only those clients updated to understand that new name can take advantage of it. With monikers, however, clients that know how to work with existing monikers can immediately and transparently work with any new moniker—with any new intelligent name—that is added to the system. A new name requires absolutely no changes whatsoever to existing clients. In short, OLE's naming and binding is extensible in all directions, requiring no changes to clients nor of the programming model.</P></font></body></HTML>
