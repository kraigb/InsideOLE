<HTML><HEAD><TITLE>Enumerators</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Enumerators</H3><P>A frequent programming task is to generate some sequence of items and iterate through that sequence. A number of places within COM and OLE require this sort of functionality, such as where a client wants to obtain a list of items from an object, regardless of what type of boundary exists between the two. For example, a client that is a data consumer usually wants a list of formats that a data source (that implements <I>IDataObject</I>) can render for it. When asked for such a list, the source returns an interface pointer to a separate object called an <I>enumerator</I>. Enumerators cleanly encapsulate, behind an interface, the knowledge of how to iterate through a sequence of items from the client's desire to iterate, thereby allowing the enumerator to be implemented in whatever way is most convenient—array, linked list, and so forth.10</P>
<P>Enumerators are so named because they implement a type-specific interface that always has the prefix <I>IEnum</I> followed by the name of a type. For example, OLE defines <I>IEnumUnknown </I>(to enumerate a list of objects by their <I>IUnknown </I>pointers) and <I>IEnumFORMATETC </I>(to enumerate FORMATETC structures from data objects). There is also the interface <I>IEnumVARIANT</I>, which enumerates data structures named VARIANT—a big union of different data types, as we'll see later with OLE Automation. A generic enumerator with <I>IEnumVARIANT </I>is usually called a <I>collection,</I> which is an appropriate term for any enumerator, literally a collection of things.</P>
<P>Regardless of the type involved, all <I>IEnum</I>* interfaces contain the same member functions, although the specific argument types vary with the enumerated type. The difference among enumerator interfaces is strictly in the types involved; the semantics are always the same. Enumerators in general can be described as a parameterized type, using a C++ template syntax (although actual templates are not used to define enumerator interfaces in header files).</P>
<P><BR></P>
<pre><code>template &lt;class ELT_T&gt; interface IEnum : IUnknown<BR>    {<BR>    virtual HRESULT Next(ULONG celt, ELT_T *rgelt<BR>        , ULONG *pceltFetched)=0;<BR>    virtual HRESULT Skip(ULONG celt)=0;<BR>    virtual HRESULT Reset(void)=0;<BR>    virtual HRESULT Clone(IEnum&lt;ELT_T&gt; ** ppEnum)=0;<BR>    };</code></pre>
<P>In this template syntax, <I>ELT</I><I>_</I><I>T</I> stands for "ELemenT Type" and is a placeholder for whatever specific type is applicable to the enumerator, such as <I>IUnknown</I>,<I> </I>FORMATETC, VARIANT,<I> </I>and so forth. By itself, <I>elt</I> means "element."</P>
<P>The following table describes the member functions of an enumerator interface, omitting the omnipresent <I>IUnknown </I>members:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="64pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Next</P></TD><TD VALIGN="TOP"><P>Returns the next <I>celt</I> elements of the list, starting at the current index. When the enumerated type is itself an interface pointer, as with <I>IEnumUnknown</I>, the <I>Next </I>function must call <I>AddRef </I>through each pointer before return, and the client must later call <I>Release </I>through each pointer.</P></TD></TR><TR><TD VALIGN="TOP"><P>Skip</P></TD><TD VALIGN="TOP"><P>Skips past <I>celt</I> elements in the list.</P></TD></TR><TR><TD VALIGN="TOP"><P>Reset</P></TD><TD VALIGN="TOP"><P>Sets the current index to 0.</P></TD></TR><TR><TD VALIGN="TOP"><P>Clone</P></TD><TD VALIGN="TOP"><P>Returns a new enumerator object with the same items but an independent index. The items in the clone are not guaranteed to be in the same order as the original enumerator.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Note that enumerators are separate and independent objects, although in almost every circumstance a client obtains an enumerator by asking another object for the pointer. This is the second method that we saw earlier through which a client obtains its first interface pointer to a new object. If the object providing the enumerator doesn't have anything to enumerate, it will return S_FALSE and a NULL interface pointer from the appropriate member function.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>10 Note that OLE Automation has a data type called a <I>Safe Array</I> that can be used to pass arrays along with information about the array dimensions and bounds when an enumerator is not necessary.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
