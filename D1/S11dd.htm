<HTML><HEAD><TITLE>Data Objects and the IDataObject Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Data Objects and the <I>IDataObject</I> Interface</H2><P>Any component that is a source of formatted data structures is a data object if it implements <I>IDataObject. </I>Any and all code that in one way or another has data to share can do so with a data object. The great benefit of doing this is that once you have a data object implementation around, you can use that data object in any transfer protocol, be it clipboard, drag and drop, compound documents, OLE Automation, and so on, and any new format you might support is instantly provided through all the protocols. A source can centralize the code that renders data into this data object implementation; a consumer can centralize the code necessary to check available formats in a data object and also centralize the code used to paste that data. Centralization reduces both the overall amount of code you must implement and the number of different API functions for dealing with each protocol.</P>
<P>Centralization is possible because the <I>IDataObject</I> interface combines the functionality of the existing data transfer protocols, thereby providing more functionality in an OLE data transfer than is available for any other existing protocol. The definition of the <I>IDataObject</I> interface is as follows:</P>
<P><BR></P>
<pre><code>interface IDataObject : IUnknown<BR>    {<BR>    HRESULT GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);<BR>    HRESULT GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);<BR>    HRESULT QueryGetData(LPFORMATETC pFE);<BR>    HRESULT GetCanonicalFormatEtc(LPFORMATETC pFEIn<BR>        , LPFORMATETC pFEOut);<BR>    HRESULT SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);<BR>    HRESULT EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);<BR>    HRESULT DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink<BR>        , LPDWORD pdwConnection);<BR>    HRESULT DUnadvise(DWORD dwConnection);<BR>    HRESULT EnumDAdvise(LPENUMSTATDATA *ppEnum);<BR>    };</code></pre>
<P>Many of the member functions have equivalents in specific Windows API functions; keep in mind, however, that data objects are used to describe data transferred by means of <I>any</I> protocol, and thus they provide the ability to treat data in a uniform fashion regardless of how you obtained the <I>IDataObject</I> pointer. The following list describes each <I>IDataObject</I> member in more detail and lists the similar (but not always exact) functionality that exists in the clipboard, DDE, and outdated OLE 1 transfer protocols:</P>
<UL><LI><I>GetData</I> renders the data described by a FORMATETC and returns it in the out-parameter STGMEDIUM, which then becomes the caller's responsibility.</LI></UL>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="87pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Protocol</B></P></TD><TD VALIGN="TOP"><P><B>Similar API Function or Message</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Clipboard</P></TD><TD VALIGN="TOP"><P><I>GetClipboardData</I></P></TD></TR><TR><TD VALIGN="TOP"><P>DDE</P></TD><TD VALIGN="TOP"><P>WM_DDE_REQUEST, WM_DDE_DATA</P></TD></TR><TR><TD VALIGN="TOP"><P>OLE 1</P></TD><TD VALIGN="TOP"><P><I>OleGetData</I></P></TD></TR></TBODY></TABLE>
<P><BR></P><UL><LI><I>SetData</I> provides data to the source described by a FORMATETC and referenced by the in-parameter STGMEDIUM. The data object is responsible for releasing the data if the <I>fRelease</I> flag is TRUE.  When you call <I>SetData</I>, the <I>tymed</I> fields in both FORMATETC and STGMEDIUM structures must match.</LI></UL>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="66pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Protocol</B></P></TD><TD VALIGN="TOP"><P><B>Similar API Function or Message</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Clipboard</P></TD><TD VALIGN="TOP"><P><I>SetClipboardData</I></P></TD></TR><TR><TD VALIGN="TOP"><P>DDE</P></TD><TD VALIGN="TOP"><P>WM_DDE_POKE</P></TD></TR><TR><TD VALIGN="TOP"><P>OLE 1</P></TD><TD VALIGN="TOP"><P><I>OleSetData</I></P></TD></TR></TBODY></TABLE>
<P><BR></P><UL><LI><I>GetDataHere</I> allows the caller to provide a preallocated medium in which to render the data.  For example, if the caller provides an <I>IStream</I> object and asks for CF_BITMAP, the source should serialize its bitmap into that stream instead of allocating a new stream on its own as it would through <I>GetData</I>. This capability is not found in any existing protocol.</LI><LI><I>QueryGetData</I> answers whether the data object can render data described by the given FORMATETC.  The caller can be as specific as desired.  <I>QueryGetData</I> returns NOERROR for "yes" or S_FALSE for "no," so <I>don</I><I>'</I><I>t</I> use the SUCCEEDED or FAILED macro to test return values; compare directly with NOERROR.</LI></UL>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Protocol</B></P></TD><TD VALIGN="TOP"><P><B>Similar API Function or Message</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Clipboard</P></TD><TD VALIGN="TOP"><P><I>IsClipboardFormatAvailable</I></P></TD></TR><TR><TD VALIGN="TOP"><P>DDE</P></TD><TD VALIGN="TOP"><P>None (perhaps handled through WM_DDE_CONNECT, WM_DDE_ADVISE)</P></TD></TR><TR><TD VALIGN="TOP"><P>OLE 1</P></TD><TD VALIGN="TOP"><P>None</P></TD></TR></TBODY></TABLE>
<P><BR></P><UL><LI><I>GetCanonic</I><I>alFormatEtc</I> provides a different but logically equivalent FORMATETC structure, allowing the caller to determine whether a rendering it has already obtained is identical to what would be obtained by calling <I>GetData</I> with a different FORMATETC. There is no equivalent to this function in any existing protocol.</LI><LI><I>EnumFormatEtc</I> instantiates and returns a FORMATETC enumerator object through which the caller can determine all available formats that the object can provide. There must be a unique element in the enumeration for each <I>cfFormat</I>, <I>dwAspect</I>, and <I>ptd</I> variation, although you can combine TYMED_* values in <I>tymed</I>. The enumerator object implements the single <I>IEnumFORMATETC</I> interface, and the caller is responsible for calling <I>IEnumFORMATETC::Release</I> when it has finished so the object can free itself. The caller can ask for an enumerator for either "direction," <I>GetData</I> or <I>SetData</I>. See the section "FORMATETC Enumerators and Format Ordering" beginning on page 508 for more details on this enumerator.</LI></UL>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="73pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Protocol</B></P></TD><TD VALIGN="TOP"><P><B>Similar API Function or Message</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Clipboard</P></TD><TD VALIGN="TOP"><P><I>EnumClipboardFormats</I> (get direction only)</P></TD></TR><TR><TD VALIGN="TOP"><P>DDE</P></TD><TD VALIGN="TOP"><P>None</P></TD></TR><TR><TD VALIGN="TOP"><P>OLE 1</P></TD><TD VALIGN="TOP"><P>None</P></TD></TR></TBODY></TABLE>
<P><BR></P><UL><LI><I>DAdvise</I>3 sets up an advisory connection between the data object and a caller, providing an advise sink in which the caller indicates the data of interest in a FORMATETC. The data object calls <I>IAdviseSink::OnDataChange</I> when a change occurs, possibly sending the data along with the notification.</LI></UL>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="84pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Protocol</B></P></TD><TD VALIGN="TOP"><P><B>Similar API Function or Message</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Clipboard</P></TD><TD VALIGN="TOP"><P>None</P></TD></TR><TR><TD VALIGN="TOP"><P>DDE</P></TD><TD VALIGN="TOP"><P>WM_DDE_ADVISE</P></TD></TR><TR><TD VALIGN="TOP"><P>OLE 1</P></TD><TD VALIGN="TOP"><P>None</P></TD></TR></TBODY></TABLE>
<P><BR></P><UL><LI><I>DUnadvise</I> terminates an advisory connection previously established with <I>DAdvise</I>.</LI></UL>
<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="75pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Protocol</B></P></TD><TD VALIGN="TOP"><P><B>Similar API Function or Message</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Clipboard</P></TD><TD VALIGN="TOP"><P>None</P></TD></TR><TR><TD VALIGN="TOP"><P>DDE</P></TD><TD VALIGN="TOP"><P>WM_DDE_UNADVISE</P></TD></TR><TR><TD VALIGN="TOP"><P>OLE 1</P></TD><TD VALIGN="TOP"><P>None</P></TD></TR></TBODY></TABLE>
<P><BR></P><UL><LI><I>EnumDAdvise</I> returns an enumerator with the <I>IEnumSTATDATA</I> interface. There is no equivalent to this function in any existing protocol. A STATDATA structure holds information pertaining to each advisory connection to the data object:
<P><BR></P>
<pre><code>typedef struct  tagSTATDATA<BR>    {<BR>    FORMATETC    formatetc;<BR>    DWORD        advf;<BR>    IAdviseSink *pAdvSink;<BR>    DWORD        dwConnection;<BR>    }   STATDATA;</code></pre></LI></UL><P>You can see from the preceding list that no existing protocol supports the full range of functionality that <I>IDataObject </I>provides for all protocols. This is not to say that any arbitrary data object that a client might obtain actually implements the full functionality of every member function. Some data objects—such as a static bitmap on the clipboard—will refuse any advisory connections. Others might not support any <I>SetData</I> calls. But you are always allowed to try to learn the data object's capabilities through error return values. With existing protocols, you are not even allowed to play a little.</P>
<P>Related to <I>IDataObject</I> is an OLE API function that you might find useful in your work: <I>OleDuplicateData. </I>This function will copy any global-memory–based format, including metafiles, bitmaps, and palettes. Its signature is as follows:</P>
<P><BR></P>
<pre><code>HANDLE OleDuplicateData(HANDLE hSrc, CLIPFORMAT cf, UINT uiFlags);</code></pre>
<P>where <I>hSrc </I>is the handle of the source data, <I>cf </I>identifies the format of the data, and <I>uiFlags </I>specifies the flags to pass to <I>GlobalAlloc</I> if such memory needs allocation. If <I>uiFlags </I>is 0, the function assumes GMEM_MOVEABLE.</P>
<P><I>OleDuplicateData </I>will perform a bytewise duplication of the data except in the case of CF_METAFILEPICT, CF_ENHMETAFILE, CF_PALETTE, and CF_BITMAP, for which special handling is required. Accordingly, <I>hSrc </I>must be a global-memory handle for any bytewise duplication, whereas it is the appropriate handle type when used with these other four formats.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="539pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>3 The <I>D</I> in the function names identifies these functions as belonging to <I>IDataObject</I>. Prior to the release of OLE 2 both <I>IDataObject</I> and <I>IOleObject</I> had the member functions <I>Advise Unadvise </I>and <I>EnumAdvise </I>which played havoc with OLE Document content objects that used multiple inheritance. To ensure that the names will not conflict <I>IDataObject</I>'s members are <I>DAdvise DUnadvise </I>and <I>EnumDAdvise </I>whereas those in <I>IOleObject</I> remain <I>Advise Unadvise </I>and <I>EnumAdvise</I>.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
