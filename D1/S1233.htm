<HTML><HEAD><TITLE>Registry Entries for Automation Objects</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Registry Entries for Automation Objects</H3><P>As for any object with a CLSID, an automation object requires a few basic registry entries to tell OLE where its server is located. It is also necessary to tell automation controllers where to find your type information given your CLSID. Knowing this, controllers don't have to instantiate an object of your class just to see what the object can do.</P>
<P>Three basic sets of entries for each automation object fall under the CLSID key, the TypeLib key, and your ProgID key or keys. These entries are necessary for each separate object CLSID, which is true for any other object server.</P>
<P>Under your CLSID entry, you should register the following:</P>
<P><BR></P>
<pre><code>\CLSID<BR>    {&lt;CLSID&gt;} = &lt;name of object&gt;<BR>        [Inproc œ Local]Server[32] = &lt;path to DLL or EXE&gt; [/Automation]<BR>        InprocHandler[32] = &lt;handler path or OLE2.DLL/OLE32.DLL&gt;<BR>        ProgID = ...<I><BR></I><I>        </I>VersionIndependentProgID = ,,,<BR>        TypeLib = {&lt;LIBID&gt; spelled out as a CLSID}<BR>        Programmable</code></pre>
<P>We've already seen the entries for type information in Chapter 3. Here NotInsertable keeps the object out of Insert Object dialog boxes in OLE Documents containers. If an object can be inserted as well as embedded, this will be Insertable. I suggest, as an extension to OLE Automation, the <I>Programmable</I> key to indicate that the object supports OLE Automation, in the same way that Insertable marks a compound document object and Control marks an OLE Control, as we'll see later. You won't find Programmable in any other documentation. I suggest it as a means of identifying object classes that can be driven through Automation. Without such a key, you cannot differentiate these objects from a regular COM component that doesn't support <I>IDispatch</I>. Programmable is useful for controllers that would like to display a list of only automation-capable objects, but it is not a standard part of OLE.</P>
<P>The only other part of these registry entries related specifically to Automation is the optional <I>/Automation</I> command-line flag. If you are registering an application object for automation using LocalServer[32], you will want to include this flag to tell your EXE that it is being launched in order to create the application object. You don't put this flag on any other LocalServer[32] entries for other objects, even with the same EXE name, because you'll use it to determine whether you must create and register a single-use class factory for the application object's CLSID. Because the object will usually be created as part of application startup, you don't want to register a class factory for that CLSID unless OLE is going to specifically use it right away (and thus exhaust its single use). Otherwise, some client might come along and try to instantiate your application object at some later time. If your class factory has not been used, it would be called at that time, but it could not create a new application.</P>
<P>Also note that your ProgID entry provides for a convenient mapping from a textual object name like "Beeper.Object" to a CLSID. This might or might not be useful to certain controllers. Visual Basic and its various derivatives allow the user to write a piece of Basic code to create an object as follows:</P>
<P><BR></P>
<pre><code>Dim X as Object<BR>Set X = CreateObject("Beeper.Object")</code></pre>
<P>When executing this code, Visual Basic goes to the registry and looks for a ProgID named "Beeper.Object" and then finds "CurVer". It then looks under that versioned ProgID to find the CLSID, and with that CLSID it can call <I>CoCreateInstance(</I>…<I>IID</I><I>_</I><I>IDispatch)</I> to instantiate the automation object and obtain its <I>IDispatch </I>pointer.</P>
<P>When OLE first establishes remote connections through a dispinterface, it automatically creates entries for <I>IDispatch </I>under the Interface key. If you have a dual interface and want to provide your own standard marshaling support, you can create your own entries under Interface as well using the IID of <I>IDispatch </I>as the BaseInterface entry.</P></font></body></HTML>
