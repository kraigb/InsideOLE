<HTML><HEAD><TITLE>In-Place Objects Step by Step</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>In-Place Objects Step by Step</H2><P>First you need an embedded object. Got one? Great, let's make it in-place capable by adding <I>IOleInPlaceObject </I>to the interfaces the object already has and providing an implementation of <I>IOleInPlaceActiveObject</I>. Well, let's not jump in quite so fast. There are crocodiles in the river. In-place activation carries some heavy implications for your object and server. So when implementing in-place activation, you should address these implications before adding anything related to in-place interfaces. Most of these implications have to do with the fact that you are going to be placing windows and menu items in a container application, so you have to check for assumptions that exist in your server windows exclusively. This may or may not be a major issue for you, but I hope to have you thinking about it before you get in too deep.</P>
<P>Given that deflating remark, here's how we'll progress through this chapter:</P>
<P>Prepare your object for the implications of in-place activation.</P>
<P>Implement skeletal <I>IOleInPlaceObject</I> and <I>IOleInPlaceActiveObject</I> interfaces and create some stubs for a few useful internal functions in your object.</P>
<P>Modify <I>DoVerb</I> to begin activation for the appropriate verbs and to provide for simple deactivation. This excludes most of the user interface.</P>
<P>Create, manage, and disassemble the shared menu.</P>
<P>Negotiate and create your in-place tools.</P>
<P>Modify your accelerators and your message loop to share the keyboard with the container.</P>
<P>Complete your implementation of the two in-place interfaces and add small fragments of code to round out your in-place object. This section, like the one in Chapter 22, is the catchall for the little fish that tend to slip through big nets. Here we'll also look briefly at inside-out objects.</P>
<P>The following sections describe these steps using Cosmo (CHAP23\COSMO) as an example. This chapter also includes an in-place–capable version of Polyline (CHAP23\POLYLINE) that behaves almost exactly the same way as Cosmo except that it doesn't have any menus or toolbars. Polyline is a simpler case of an in-place object, which makes a nice foundation for creating an OLE control in Chapter 24.</P>
<P>I have not provided an updated version of the HCosmo handler that we saw in Chapter 19. The registry files used for Cosmo in this chapter specify the default handler as the InprocHandler32 entry. If you encounter odd problems when working with Cosmo here, check the handler entry and be sure it specifies the default handler.</P></font></body></HTML>
