<HTML><HEAD><TITLE>The Easy Way: MKTYPLIB and the Object Description Language</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Easy Way:<I> </I>MKTYPLIB and the Object Description Language</H3><P>If you think about the amount of information you might want to describe for, say, one object and four interfaces, with each interface having about six member functions, you can quickly see that calling <I>ICreateTypeLib</I> and <I>ICreateTypeInfo</I> functions directly would get tedious beyond human patience. You can also see that much of what goes into a type library is similar to what you'd put in a header file. You would figure it makes sense to have some sort of tool that would parse headerlike information and call the appropriate interfaces and member functions internally to create type information out of that header. Just such a tool exists: MKTYPLIB.EXE—literally, "Make Type Library." This small compiler is more or less a C++ preprocessor that uses a file written in ODL as input. The parser recognizes ODL keywords and syntax and in turn calls <I>CreateTypeLib</I> and the other interfaces' member functions to turn the ODL information into a real type library. MKTYPLIB can also create a C/C++ header file containing interface and GUID definitions to simplify your implementation of the interfaces and classes defined in the library. This is quite convenient, and we'll see examples of this in later chapters.</P>
<P>To ship type information with an object, you can either ship the type library file stand-alone, integrate it into the resources of an EXE or a DLL, or place it inside a compound file. In a later section, we'll look at deployment and use of a type library. First, however, let's look at the format of an ODL file in more detail.</P>
<P>The keywords you can use and the syntax of an ODL file allow you to basically describe any structures, interfaces, dispinterfaces, modules, and objects that you want, using whatever types you want. An ODL file is simply a text file that has the following general syntax structure, in which keywords are indicated with boldface:</P>
<P><BR></P>
<pre><code>[<B>uuid</B>(&lt;GUID&gt;), &lt;helpinfo&gt;, &lt;attributes&gt;]<BR><B>library</B> &lt;name&gt;<BR>    {<BR>    <B>importlib</B>(&lt;path to another type library&gt;)<BR><BR>    <B>typedef</B> [&lt;attributes&gt;] &lt;basename | <B>struct</B> | <B>enum</B> | <B>union</B>&gt;<BR>        {<BR>        §<BR>        } &lt;type&gt;;<BR><BR>    [attributes] <B>module</B> &lt;name&gt;<BR>        {<BR>        &lt;element list&gt;<BR>        };<BR><BR>    [<B>uuid</B>(&lt;GUID&gt;), &lt;helpinfo&gt;, &lt;attributes&gt;]<BR>    <B>interface</B> &lt;name&gt;<BR>        {<BR>        [&lt;attributes&gt;] &lt;return type&gt; [calling convention] <BR>            &lt;function name&gt;(&lt;arguments&gt;);<BR>        §<BR>        }<BR><BR>    [<B>uuid</B>(&lt;GUID&gt;), &lt;helpinfo&gt;, &lt;attributes&gt;]<BR>    <B>dispinterface</B> &lt;name&gt;<BR>        {<BR>        <B>Properties</B>:<BR>            [&lt;attributes&gt;] &lt;type&gt; &lt;name&gt;;<BR>            §<BR>        <B>Methods</B>:<BR>            [&lt;attributes&gt;] &lt;return type&gt; &lt;name&gt;(&lt;arguments&gt;);<BR>            §<BR>        }<BR><BR>    [<B>uuid</B>(&lt;GUID&gt;), &lt;helpinfo&gt;, &lt;attributes&gt;]<BR>    <B>dispinterface</B> &lt;name&gt;<BR>        {<BR>        <B>interface</B> &lt;name&gt;;<BR>        }<BR><BR>    [<B>uuid</B>(&lt;GUID&gt;), &lt;helpinfo&gt;, &lt;attributes&gt;]<BR>    <B>coclass</B><BR>        {<BR>        [&lt;attributes&gt;] <B>dispinterface</B>  &lt;dispinterface name&gt;;<BR>        §<BR>        [&lt;attributes&gt;] <B>interface</B>      &lt;interface name&gt;;<BR>        }<BR>    };</code></pre>
<P>Although the <I>OLE Programmer</I><I>'</I><I>s Reference</I> has a complete description of ODL (it's too lengthy to repeat here), let's nonetheless take a look at this structure and point out the most important concepts.</P>
<P>You define the type library with the <I>library</I> keyword, assigning to it a LIBID (a GUID, the <I>uuid</I>), help information such as a descriptive string, and other attributes, all of which are specified between the square brackets preceding <I>library</I>. The <I>attributes</I> can include version information, the library LCID, and whether the entire library is hidden or restricted.</P>
<P>The body of a type library is contained between the braces following the <I>library</I> statement and can contain any number of each of the statements listed in Table 3-5. The most interesting statements to us so far are <I>coclass</I> and <I>interface</I> </P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>Head-Banging MKTYPLIB Errors</H4><P>MKTYPLIB is not necessarily the friendliest tool in the world, and the error messages that it generates can be the epitome of ambiguity. Here are a few I've seen:</P>
<P>First, it might complain, "Error generating type library: MKTYPLIB cannot preprocess the file." This is provoked either by a failure to find STDOLE.TLB as referenced in your <I>importlib</I><B> </B>statement or by a failure to find CL.EXE, the C-compiler preprocessor, both of which have to be on your path. To avoid the preprocessing step, you can use the /nocpp switch to bypass it without consequence.</P>
<P>The second strange error message is MKTYPLIB complaining of "unknown types," especially about things like <I>boolean </I>and BSTR which are definitely known types. This problem is caused by mismatched OLE DLLs on your system—MKTYPLIB uses the OLE DLLs themselves, where the implementation of <I>CreateTypeLib </I>and <I>ICreateType[Lib- </I><I>|</I><I> Info]</I> are found. If, for example, you have debug OLE DLLs in your path, you'll end up with an OLENLS.DLL that is not enabled for DBCS characters and ends up for a variety of reasons making types line <I>BSTR </I>unrecognizable.</P>
<P>Finally, you need to be very careful when creating a dispinterface or one marked as <I>oleautomation</I><B> </B>(automation compatible). MKTYPLIB itself can accept any type you want to put in an interface, including your own <I>structs</I>, <I>enums</I>, and <I>unions</I>. However, as we've seen, these are not accepted in an automation-compatible interface which includes by design any dispinterface. Furthermore, <I>unsigned </I>is not accepted for automation-compatible interfaces, although you can use it anywhere else. The inconsistencies that arise from not understanding what automation compatible means can really drive you batty.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>(and <I>dispinterface</I>). Through these statements, you describe the core of an object: its interfaces and the methods and properties of those interfaces. All of the <I>&lt;type&gt;</I> entries shown earlier can be a predefined standard type such as <I>int</I>,<I> long</I>,<I> double</I>, or<I> char</I> or any user-defined type created with a <I>typedef</I> statement.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="84pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Statement</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>importlib</P></TD><TD VALIGN="TOP"><P>Brings in all the information contained in another type library and makes it part of this library. The statement requires the filename of the TLB file. If a full pathname is not specified, this statement looks for the file in directories specified by the system path. All ODL files must have the statement <I>importlib</I> ("STDOLE.TLB") to pull in standard types.</P></TD></TR><TR><TD VALIGN="TOP"><P>coclass</P></TD><TD VALIGN="TOP"><P>Describes a component class in which <I>uuid</I> is the object's CLSID. The object can have any number of interfaces and dispinterfaces listed in its body, specifying the full set of interfaces that the object implements, both incoming and outgoing.</P></TD></TR><TR><TD VALIGN="TOP"><P>interface</P></TD><TD VALIGN="TOP"><P>Describes a vtable interface with the given name in which the body contains only member functions as in any other interface declaration. The <I>uuid</I> attribute is the IID.</P></TD></TR><TR><TD VALIGN="TOP"><P>dispinterface</P></TD><TD VALIGN="TOP"><P>Describes a dispinterface with the given name in which the body contains the list of properties and methods; properties are listed as data members in a C++ class and methods as C++ member functions. An alternative syntax can be used to distinguish a dispinterface from a vtable interface. The <I>uuid</I> attribute is the IID.</P></TD></TR><TR><TD VALIGN="TOP"><P>typedef</P></TD><TD VALIGN="TOP"><P>Defines a new type as an alias for an existing type or as a <I>struct</I>, <I>enum</I>, or <I>union</I>. The syntax is identical to the C <I>typedef</I> syntax. To be included in the final type library, a <I>typedef</I> must have at least one attribute, the most common of which is <I>public</I>, making it a public type. All <I>typedefs</I> can also have help information, a UUID, and a version number.</P></TD></TR><TR><TD VALIGN="TOP"><P>module</P></TD><TD VALIGN="TOP"><P>Describes exported functions and constants from a DLL just like an import library (LIB), which can be used for linking without an import library at all.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 3-5.</B></P>
<P><B>Statements that can appear in a type library.</B></P>
<H4><A NAME="sec1"></A>The coclass statement </H4><P>If you'll remember back to Chapter 2, there was the question about why <I>IUnknown</I> didn't have a way to ask an object to enumerate all of its incoming interfaces short of calling <I>QueryInterface</I> for everything you knew. The answer was type information, and the <I>coclass</I> statement provides just such a listing of the interfaces an object supports. The object itself is identified with its CLSID, given in the <I>uuid</I> attribute. A client that knows this CLSID can look through the type information, with or without instantiating the object, to easily determine an object's full set of incoming and outgoing interfaces. Without type information, <I>QueryInterface</I> is the only way to learn about the incoming interfaces; <I>IConnectionPointContainer::EnumConnectionPoints</I> is the only way to know an object's outgoing interfaces, and then you have to make sense of the enumerated IIDs for which you need type information anyway.</P>
<P>One very important attribute for <I>coclass</I> is called <I>licensed</I>. This attribute identifies the object's server as supporting an interface named <I>IClassFactory2</I>, which means the object (component) is licensed. This makes a difference with respect to how an object of the class must be instantiated, as we'll see in Chapter 5.</P>
<P>Each interface or dispinterface listed in a <I>coclass</I> can have only two optional attributes: <I>default</I> and <I>source</I>. If an interface or dispinterface is marked <I>source</I>, it is an outgoing interface; otherwise, it's an incoming interface. The default attribute can be used for one incoming and one outgoing interface or dispinterface. The default incoming interface is the primary interface for the object. If the interface is a dispinterface, a client can obtain its pointer with <I>QueryInterface(IID</I><I>_</I><I>IDispatch)</I>; all other dispinterfaces must be queried for by using their specific IIDs. The default source interface is called the primary event set for the object, but the object can have any number of event sets or other outgoing interfaces. Marking interfaces and dispinterfaces as <I>default</I> makes it convenient for a client to locate the object's most important interfaces.</P>
<H4><A NAME="sec2"></A>The interface statement</H4><P>If you want to describe a vtable interface, such as <I>IUnknown</I>, the <I>interface</I> statement lets you list all the member functions of that interface with the syntax shown earlier. Each function has optional attributes, a return type, an optional calling convention (<I>cdecl</I>, <I>pascal</I>, or <I>stdcall</I>, with or without a leading _ or __ ), the name of the member function, and its list of arguments, which can be <I>void</I> or any sequence of <I>[attributes]</I> <I>&lt;type&gt;</I> <I>&lt;name&gt;</I> entries separated by a comma. Yes, this is pretty rich stuff.</P>
<P>The attributes you can specify on an <I>interface</I> include its IID, help information, version information, whether it is <I>hidden</I> or <I>restricted,</I> whether the interface is what is called a <I>dual</I> interface in OLE Automation, and whether the interface uses only <I>oleautomation</I>-compatible argument types (which are restricted, as we'll see in Chapter 14). You must also always include the <I>odl</I> attribute on every <I>interface</I> to distinguish it from an IDL definition.5 The attributes on each function in the interface include whether the function is a property get, property put, or property put-by-reference operation (<I>propget</I>, <I>propput</I>, <I>propputref</I>); whether it has variable arguments; and whether it is <I>hidden</I>. A leading underscore on a member name, as in <I>_</I><I>NewEnum</I>, is equivalent to including the <I>hidden</I> attribute. In addition, the <I>id(xx)</I> attribute assigns some identifier to the member (useful for OLE Automation, especially dual interfaces). Finally, arguments themselves each have attributes such as <I>in</I>, <I>out</I>, and <I>optional</I>, which specify the behavior of the argument.</P>
<H4><A NAME="sec3"></A>The dispinterface statement</H4><P>You might have noticed that <I>dispinterface</I> has two forms. The first form allows you to describe methods and properties as if you were declaring a C++ class, using the keywords <I>Properties</I> or <I>Methods</I> as you would use <I>public</I> or <I>private</I>. Each property can have an <I>id</I> attribute to specify its dispatch identifier (dispID) as well as help information, whether it's <I>hidden,</I> and whether this particular property is <I>read-only</I>. Each method and argument can have the same attributes as <I>interface.</I></P>
<P>The second form of the <I>dispinterface</I> statement basically picks up the functions in some interface and makes a dispinterface out of it. Whichever members in the interface had <I>propget</I>, <I>propput</I>, or <I>propputref</I> on them become properties in the dispinterface; other members become methods. In all cases, any <I>id</I> in the <I>interface</I> is preserved.</P>
<P>Having two forms for <I>dispinterface</I> was necessary before the idea of dual interfaces became available. Dual interfaces are now recommended over the definition of a dispinterface from an interface. We'll see dual interfaces in Chapter 14.</P>
<P>The previous discussion of the most important ODL statements mentioned a fair number of attributes, but not all of them. The complete list as of the time of writing this chapter appears in Table 3-6. Entries marked with an asterisk (*) are available under Win16 with OLE 2.02 or later, and those marked with a double asterisk (**) are available only under Win16 if you have the MKTYPLIB.EXE file from the OLE Custom Controls Development Kit. Because not all of these attributes can be used with every statement or other field in an ODL file, the allowable uses of each attribute are cross-referenced in Figure 3-2 on page 168.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="95pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Attribute</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>appobject</P></TD><TD VALIGN="TOP"><P>Identifies a <I>coclass</I> as an <I>application object,</I> which is associated with a full EXE application.</P></TD></TR><TR><TD VALIGN="TOP"><P>bindable**</P></TD><TD VALIGN="TOP"><P>Identifies a property as supporting data binding through the <I>IPropertyNotifySink::OnChanged</I> function.</P></TD></TR><TR><TD VALIGN="TOP"><P>control**</P></TD><TD VALIGN="TOP"><P>Identifies a <I>coclass</I> as an OLE control.</P></TD></TR><TR><TD VALIGN="TOP"><P>default**</P></TD><TD VALIGN="TOP"><P>Specifies a default incoming or outgoing interface in a <I>coclass</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>defaultbind**</P></TD><TD VALIGN="TOP"><P>Identifies a <I>bindable</I> property that best represents the object as a whole.</P></TD></TR><TR><TD VALIGN="TOP"><P>displaybind**</P></TD><TD VALIGN="TOP"><P>Indicates that the binding capability of a property can be displayed in the user interface of a controller.</P></TD></TR><TR><TD VALIGN="TOP"><P>dllname</P></TD><TD VALIGN="TOP"><P>Identifies the name of the DLL described in a module.</P></TD></TR><TR><TD VALIGN="TOP"><P>dual*</P></TD><TD VALIGN="TOP"><P>Marks an interface as a dual interface.</P></TD></TR><TR><TD VALIGN="TOP"><P>entry</P></TD><TD VALIGN="TOP"><P>Specifies an exported function or constant in a module.</P></TD></TR><TR><TD VALIGN="TOP"><P>helpcontext</P></TD><TD VALIGN="TOP"><P>Specifies a context ID within a help file that can be used to view information about this element.</P></TD></TR><TR><TD VALIGN="TOP"><P>helpfile</P></TD><TD VALIGN="TOP"><P>Specifies the filename (no path) of the help file that contains information about this element. Your installation program must save the path of the help file in the registry under TypeLib\HELPDIR; you do not want to hard code such paths into your type library.</P></TD></TR><TR><TD VALIGN="TOP"><P>helpstring</P></TD><TD VALIGN="TOP"><P>Contains a short description of the element, usually suitable for a status line or a similar user interface.</P></TD></TR><TR><TD VALIGN="TOP"><P>hidden*</P></TD><TD VALIGN="TOP"><P>Indicates that the element should never be displayed in a browser in a programming environment.</P></TD></TR><TR><TD VALIGN="TOP"><P>id</P></TD><TD VALIGN="TOP"><P>Assigns a DISPID to a function, method, or property.</P></TD></TR><TR><TD VALIGN="TOP"><P>in</P></TD><TD VALIGN="TOP"><P>Identifies an argument as an in-parameter.</P></TD></TR><TR><TD VALIGN="TOP"><P>lcid</P></TD><TD VALIGN="TOP"><P>Identifies the locale for a library or an argument.</P></TD></TR><TR><TD VALIGN="TOP"><P>licensed**</P></TD><TD VALIGN="TOP"><P>Indicates that a <I>coclass</I> must be instantiated using <I>IClassFactory2</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>nonextensible*</P></TD><TD VALIGN="TOP"><P>Indicates that an interface or dispinterface includes only those methods and properties listed and cannot be extended with additional members at run time.</P></TD></TR><TR><TD VALIGN="TOP"><P>odl</P></TD><TD VALIGN="TOP"><P>Required for all <I>interface</I> statements to identify the description as an ODL description as opposed to IDL.</P></TD></TR><TR><TD VALIGN="TOP"><P>oleautomation*</P></TD><TD VALIGN="TOP"><P>Indicates that the interface or dispinterface is OLE Automation compatible.</P></TD></TR><TR><TD VALIGN="TOP"><P>optional</P></TD><TD VALIGN="TOP"><P>Marks an argument as optional.</P></TD></TR><TR><TD VALIGN="TOP"><P>out</P></TD><TD VALIGN="TOP"><P>Marks an argument as an out-parameter.</P></TD></TR><TR><TD VALIGN="TOP"><P>propget</P></TD><TD VALIGN="TOP"><P>Used in an interface to indicate that the named function performs a property get on a property of the same name.</P></TD></TR><TR><TD VALIGN="TOP"><P>propput</P></TD><TD VALIGN="TOP"><P>Used in an interface to indicate that the named function performs a property put on a property of the same name.</P></TD></TR><TR><TD VALIGN="TOP"><P>propputref</P></TD><TD VALIGN="TOP"><P>Same as <I>propput</I> but indicates that the put value can be passed by reference.</P></TD></TR><TR><TD VALIGN="TOP"><P>public</P></TD><TD VALIGN="TOP"><P>Includes a <I>typedef</I> in the type library so it can be browsed later; otherwise, treats it as a <I>#</I><I>define</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>readonly</P></TD><TD VALIGN="TOP"><P>Marks a property as read-only.</P></TD></TR><TR><TD VALIGN="TOP"><P>requestedit**</P></TD><TD VALIGN="TOP"><P>Identifies a property that will send <I>IPropertyNotifySink::OnRequestEdit</I> before changing.</P></TD></TR><TR><TD VALIGN="TOP"><P>restricted</P></TD><TD VALIGN="TOP"><P>Indicates that a library or members in a module or interface or dispinterface cannot be called from arbitrary clients. Usually this means that some other form of access is required to call the function.</P></TD></TR><TR><TD VALIGN="TOP"><P>retval*</P></TD><TD VALIGN="TOP"><P>Marks a parameter in a dual interface as the actual return value for a method when the method returns HRESULT.</P></TD></TR><TR><TD VALIGN="TOP"><P>source**</P></TD><TD VALIGN="TOP"><P>Indicates that an interface or dispinterface listed in a <I>coclass</I> is outgoing.</P></TD></TR><TR><TD VALIGN="TOP"><P>string</P></TD><TD VALIGN="TOP"><P>Declares a string for compatibility with IDL.</P></TD></TR><TR><TD VALIGN="TOP"><P>uuid</P></TD><TD VALIGN="TOP"><P>Assigns a GUID to the element.</P></TD></TR><TR><TD VALIGN="TOP"><P>vararg</P></TD><TD VALIGN="TOP"><P>Indicates that the function takes variable arguments.</P></TD></TR><TR><TD VALIGN="TOP"><P>version</P></TD><TD VALIGN="TOP"><P>Specifies a version number for the element.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 3-6.</B></P>
<P><B>Listing of ODL attributes.</B></P>
<P>    <img src="table.gif"></P>
<P><B>Figure 3-2.</B></P>
<P><B>Attributes and their corresponding ODL statements.</B></P>
<P>Keep in mind that you can use C-language comments, /*...*/ and //, in an ODL file. The various samples that accompany this chapter show different ODL files that use many of these attributes in real working pieces of code.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec4"></A>Other Type Library Generation Tools</H4><P>Since MKTYPLIB is really little more than a preprocessor that ties into an OLE service, you can create other tools that generate type libraries without involving MKTYPLIB at all. You can, in fact, even bypass ODL files completely since such a file is simply input to MKTYPLIB. You can easily imagine a tool that would provide a way to specify interfaces and object classes faster and easier than writing an ODL file from scratch. You can also imagine a tool that would actually write the ODL file for you. (The ClassWizard in Microsoft Visual C++ does this.) The point is that MKTYPLIB and ODL files should not be considered the final word in creating type libraries—they're just tools.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>5 The Interface Definition Language is used to describe interfaces for marshaling purposes as we'll see in Chapter 6. ODL and IDL are very similar and have their differences but Microsoft is currently looking at ways to merge the two. Interface descriptions in ODL without the <I>odl </I>will simply fail to compile.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
