<HTML><HEAD><TITLE>Call the Dispinterface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Call the Dispinterface</H3><P>While executing an automation script, a controller will get or put properties and call object methods. Which operation is performed depends on how an expression such as <I>Object.Property </I>or <I>Object.Method </I>is used in the controller's scripting language. A specific controller that drives a specific object (such as AutoCli) may not have a language script, in which case the controller's structure and code determine which operation is used. We'll look at each case in turn, but first we have to know which dispID to send to <I>Invoke </I>in order to perform the operation.</P>
<H4><A NAME="sec0"></A>Mapping a Name to a dispID</H4><P>Mapping the text names (which are used in scripting languages) of methods and properties to a dispID is the first step in late binding to the object's features. There are two ways to accomplish this. The first, demonstrated in AutoCli and also used in DispTest and Visual Basic 3, is to call <I>IDispatch::GetIDsOfNames</I> before calling <I>Invoke</I>. AutoCli has the function <I>CApp::NameToID </I>that performs the lookup:</P>
<P><BR></P>
<pre><code>    §<BR>    //Elsewhere<BR>    hr=pApp-&gt;NameToID(OLETEXT("Sound"), &amp;dispID);<BR>    §<BR><BR>HRESULT CApp::NameToID(OLECHAR *pszName, DISPID *pDispID)<BR>    {<BR>    HRESULT     hr;<BR>    TCHAR       szMsg[80];<BR><BR>    hr=m_pIDispatch-&gt;GetIDsOfNames(IID_NULL, &amp;pszName, 1<BR>        , m_lcid, pDispID);<BR><BR>    if (FAILED(hr))<BR>        {<BR>        wsprintf(szMsg<BR>            , TEXT("GetIDsOfNames on '%s' failed with 0x%lX")<BR>            , pszName, hr);<BR>        Message(szMsg);<BR>        }<BR><BR>    return hr;<BR>    }</code></pre>
<P>This is about the least efficient way, however, to accomplish the name-to-dispID mapping, especially when an out-of-process object is being used. In that case, it is wasteful to call across the process boundary twice for every property or method invocation.</P>
<P>One optimization would be to load the object's type information yourself (with <I>LoadRegTypeLib </I>or<I> LoadTypeLib</I>)<I> </I>and use <I>ITypeInfo::GetIDsOfNames</I> (which is usually called from within <I>IDispatch::GetIDsOfNames </I>anyway, but in the other process).2 Because the type information would be loaded in your controller's process, you would avoid all the extra cross-process calls, and you could do all this before<I> </I>creating the object. There is no gain in calling <I>IDispatch::GetTypeInfo</I> at run time and performing the dispID lookups through the returned <I>ITypeInfo</I><I>—</I>this <I>ITypeInfo </I>is itself tied to an out-of-process object, and as a result, you aren't saving anything.</P>
<P>Of course, an object might not have type information (Beeper1 in Chapter 14, for example) for you to load, in which case you have no choice but to call <I>IDispatch::GetIDsOfNames </I>after the object has been created, as is done in AutoCli.</P>
<P>With or without type information, there is still one more optimization—instead of mapping the name to a dispID before each call, map all the names in the controller script before execution begins, and keep the dispIDs in a cached table. You will then not only avoid two function calls (potentially across a process boundary) for each invocation, but you will eliminate all redundant calls to <I>GetIDsOfNames.</I> Later versions of Visual Basic use this sort of technique to improve run-time performance.</P>
<P>Whichever operation is being performed—property get, property set, or method call—your program ends up with a dispID for the method or property being invoked. Let's see how each different operation appears in a call to <I>IDispatch::Invoke</I>. In AutoCli, the actual call to <I>Invoke</I> happens through <I>CApp::Invoke</I>, which centralizes the <I>IDispatch </I>call as well as exception handling:</P>
<P><BR></P>
<pre><code>HRESULT CApp::Invoke(DISPID dispID, WORD wFlags, DISPPARAMS *pdp<BR>    , VARIANT *pva, EXCEPINFO *pExInfo, UINT *puErr)<BR>    {<BR>    HRESULT    hr;<BR>    §<BR><BR>    if (NULL==m_pIDispatch)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    hr=m_pIDispatch-&gt;Invoke(dispID, IID_NULL, m_lcid, wFlags<BR>        , pdp, pva, pExInfo, puErr);<BR><BR>    §<BR>    }</code></pre>
<P>This function is called from specific cases within the WM_COMMAND handling code (for the menu items) in <I>AutoClientWndProc</I>. This procedure declares as stack variables the various structures that we'll need to make the <I>Invoke </I>call:</P>
<P><BR></P>
<pre><code>DISPID          dispID, dispIDParam;<BR>DISPPARAMS      dp;<BR>VARIANTARG      va;<BR>EXCEPINFO       exInfo;<BR>UINT            uErr;<BR>HRESULT         hr;</code></pre>
<P>Let's look at each <I>Invoke </I>case separately.</P>
<H4><A NAME="sec1"></A>A Property Get</H4><P>Retrieving a property is about the easiest thing for an automation controller to accomplish because it involves no arguments to pass to <I>Invoke </I>and is concerned only with the return value of the property:</P>
<P><BR></P>
<pre><code>    hr=pApp-&gt;NameToID(OLETEXT("Sound"), &amp;dispID);<BR>    <BR>    if (FAILED(hr))<BR>        break;<BR>    <BR>    SETNOPARAMS(dp);<BR>    hr=pApp-&gt;Invoke(dispID, DISPATCH_PROPERTYGET<BR>        , &amp;dp, &amp;va, &amp;exInfo, NULL);</code></pre>
<P>In this code, AutoCli is finding the dispID of the <I>Sound </I>property (which is why this doesn't work in a language other than English or the neutral language) and passing that dispID to <I>Invoke </I>with the flag DISPATCH_PROPERTYGET to identify the operation. The return value comes back in the <I>va </I>parameter, in which <I>va.lVal</I> will have the sound. (AutoCli makes a string out of this sound and displays that string in its client area.) You'll notice that we must still pass a DISPPARAMS<I> </I>structure to <I>Invoke </I>here, but because there are no arguments, the structure is empty. The macro SETNOPARAMS, which you will find in the sample code file INC\INOLE.H, stores the appropriate NULLs and zeros in the structure using a more general macro, which is named SETDISPPARAMS:</P>
<P><BR></P>
<pre><code>#define SETDISPPARAMS(dp, numArgs, pvArgs, numNamed, pNamed) \<BR>    {\<BR>    (dp).cArgs=numArgs;\<BR>    (dp).rgvarg=pvArgs;\<BR>    (dp).cNamedArgs=numNamed;\<BR>    (dp).rgdispidNamedArgs=pNamed;\<BR>    }<BR><BR>#define SETNOPARAMS(dp) SETDISPPARAMS(dp, 0, NULL, 0, NULL)</code></pre>
<P>These macros are simply a convenient way to save tedious typing. Note that if a property involves indices into an array, the controller can pass those indices in DISPPARAMS<I> </I>as arguments to the property get.</P>
<H4><A NAME="sec2"></A>A Property Put</H4><P>Setting a property to a new value is a little more complex than retrieving its current value. As we learned in Chapter 14, a controller must pass the new value for the property in a VARIANTARG<I> </I>structure in DISPPARAMS, and that one argument must be named with DISPID_PROPERTYPUT. Functions such as <I>ITypeInfo::Invoke </I>will enforce this, returning DISP_E_PARAMNOTFOUND, which is a difficult error to track down. (Additional arguments are allowed if the controller is passing array indices.)</P>
<P>In the following code, AutoCli again finds the dispID for <I>Sound</I>, packs up the new sound value—which is either the menu command value itself in <I>wID</I> or the value 0—in the <I>va </I>variable, puts that VARIANTARG<I> </I>into DISPPARAMS<I> </I>as a VT_I4<I>, </I>sets the rest of the DISPPARAMS structure, and then calls <I>Invoke</I>:</P>
<P><BR></P>
<pre><code>    hr=pApp-&gt;NameToID(OLETEXT("Sound"), &amp;dispID);<BR><BR>    if (FAILED(hr))<BR>        break;<BR><BR>    VariantInit(&amp;va);<BR>    va.vt=VT_I4;<BR>    va.lVal=(IDM_SETSOUNDDEFAULT==wID)<BR>        ? 0L : (long)(wID);<BR><BR>    dispIDParam=DISPID_PROPERTYPUT;<BR>    SETDISPPARAMS(dp, 1, &amp;va, 1, &amp;dispIDParam);<BR><BR>    hr=pApp-&gt;Invoke(dispID, DISPATCH_PROPERTYPUT<BR>        , &amp;dp, NULL, &amp;exInfo, NULL);</code></pre>
<P>You'll notice again that the controller has to set both the <I>cArgs </I>and <I>cNamedArgs</I> fields in DISPPARAMS<I> </I>to 1 in a property put operation. Also, because a property put has no return value, there is no reason to pass a VARIANT to <I>Invoke </I>for that purpose, which is why the fourth parameter to <I>Invoke</I> here is NULL.</P>
<H4><A NAME="sec3"></A>A Method Call with No Arguments</H4><P>When AutoCli invokes the <I>Beep</I> method, it executes almost exactly the same sequence of steps that were used in the property put case:</P>
<P><BR></P>
<pre><code>    hr=pApp-&gt;NameToID(OLETEXT("Beep"), &amp;dispID);<BR><BR>    if (FAILED(hr))<BR>        break;<BR><BR>    SETNOPARAMS(dp);<BR>    hr=pApp-&gt;Invoke(dispID, DISPATCH_METHOD, &amp;dp<BR>        , &amp;va, &amp;exInfo, &amp;uErr);</code></pre>
<P>In fact, if we used the dispID for <I>Sound </I>here instead of the one for <I>Beep</I> and changed the DISPATCH_METHOD flag to DISPATCH_PROPERTYGET, we'd have the equivalent of a property get. You can see from this why controllers that can't discern a property get from a method invocation have no trouble—they simply get the dispID and pass both DISPATCH_METHOD and DISPATCH_PROPERTYGET to <I>Invoke. </I>Even the return value is the same.</P>
<H4><A NAME="sec4"></A>A Method Call with Arguments</H4><P>The method call demonstrated in AutoCli is a degenerate one in which the situation is not complicated by those petty annoyances called arguments. Let's look at a hypothetical example of a method call for which arguments are involved. Let's assume we're working with Chapter 14's Cosmo as the automation server and that we want to invoke the <I>Figure::AddPoint </I>method, which takes two arguments. The hypothetical automation script the controller is running might have a line such as the following—in this case, we must parse the line and generate the right method call:</P>
<P><BR></P>
<pre><code>Figure.AddPoint 15000,43200</code></pre>
<P>In parsing this code, we know first that <I>Figure </I>refers to a specific <I>IDispatch</I> pointer. We then find the name <I>AddPoint</I>, and given the dispinterface's type information, we know <I>AddPoint</I> is a method. In parsing the remainder of this line, we find two arguments—15000 and 43200—that we can assume are of type <I>short</I>. For the most part, the actual type is unimportant as long as the object can convert it to the correct type. In this example, we could send <I>short</I>,<I> long</I>,<I> float</I>,<I> double</I>,<I> </I>or BSTR types, and the object would probably be able to convert it. This is, of course, the lazy man's controller—the best thing you can actually do is to check the types that are present in the type information and try to match the type of your arguments to what the controller is expecting. That greatly increases the chances that the object will be able to use what you send.</P>
<P>So we have two <I>short</I> values that we now need to send to <I>Invoke</I>. We allocate two VARIANTARG<I> </I>structures and stuff them into DISPPARAMS:</P>
<P><BR></P>
<pre><code>//Assume dispID has "AddPoint" method ID.<BR>//Assume xArg and yArg are the values we have from parsing.<BR><BR>DISPPARAMS     dp;<BR>VARIANTARG    *pva;<BR><BR>pva=/(VARIANTARG*)malloc(sizeof(VARIANTARG)*2);<BR><BR>if (NULL==pva)<BR>    [memory error]<BR><BR>VariantInit(pva[0]);<BR>pva[0].vt=VT_I2;<BR>pva[0].iVal=xArg;<BR>VariantInit(pva[1]);<BR>pva[1].vt=VT_I2;<BR>pva[1].iVal=yArg;<BR><BR>//cArgs=2, cNamesArgs=0<BR>SETDISPPARAMS(dp, 2, pva, 0, NULL);<BR>hr=pFigure-&gt;Invoke(dispID, DISPATCH_METHOD, &amp;dp<BR>    , &amp;vaRet, &amp;exInfo, &amp;uErr);<BR><BR>free(pva);<BR>§</code></pre>
<P>This code demonstrates the steps necessary to call the <I>AddPoint </I>method. Most likely a controller that does any kind of language parsing will have a generic function to create the correct argument list from any method signature and would not have specific code written as this is. In any case, this example—although limited—does illustrate passing more than one argument.</P>
<P>You may have a situation in which you need to pass the address of a variable for use as an out-parameter or for any other by-reference passing convention. If you do, the VARIANTARG<I> </I>you create will simply include the VT_BYREF flag and the right pointer value in the correct field of the VARIANTARG<I> </I>union. For example, if we passed <I>xArg </I>by reference in the preceding example, we'd set the argument this way:</P>
<P><BR></P>
<pre><code>VariantInit(pva[0]);<BR>pva[0].vt=VT_I2 œ VT_BYREF;<BR>pva[0].piVal=&amp;xArg;</code></pre>
<H4><A NAME="sec5"></A>A Method Call with Optional Arguments</H4><P>Calling a method that takes optional arguments requires that you actually send one VARIANTARG<I> </I>to the function for each optional argument. For those arguments that are not present, the VARTYPE must be set to VT_ERROR and the <I>scode </I>field must be set to DISP_E_PARAMNOTFOUND. For example, consider the standard document <I>Close </I>method that takes two optional parameters, <I>SaveChanges </I>and <I>SaveFile</I>. The code that appears in the controller can take one of any three forms, here using Cosmo's Figure object as an example:</P>
<P><BR></P>
<pre><code>Figure.Close<BR>Figure.Close (False)<BR>Figure.Close (True, "saveit.cos")</code></pre>
<P>Let's assume that we encounter the first form of the call. We know from the object's type information that <I>Close </I>takes two optional arguments that we need to supply, but we know from parsing the running script that we have nothing to send it. We need to allocate two VARIANTARG<I> </I>structures anyway and fill them as follows:</P>
<P><BR></P>
<pre><code>pva=malloc(sizeof(VARIANTARG)*2);<BR>§<BR>VariantInit(pva[0]);<BR>pva[0].vt=VT_ERROR;<BR>pva[0].scode=DISP_E_PARAMNOTFOUND;<BR>VariantInit(pva[1]);<BR>pva[1].vt=VT_ERROR;<BR>pva[1].scode=DISP_E_PARAMNOTFOUND;</code></pre>
<P>The object will see these empty arguments and simply perform the default action for <I>Close</I>.</P>
<P>If we encounter the second form of the call, we know from parsing the line that we have one argument that we store in, say, <I>fSave</I>. We still have to allocate both VARIANTARGs, filling the first with actual data:</P>
<P><BR></P>
<pre><code>VariantInit(pva[0]);<BR>pva[0].vt=VT_BOOL;<BR>pva[0].bool=fSave;       //fSave is a variable from parsing.<BR>VariantInit(pva[1]);<BR>pva[1].vt=VT_ERROR;<BR>pva[1].scode=DISP_E_PARAMNOTFOUND;</code></pre>
<P>The object will see that it should not save changes in this case and will ignore the second argument because it is irrelevant.</P>
<P>In the third form of the call, our parsing gives us a Boolean (<I>fSave</I>)<I> </I>and a string (<I>pszFile</I>). To pass the string we have to create a BSTR,<I> </I>which we free ourselves after <I>Invoke </I>returns:</P>
<P><BR></P>
<pre><code>VariantInit(pva[0]);<BR>pva[0].vt=VT_BOOL;<BR>pva[0].bool=fSave;       //fSave is a variable from parsing.<BR>VariantInit(pva[1]);<BR>pva[1].vt=VT_BSTR;<BR>pva[1].bstrVal=SysAllocString(pszFile);<BR><BR>[Set up DISPPARAMS and call Invoke.]<BR>SysFreeString(pva[1].bstrVal);<BR>§</code></pre>
<H4><A NAME="sec6"></A>A Method Call with Named Arguments</H4><P>Dealing with methods that require named arguments is probably the hardest case in all the possible types of method calls because it involves more work with <I>IDispatch::GetIDsOfNames. </I>An example of this kind of method was given in Chapter 14, the <I>FindRockBand </I>method in the dispinterface of a database-type object:</P>
<P><BR></P>
<pre><code>[id(7)] long FindRockBand(int cMembers, BSTR LeadGuitar, BSTR BassGuitar<BR>    , BSTR Percussion)</code></pre>
<P>When this line of ODL script was compiled into the object's type information, the arguments were given member IDs of 0, 1, 2, and 3, based on the order listed in the function signature. Now let's imagine a line of code in the automation controller's script in which these named arguments are not necessarily given in the same order:</P>
<P><BR></P>
<pre><code>id=Database.FindRockBand(3, BassGuitar="Lee", LeadGuitar="Lifeson"<BR>    , Percussion="Peart")</code></pre>
<P>When we call <I>GetIDsOfNames </I>to find the dispID for <I>FindRockBand</I>,<I> </I>we have to pass the names <I>BassGuitar</I>,<I> LeadGuitar</I>,<I> </I>and <I>Percussion</I> to get their member IDs as well. This makes the call to <I>GetIDsOfNames</I> more complicated because you must create an array of string pointers to each name (method and arguments) as well as allocate an array of DISPIDs, one for each method and argument. Then you can retrieve the dispIDs:</P>
<P><BR></P>
<pre><code>//Assume we know we have 4 names (1 method, 3 arguments).<BR>LPTSTR  *ppsz;<BR>DISPID  *rgDispID;<BR><BR>ppsz=(DISPID *)malloc(sizeof(LPOLESTR)*cNames);<BR>ppsz[0]=pszMethod;       //Points to "FindRockBand" from parsing<BR>ppsz[1]=pszArg1;         //Points to "BassGuitar," the first parsed<BR>ppsz[2]=pszArg2;         //Points to "LeadGuitar," the second parsed<BR>ppsz[3]=pszArg3;         //Points to "Percussion," the third parsed<BR><BR>pDispID=malloc(sizeof(DISPID)*cNames);<BR>pDatabase-&gt;GetIDsOfNames(IID_NULL, ppsz, cNames, lcid, pDispID);</code></pre>
<P>On return, the <I>pDispID </I>array will contain the numbers 7 (dispID of <I>FindRockBand</I>), 2 (member ID of <I>BassGuitar</I>), 1 (member ID of <I>LeadGuitar</I>), and 3 (member ID of <I>Percussion</I>).</P>
<P>When we call <I>Invoke</I>,<I> </I>we have to allocate four VARIANTARG<I> </I>structures (three names plus the argument <I>cMembers</I>, which will have the value 3) and stuff them into the DISPPARAMS structure. Each string, of course, will have to be allocated as a BSTR. Assuming we've created the argument structures, we will fill DISPPARAMS<I> </I>as follows:</P>
<P><BR></P>
<pre><code>dp.cArgs=4;<BR>dp.rgvarg=pva;<BR>dp.cNamedArgs=3;<BR>dp.rgdispidNamedArgs=&amp;(pDispID[1]);  //Skip method name!</code></pre>
<P>The object will see that it has been sent named arguments and will use <I>rgdispIDNamedArgs </I>to determine which argument is which in the <I>rgvarg </I>array. For a controller, this means that you must absolutely match the order of the <I>rgdispIDNamedArgs</I> array with the order of VARIANTARG structures in <I>rgvarg</I>. Failure to do this will cause, well, mayhem. The order in which the arguments appear in the object's type information and the order in which they appear in the actual running script are both completely irrelevant: all that matters is that you precisely identify which argument is in what element of <I>rgvarg</I>.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 This technique will not work for <I>ITypeInfo::Invoke </I>because you'd need the object's custom interface in order to call the function. The interface might not be exposed and probably would not marshal anyway. So it's not an option.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
