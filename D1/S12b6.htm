<HTML><HEAD><TITLE>Summary</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Summary</H2><P>A local server for embedded content objects is primarily responsible for defining what an object looks like, how it behaves, and what sort of native data is required to generate and regenerate that content object whenever necessary. The structure of a content object in a local server is considerably simpler than the structure of an in-process handler. Specifically, such an object needs to implement only <I>IPersistStorage</I>, <I>IDataObject</I>, and <I>IOleObject</I>.</P>
<P><I>IPersistStorage </I>gives the object the ability to incrementally access its native data in persistent storage, that is, inside the container's compound document itself. The object does not need to load any data until absolutely necessary, and it can also write incremental changes. When an object wants to save itself, it actually asks the container to do so first by calling <I>IOleClientSite::SaveObject</I>, which gives the container a chance to save the cache and any other information the container maintains for that object. In turn, the container will tell the object to save its own data by calling <I>IPersistStorage::Save. </I>It is also through <I>IPersistStorage</I> that a server supports conversion as well as emulation—the server's implementation of this interface must be able to read and possibly write foreign formats in order to support the conversion and emulation features.</P>
<P><I>IDataObject </I>is how the cache on the container side of the picture retrieves graphical presentations from the object for whatever display aspect is used in the container. Correspondingly, a content object in a local server must supply at least CF_METAFILEPICT, CF_BITMAP, or CF_DIB through <I>IDataObject::GetData</I>. Any other formats are optional but usually include CFSTR_EMBEDSOURCE or CFSTR_EMBEDDEDOBJECT.</P>
<P><I>IOleObject </I>is the workhorse of OLE Documents, but of its 21 member functions, only 3 really require nontrivial implementations. The most notable is <I>IOleObject::DoVerb</I>, which instructs an object to activate. Activation is, of course, one of the key elements of OLE Documents as a technology. The other most important member function is <I>IOleObject::Close</I>, which tells an object to move from the active or running state to the loaded state. Other member functions can be left unimplemented, delegated to helper functions in OLE, or implemented by returning a value that tells OLE to provide a default implementation. So overall, even this large interface doesn't present a major problem to the implementation of a local server for OLE Documents.</P>
<P>Besides the differences between local and in-process servers, there is also a difference between miniservers and full servers. The former are typically written for the express purpose of servicing an embedded object; that is, the user cannot run a miniserver as a stand-alone server but only to create a new object or to manipulate an existing one. As a consequence, miniservers typically do not support linking. Full servers, on the other hand, can run as stand-alone servers, outside OLE Documents altogether, and can easily support linking.</P>
<P>This chapter takes a brief look at the structure of local servers and the considerations that influence uses of miniservers and full servers. The implementation of a local server for embedded content objects is detailed in step-by-step fashion, using the Cosmo sample for demonstration. The treatment of in-process servers for OLE Documents is left to Chapter 19.</P></font></body></HTML>
