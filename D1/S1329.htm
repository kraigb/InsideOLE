<HTML><HEAD><TITLE>Rounding Third...and Heading for Home</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Rounding Third...and Heading for Home</H3><P>We're now on the home stretch and have only to add little bits of code to complete our in-place object implementation. Some of the following steps are required, and some are optional:</P>
<P>(Required) Resize your tools on <I>IOleInPlaceActiveObject::ResizeBorder</I>.</P>
<P>(Required) Implement <I>IOleInPlaceObject::SetObjectRects</I> to update your editing window's position, and call <I>IOleInPlaceSite::OnPosRectChange</I> and <I>IOleInPlaceSite::Scroll</I> if you need more room.</P>
<P>(Required) Implement <I>IOleInPlaceActiveObject::OnFrameWindowActivate</I> and <I>IOleInPlaceActiveObject::OnDocWindowActivate</I> to handle UI changes appropriately.</P>
<P>(Required) Implement minimal context-sensitive help support in case the container supports it, even if you don't.</P>
<P>(Required) Provide Undo support by calling <I>IOleInPlaceSite::DiscardUndoState</I> when making a change after activation and by implementing <I>IOleInPlaceObject::ReactivateAndUndo</I>.</P>
<P>(Optional) If you have an Undo command, call <I>IOleInPlaceSite::DeactivateAndUndo</I> if the command is given immediately after deactivation. Also implement <I>IOleObject::DoVerb</I> for OLEIVERB_DISCARDUNDOSTATE.</P>
<P>(Optional) Call <I>IOleInPlaceFrame::SetStatusText</I> with messages for your menu items even if you don't have your own status line.</P>
<P>(Optional) Provide methods for opening the object into a server window from an in-place–active state.</P>
<P>(Optional) If you have modeless pop-up windows that are usually shown as part of your user interface, show/hide or enable/disable these windows when your <I>IOleInPlaceActiveObject::EnableModeless</I> function is called. You can also tell the container to do the same by calling <I>IOleInPlaceFrame::EnableModeless</I>.</P>
<P>Also, if you want to experiment with your object as an inside-out object, mark it with OLEMISC_INSIDEOUT and OLEMISC_ACTIVATEWHENVISIBLE (I've done the latter for the Polyline sample in this chapter) and then run the object with a container that supports inside-out objects. You'll see that such a container treats your application somewhat differently when it's marked with these bits, especially the latter bit, which is common with OLE controls.</P>
<P>Let's now look at each of these steps in more detail.</P>
<H4><A NAME="sec0"></A>Implement <I>IOleInPlaceActiveObject::ResizeBorder</I></H4><P>Whenever an end user resizes the container's frame window or document window, the container calls your <I>IOleInPlaceActiveObject::ResizeBorder</I> function with the <I>IOleInPlaceUIWindow</I> interface for the container's frame or document.6 A flag indicates which one the pointer refers to. Within <I>ResizeBorder</I>, you must renegotiate for space for your object's tools and resize those tools to fit in that space:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceActiveObject::ResizeBorder(LPCRECT pRect<BR>    , LPOLEINPLACEUIWINDOW pIUIWindow, BOOL fFrame)<BR>    {<BR>    //The document case is uninteresting to us.<BR>    if (!fFrame)<BR>        return NOERROR;<BR><BR>    if (!m_pObj-&gt;InPlaceToolsRenegotiate())<BR>        return ResultFromScode(INPLACE_E_NOTOOLSPACE);<BR><BR>    SetWindowPos(m_pObj-&gt;m_pTB-&gt;Window(), NULL, pRect-&gt;left, pRect-&gt;top<BR>        , pRect-&gt;right-pRect-&gt;left, m_pObj-&gt;m_cyBar, SWP_NOZORDER);<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>This code from Cosmo first shows that as a result of not having any document tools, we can simply return NOERROR if the <I>fFrame</I> parameter is FALSE. Otherwise, we need to go through the <I>RequestBorderSpace</I> and <I>SetBorderSpace</I> process again, which is handled by <I>CFigure::InPlaceToolsRenegotiate</I>. To optimize, you can try calling <I>SetBorderSpace</I> first; only if that fails do you need to call <I>RequestBorderSpace</I> again. Either way works—containers expect this.</P>
<P>When you've renegotiated for space, reposition your tools by using the rectangle passed to this function. This rectangle contains the same thing you would receive from a call to the container's <I>GetBorder</I> function.</P>
<H4><A NAME="sec1"></A>Implement <I>IOleInPlaceObject::SetObjectRects</I> and Call Container Position Functions</H4><P>There will probably be situations in which your object is not entirely visible and the end user will want to see more of the object. This can occur in two ways. The end user might scroll the container document directly or might perform some action in your object that would require your application to bring more of itself into view.</P>
<P>When the user scrolls the container document, the container calls <I>IOleInPlaceObject::SetObjectRects</I> with a new position rectangle and a new clipping rectangle. The object must resize its editing window to the new position rectangle, keeping it clipped to the clipping rectangle. Cosmo tells its hatch window to do this, using <I>CHatchWin::SetObjectRects</I>, as we saw earlier:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceObject::SetObjectRects(LPCRECT prcPos<BR>    , LPCRECT prcClip)<BR>    {<BR>    m_pObj-&gt;m_pHW-&gt;RectsSet((LPRECT)prcPos, (LPRECT)prcClip);<BR>    return NOERROR;<BR>    }</code></pre>
<P>When <I>IOleObject::SetObjectRects </I>is called, you have no choice but to obey the restrictions of the container. However, that does not mean that you have no control over the size of your object. The object can itself provide grab handles in the hatch border (which are capable of producing mouse events that would show up in the hatch window's message procedure). If the user resizes the object in this way, you can expand the editing window to show more data. (This does not affect the container's site size, however.) When an object is resized in this way, calculate the new position rectangle of the editing area of the window—making sure that you exclude all object adornments and the hatch border—and call <I>IOleInPlaceSite::OnPosRectChange</I>. In this function, the container will determine whether it can give you this space, or at least a portion of it, and will call your <I>IOleInPlaceObject::SetObjectRects</I> in response. At that time, your application obediently resizes itself. Some containers will let your object grow as much as it wants. Others will never let it grow larger than the container site itself. It's your responsibility to determine how your application will respond in these cases. You can either scale your object to fit the container's specified position rectangle or add scroll bars to your in-place editing window if you cannot scale and cannot display all the object's data in the position rectangle. In any case, what you do with the position rectangle from <I>SetObjectRects</I> is your choice, as long as your object can fit into it somehow.</P>
<P>Scrolling can also occur when part of your object's window is clipped by the container's windows. For example, a table object with only half the cells visible might be clipped by the edge of the container's document window. The user might use the arrow keys to move the cell selection into one of the hidden cells. In that case, your object can call <I>IOleInPlaceSite::Scroll</I> to scroll the document programmatically. If the container scrolls, it will again call <I>IOleObject::SetObjectRects</I> to tell the object its new position.</P>
<H4><A NAME="sec2"></A>Implement <I>IOleInPlaceActiveObject </I>Functions for Window Activation Changes</H4><P>When an object is UI active in a container document, it has menus and tools displayed in the container's frame window. If that container has multiple documents, the object's user interface should no longer appear in the frame when the user switches to another document. Therefore, the container might need to ask an object to temporarily remove its UI or to reinstall it when document activation changes. For this reason, <I>IOleInPlaceActiveObject::OnDocWindowActivate</I> is passed a BOOL indicating whether the document is becoming active or inactive. In response, the object must either show or hide its UI-active state:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceActiveObject::OnDocWindowActivate<BR>    (BOOL fActivate)<BR>    {<BR>    HWND        hWndTB;<BR><BR>    if (NULL==m_pObj-&gt;m_pIOleIPFrame)<BR>        return NOERROR;<BR><BR>    hWndTB=m_pObj-&gt;m_pTB-&gt;Window();<BR><BR>    if (fActivate)<BR>        {<BR>        m_pObj-&gt;m_pIOleIPFrame-&gt;SetActiveObject(this<BR>            , (*m_pObj-&gt;m_pST)[IDS_INPLACETITLE]);<BR><BR>        m_pObj-&gt;m_pIOleIPFrame-&gt;SetMenu(m_pObj-&gt;m_hMenuShared<BR>            , m_pObj-&gt;m_hOLEMenu, m_pObj-&gt;m_pFR-&gt;Window());<BR><BR>        if (m_pObj-&gt;InPlaceToolsRenegotiate())<BR>            {<BR>            RECT    rc;<BR><BR>            m_pObj-&gt;m_pIOleIPFrame-&gt;GetBorder(&amp;rc);<BR>            SetWindowPos(hWndTB, NULL, rc.left, rc.top<BR>                , rc.right-rc.left, m_pObj-&gt;m_cyBar<BR>                , SWP_NOZORDER);<BR><BR>            ShowWindow(hWndTB, SW_SHOW);<BR>            }<BR>        }<BR>    else<BR>        {<BR>        m_pObj-&gt;m_pIOleIPFrame-&gt;SetActiveObject(NULL, NULL);<BR><BR>        //Hide our tools, but do not call SetMenu.<BR>        ShowWindow(hWndTB, SW_HIDE);<BR>        }<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>The implementation of this function need not perform full UI deactivation or UI activation. To hide our UI, we simply need to call the frame's <I>SetActiveObject </I>with NULLs and hide our own tools. The container will then reinstate its tools, or if the document that is becoming active also has a UI-active object, that other object will reinstate its own tools. Hiding the object's UI requires no call to <I>IOleInPlaceFrame::SetMenu </I>because either the container will show its own UI or another object will display its shared menu.</P>
<P>When asked to show the object's UI, we call <I>SetActiveObject </I>again and reinstall the shared menu (which we saved in <I>CFigure </I>variables for this exact reason). We must also negotiate space for our tools again because conditions might have changed in the container since we were last active and the container might now refuse our tools.</P>
<P>Closely related to document switches is the function <I>IOleInPlaceActiveObject::OnFrameWindowActivate</I>, which tells the active object that the container's frame window has become active or inactive. An object has no set requirements here, but it can use this notification to perhaps show or hide modeless pop-up windows or control the activation of other user interface elements.</P>
<H4><A NAME="sec3"></A>Implement Minimal Context-Sensitive Help Support</H4><P>Both containers and objects must provide at least some support for context-sensitive help even if they do not support that feature themselves. An object that doesn't support this help mode must avoid trapping the Shift+F1 and Esc accelerators—let them pass through to the container. If the container wants to enter the help mode, it will do so and call <I>IOleInPlaceObject::ContextSensitiveHelp(TRUE)</I> in your object. When this help mode is on and you do not support such help, ignore all mouse clicks in your object—that is, provide no help.</P>
<P>If an object does support context-sensitive help, it will trap Shift+F1 and Esc. On Shift+F1, enter the mode and tell the container by calling <I>IOleInPlaceSite::ContextSensitiveHelp(TRUE)</I>. When you detect Esc, stop the help mode and tell the container with <I>IOleInPlaceSite::ContextSensitiveHelp(FALSE)</I>.</P>
<H4><A NAME="sec4"></A>Provide Undo Support</H4><P>Undo is another function that you might or might not support and your container might or might not support. Even if an object does not support Undo, the object must still reactivate itself in <I>IOleInPlaceObject::ReactivateAndUndo</I>. If your object has an Undo command itself, you not only reactivate yourself but also perform an Undo directly. Cosmo does the reactivation only because its Undo is really a Remove Last Point command, not a true Undo. (Cosmo does not maintain a last command variable to perform an Undo properly.) So it handles this case as follows:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceObject::ReactivateAndUndo(void)<BR>    {<BR>    return m_pObj-&gt;InPlaceActivate(m_pObj-&gt;m_pIOleClientSite, TRUE);<BR>    }</code></pre>
<P>An object that supports the Undo command should maintain a flag such as <I>CFigure::m</I><I>_</I><I>fUndoDeactivates</I>, which is initially set to TRUE in <I>CFigure::InPlaceActivate</I>. If the user selects Undo when this flag is set, call <I>IOleInPlaceSite::DeactivateAndUndo</I>, which will cause the container to deactivate the object. Cosmo does this in <I>CFigure::Undo</I>, which is called whenever Ctrl+Z or Alt+ Backspace accelerators are detected:</P>
<P><BR></P>
<pre><code>BOOL CFigure::Undo(void)<BR>    {<BR>    if (!m_fUndoDeactivates)<BR>        return FALSE;<BR><BR>    m_fUndoDeactivates=FALSE;<BR>    m_pIOleIPSite-&gt;DeactivateAndUndo();<BR>    return TRUE;<BR>    }</code></pre>
<P>Cosmo clears <I>m</I><I>_</I><I>fUndoDeactivates </I>whenever the user makes any change whatsoever to the figure. This happens in <I>CFigure::SendAdvise </I>just before Cosmo sends off an <I>IAdviseSink::OnDataChange </I>notification, which also happens for any change to the object. In addition, if this is the first change to the object after activation, we must call <I>IOleInPlaceSite::DiscardUndoState</I> to tell the container that we will not be calling <I>DeactivateAndUndo</I> so that it can free any state it's holding.</P>
<P>The object can hold some Undo state itself in case the container calls <I>IOleInPlaceObject::ReactivateAndUndo</I>. (Cosmo does not maintain such a state.) If the container makes a change after deactivation so that it will not call this function, it calls <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>DISCARDUNDOSTATE)</I>, at which time the object frees the state. <I>DoVerb </I>is used because once an object is deactivated, the container no longer has <I>IOleInPlaceObject </I>or <I>IOleInPlaceActiveObject </I>pointers but will have <I>IOleObject</I>.</P>
<P>The overall effect of this Undo handling is meant to create the illusion that the user is working with a single undo stack in the container, even though objects from other components are being activated. This is why <I>ReactivateAndUndo </I>and <I>DeactivateAndUndo </I>involve both the activation change and the Undo operation—activation changes themselves are not meant to be visually undoable operations.</P>
<H4><A NAME="sec5"></A>Call <I>IOleInPlaceFrame::SetStatusText</I></H4><P>As described in Chapter 22, the container maintains ownership of the status line throughout in-place sessions. If an object ever needs to display text in that status line, it can pass the string to <I>IOleInPlaceFrame::SetStatusText</I>. Cosmo does this whenever it detects WM_MENUSELECT messages in <I>CCosmoFrame::FMessageHook</I>; the strings, of course, describe the functionality of the menu item in question. Cosmo has its own status line (which is hidden along with the rest of the server's main window) process the message and load the correct string. For an in-place object, we extract this string and send it to the container, making support for this feature quite simple:</P>
<P><BR></P>
<pre><code>BOOL CCosmoFrame::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam<BR>    , LPARAM lParam, LRESULT FAR *pLRes)<BR>    {<BR>    TCHAR            szText[128];<BR><BR>    if (WM_MENUSELECT!=iMsg)<BR>        return FALSE;<BR><BR>    if (NULL==m_pIOleIPFrame)<BR>        return FALSE;<BR><BR>    m_pSL-&gt;MenuSelect(wParam, lParam);<BR>    m_pSL-&gt;MessageGet(szText, sizeof(szText));<BR>    m_pIOleIPFrame-&gt;SetStatusText(szText);<BR><BR>    *pLRes=0L;<BR>    return TRUE;<BR>    }</code></pre>
<P>You can see this interaction at work when you activate a Cosmo figure in place in the version of Patron from Chapter 22.</P>
<H4><A NAME="sec6"></A>Provide Techniques for Opening into a Window</H4><P>I mentioned before that a container can call <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>OPEN</I>) to end in-place activation and activate an object in a separate window. We saw earlier how Cosmo implements this verb. In addition, Cosmo provides the user with two other ways to do the same thing:  through the Open item on the Edit menu and by picking up double clicks in the hatch border around the figure. You can also use a Ctrl+Enter accelerator for this purpose. (Cosmo does not.) In Cosmo, the menu selection and hatch border double click end up in <I>CFigure::OpenIntoWindow</I>, which calls our own <I>DoVerb </I>to deactivate and open into a separate window:</P>
<P><BR></P>
<pre><code>void CFigure::OpenIntoWindow(void)<BR>    {<BR>    if (NULL!=m_pIOleIPSite)<BR>        {<BR>        m_fUndoDeactivates=FALSE;<BR><BR>        m_pImpIOleObject-&gt;DoVerb(OLEIVERB_OPEN, NULL<BR>            , m_pIOleClientSite, -1, NULL, NULL);<BR><BR>        m_fForceSave=TRUE;<BR>        SendAdvise(OBJECTCODE_DATACHANGED);<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>We clear <I>m</I><I>_</I><I>fUndoDeactivates</I> so that an Undo command in the open Cosmo window will not attempt to in-place deactivate.</P>
<P>When I implemented the Open command in Cosmo, I encountered a couple of problems. The first was that the object would not be saved (through <I>IPersistStorage::Save</I>) after I opened it in a window and closed the window. The problem was that the object was not marked as dirty after such an operation. To correct this, I added the flag <I>m</I><I>_</I><I>fForceSave</I> to <I>CFigure</I> and set it to TRUE in <I>CFigure::OpenIntoWindow</I>. That causes the object to appear as dirty when closing, which generates the proper call to <I>IOleClientSite::SaveObject</I>. The other, related, problem was that the container site was blank when I opened the object into a window until that site was repainted. So in <I>CFigure::O</I><I>penIntoWindow</I>, I immediately send an <I>OnDataChange</I> notification, which propagates to the container as <I>OnViewChange</I>, causing it to repaint the site.</P>
<H4><A NAME="sec7"></A>Show or Hide Modeless Pop-Up Windows</H4><P>The final bit to complete an in-place object is to handle <I>IOleInPlaceActiveObject::EnableModeless</I> and call <I>IOleInPlaceFrame::EnableModeless</I>. As mentioned in Chapter 22, the container and the object use each other's <I>EnableModeless</I> to show/enable or hide/disable floating pop-up windows at various points in the in-place session. If you ever have occasion to tell the container to hide its pop-up windows (say, for example, when you display a modal dialog box), call <I>IOleInPlaceFrame::EnableModeless</I> with TRUE when showing the dialog box and with FALSE when closing the dialog box. The container will do the same thing for the same reasons with <I>IOleInPlaceActiveObject::Enable Modeless</I>. The use and implementation of these functions are, however, entirely optional.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>6 Remember that <I>IOleInPlaceFrame</I> inherits from <I>IOleInPlaceUIWindow</I>, but do <I>not </I>typecast this <I>IOleInPlaceUIWindow </I>to <I>IOleInPlaceFrame</I> because the additional frame members will not be in the vtable for the interface pointer you receive. Upcasting like this is playing with some serious fire.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
