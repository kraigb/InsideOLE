<HTML><HEAD><TITLE>User Interface for Object Browsing and Creation</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>User Interface for Object Browsing and Creation</H3><P>As described in the previous section, controllers with programming languages should support some sort of syntax through which a user can give a "create this object" command. Although this works, it is not by any means the only way to create an object. </P>
<P>As we'll see in the chapters about OLE Documents and OLE Controls, there are basic dialog box standards through which container applications (controllers of a different nature) present the user with a list of available compound document objects or controls. When the user selects a control, for example, he or she can then draw a rectangle on the container's form that the control will occupy. The container then creates the initial control in that rectangle, holding on to whatever pointers are necessary. (Visual Basic 3 works with VBX controls; later versions of Visual Basic work with OLE controls.) The user then assigns to that control object a container-managed name, which is used to refer to the control in the container's source code. Whenever the container executes a script that contains references to the object's name, it knows which interface pointers to use. This eliminates the need for a user to write the tedious code to create and position objects. However, this doesn't mean a user might not want to create an object at some other time for temporary use—you can support this sort of automatic object creation in addition to a language syntax for the same thing.</P>
<P>In the same way that OLE Documents and OLE Controls object selection dialog boxes use the Insertable and Control registry keys, automation controllers can try to use something like the Programmable key to search for objects that implement <I>IDispatch</I>. (As I mentioned in Chapter 14, this key is not actually documented in OLE, but I recommend it for automation objects so controllers can identify specific objects that support automation using only registry information.)1 Browsing the registry in this way allows the user to see what's there without having to find a ProgID in some other way. The same sort of dialog box might also allow the user to browse for names of document files and use those names in object creation as well. Even if you don't use a dialog box in this manner to automatically create objects, a dialog box is still useful for determining the argument for a command such as Visual Basic's <I>CreateObject</I>. (Visual Basic 3 doesn't actually do this, but it would be nice if you didn't have to hunt for ProgIDs.)</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 A further note about a <I>Programmable</I> key: controllers that decide to use this key and ship after other known servers have shipped can add the <I>Programmable</I> key to the registry entries for known servers without harm. This is because the servers and anything else that doesn't know about the key will ignore it entirely. This is one way a controller can create a new user interface and bring existing servers into that interface.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
