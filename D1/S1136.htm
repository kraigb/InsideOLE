<HTML><HEAD><TITLE>Implementing and Connecting a Sink</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implementing and Connecting a Sink</H3><P>As mentioned earlier, the main client code in the Connect sample is contained within the <I>CApp </I>class, which is defined in CONNECT.H:</P>
<P><BR></P>
<pre><code>//Identifiers for sinks, indexes into m_rgpSink below<BR>enum<BR>    {<BR>    SINK1=0,<BR>    SINK2<BR>    };<BR><BR>class CApp<BR>    {<BR>    friend LRESULT APIENTRY ConnectWndProc(HWND, UINT, WPARAM, LPARAM);<BR><BR>    protected:<BR>        HINSTANCE       m_hInst;            //WinMain parameters<BR>        HINSTANCE       m_hInstPrev;<BR>        UINT            m_nCmdShow;<BR>        HWND            m_hWnd;             //Main window handle<BR>        PCDuckEvents    m_rgpSink[2];       //Sinks to connect<BR><BR>        PCConnObject    m_pObj;             //Source object<BR><BR>    protected:<BR>        void              Connect(UINT);<BR>        void              Disconnect(UINT);<BR>        IConnectionPoint *GetConnectionPoint(void);
    public:<BR>        CApp(HINSTANCE, HINSTANCE, UINT);<BR>        ~CApp(void);<BR><BR>        BOOL        Init(void);<BR>        void        Message(LPTSTR);<BR>    };<BR><BR>typedef CApp *PAPP;</code></pre>
<P>One of the reasons I say this sample is contrived is that <I>CApp </I>maintains a pointer to the source object it creates using the C<I>++ </I>type instead of an interface. This lets us tell the source to trigger events when the menu commands are given. Obviously, when a real OLE client-object relationship is at work, the client would have only an interface pointer at any given time, and something outside the client would trigger events. That consideration aside, everything else is more or less what any client might have. This class has three protected member functions—<I>Connect</I>, <I>Disconnect</I>, and <I>GetConnectionPoint</I><I>—</I>to centralize the connection process for whatever sink we might want to work with. The little enumeration of the values SINK1<I> </I>and SINK2 provides names for the indexes into the array of sink objects stored in <I>m</I><I>_</I><I>rgpSink.</I></P>
<P>The sinks themselves are implemented using the C++ class <I>CDuckEvents</I>, also defined in CONNECT.H:</P>
<P><BR></P>
<pre><code>class CDuckEvents : public IDuckEvents<BR>    {<BR>    private:<BR>        ULONG       m_cRef;     //Reference count<BR>        PAPP        m_pApp;     //For calling Message<BR>        UINT        m_uID;      //Sink identifier<BR><BR>    public:<BR>        //Connection key, public for CApp's usage<BR>        DWORD       m_dwCookie;<BR><BR>    public:<BR>        CDuckEvents(PAPP, UINT);<BR>        ~CDuckEvents(void);<BR><BR>        //IUnknown members<BR>        STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>        STDMETHODIMP_(DWORD) AddRef(void);<BR>        STDMETHODIMP_(DWORD) Release(void);<BR><BR>        //IDuckEvents members<BR>        STDMETHODIMP Quack(void);<BR>        STDMETHODIMP Flap(void);<BR>        STDMETHODIMP Paddle(void);<BR>    };</code></pre>
<P>This is pretty standard stuff for implementing a simple object with a single interface, which is usually all we need for sink objects. If you require a sink with multiple interfaces, feel free to use any of the three techniques for doing so described in the "Implementing Multiple Interfaces" section in Chapter 2. The implementation of this class, found in SINK.CPP, is also typical. The only interesting parts for our discussion are the <I>event handlers,</I> that is, the implementations of the specific members of <I>IDuckEvents</I>, each of which looks just like the following code for <I>CDuckEvents::Quack</I>, with nothing more than a few names changed:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CDuckEvents::Quack(void)<BR>    {<BR>    TCHAR       szTemp[100];<BR><BR>    wsprintf(szTemp, TEXT("Sink #%u received Quack."), m_uID+1);<BR>    m_pApp-&gt;Message(szTemp);<BR><BR>   #ifdef WIN32<BR>    PlaySound(TEXT("quack.wav"), NULL, SND_SYNC);<BR>   #endif<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P><B>Note:</B><B> </B> The PlaySound function is part of the Win32 API in the import library WINMM.LIB, and it requires a sound card to operate. SND_SYNC means that PlaySound will not return until the sound has finished playing. This ensures that you'll be able to see and hear events in both sinks when they're both connected.</P>
<P>As I mentioned, the Connect sample creates two instances of <I>CDuckEvents </I>during initialization in <I>CApp::Init</I>, using the C++ <I>new </I>operator. Immediately after they're created, <I>CApp::Init </I>calls <I>AddRef </I>on both sinks to ensure that their lifetimes will be stable until Connect is closed. These references are released in <I>CApp::~CApp</I>, which will cause the sink objects to destroy themselves.</P>
<P>Now for the interesting parts of the client code. Object creation happens through use of the C++ <I>new</I> operator within the IDM_OBJECTCREATE case of <I>ConnectWndProc</I>, as seen in the following:</P>
<P><BR></P>
<pre><code>pObj=new CConnObject();<BR><BR>if (NULL!=pObj)<BR>    {<BR>    fRes=pObj-&gt;Init();<BR>    pObj-&gt;AddRef();<BR>    }</code></pre>
<P>Again, this sample is contrived because no<I> </I>OLE client ever has access to a C++ object for an OLE object. All of this creation code would always be encapsulated within an object's own creation process. The call to <I>AddRef </I>here, however, allows the rest of the code to treat the object like any other OLE object, calling <I>Release </I>to free it.</P>
<P>With an instantiated object, you can connect either or both sinks to the source object. Selecting Connect from the menu calls <I>CApp::Connect</I>, and selecting Disconnect calls <I>CApp::Disconnect.</I> Big surprise. In either case, we need to have an <I>IConnectionPoint </I>pointer to the connection point for <I>IDuckEvents</I>. Retrieving this pointer from the object is the purpose of <I>CApp::GetConnectionPoint</I>:</P>
<P><BR></P>
<pre><code>IConnectionPoint * CApp::GetConnectionPoint(void)<BR>    {<BR>    HRESULT                     hr;<BR>    IConnectionPointContainer  *pCPCont;<BR>    IConnectionPoint           *pCP=NULL;<BR><BR>    hr=m_pObj-&gt;QueryInterface(IID_IConnectionPointContainer<BR>        , (PPVOID)&amp;pCPCont);<BR><BR>    if (FAILED(hr))<BR>        return NULL;<BR><BR>    hr=pCPCont-&gt;FindConnectionPoint(IID_IDuckEvents, &amp;pCP);<BR>    pCPCont-&gt;Release();<BR><BR>    if (FAILED(hr))<BR>        return NULL;<BR><BR>    return pCP;<BR>    }</code></pre>
<P>This function executes the sequence described earlier in this chapter for obtaining the connection point interface pointer for a known IID. It also demonstrates that you can call <I>Release </I>on the <I>IConnectionPointContainer </I>interface without harm to the <I>IConnectionPoint </I>pointer. This is because connection points are contained within the source object and therefore contribute to its overall reference count. (It would also be silly to destroy an object you're trying to connect to, so a client will usually have another unrelated interface pointer to the same source object that keeps it alive anyway.)</P>
<P>With the <I>IConnectionPoint </I>pointer for the connection point that supports <I>IDuckEvents</I>, <I>Connect </I>establishes the connection and <I>Disconnect </I>terminates it, as shown in the following:</P>
<P><BR></P>
<pre><code>void CApp::Connect(UINT uID)<BR>    {<BR>    HRESULT             hr;<BR>    IConnectionPoint   *pCP;<BR><BR>    [Trivial validation code omitted]<BR><BR>    //Is this sink connected already?<BR>    if (0!=m_rgpSink[uID]-&gt;m_dwCookie)<BR>        {<BR>        Message(TEXT("This sink is already connected."));<BR>        return;<BR>        }<BR><BR>    pCP=GetConnectionPoint();<BR><BR>    if (NULL!=pCP)<BR>        {<BR>        hr=pCP-&gt;Advise(m_rgpSink[uID]<BR>            , &amp;m_rgpSink[uID]-&gt;m_dwCookie);<BR><BR>        if (FAILED(hr))<BR>            Message(TEXT("Connection failed."));<BR>        else<BR>            Message(TEXT("Connection complete."));<BR><BR>        pCP-&gt;Release();<BR>        }<BR>    else<BR>        Message(TEXT("Failed to get IConnectionPoint."));<BR><BR>    return;<BR>    }<BR><BR>void CApp::Disconnect(UINT uID)<BR>    {<BR>    HRESULT             hr;<BR>    IConnectionPoint   *pCP;<BR><BR>    [Trivial validation code omitted]<BR><BR>    //Is the sink connected at all?<BR>    if (0==m_rgpSink[uID]-&gt;m_dwCookie)<BR>        {<BR>        Message(TEXT("This sink is not connected."));<BR>        return;<BR>        }<BR><BR>    pCP=GetConnectionPoint();<BR><BR>    if (NULL!=pCP)<BR>        {<BR>        hr=pCP-&gt;Unadvise(m_rgpSink[uID]-&gt;m_dwCookie);<BR><BR>        if (FAILED(hr))<BR>            Message(TEXT("Disconnection failed."));<BR>        else<BR>            {<BR>            Message(TEXT("Disconnection complete."));<BR>            m_rgpSink[uID]-&gt;m_dwCookie=0;<BR>            }<BR><BR>        pCP-&gt;Release();<BR>        }<BR>    else<BR>        Message(TEXT("Failed to get IConnectionPoint."));<BR><BR>    return;<BR>    }</code></pre>
<P>These functions can work with either sink stored in <I>CApp </I>according to the index <I>uID </I>passed as an argument. <I>Connect </I>simply calls <I>IConnectionPoint::Advise </I>and stores the returned connection key in the <I>m</I><I>_</I><I>dwCookie </I>member of <I>CDuckEvents. Disconnect </I>checks to be sure the connection exists and then passes that same <I>m</I><I>_</I><I>dwCookie </I>to <I>IConnectionPoint::Unadvise </I>to terminate the relationship.</P>
<P>So the stage is set. The lights are turned low. We're ready to see how the connectable object uses these connected sinks to fire events.</P></font></body></HTML>
