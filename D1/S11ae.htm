<HTML><HEAD><TITLE>Of Persistent Objects: Polyline</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Of Persistent Objects: Polyline</H2><P>In Chapter 5's version of Polyline, the <I>IPolyline5 </I>interface had two member functions, <I>ReadFromFile </I>and <I>WriteToFile</I>. Because CoCosmo now uses compound files, these <I>IPolyline5</I> members are no longer useful. (This sample doesn't retain backward compatibility with the traditional file–based version of Chapter 5.) In their place, Polyline uses implementations of both the <I>IPersistStorage </I>and <I>IPersistStreamInit</I> interfaces.6 This code is found in CHAP08\POLYLINE. To support and manage the additional interfaces, Polyline requires a few minor modifications to its <I>QueryInterface </I>and its initialization and cleanup code. The primary changes are the interface implementations themselves, in IPERSTOR.CPP and IPERSTMI.CPP. Note also that Polyline now uses <I>IPolyline8 </I>and <I>IPolylineAdviseSink8 </I>(instead of the Chapter 5 versions), which are defined in INC\IPOLY8.H.</P>
<P>Now, according to CoCosmo's initialization code, which we saw in the last section, CoCosmo will ask Polyline for <I>IPersistStorage </I>first and then use that interface exclusively if it's found. Because Polyline implements that interface and <I>IPersistStreamInit </I>(thus<I> IPersistStream </I>also), CoCosmo will never touch the stream-based implementation if you run the code as is. To test the stream interaction, either modify CoCosmo to not ask for <I>IPersistStorage </I>or modify Polyline to not respond to <I>IID</I>_<I>IPersistStorage</I> in its <I>QueryInterface. </I>Either change will cause CoCosmo to use <I>IPersistStreamInit</I>. You can make another modification to turn off this interface and have CoCosmo use <I>IPersistStream</I>. To avoid recompilation, run CoCosmo in a debugger and skip over the <I>QueryInterface </I>calls in <I>CCosmoDoc::Init </I>for the interfaces you want to omit.</P>
<P>The <I>IPersistStrea</I><I>m </I>implementation is simple, as you can see in Listing 8-1. The <I>GetClassID </I>member returns a CLSID, <I>IsDirty </I>returns the right HRESULT depending on Polyline's dirty flag, <I>GetSizeMax </I>returns the size of Polyline's data structure, and <I>InitNew </I>doesn't do anything at all. (Polyline has no other state to initialize.) The bulk of the work happens in <I>Load</I> and <I>Save</I>, which do little more than call <I>IStream::Read </I>and <I>IStream::Write.</I></P>
<H3><A NAME="sec0"></A>IPERSTMI.CPP</H3><P><BR></P>
<pre><code>/*<BR> * IPERSTMI.CPP<BR> * Polyline Component Chapter 8<BR> *<BR> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved<BR> */<BR><BR>#include "polyline.h"<BR><BR>[Constructor, Destructor, IUnknown members omitted]<BR><BR>STDMETHODIMP CImpIPersistStreamInit::GetClassID(LPCLSID pClsID)<BR>    {<BR>    *pClsID=m_pObj-&gt;m_clsID;<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStreamInit::IsDirty(void)<BR>    {<BR>    return ResultFromScode(m_pObj-&gt;m_fDirty ? S_OK : S_FALSE);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStreamInit::Load(LPSTREAM pIStream)<BR>    {<BR>    POLYLINEDATA    pl;<BR>    ULONG           cb;<BR>    HRESULT         hr;<BR><BR>    if (NULL==pIStream)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    //Read all data into the POLYLINEDATA structure.<BR>    hr=pIStream-&gt;Read(&amp;pl, CBPOLYLINEDATA, &amp;cb);
    if (FAILED(hr) || CBPOLYLINEDATA!=cb)<BR>        {<BR>        pIStream-&gt;Release();<BR>        return hr;<BR>        }<BR><BR>    m_pObj-&gt;m_pImpIPolyline-&gt;DataSet(&amp;pl, TRUE, TRUE);<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIPersistStreamInit::Save(LPSTREAM pIStream<BR>    , BOOL fClearDirty)<BR>    {<BR>    POLYLINEDATA    pl;<BR>    ULONG           cb;<BR>    HRESULT         hr;<BR><BR>    if (NULL==pIStream)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    m_pObj-&gt;m_pImpIPolyline-&gt;DataGet(&amp;pl);<BR><BR>    hr=pIStream-&gt;Write(&amp;pl, CBPOLYLINEDATA, &amp;cb);<BR>    pIStream-&gt;Release();<BR><BR>    if (FAILED(hr) || CBPOLYLINEDATA!=cb)<BR>        return ResultFromScode(STG_E_WRITEFAULT);<BR><BR>    m_pObj-&gt;m_fDirty=fClearDirty;<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIPersistStreamInit::GetSizeMax(ULARGE_INTEGER<BR>    *pcbSize)<BR>    {<BR>    if (NULL==pcbSize)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    ULISet32(*pcbSize, CBPOLYLINEDATA);<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIPersistStreamInit::InitNew(void)<BR>    {<BR>    return NOERROR;<BR>    }</code></pre>
<P><B>Listing 8-1</B></P>
<P><B>The <I>IPersistStreamInit</I> interface implementation for the Polyline object.</B></P>
<P>You can see why <I>IPersistStream[Init] </I>is the simplest persistence model. The implementation of <I>IPersistStorage</I>, which is shown in Listing 8-2, is more complicated. This code is a basic framework for any <I>IPersistStorage </I>implementation, in which values starting with "PSSTATE" identify the various object states such as scribble and zombie. The values are defined as follows in an enumerator in the common header file INC\INOLE.H because many other samples in the rest of this book will include similar implementations of <I>IPersistStorage</I>:</P>
<P><BR></P>
<pre><code>typedef enum<BR>    {<BR>    PSSTATE_UNINIT,     //Uninitialized<BR>    PSSTATE_SCRIBBLE,   //Scribble<BR>    PSSTATE_ZOMBIE,     //No-scribble<BR>    PSSTATE_HANDSOFF    //Hands-off<BR>    } PSSTATE;</code></pre>
<P>Overall, the <I>IPersistStorage </I>implementation in Polyline demonstrates the correct changes in the object's storage state when it shifts among all the states. The only differences between this code and code for a more complex storage scheme are in the number of open elements managed by the object and in the complexity of the data stored in those elements. Thus, this implementation works as a solid framework for your own development needs.</P>
<H3><A NAME="sec1"></A>IPERSTOR.CPP</H3><P><BR></P>
<pre><code>/*<BR> * IPERSTOR.CPP<BR> * Polyline Component Chapter 8<BR> *<BR> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved<BR> */<BR><BR>#include "polyline.h"<BR><BR>CImpIPersistStorage::CImpIPersistStorage(PCPolyline pObj<BR>    , LPUNKNOWN pUnkOuter)<BR>    {<BR>    [Other initialization omitted]<BR>    m_psState=PSSTATE_UNINIT;<BR>    return;<BR>    }
    [Destructor and IUnknown members omitted]<BR><BR>STDMETHODIMP CImpIPersistStorage::GetClassID(LPCLSID pClsID)<BR>    {<BR>    if (PSSTATE_UNINIT==m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    *pClsID=m_pObj-&gt;m_clsID;<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStorage::IsDirty(void)<BR>    {<BR>    if (PSSTATE_UNINIT==m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    return ResultFromScode(m_pObj-&gt;m_fDirty ? S_OK : S_FALSE);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStorage::InitNew(LPSTORAGE pIStorage)<BR>    {<BR>    HRESULT         hr;<BR>    ULARGE_INTEGER  uli;<BR><BR>    if (PSSTATE_UNINIT!=m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    if (NULL==pIStorage)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    hr=pIStorage-&gt;CreateStream(SZSTREAM, STGM_DIRECT<BR>        | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE<BR>        , 0, 0, &amp;m_pObj-&gt;m_pIStream);<BR><BR>    if (FAILED(hr))<BR>        return hr;<BR><BR>    //Preallocate stream space.<BR>    ULISet32(uli, CBPOLYLINEDATA);<BR>    m_pObj-&gt;m_pIStream-&gt;SetSize(uli);
    //We expect that client has called WriteClassStg.<BR>    WriteFmtUserTypeStg(pIStorage, m_pObj-&gt;m_cf<BR>        , (*m_pObj-&gt;m_pST)[IDS_USERTYPE]);<BR><BR>    m_pObj-&gt;m_pIStorage=pIStorage;<BR>    pIStorage-&gt;AddRef();<BR><BR>    m_psState=PSSTATE_SCRIBBLE;<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStorage::Load(LPSTORAGE pIStorage)<BR>    {<BR>    POLYLINEDATA    pl;<BR>    ULONG           cb;<BR>    LPSTREAM        pIStream;<BR>    HRESULT         hr;<BR><BR>    if (PSSTATE_UNINIT!=m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    if (NULL==pIStorage)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    //We don't check CLSID to remain compatible with other chapters.<BR><BR>    hr=pIStorage-&gt;OpenStream(SZSTREAM, 0, STGM_DIRECT<BR>        | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream);<BR><BR>    if (FAILED(hr))<BR>        return ResultFromScode(STG_E_READFAULT);<BR><BR>    //Read all data into the POLYLINEDATA structure.<BR>    hr=pIStream-&gt;Read(&amp;pl, CBPOLYLINEDATA, &amp;cb);<BR><BR>    if (FAILED(hr) || CBPOLYLINEDATA!=cb)<BR>        {<BR>        pIStream-&gt;Release();<BR>        return hr;<BR>        }
    m_pObj-&gt;m_pIStream=pIStream;<BR>    m_pObj-&gt;m_pIStorage=pIStorage;<BR>    pIStorage-&gt;AddRef();<BR><BR>    m_pObj-&gt;m_pImpIPolyline-&gt;DataSet(&amp;pl, TRUE, TRUE);<BR>    m_psState=PSSTATE_SCRIBBLE;<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStorage::Save(LPSTORAGE pIStorage<BR>    , BOOL fSameAsLoad)<BR>    {<BR>    POLYLINEDATA    pl;<BR>    ULONG           cb;<BR>    LPSTREAM        pIStream;<BR>    HRESULT         hr;<BR><BR>    //Have to come here from scribble state.<BR>    if (PSSTATE_SCRIBBLE!=m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    //Must have an IStorage if we're not in SameAsLoad.<BR>    if (NULL==pIStorage &amp;&amp; !fSameAsLoad)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    if (fSameAsLoad)<BR>        {<BR>        LARGE_INTEGER   li;<BR><BR>        pIStream=m_pObj-&gt;m_pIStream;<BR>        LISet32(li, 0);<BR>        pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL);<BR><BR>        //This matches the Release below.<BR>        pIStream-&gt;AddRef();<BR>        }<BR>    else<BR>        {<BR>        hr=pIStorage-&gt;CreateStream(SZSTREAM, STGM_DIRECT<BR>            | STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE<BR>            , 0, 0, &amp;pIStream);<BR><BR>        if (FAILED(hr))<BR>            return hr;
        //Do this only with new storages.<BR>        WriteFmtUserTypeStg(pIStorage, m_pObj-&gt;m_cf<BR>            , (*m_pObj-&gt;m_pST)[IDS_USERTYPE]);<BR>        }<BR><BR>    //DataGet does not make allocations; it's just a memory copy.<BR>    m_pObj-&gt;m_pImpIPolyline-&gt;DataGet(&amp;pl);<BR><BR>    hr=pIStream-&gt;Write(&amp;pl, CBPOLYLINEDATA, &amp;cb);<BR>    pIStream-&gt;Release();<BR><BR>    if (FAILED(hr) || CBPOLYLINEDATA!=cb)<BR>        return ResultFromScode(STG_E_WRITEFAULT);<BR><BR>    m_psState=PSSTATE_ZOMBIE;<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStorage::SaveCompleted(LPSTORAGE<BR>    pIStorage)<BR>    {<BR>    HRESULT     hr;<BR>    LPSTREAM    pIStream;<BR><BR>    //Must be called in no-scribble or hands-off state.<BR>    if (!(PSSTATE_ZOMBIE==m_psState <BR>        || PSSTATE_HANDSOFF==m_psState))<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    //If we're in hands-off state, we'd better get storage.<BR>    if (NULL==pIStorage &amp;&amp; PSSTATE_HANDSOFF==m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    if (NULL!=pIStorage)<BR>        {<BR>        hr=pIStorage-&gt;OpenStream(SZSTREAM, 0, STGM_DIRECT<BR>            | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0<BR>            , &amp;pIStream);<BR><BR>        if (FAILED(hr))<BR>            return hr;
        if (NULL!=m_pObj-&gt;m_pIStream)<BR>            m_pObj-&gt;m_pIStream-&gt;Release();<BR><BR>        m_pObj-&gt;m_pIStream=pIStream;<BR><BR>        if (NULL!=m_pObj-&gt;m_pIStorage)<BR>            m_pObj-&gt;m_pIStorage-&gt;Release();<BR><BR>        m_pObj-&gt;m_pIStorage=pIStorage;<BR>        m_pObj-&gt;m_pIStorage-&gt;AddRef();<BR>        }<BR><BR>    m_psState=PSSTATE_SCRIBBLE;<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStorage::HandsOffStorage(void)<BR>    {<BR>    /*<BR>     * Must be in scribble or no-scribble state. A repeated call<BR>     * to HandsOffStorage is an unexpected error (bug in client).<BR>     */<BR>    if (PSSTATE_UNINIT==m_psState || PSSTATE_HANDSOFF==m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    //Release held pointers.<BR>    if (NULL!=m_pObj-&gt;m_pIStream)<BR>        ReleaseInterface(m_pObj-&gt;m_pIStream);<BR><BR>    if (NULL!=m_pObj-&gt;m_pIStorage)<BR>        ReleaseInterface(m_pObj-&gt;m_pIStorage);<BR><BR>    m_psState=PSSTATE_HANDSOFF;<BR>    return NOERROR;<BR>    }</code></pre>
<P><B>Listing 8-2</B></P>
<P><B>The <I>IPersistStorage</I> interface implementation for the Polyline object.</B></P>
<P>You can see that most of the implementation is fairly simple. <I>GetClassID</I> and <I>IsDirty</I> are trivial, and <I>InitNew</I>, <I>SaveCompleted</I>, and <I>HandsOffStorage</I> need only to manage <I>IStorage </I>and <I>IStream </I>pointers for use in <I>Save.</I> These three functions demonstrate how you should maintain these pointers so that you do not need to create any new objects in <I>Save</I> under a low-memory scenario. <I>InitNew </I>and <I>Load </I>also demonstrate preallocation of the object's needed stream space to avoid problems with a full storage medium later on.</P>
<P>Polyline's <I>IPersistStorage::Load</I> function simply opens the "CONTENTS" <I>stream</I> (the symbol SZSTREAM is defined as this string), reads the data, makes the data current, and holds on to the <I>IStream</I> pointer for <I>Save.</I> Because <I>IStorage::OpenStream</I> returns an <I>IStream</I> pointer with a reference count, we do not need an extra call to <I>AddRef</I> when we store that pointer in <I>m</I>_<I>pIStream</I>.</P>
<P>The implementation of <I>IPersistStorage::Save</I> is the interesting part. If <I>fSameAsLoad </I>is TRUE, we're writing into the storage we received during <I>InitNew </I>or <I>Load</I>, so we already have the <I>IStream</I> pointer in which to write our current data. If you look carefully at the implementation of <I>Save</I> in Listing 8-2, you will notice that it allocates no memory (and creates no new objects), fulfilling the requirement that <I>Save</I> will not fail because of an out-of-memory condition. When <I>fSameAsLoad</I> is FALSE, however, we have to write data into the <I>IStorage </I>passed to <I>Save</I>, so we have to create new streams. Again, the object is allowed to fail in this case if no memory is left. If the new storage object that we're writing into is to become the current one, we'll see it again in <I>SaveCompleted.</I></P>
<P>Inside <I>SaveCompleted</I>,<I> </I>you can see that what we do depends on whether <I>pIStorage </I>is NULL or not. If it is NULL, we can just switch back to the scribble state, using all the same pointers we currently hold. Otherwise, we have to release those pointers and replace them with ones we open in the new storage, making this new storage current. Also, the implementation of <I>HandsOffStorage</I> does what it must, of course, by releasing the <I>IStorage </I>and <I>IStream </I>pointers to our open elements.</P>
<P>Finally, the storage created through these implementations of CoCosmo and Polyline is identical to those generated by Chapter 7's Cosmo, with the exception of the exact CLSID and format tags. A file from either sample can be opened in the other.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>6 <I>IPersistFile</I> was not used for two reasons. First CoCosmo manages the document and has an <I>IStorage </I>pointer for it (or an <I>IStream</I>) and we want Polyline's data to be part of that document not in a separate file. Second Polyline is a good code base for a compound document content object (as we'll make it in Chapter 18) as well as an OLE control (Chapter 24). Implementing these interfaces now saves us work later.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
