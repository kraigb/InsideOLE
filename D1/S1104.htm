<HTML><HEAD><TITLE>Call CoInitialize or OleInitialize</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Call <I>CoInitialize</I> or <I>OleInitialize</I></H3><P>On startup, an application must call <I>CoInitialize</I> or <I>OleInitiali</I><I>ze</I> before calling any other function in their respective libraries. Most 32-bit applications should use <I>OleInitialize</I>. You need to remember whether initialization works, usually through some variable such as <I>m</I><I>_</I><I>fInitialized</I>:</P>
<P><BR></P>
<pre><code>if (FAILED(CoInitialize(NULL)))    //Or OleInitialize<BR>    [Fail loading the task]<BR><BR>m_fInitialized=TRUE;</code></pre>
<P><img src="16bit.gif"></P>
<P>In 32-bit OLE, both initialization functions take a NULL reserved pointer and will fail with E_INVALIDARG if you pass a non-NULL value.</P>
<P>Any code within the same task can call <I>CoInitialize</I> or <I>OleInitialize </I>multiple times. This allows any code (usually that in a DLL) to ensure that the OLE DLLs are initialized, even if the application that loaded the DLL is OLE-ignorant and did not perform initialization. The first successful call to <I>[Co</I><I>|</I><I>Ole]Initialize </I>will return NOERROR; subsequent successful calls will return S_FALSE, meaning that the call still worked but that it wasn't the first call. Because a DLL's <I>LibMain</I> is called before the application's <I>WinMain</I>, <I>[Co</I><I>|</I><I>Ole]Initialize</I> will never have been called by that time. It's best to defer this code to a later DLL-specific initialization call if possible, but there's no real harm in a DLL making the first call within a task. Internally, OLE associates task information with a unique number returned from the function <I>CoGetCurrentProcess</I>, which you can use whenever you need a process-specific (as opposed to thread-specific) identifier. This identifier is considerably closer to unique than a Windows HTASK is.</P>
<P>Any caller to the initialization functions must remember whether initialization worked so that it knows whether to call <I>CoUninitialize</I> or <I>OleUninitialize</I> when it shuts down. In other words, every <I>Uninitialize</I> must be matched one-to-one with an <I>Initialize</I>.</P></font></body></HTML>
