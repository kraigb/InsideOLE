<HTML><HEAD><TITLE>The Basic OLE Documents Architecture</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>The Basic OLE Documents Architecture</H2><P>Whenever any object is in the loaded, running, or active state, a client or a container has at least one interface pointer for that object. To have this pointer, some in-process piece of code must be loaded for that object. The code can be the object server itself, a handler, or simply a proxy. In OLE Documents, the object exposes at least those interfaces shown in Figure 17-2 on page 819: <I>IOleObject</I>,<I> IDataObject</I>,<I> IPersistStor</I><I>age</I>,<I> IViewObject2</I>,<I> IRunnableObject</I>,<I> IOleCache2</I>,<I> </I>and, optionally, <I>IOleCacheControl</I>. This is not to say that any embedded object implementation must manually implement all of these interfaces directly. There are, in fact, three basic ways to create the proper in-process objects:</P>
<UL><LI>If the object is implemented entirely in a local server and has no custom handler or other in-process piece registered, OLE will use an instance of the <I>default handler</I> as the in-process object. The default handler will internally create a data cache to store presentations, thereby relying on a local server to supply an object with <I>IDataObject </I>through which the handler can retrieve presentations. The default handler also relies on a local server for the implementation of <I>IOleObject::DoVerb.</I></LI><LI>If the object wants to provide an in-process handler to work with its local server, that handler will typically aggregate on the default handler for most of these interfaces through the OLE API function <I>OleCreateDefaultHandler</I>. This is discussed in Chapter 19. We'll see how such a handler typically relies on a local server just as the default handler does.</LI><LI>If the object is implemented completely in an in-process server, it can aggregate on an instance of the OLE data cache through <I>CreateDataCache</I>, as was demonstrated in Chapter 11. The object exposes at least <I>IOleCache2</I> directly from the cache. The object also delegates various member functions of <I>IDataObject</I>, <I>IViewObject2</I>, and <I>IPersis</I><I>tStorage</I> to the cache for handling graphical formats or display aspects that the object doesn't otherwise render itself (such as an iconic presentation). Because the object is implemented completely in-process, there is no dependency on a local server. This is also discussed in Chapter 19.</LI></UL><P>Regardless of the technique in use, the container always sees the same interfaces. Many of these interfaces are strictly in-process or container-side interfaces—namely, <I>IViewObject2</I>, <I>IOleCache2</I>, <I>IOleCacheControl</I>, and <I>IRu</I><I>nnableObject</I>. Accordingly, a content object implemented in a local server does not bother with these interfaces; the object implements only <I>IOleObject</I>,<I> IDataObject</I>,<I> </I>and <I>IPersistStorage</I>.<I> IDataObject </I>exists mostly so that the container-side cache can retrieve presentations. This process is illustrated in Figure 17-3.</P>
<P>The presence of <I>IPersistStorage </I>means that each embedded (or linked) object, regardless of what sort of server implements it, requires its own storage element in the container's underlying file. It also means that the object will maintain incremental access to this storage unless told otherwise through various <I>IPersistStorage </I>members. Obviously, the easy way to provide individual storage elements is for the container to use a compound file, as discussed in Chapter 7, but this is not strictly required. Using <I>ILockBytes </I>and the functions <I>StgCreateDocfileOnILockBytes </I>and <I>StgOpenStorageOnILockBytes</I>,<I> </I>a container can wrap individual pieces of its own storage medium inside <I>IStorage </I>pointers. The content object doesn't know the difference. Thus, a container can have objects read and write to a piece of some private file, to a database record, to a piece of global memory, and so on. When implementing a container, one of your first steps should be to define exactly how you will provide a separate <I>IStorage </I>pointer to each content object.</P>
<P>A major benefit of using a compound file as the compound document is that objects in both in-process handlers and local servers can simultaneously maintain incremental access to the object's storage while the container itself maintains access to the rest of the file. This relationship also is shown in Figure 17-3.</P>
<P>    <img src="f17dd03.gif"></P>
<P><B>Figure 17-3.</B></P>
<P><B>The container, the cache, and the objects inside in-process handlers and local servers can all access the object's storage simultaneously as needs arise.</B></P>
<P>The container itself can store custom streams inside the object's storage as long as those streams are named with an ASCII 3 prefix. As described in Chapter 7, this naming convention marks the stream as "container owned" so that the content object as well as OLE will never touch or mangle the stream in any way. OLE itself uses other specifically named streams to store its own information in the object's storage, as shown in the following table:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="103pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Stream Name</B></P></TD><TD VALIGN="TOP"><P><B>Contents</B></P></TD></TR><TR><TD VALIGN="TOP"><P>\001CompObj</P></TD><TD VALIGN="TOP"><P>The CLSID of the object written with <I>WriteClassStg</I>. <I>ReadClassStg</I> opens this stream to retrieve the CLSID.</P></TD></TR><TR><TD VALIGN="TOP"><P>\001Ole</P></TD><TD VALIGN="TOP"><P>Contains information about the object, such as whether it's linked or embedded.</P></TD></TR><TR><TD VALIGN="TOP"><P>\002OlePres000</P></TD><TD VALIGN="TOP"><P>The primary cached presentation for this object. If there are no cached presentations, this stream will not be present.</P></TD></TR><TR><TD VALIGN="TOP"><P>\002OlePres<I>nnn</I></P></TD><TD VALIGN="TOP"><P>Additional cached presentations.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
