<HTML><HEAD><TITLE>Storage Objects and the IStorage Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Storage Objects and the <I>IStorage</I> Interface</H3><P>Again, a storage object is like a directory: it can contain any number of storages (subdirectories) and any number of streams (files). Because any substorage is a storage in itself, just as any subdirectory is always a directory, substorages might themselves contain more storages and more streams—ad nauseam—until you deplete your available storage space. But in and of themselves, storage objects do not hold data—they only hold streams that hold data.</P>
<P>The client of a storage object, be it an application or some other component itself, works with a storage through the <I>IStorage</I> members described in Table 7-1. As you can see, a storage can perform many of the operations that you'll find in command-line shells like COMMAND.COM, such as enumerate, copy, move, rename, and delete elements, as well as change the creation and last modified time stamps of those elements. Combined with the fact that storages also have their own access rights (read-only, read/write, and so forth), a storage is more powerful than a command shell and more powerful than traditional file I/O libraries.</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="147pt" VALIGN="TOP"><COL WIDTH="101pt" VALIGN="TOP"><COL WIDTH="147pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Istorage<BR>Member</B></P></TD><TD VALIGN="TOP"><P><B>Command-Line<BR>Equivalent</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P><I>Release </I>(last reference count only)</P></TD><TD VALIGN="TOP"><P>(none)</P></TD><TD VALIGN="TOP"><P>Closes the storage element. If the storage is a root object attached to a file,<I> Release </I>closes the file and can optionally delete it. If the storage is transacted, <I>Release </I>discards changes. (See also <I>Revert</I>.)</P></TD></TR><TR><TD VALIGN="TOP"><P>CreateStream</P></TD><TD VALIGN="TOP"><P>Copy</P></TD><TD VALIGN="TOP"><P>Creates and opens a stream within the storage, returning an <I>IStream</I> pointer.</P></TD></TR><TR><TD VALIGN="TOP"><P>OpenStream</P></TD><TD VALIGN="TOP"><P>Copy, Type</P></TD><TD VALIGN="TOP"><P>Opens an existing stream within the storage, returning an <I>IStream</I> pointer.</P></TD></TR><TR><TD VALIGN="TOP"><P>CreateStorage</P></TD><TD VALIGN="TOP"><P>Mkdir, Chdir</P></TD><TD VALIGN="TOP"><P>Creates and opens a new substorage within the storage, returning an <I>IStorage</I> pointer.</P></TD></TR><TR><TD VALIGN="TOP"><P>OpenStorage</P></TD><TD VALIGN="TOP"><P>Chdir</P></TD><TD VALIGN="TOP"><P>Opens an existing substorage within the storage, returning an <I>IStorage</I> pointer.</P></TD></TR><TR><TD VALIGN="TOP"><P>CopyTo</P></TD><TD VALIGN="TOP"><P>Copy</P></TD><TD VALIGN="TOP"><P>Copies the entire contents from the storage into another storage, removing excess unused space in the process.</P></TD></TR><TR><TD VALIGN="TOP"><P>Commit</P></TD><TD VALIGN="TOP"><P>(none)</P></TD><TD VALIGN="TOP"><P>Ensures that all changes made to a storage are reflected to the parent storage (or to the device itself in the case of a root storage); also flushes buffers.</P></TD></TR><TR><TD VALIGN="TOP"><P>Revert</P></TD><TD VALIGN="TOP"><P>(none)</P></TD><TD VALIGN="TOP"><P>Discards any changes made to a transacted storage since the last <I>Commit</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>EnumElements</P></TD><TD VALIGN="TOP"><P>Dir</P></TD><TD VALIGN="TOP"><P>Returns a STATSTG enumerator object (implementing <I>IEnumSTATSTG</I>), which enumerates information relating to the substorages and streams within the storage.</P></TD></TR><TR><TD VALIGN="TOP"><P>MoveElementTo</P></TD><TD VALIGN="TOP"><P>Copy (+Del)</P></TD><TD VALIGN="TOP"><P>Copies or moves a substorage or a stream from the storage into another storage.</P></TD></TR><TR><TD VALIGN="TOP"><P>DestroyElement</P></TD><TD VALIGN="TOP"><P>Del, Deltree</P></TD><TD VALIGN="TOP"><P>Removes a specified substorage or stream from within the storage. If a substorage is destroyed, all elements contained within it are also destroyed.</P></TD></TR><TR><TD VALIGN="TOP"><P>RenameElement</P></TD><TD VALIGN="TOP"><P>Rename</P></TD><TD VALIGN="TOP"><P>Changes the name of a stream or a substorage.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetElementTimes</P></TD><TD VALIGN="TOP"><P>(none)</P></TD><TD VALIGN="TOP"><P>Sets the modification, last access, and creation date and time of a substorage or stream, subject to file-system support.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetClass</P></TD><TD VALIGN="TOP"><P>(none)</P></TD><TD VALIGN="TOP"><P>Assigns a CLSID to the storage, which can be retrieved by using <I>Stat</I>. The CLSID identifies code associated with the contents of the storage.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetStateBits</P></TD><TD VALIGN="TOP"><P>Attrib</P></TD><TD VALIGN="TOP"><P>Marks the storage with various flags.</P></TD></TR><TR><TD VALIGN="TOP"><P>Stat</P></TD><TD VALIGN="TOP"><P>(varies)</P></TD><TD VALIGN="TOP"><P>Retrieves a STATSTG structure describing storage statistics and attributes.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 7-1.</B></P>
<P><B>The <I>IStorage</I> interface.</B></P>
<P>It is important to realize that all storage objects that implement <I>IStorage </I>are the same as far as the interface is concerned, regardless of whether they are a substorage deep in a hierarchy or a root storage attached to the underlying file system or storage medium itself. So, for example, the <I>MoveElementTo </I>member can move or copy a stream between storages in different points in the same storage hierarchy or between storages in different hierarchies. <I>CopyTo </I>can copy all the elements under a root storage to a substorage in some other hierarchy. In other words, all storages are peers without regard to their position within a hierarchy.</P>
<P>As we can see from Table 7-1, <I>IStorage::CreateStorage </I>and <I>IStorage::OpenStorage</I> return an <I>IStorage </I>pointer, and these functions are the only means to obtain such a pointer to a substorage anywhere in a hierarchy. This is another example of the third way to obtain an interface pointer for a new object, which we described in Chapter 2. But how does one obtain the pointer to the root storage object? That depends on the implementation of Structured Storage, and as we'll see a little later in this chapter, OLE's Compound Files provide a few API functions through which you obtain that first <I>IStorage </I>pointer. But let's first see how a stream works.</P></font></body></HTML>
