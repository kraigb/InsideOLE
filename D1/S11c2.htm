<HTML><HEAD><TITLE>Binding Optimizations II: The Bind Context</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Binding Optimizations II: The Bind Context</H3><P>More than half the member functions of <I>IMoniker </I>take an argument of type <I>IBindCtx</I> *, which points to the bind context object for the current binding operation. The bind context carries information that applies to the entire binding underway, as opposed to the binding action of a single moniker. In other words, the bind context carries information global to the entire outer composite being bound and thus all other monikers within it, regardless of the complexity of the composite.</P>
<P>OLE provides bind context objects as a standard service. To create a bind context, call the API function <I>CreateBindCtx</I> as follows (the first argument is reserved and must be 0):</P>
<P><BR></P>
<pre><code>IBindCtx *pbc;<BR>HRESULT   hr;<BR><BR>hr=CreateBindCtx(0, &amp;pbc);<BR>§<BR>pbc-&gt;Release();</code></pre>
<P>This creates a default initialized bind context that can be passed to various <I>IMoniker </I>functions. A bind context is, in fact, the first argument to <I>IMoniker::BindToObject</I>; creation of the context is one of the steps that the API function <I>BindMoniker </I>performs:</P>
<P><BR></P>
<pre><code>HRESULT BindMoniker(IMoniker *pmk, DWORD grfOpt, REFIID riid, void **ppv)<BR>    {<BR>    IBindCtx  *pbc;<BR>    HRESULT    hr;<BR><BR>    hr=CreateBindCtx(0, &amp;pbc);<BR><BR>    if (SUCCEEDED(hr))<BR>        {<BR>        hr=pmk-&gt;BindToObject(pbc, NULL, riid, ppv)<BR>        pbc-&gt;Release();<BR>        }<BR><BR>    return hr;<BR>    }</code></pre>
<P>So one bind context travels through a binding procedure regardless of the monikers involved, as shown in Figure 9-5.</P>
<P>    <img src="f09dd05.gif"></P>
<P><B>Figure 9-5.</B></P>
<P><B>The role of the bind context when binding a composite moniker. It acts as a centralized repository for information available to all monikers used in the process.</B></P>
<P><I>CreateBindCtx</I> is the extent to which clients usually have to deal with these objects. Monikers, on the other hand, deal with them frequently during binding, always through the <I>IBindCtx </I>interface:</P>
<P><BR></P>
<pre><code>interface IBindCtx : IUnknown<BR>    {<BR>    HRESULT RegisterObjectBound IUnknown *pUnk);<BR>    HRESULT RevokeObjectBound(IUnknown *pUnk);<BR>    HRESULT ReleaseBoundObjects(void);<BR>    <BR>    HRESULT SetBindOptions(BIND_OPTS *pbindopts);<BR>    HRESULT GetBindOptions(BIND_OPTS *pbindopts);<BR><BR>    HRESULT GetRunningObjectTable(IRunningObjectTable **ppROT);<BR><BR>    HRESULT RegisterObjectParam(LPOLESTR pszKey, IUnknown *pUnk);<BR>    HRESULT GetObjectParam(LPOLESTR pszKey, IUnknown **ppUnk);<BR>    HRESULT EnumObjectParam(IEnumString **ppEnum);<BR>    HRESULT RevokeObjectParam(LPOLESTR pszKey);<BR>    };</code></pre>
<P>As you can see, four groupings of functions represent the basic capabilities of a bind context:</P>
<UL><LI><I>RegisterObjectBound</I>, <I>RevokeObjectBound</I>, and <I>ReleaseBoundObjects </I>manage a list of intermediate objects that have been bound during the entire binding process. When a moniker binds to an object, it calls <I>RegisterObjectBound</I>; it can remove the object from the bind context at will with <I>RevokeObjectBound</I>. The simple act of registration creates an extra reference count on the object (a strong lock), which ensures that the object stays running throughout the bind operation. This really means that once a moniker binds its <I>pmkLeft</I>, for example, and registers it as bound, any further uses of <I>pmkLeft </I>that might also require binding will execute quickly because the object is still running. Only when the object is revoked and released can it destroy itself. <I>ReleaseBoundObjects </I>revokes all registered objects, which the bind context calls within its own destructor. Some monikers and sophisticated clients might use this sweeping release function without releasing the bind context itself, to free any object pointers without destroying the rest of the information in the bind context.</LI><LI><I>SetBindOptions </I>and <I>GetBindOptions</I> store and retrieve a BIND_OPTS structure in the bind context that controls various binding aspects. (See the discussion that follows.)</LI><LI><I>GetRunningObjectTable </I>returns an <I>IRunningObjectTable </I>pointer appropriate to the bind context. The design point is that a moniker should access all state information through the bind context instead of depending on a global state such as the running object table. OLE's bind context actually calls <I>GetRunningObjectTable</I> itself simply to encapsulate this global dependency.</LI><LI><I>RegisterObjectParam</I>, <I>RevokeObjectParam</I>, <I>GetObjectParam</I>, and <I>EnumObjectParam</I> manage a table of miscellaneous object pointers, in which each pointer is associated with a specific key (a string). <I>RegisterObjectParam </I>revokes any object that is already registered under the same key and calls <I>AddRef </I>on the object. <I>RevokeObjectParam </I>removes the object from the table and calls its <I>Release</I>. <I>GetObjectParam </I>retrieves the pointer for any key (it also calls <I>AddRef </I>on that object before returning), and <I>EnumObjectParam</I> creates an enumerator with <I>IEnumString</I>, which enumerates the existing registered key names. (These strings are managed inside the enumerator—do not free the strings obtained through <I>IEnumString:</I><I>:Next</I>!) Releasing the bind context will clear the table and call <I>Release </I>on each object therein.</LI></UL><P>These last four *<I>ObjectParam </I>functions enable the monikers involved in the binding to store custom information that remains valid throughout the operation. A moniker can place a pointer to any object whatsoever in this table as long as it supports <I>IUnknown</I>. Only the moniker that stores the object knows what the object means, and these objects are always in the same process as the moniker. This means you can use as many custom interfaces as you want to store whatever information you want with the object. You can even get away with storing a C++ object pointer here as long as that object's vtable starts with <I>IUnknown.</I> In short, this is a very nice little object repository.6</P>
<P>The bind options described in a BIND_OPTS structure remain fixed throughout binding. This structure contains a set of flags, sharing flags, and a timer count that establishes the client's deadline for binding to complete:</P>
<P><BR></P>
<pre><code>typedef struct tagBIND_OPTS<BR>    {<BR>    DWORD       cbStruct;<BR>    DWORD       grfFlags;<BR>    DWORD       grfMode;<BR>    DWORD       dwTickCountDeadline;<BR>    } BIND_OPTS;</code></pre>
<P>The <I>cbStruct </I>field describes the size of this structure. The default bind context sets <I>grfFlags </I>to 0, but the client can store other options from the enumeration BINDFLAGS, as you see in the code at the top of the following page.</P>
<P><BR></P>
<pre><code>typedef enum tagBINDFLAGS<BR>    {<BR>    BIND_MAYBOTHERUSER     = 1,<BR>    BIND_JUSTTESTEXISTENCE = 2<BR>    } BINDFLAGS;</code></pre>
<P>The BIND_MAYBOTHERUSER option tells monikers that they can incorporate user interface in their binding process; for example, they can display a dialog box that a user must type a password in, or they can ask the user to make a network connection manually. If this option is not present, monikers must either use a binding algorithm that requires no user interaction or return MK_E_MUSTBOTHERUSER to fail the binding.</P>
<P>The BIND_JUSTTESTEXISTENCE flag allows the client requesting the binding to indicate that it wants to know only whether binding is possible but not to actually carry out the operation. Usually this ends up being as expensive as performing the actual binding, especially because monikers themselves may completely ignore this flag if they choose to. This flag enables a sophisticated client to create a populated bind context ahead of time and hold that bind context until it really does want to bind at some time shortly thereafter. Because the bind context would still have all the registered bound objects inside it, the actual binding operation would be much faster than the test.</P>
<P>The flags allowed for <I>grfMode </I>are taken from the STGM enumeration that we saw in Chapter 7—that is, storage-mode flags. These flags communicate to the object being bound, as well as to any intermediate objects, the types of access mode to use for any storages that need to be opened in the process. This is especially useful for <I>IMoniker::BindToStorage</I> and is critical if there is an issue with concurrent access. By default, a new bind context will set this option to STGM_READWRITE ¦ STGM_SHARE_EXCLUSIVE.</P>
<P>Finally, the <I>dwTickCountDeadline </I>field gives the client a way to say how long it is willing to wait for binding to be complete—clients who need binding to occur rapidly can ensure that they won't get locked up inside a moniker for too long. The value 0 in <I>dwTickCountDeadline</I>, which is the default value, means "no deadline." A client that wants to set a deadline must call the Windows API <I>GetTickCount </I>and add to it the number of milliseconds it is willing to wait, taking wraparound of the DWORD tick count into consideration. That value then goes into this field.</P>
<P>Monikers that might perform a potentially time-consuming operation should check the deadline frequently; monikers such as a pointer moniker—which just call <I>QueryInterface</I>—need not pay attention to this. Those that do pay attention do not have to be completely accurate in the timing (it being difficult to predict how long some operation might take) as long as they stay in the ballpark of the deadline. It is allowable to exceed it a little, say by a few hundred milliseconds at most. When the deadline is passed, the moniker should fail with MK_E_EXCEEDEDDEADLINE.</P>
<P>If a moniker exceeds the deadline because one or more intermediate objects that it would like to use in binding are not running, it can save the monikers of these objects with <I>IBindCtx::RegisterObjectParam</I>. This tells the client that if these objects had been running, the binding might have happened faster. The client can then force the objects into the running state with the <I>OleRun </I>API function and try again. The monikers themselves are stored with the key names <I>ExceededDeadline</I>, <I>ExceededDeadline1</I>, <I>ExceededDeadline2</I>, and so on.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>6 It is worthwhile to point out that if you have a need for some generic list management service, you could use the *<I>ObjectParam</I> members in a bind context, just as you might use a Windows list box control for the same purpose.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
