<HTML><HEAD><TITLE>Language Integration: Syntax Structures</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Language Integration: Syntax Structures</H3><P>If you are planning to create a general purpose automation controller that allows a user to write a script to drive objects, you'll need code structures or other such commands to identify the following operations:</P>
<UL><LI>Object creation: A way to identify an object class and create an instance of it. Ideally, the class identification is tied as closely as possible to the CLSID. Storing the name in the registry as the value of the CLSID is a good technique for doing this. Sometimes, however, these names are unwieldy, so another choice—albeit a less precise one—is to identify a class using the ProgID or VersionIndependentProgID. Another way to find a class is by specifying a filename that is associated with the class. In this case, the object creation sequence is really meant to get at the document object that has loaded the contents of that file.
<P>As an example, Visual Basic has an instrinsic function, <I>GetObject</I>, that takes either a ProgID— as in "Cosmo.Figure"— or a filename such as "C:\INOLE\CHAP14\COSMO\TEST\SAMP1.COS"<I> </I>and creates the object. In both cases, the information given is mapped to a CLSID and is passed to <I>CoCreateInstance</I>;<I> </I>in the latter case, the controller should create a file moniker with the name and bind to it, asking for <I>IDispatch </I>(which will launch the server, load the file, and so on, as we saw in Chapter 9). It is nice that users don't need to see CLSIDs. If you provide a user interface through which the user can specify the object to create (see the next section), the user doesn't have to type in any code.</P></LI><LI>Object destruction: A way for the user to say, "This object is no longer needed," which internally calls the object's <I>Release </I>function followed by <I>CoFreeUnusedLibraries </I>if wanted. In Visual Basic, the expression <I>Set doc = nothing</I> accomplishes this for the object referenced by the <I>doc </I>variable, as does letting a local variable go out of scope.</LI><LI>Connect to an active object: Some function or command that ties into the <I>GetActiveObject</I> API function that we saw in Chapter 14. <I>GetActiveObject </I>itself works only on a CLSID, but that doesn't mean you are limited to working with running objects based only on classes. Because the active object capability in OLE uses the running object table, you can support connecting to objects of any kind as long as you can create a moniker for that object and check for that moniker in the running object table. In Visual Basic, for example, the <I>GetObject </I>command can take either a pathname to a file or a classname (the ProgID), the same as its <I>CreateObject </I>function. If you specify a ProgID, Visual Basic uses the <I>GetActiveObject </I>function. If you specify a filename, Visual Basic creates a file moniker from that name and binds that file moniker. If the document is already loaded somewhere, the binding process will find it in the running object table and connect to it immediately. Otherwise, binding launches the application that can load the document, just as an object creation process would do.
<P>You do not have to stop with the idea of binding to a running document—if you want to support additional syntax, you can allow the user to create a composite moniker by specifying additional information, such as a filename and one or more item names. When you bind the moniker successfully, you'll get an interface pointer to a portion of the document. This works very well in deeper object hierarchies, as described in "Design of an Object Hierarchy" in Chapter 14.</P></LI><LI>Set a property: This should happen whenever an <I>Object::Property</I> reference is on the <I>left</I><B> </B>side of an expression, as in <I>Cosmo.LineStyle </I><I>=</I><I> 3</I>. How your language expresses the <I>Object::Property </I>relationship is up to you. Visual Basic uses the dot operator, as we've seen, but there's nothing sacred about it. You could use <I>:: </I>or <I>-&gt; </I>or <I>( ) </I>or <I>[ ]</I> or <I>{</I><I> </I><I>}</I><I> </I>or whatever else you want, as long as it's consistent and fits the programming language of the controller. A controller can also support any number of array indices with a property set.</LI><LI>Get a property: This should happen whenever an <I>Object::Property</I> reference is on the <I>right</I><B> </B>side of an expression, as in <I>curStyle </I><I>=</I><I> Cosmo.LineStyle</I>. As with a property put, you have a choice over how the user expresses the <I>Object::Property </I>relationship, and you will probably want to include some sort of array index operator as well.</LI><LI>Call a method with arguments (possibly optional and named): Method calls are always on the <I>right</I><B> </B>side of an expression, which makes them similar to property get operations. This is why some languages, Basic being one of them, cannot differentiate between property get operations and method calls. In Visual Basic, for example, <I>Object.Property </I>has the same syntax as <I>Object.Method</I> when the method has no arguments and has a return value. In any case, a method is always on the right side of an expression even when used alone: <I>Object.Method</I> is the same as <I>temp</I><I>=</I><I>Object.Method</I> without requiring the <I>temp </I>variable.
<P>Your language must allow the user to express optional arguments as well as named arguments. A language such as Basic is good with optional arguments: if they're in the script, send those values to the object; if not, send empty arguments. Other languages may be more precise about the specification of such options. As far as named arguments are concerned, you must allow the user to specify the name and assign some value to it, as in <I>Name</I><I>=</I><I>value</I>, <I>Name:</I><I>=</I><I>value</I>,<I> Name:Value</I>, or whatever syntax best suits your language.</P></LI><LI>Event sinks: Assign script code to the events that an object might fire, using the object's type information to find outgoing interfaces and displaying the functions in those interfaces. The user can then specify actions to perform when those events occur through additional script or code.</LI><LI><I>QueryInterface</I>: Include a way for a user to write a script that exploits the idea of multiple interfaces on an object. As we saw in Chapter 14, an object can have multiple dispinterfaces as easily as it can have multiple vtable interfaces. Providing the capability for a script to create a <I>QueryInterface </I>call to an object is as important here for robust evolution of functionality as it is anywhere else in OLE. In short, the script should be able to test the existence of functionality before attempting to execute that functionality.</LI></UL><P>With some sort of syntactical convention for each of these eight operations, you'll allow a user to fully exploit an object's interfaces, incoming and outgoing, through <I>IDispatch </I>and even through custom interfaces. There is also the possibility of creating controllers that have a graphically based programming environment, but even these have some way of expressing these operations and object-to-object relationships.</P></font></body></HTML>
