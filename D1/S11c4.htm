<HTML><HEAD><TITLE>IMoniker: Table Group</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IMoniker</I>: Table Group</H3><P>Two monikers that compare as equal through <I>IsEqual </I>must also return the same value from <I>Hash</I>—both of these functions should be developed with the other in mind. The reason is that <I>Hash </I>makes a convenient value to use as an index for a moniker table (like the running object table) and <I>IsEqual </I>is commonly used to match a moniker to a moniker entry in such a table.</P>
<P>Hashing is not a difficult proposition. For example, the file moniker merely runs through the characters in the pathname and munges the characters with some XOR operations (this is code based on Unicode):</P>
<P><BR></P>
<pre><code>HRESULT CFileMoniker::Hash(LPDWORD pdwHash)<BR>    {<BR>    DWORD   dwTemp = m_cAnti;<BR>    WCHAR  *pch;<BR>    WCHAR   ch;<BR><BR>    [Set pch to path string, converting to Unicode if needed.]<BR><BR>    while (*pch)<BR>        {<BR>        dwTemp *= 3;<BR>        ch = *pch++;<BR>        dwTemp ^= ch;<BR>        }<BR><BR>    *pdwHash = dwTemp;<BR>    return NOERROR;<BR>    }</code></pre>
<P>OLE's item monikers do exactly the same thing with their strings. For your own monikers, any suitable hash algorithm is fine.</P>
<P>Another important note about the hash value is that it must be consistent across processes—that is, the hash value can be marshaled. Be sure to take this into account when you're writing <I>Hash</I> because you cannot use the value of a pointer as part of the algorithm.</P>
<P>For <I>IsRunning</I>, its <I>pmkNewlyRunning </I>argument is the moniker of the last object registered as running in the running object table. If this argument is NULL, the moniker can use the running object table to implement this function directly (using <I>IBindCtx::GetRunningObjectTable</I>, of course). If <I>pmkNewlyRunning </I>is non-NULL, the return value from <I>IsRunning </I>is NOERROR only if <I>pmkNewlyRunning </I>is the same moniker as <I>this</I>. You can make this assumption because of the nature of composite binding and because servers will register newly running objects as they are bound in the process. This means that a moniker doesn't need to perform an exhaustive search to see that the object is running. At most, the moniker needs to look in the running object table. The documentation for <I>IsRunning </I>in the <I>OLE Programmer</I><I>'</I><I>s Reference </I>has a number of sample implementations of this function that also account for "wildcard," as described earlier.</P>
<P><I>IMoniker::GetTimeOfLastChange </I>can generally use <I>IRunningObjectTable::GetTimeOfLastChange </I>to implement itself. This function should not attempt to run an object to obtain information but should rely instead on any cached information the moniker might already have. The reason to keep change times in the first place is to help clients decide whether to bother binding to the object. For example, if the object has not changed for a long time, binding to it to get an update is not necessary. You can optimize the implementation of this member if the <I>pmkToLeft </I>passed to this function is non-NULL because then the moniker can assume that it cannot have changed any later than the moniker to its left, so it can pass this function call to <I>pmkLeft-&gt;GetTimeOfLastChange.</I> If <I>pmkLeft </I>is NULL, the moniker can try the running object table and then pursue other means such as checking file time stamps.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>The <I>IROTData </I>Interface and Custom Monikers</H4><P>The running object table in OLE under Windows NT 3.5 exhibited poor performance when calling <I>IMoniker::IsEqual.</I> To solve the performance question, monikers that are going to be registered in the running object table must implement a second interface, named <I>IROTData</I>. This interface has a single member—<I>GetComparisonData</I>—through which the table asks the moniker for data it can use to compare with another moniker in lieu of calling <I>IsEqual</I>. All of OLE's standard monikers will follow this rule, as should custom monikers. Monikers that do not implement this interface will not be allowed to register as running. This rule will affect custom monikers on Windows 95, Windows NT 3.51, and later platforms. Check your documentation for the details.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
