<HTML><HEAD><TITLE>Active Automation Objects</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Active Automation Objects</H3><P>When writing an automation script, a developer or a user might want to connect to an instance of some object type that is already running. One might, for example, want to try to connect to the automation object attached to a running application so one can ask it to create a new document in which one can execute another task. One might also want to connect to a document that is already open and extract information from it instead of trying to reload that document, which would most likely fail.</P>
<P>To facilitate connections to a running object, which is optional for an automation object, OLE utilizes the running object table, as we saw in Chapter 9, to maintain an <I>active</I> object for each CLSID that is running. The choice of the word <I>active</I> is an unfortunate one because object activation has a much different meaning in the context of OLE Documents. In the context of Automation, the active object would be better called the <I>running</I> object for a given CLSID. But we're stuck with the <I>active</I> name, which is part of the three enumerator object. As we've seen before, an enumerator is a separate object that is generally tied to the collection itself, but because the collection can provide any number of separate enumerator objects, and because enumerators can make copies of themselves through <I>IEnum&lt;Type&gt;::Clone</I>, the enumerator cannot be the same as the collection. The older documentation even mentions how the collection doesn't implement <I>IClassFactory</I>. We all know better at this point in this book because we understand the role of the class factory and its separation from the class of objects it instantiates.</P>
<P>API functions dealing with active object instances. These functions are nothing but simple wrapper functions around the <I>GetRunningObjectTable </I>API and the <I>IRunningObjectTable </I>interface:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="114pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>RegisterActiveObject</P></TD><TD VALIGN="TOP"><P>Registers an object (given its <I>IUnknown</I> pointer and CLSID) as active by creating a moniker from the CLSID (converted to a string) and registering it in the running object table with <I>IRunningObjectTable::Register</I>. This returns a DWORD registration key that is returned from <I>RegisterActiveObject</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>RevokeActiveObject</P></TD><TD VALIGN="TOP"><P>Given the DWORD key from the registration, unregisters an object. This function employs <I>IRunningObjectTable::Revoke</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetActiveObject</P></TD><TD VALIGN="TOP"><P>Retrieves the <I>IUnknown</I> pointer for the most recently registered active object or a given CLSID through <I>IRunningObjectTable::GetObject</I>.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>It is an automation object that calls <I>RegisterActiveObject </I>and <I>RevokeActiveObject </I>and usually an automation controller that calls <I>GetActiveObject</I>, as you might expect. But as OLE API functions, any program can call these functions at any time for whatever reason.</P>
<P>How does this facilitate connections to running objects? When an application starts, it generally registers its application-level automation object with <I>RegisterActiveObject</I>. At this point a controller, executing some script, can call <I>GetActiveObject </I>with that application object's CLSID and get an <I>IUnknown </I>pointer to it. The controller can then query for <I>IDispatch </I>and drive that application programmatically. When the application shuts down, it calls <I>RevokeActiveObject</I>, which removes it from the running object table and makes it unavailable to controllers. An application can do exactly the same thing for a document that it opens: when creating the document, register its automation object as active (meaning the document class has its own CLSID), and revoke that object when closing the document. In this way, a controller can call <I>GetActiveObject </I>to connect to the open document.</P>
<P>It is very likely, of course, that the application might create and register additional documents; it is also possible that the user would launch another instance of the application. In these cases, the most recently registered object will be the active one as stipulated by the behavior of the running object table itself. So if an application created three documents and registers each one on creation, the last document created will be the active document object. If that document is closed, the second document created will become active because it is the next most recently registered. If the first document is closed, the active object does not change because the second document is still the most recently registered. If, however, the application were to create another new document, it would become the new active object. The same principle applies to instances of applications or to any other type of object that is being registered and revoked in this manner.</P>
<P>Simple enough? Well, as you might expect, there is one catch when using the running object table. If I have a document object with a reference count, I will usually use that reference count to destroy the document when the reference count goes to 0. However, <I>RegisterActiveObject </I>itself usually creates a strong lock by calling <I>AddRef </I>on the object you register, and that reference count is released only in <I>RevokeActiveObject</I>. You would call <I>RevokeActiveObject</I> only if the document were being destroyed, but you can't destroy the document because it has a reference count on it. The same problem applies to the application object and the application itself. Sound familiar? We discussed similar problems in Chapter 6. The solution is to use a strong or weak lock as necessary.</P>
<P><img src="16bit.gif"></P>
<P>When calling <I>RegisterActiveObject</I>, you can specify either ACTIVEOBJECT_STRONG or ACTIVEOBJECT_WEAK to control the type of lock kept in the running object table. This works similarly to the first argument to <I>IRunningObjectTable::Register.</I> If you register a strong lock, the table calls <I>AddRef </I>on your object and that reference can be removed only with a call to <I>IRunningObjectTable::Revoke</I>. This isn't a problem when you don't need to destroy the object (and accordingly destroy a document or shut down an application). In these cases, the user is explicitly closing a window associated with the object, and the reference count is quite meaningless. If, however, you want to allow a zero reference count to destroy the object, you have to register a weak lock or you have to implement the <I>IExternalConnection</I> interface on the object, as we discussed in Chapter 6.</P></font></body></HTML>
