<HTML><HEAD><TITLE>Serialization and Deserialization of Event Mappings</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Serialization and Deserialization of Event Mappings</H3><P>After the end user has gone to the trouble of creating a form with controls, assigning actions to events, setting properties, and so on, you'd better be sure that you can save this information persistently and reload it when you load the object. As mentioned before, Patron stores its event mappings for each tenant in a stream named "\003Event Mappings" inside the object's storage.</P>
<P>The <I>CEventMap::Serialize </I>member, called from <I>CTenant::Update</I>, takes care of saving the information. This means writing the dispID/action pairs from its array of EVENTMAP structures and writing a terminator pair at the end of the list:</P>
<P><BR></P>
<pre><code>void CEventMap::Serialize(LPSTREAM pIStream)<BR>    {<BR>    EVENTMAP        emTemp;<BR>    ULONG           cbWrite=sizeof(DISPID)+sizeof(EVENTACTION);<BR><BR>    if (NULL==pIStream)<BR>        return;<BR><BR>    if (NULL!=m_pEventMap)<BR>        {<BR>        UINT        i;<BR><BR>        for (i=0; i &lt; m_cEvents; i++)<BR>            pIStream-&gt;Write(&amp;m_pEventMap[i], cbWrite, NULL);<BR>        }<BR><BR>    //Write terminating entry.<BR>    emTemp.id=0;<BR>    emTemp.iAction=ACTION_TAILING;<BR>    pIStream-&gt;Write(&amp;emTemp, cbWrite, NULL);<BR><BR>    return;<BR>    }</code></pre>
<P>Loading the event map for a control simply means reading these pairs back into memory, which happens in <I>CEventMap::Deserialize</I>. This function is called from <I>CTenant::ControlInitialize </I>(itself called from <I>CTenant::Load</I>) when a control is known to have events. The deserialization process ensures that the dispID still exists for the control in question and restores the assigned action if so.</P>
<P><BR></P>
<pre><code>void CEventMap::Deserialize(LPSTREAM pIStream)<BR>    {<BR>    if (NULL==pIStream)<BR>        return;<BR><BR>    if (NULL==m_pEventMap)<BR>        return;<BR><BR>    while (TRUE)<BR>        {<BR>        ULONG       cbRead=sizeof(DISPID)+sizeof(EVENTACTION);<BR>        UINT        i;<BR>        HRESULT     hr;<BR>        EVENTMAP    em;<BR><BR>        hr=pIStream-&gt;Read(&amp;em, cbRead, NULL);<BR><BR>        if (FAILED(hr))<BR>            break;<BR><BR>        //If we hit the tail, we're done.<BR>        if (ACTION_TAILING==em.iAction)<BR>            break;<BR><BR>        //Assign action to ID if it exists.<BR>        Set(em.id, em.iAction);<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>This code, which involves <I>CEventMap::Set</I>, does not assume that a control's events remain constant between instantiations. Before the tenant asks the event map to load its data from a stream, that event map will have already been initialized using the control's type information (as we do for a new control). Each call to <I>CEventMap::Set</I> will verify that the event dispID in question actually exists in the control's event set, and only then will it assign the action loaded from the stream.</P>
<P>If an event that used to exist is no longer available, Patron simply discards the action that was mapped to it. This is no big deal because the user hardly did any work to assign the action in the first place. However, if a user attached hard-written code to an event, we would not want to simply discard that code! That is a surefire way to annoy your users and draw fire from the popular press. So even though the code cannot remain attached to an event, you must still preserve it. Visual Basic, for example, copies the code to a global function. A sophisticated container will likely do something similar.</P></font></body></HTML>
