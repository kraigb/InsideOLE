<HTML><HEAD><TITLE>FORMATETC Enumerators and Format Ordering</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>FORMATETC Enumerators and Format Ordering</H3><P><I>IDat</I><I>aObject::EnumFormatEtc</I> is responsible for creating and returning an enumerator object for FORMATETC structures, in which the object implements <I>IEnumFORMATETC</I>. The data consumer can ask <I>EnumFormatEtc </I>for an enumerator that knows the formats obtainable from <I>IDataObject::GetData</I>—the get direction—or<I> </I>the formats that can be sent to <I>IDataObject::SetData</I>—the set direction. Directions are taken from the DATADIR enumeration:</P>
<P><BR></P>
<pre><code>typedef enum tagDATADIR<BR>    {<BR>    DATADIR_GET = 1,<BR>    DATADIR_SET = 2<BR>    } DATADIR;</code></pre>
<P>As with all enumerators we've seen, <I>IEnumFORMATETC </I>implements the same member functions as all other enumerators: <I>Next</I>, <I>Skip</I>, <I>Reset</I>, and <I>Clone</I>. They merely deal with FORMATETC structures instead of some other type.</P>
<P>What is most important about a FORMATETC enumerator is its logical equivalence to the Windows API function <I>EnumClipboardFormats</I>, meaning that the order of formats enumerated through <I>IEnumFORMATETC</I> should proceed from the highest-detail, highest-fidelity formats to the lowest. A consumer will enumerate the available formats, looking for an acceptable one; the first such format is assumed to be the best the consumer can obtain from the source. The enumerated formats usually start with the most precise private data structures and proceed through other standard interchange formats (such as those for compound documents), picture or graphic formats such as CF_METAFILEPICT and CF_BITMAP, and simple link information such as a moniker. Link information is always considered to be the lowest-priority format so that the user has to explicitly ask for a link in order to have the consumer use such a format.</P>
<P><I>IEnumFORMATETC</I> is one of the few enumerators that you may actually need to implement yourself in a data source unless you have a fixed list of formats. In that case, you can let OLE implement the enumerator for you provided you have registry entries describing the formats available in both get and set directions. Because the registry holds somewhat fixed information, the available formats are also relatively fixed. If you can live with this restriction, which many data sources can, you can use OLE's services provided through the API function <I>OleRegEnumFormatEtc</I>, which has the following signature:</P>
<P><BR></P>
<pre><code>HRESULT OleRegEnumFormatEtc(CLSID clsid, DWORD dwDirection<BR>    , LPENUMFORMATETC *ppEnum);</code></pre>
<P>Here <I>clsid </I>identifies where to find the appropriate registry entries, <I>dwDirection </I>identifies the direction of the enumeration, and <I>ppEnum </I>is where the enumerator's <I>IEnumFORMATETC </I>pointer is returned. With this function and appropriate registry entries, a data object's implementation of <I>IDataObject::EnumFormatEtc </I>is reduced to the following:</P>
<P><BR></P>
<pre><code>HRESULT CImpIDataObject::EnumFormatEtc(DWORD dwDirection<BR>    , LPENUMFORMATETC *ppEnum);<BR>    {<BR>    //m_clsID is the object's CLSID.<BR>    return OleRegEnumFormatEtc(m_clsID, dwDirection, ppEnum);<BR>    }</code></pre>
<P>This API function will look for registry entries in the following format:</P>
<P><BR></P>
<pre><code>\<BR>    CLSID<BR>        {&lt;CLSID&gt;} = &lt;Name&gt;<BR>            DataFormats<BR>                GetSet<BR>                    0 = &lt;format,aspect,medium,direction&gt;<BR>                    1 = &lt;format,aspect,medium,direction&gt;<BR>                    2 = &lt;format,aspect,medium,direction&gt;<BR>                    &lt;n&gt; = &lt;format,aspect,medium,direction&gt;</code></pre>
<P>You can list as many formats as you want, provided each is given a unique integer key name under <I>GetSet</I>. Note that <I>DataFormats </I>and <I>GetSet </I>are literal keywords in registry entries of this type.</P>
<P>Each format entry is made of a clipboard format value or string, followed by any combination of DVASPECT values (<FONT FACE="Symbol">-</FONT>1 means "all"), then by any combination of TYMED values (be specific; no wildcards allowed), and finally by any one of the DATADIR values. Take, for example, the following entry:</P>
<P><BR></P>
<pre><code>1 = 3,-1,32,1</code></pre>
<P>This entry describes CF_METAFILEPICT (3) for all aspects (<FONT FACE="Symbol">-</FONT>1) on the TYMED_MFPICT medium (32) available in the get direction (<I>DATADIR</I><I>_</I><I>GET</I>, which equals 1). Another example is the following entry:</P>
<P><BR></P>
<pre><code>2 = 2,1,16,1</code></pre>
<P>This entry describes CF_BITMAP (2) for only DVASPECT_CONTENT (1) in TYMED_GDI (16) for the get direction. Remember that the format can also be a string (spaces allowed) to identify a registered clipboard format. You can see this in the following entry:</P>
<P><BR></P>
<pre><code>0 = Polyline Figure,3,5,3</code></pre>
<P>Here a registered format "Polyline Figure" for DVASPECT_CONTENT ¦ DVASPECT_THUMBNAIL (3) in TYMED_HGLOBAL ¦ TYMED_ISTREAM (5) is available in both get and set directions (DATADIR_GET ¦ DATADIR_SET, which equals 3).</P>
<P>The integer key given to each format determines their order. The format described by key 0 is the preferred format, followed by key 1, then key 2, and so on. In the three examples shown here, we have the format order of "Polyline Figure," CF_METAFILEPICT, and CF_BITMAP. This is the information that a consumer would obtain through the <I>IEnumFORMATETC </I>interface that it would obtain through <I>IDataObject::EnumFormatEtc.</I></P>
<P>It's not always the case that a data source can fix its available formats in stone. For example, a data object representing information on the clipboard has to work with a variable data set, so each enumerator it creates might have a different list of formats. Even so, given an array of FORMATETC structures, you can use a reasonably standard implementation—such as that found in the <I>CEnumFormatEtc </I>class in INTERFAC\IENUMFE.CPP—which is also used in some of this chapter's samples. This particular implementation takes an array of FORMATETC structures in its constructor, which it copies as the list to enumerate.</P>
<P><BR></P>
<pre><code>CEnumFormatEtc::CEnumFormatEtc(ULONG cFE, LPFORMATETC prgFE)<BR>    {<BR>    UINT        i;<BR><BR>    m_cRef=0;<BR><BR>    m_iCur=0;<BR>    m_cfe=cFE;<BR>    m_prgfe=new FORMATETC[(UINT)cFE];<BR><BR>    if (NULL!=m_prgfe)<BR>        {<BR>        for (i=0; i &lt; cFE; i++)<BR>            m_prgfe[i]=prgFE[i];<BR>        }<BR><BR>    return;<BR>    }<BR><BR>CEnumFormatEtc::~CEnumFormatEtc(void)<BR>    {<BR>    if (NULL!=m_prgfe)<BR>        delete [] m_prgfe;<BR><BR>    return;<BR>    }</code></pre>
<P>As an independent object, <I>CEnumFormatEtc</I> enjoys the luxury of managing its own private reference count because it doesn't depend on the data object to stick around to provide the list of current formats. If you implement an enumerator that has such a dependency, it's best to have the enumerator hold a single reference count to the data object until the enumerator itself is destroyed. This is merely an implementation technique and has no impact whatsoever on the consumer, which will consider the data object destroyed when it releases its final pointer to that object.</P>
<P>Between <I>OleRegEnumFormatEtc </I>and this standard implementation, you shouldn't have to spend much time writing your own enumerator except in very special circumstances. Just remember to get the formats ordered the way you want consumers to see them.</P></font></body></HTML>
