<HTML><HEAD><TITLE>Outgoing Interface Definitions and Type Information</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Outgoing Interface Definitions and Type Information</H2><P>This whole scheme of connectable objects and their relationships to clients and sinks is quite powerful, but it raises some concerns. Given an arbitrary object, a client can, by asking for <I>IConnectionPointContainer</I>, determine whether the object has any outgoing interfaces. If that client already knows about the outgoing interfaces it wants to connect—that is, it has compiled header files with the definitions of those interfaces—there is little complication: it calls <I>FindConnectionPoint </I>and goes through the steps listed earlier.</P>
<P>However, what if a client wants to connect to whatever outgoing interfaces there may be, regardless of whether it had compile-time knowledge about those interfaces? In this case, it has to call <I>EnumConnectionPoints</I> and then <I>IConnectionPoint::GetConnectionInterface</I> to get a list of all the outgoing interface IIDs. But what good is an IID if you don't have any information about it?</P>
<P>Well, an IID by itself with no other context is practically useless, which is one reason why type information is fundamentally important. Given an object and a list of its outgoing IIDs, a client can ask the source for type information by querying for <I>IProvideClassInfo </I>followed by a call to <I>GetClassInfo </I>in that interface. With the <I>ITypeInfo</I> pointer you are given back, you can use functions such as <I>ITypeInfo::GetRefOfImplType</I> and <I>ITypeInfo::GetRefTypeInfo </I>to find the <I>ITypeInfo</I> structure for the interface matching the IID you already have. Through that <I>ITypeInf</I><I>o </I>structure, you can learn about all the attributes, member functions, and arguments for that interface, enough information to provide an implementation of it on a sink and connect that sink to the connectable object. This run-time process works much more easily with outgoing dispinterfaces than with outgoing vtable interfaces because dispinterfaces were designed for such late-binding considerations.2 We'll see how to do this when we deal with OLE Control containers in Chapter 24.</P>
<P>Suffice it to say that if a client encounters an unknown outgoing IID in a connectable object but cannot retrieve type information for that object, it is, to put it mildly, flat out of luck. The client simply doesn't have enough information to connect to the object through that interface.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H3><A NAME="sec0"></A>Specific Outgoing Interfaces and Historical Trivia</H3><P>As time moves on, the vast majority of connectable outgoing interfaces will be defined through type information, especially because a plethora of new OLE controls and other similar objects will be coming to market.</P>
<P>There are, however, a few standard interfaces defined in the OLE header files that deal with various types of object-to-client events, notifications, and requests, all of which are designed for specific purposes. These are <I>IAdviseSink</I>, <I>IPropertyNotifySink</I>, <I>IOleClientSite</I>, <I>IOleInPlaceSite</I>, <I>IPropertyPageSite</I>, and <I>IOleControlSite. </I>However, only one of them, <I>IPropertyNotifySink</I>, is handled through connection points as described in this chapter. Connections to the others are established through specific member functions of <I>IDataObject</I>, <I>IViewObject</I>, <I>IViewObject2</I>, <I>IOleObject</I>, <I>IOleInPlaceObject</I>, <I>IPropertyPage</I>, and <I>IOleControl</I>. There are two reasons for this.</P>
<P>The first reason applies to the interface <I>IAdviseSink</I>, which contains notifications of data changes, view changes, layout changes, object closure, object renaming, and object saving. This interface was designed as part of the original OLE 2 specification way back in 1991–92. It works specifically with aspects of Uniform Data Transfer, Viewable Objects, and OLE Documents, which were defined at the same time. The interfaces <I>IDataObject</I>, <I>IViewObject2</I>, and <I>IOleObject </I>each have advise and unadvise member functions to establish and terminate connections through <I>IAdviseSink</I>. This was an ad hoc solution to the specific problems of these technologies. In 1994, the authors of the OLE Controls specification were faced with creating either another ad hoc solution only for OLE Controls or an extensible generic mechanism that would be reusable in other present and future designs. So the OLE Controls specification is the original source of all the connection point business and the <I>IConnection</I>* interfaces. Because <I>IAdviseSink </I>appeared way before OLE Controls, it remains an oddity, and it will remain so unless there's some compelling reason to change it.</P>
<P>The other reason applies to the <I>Site</I> interfaces, which generally contain very rich functionality for an object to use itself. In fact, <I>Site</I> interfaces represent more than just simple notifications or requests; they expose services from both containers and clients to their respective objects. These interfaces were designed specifically for the rich OLE Documents and OLE Controls integration protocols. In these protocols, bidirectional communication is <I>not optional,</I> as it is with connectable objects. Both sides need to talk to each other. Establishing a connection between an object and the site that conceptually "contains" it is a fixed part of the protocol.</P>
<P>As you see new interfaces—and design your own—anything using <I>Sink </I>in its name implies a simpler interface that is managed with connection points. A <I>Site</I> as part of the interface name implies a more complex relationship between an object and a container that goes beyond the scope of sinks.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 A dispinterface is simpler because a sink can implement an <I>IDispatch</I> interface at compile time whose specific methods and properties are not determined until run time using type information. This involves code that executes some sequence of actions when <I>IDispatch::Invoke </I>is passed an appropriate dispID. It is far more tedious to create a run-time interface implementation that requires you to construct the vtable and create entry points for each member function that will handle a proper stack frame for that function. It is possible, but it's not nearly as trivial as implementing a run-time dispinterface.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
