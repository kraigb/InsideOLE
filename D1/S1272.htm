<HTML><HEAD><TITLE>Chapter 16 Property Pages, Changes, and Persistence</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H1>Chapter 16 Property Pages, Changes, and Persistence</H1><P><I>The best ideas are common property.</I></P>
<P><B>—</B><B>Lucius Annaeus Seneca, c. 4 </B><B>B.C.</B><B>–</B><B>A.D.</B><B> 65</B></P>
<P><I>My guiding star always is, Get hold of portable property.</I></P>
<P><B>—</B><B>John Huffam in </B><B><I>Great Expectations,</I></B><B> by Charles Dickens</B></P>
<P>Throughout many of the preceding chapters, we've explored ways through which a client and an object share their functionality and their information. In Chapters 2, 4, 5, and 6, we saw how clients and objects communicate. In Chapter 3, we saw how an object describes itself. In Chapters 7 and 8, we explored information storage, and in Chapter 9, we dealt with the naming of such information as well as the process of binding back to it again. In Chapters 10 through 13, we examined the means of exchanging structured data formats as well as the rendering and caching of graphic views of data. And in Chapters 14 and 15, we saw how an object can expose its functionality through late-bound methods and its information through individual properties using a dispID to identify a property in the context of an object.</P>
<P>Again, the common theme is that objects have functionality and content to share—objects share them in many ways. This chapter, the last before we explore the larger and more complex protocols of OLE Documents and OLE Controls, examines a number of additional considerations for an object's properties.</P>
<P>First we'll examine the user interface called <I>property sheets,</I> used for manipulating properties directly. Although property sheets have been seen in a number of applications for some time, no general mechanisms for creating them had been developed until recently. Windows 95 introduces this user interface on a system level, and OLE has its own set of interfaces and standards—namely property page components—that let you create property sheets in a more self-contained way. OLE-based property pages were introduced with OLE Controls as a standard means of manipulating a control's properties. The user interface, however, extends down to any<I> </I>object with properties, no matter how mundane that object. The key is that OLE's mechanism lets the object specify exactly which property pages to display, and those property pages can then communicate with the object in whatever way they want.</P>
<P>Next we'll discuss the use of an outgoing interface named <I>IPropertyNotifySink </I>through which a client can receive property change requests and property change notifications. This interface is especially useful when a mechanism such as property pages or an object's own user interface (such as for an OLE control) can change properties without the client itself having initiated the change. Because <I>IPropertyNotifySink </I>was designed at the same time as connection points (Chapter 4), a client uses that generic mechanism to connect its sink to the object and can then check for specific attributes in an object's type information in order to know which properties support the notifications in this interface.</P>
<P>Finally we'll look at a standard for the persistent storage of properties in what are called <I>property sets</I>. These are basically a sparse, flexible, and extensible stream format in which you can serialize almost any information you want. We will also see the specific property set named Summary Information, which, when attached to a compound file's root storage object, allows system shells such as that in Windows 95 to display such properties without otherwise opening the file or running the application that created it.</P>
<P>So as in earlier chapters we've seen how to exchange formatted data structures, how to notify a client of changes in such data, and how to access properties programmatically, here we'll see the standards for notifying a client of changes in individual properties, the standards for showing and accessing properties through a user interface, and the standards for accessing properties that exist in persistent storage.1 Thus we complete the picture, sharing an object's properties through code, user interface, and storage, and essentially making properties not only common but also portable.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 At the time of writing, marshaling support does not exist for any of the interfaces introduced in this chapter.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
