<HTML><HEAD><TITLE>A Server-Side Message Filter: EKoala3</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>A Server-Side Message Filter: EKoala3</H3><P>A server's message filter allows it to block incoming calls if the server (as a whole) or one or more of its objects are in some state that would force them to either reject calls completely or specify that a client should try again later. For example, a server might be in the middle of a calculation using data that a client can modify through some object's interfaces—it would be best if that data didn't change during the calculation!</P>
<P><I>IMessageFilter::Ha</I><I>ndleInComingCall </I>is the single entry point on the server side for all incoming calls, regardless of which object and which interface those calls are headed toward. But to see the calls as they happen, the server has to implement, instantiate, and register a message filter. EKoala3 accomplishes this through a C++ class, <I>CMessageFilter</I>,<I> </I>defined in EKOALA3.H (singly inheriting from <I>IMessageFilter</I>) and implemented in MSGFILT.CPP. This message filter (which needs no CLSID) has its own reference count and deletes itself on the final <I>Release </I>call, just as any other simple object does. The only interesting part of the entire object is the <I>HandleInComingCall </I>function; the other two members simply return default values because they are not used in a server that makes no outgoing calls:</P>
<P><BR></P>
<pre><code>//m_pApp set in CMessageFilter constructor<BR><BR>STDMETHODIMP_(DWORD) CMessageFilter::HandleInComingCall<BR>    (DWORD dwCallType, HTASK htaskCaller, DWORD dwTickCount<BR>    , LPINTERFACEINFO pInterfaceInfo)<BR>    {<BR>    if (m_pApp-&gt;m_fBlock)<BR>        return SERVERCALL_REJECTED;<BR><BR>    if (m_pApp-&gt;m_fDelay)<BR>        return SERVERCALL_RETRYLATER;<BR><BR>    return SERVERCALL_ISHANDLED;<BR>    }<BR><BR>//These functions are not used unless you make outgoing calls.<BR>STDMETHODIMP_(DWORD) CMessageFilter::RetryRejectedCall<BR>    (HTASK htaskCallee, DWORD dwTickCount, DWORD dwRejectType)<BR>    {<BR>    return 0;<BR>    }<BR><BR>STDMETHODIMP_(DWORD) CMessageFilter::MessagePending<BR>    (HTASK htaskCallee, DWORD dwTickCount, DWORD dwPendingType)<BR>    {<BR>    return PENDINGMSG_WAITDEFPROCESS;<BR>    }</code></pre>
<P>Again, the LPINTERFACEINFO structure passed to <I>HandleInComingCall </I>identifies which interface member (the <I>iid </I>and <I>wMethod </I>fields) of which object (the <I>pUnk </I>field) is being called. EKoala3's implementation of this function, however, doesn't care which object or which interface member is being called; instead, it checks its <I>CApp </I>variables <I>m</I><I>_</I><I>fBlock </I>and <I>m</I><I>_</I><I>fDelay</I>, which EKoala3 toggles through the Block and Delay items on its Incoming Call menu.</P>
<P>When you tell EKoala3 to block calls, it rejects everything that comes into <I>HandleInComingCall </I>by immediately returning SERVERCALL_REJECTED. This generates an RPC_E_CALL_REJECTED error in the client making the call. If you tell EKoala3 to delay calls, it returns SERVERCALL_RETRYLATER. Both these return values end up in the client message filter's <I>RetryRejectedCall </I>function, as we'll see shortly. If neither condition is set, EKoala3 returns SERVERCALL_ISHANDLED, allowing the call to go through as usual. OLE's default message filter, remember, always returns SERVERCALL_ISHANDLED.</P>
<P>EKoala3 creates an instance of its message filter inside <I>CApp::Init </I>(EKOALA3.CPP) and registers the instance with <I>CoRegisterMessageFilter</I>. If for some reason it fails to instantiate the filter, EKoala3 skips the registration entirely:</P>
<P><BR></P>
<pre><code>m_pMsgFilter=new CMessageFilter(this);<BR><BR>if (NULL!=m_pMsgFilter)<BR>    {<BR>    m_pMsgFilter-&gt;AddRef();<BR><BR>    if (FAILED(CoRegisterMessageFilter(m_pMsgFilter, NULL)))<BR>        ReleaseInterface(m_pMsgFilter);    <BR>    }</code></pre>
<P>The <I>CMessageFilter </I>constructor sets the message filter's reference count to 0 initially. The explicit call to <I>AddRef </I>here gives EKoala3 control of the object's lifetime. If <I>CoRegisterMessageFilter </I>works, it will also call <I>AddRef </I>on the object. If it fails, however, the <I>ReleaseInterface </I>macro (INC\INOLE.H) will remove EKoala3's reference count and delete the object, in which case we just do without the message filter. All of this is also reversed inside <I>CApp::~CApp</I>, calling <I>CoRegisterMessageFilter </I>again to remove the filter (which calls the object's <I>Release</I>), followed by <I>ReleaseInterface </I>to destroy the object:</P>
<P><BR></P>
<pre><code>if (NULL!=m_pMsgFilter)<BR>    {<BR>    CoRegisterMessageFilter(NULL, NULL);<BR>    ReleaseInterface(m_pMsgFilter);<BR>    }</code></pre>
<P>While the filter remains registered, you can play around with external calls, blocking and delaying them. Because EKoala3 is a multiuse server, you can run multiple instances of ObjectUser2 against it and watch calls to different objects coming in through <I>HandleInComingCall</I>. With this sample, you can make a few simple modifications to allow, reject, or delay specific calls to specific objects. By blocking one object's calls and not another's, you can watch one client make successful calls while another has to wait and, after a few seconds, display the busy dialog box. Let's now take a look at the OLE UI Library, where this dialog comes from.</P></font></body></HTML>
