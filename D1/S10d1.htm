<HTML><HEAD><TITLE>Naming and Binding: Monikers</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Naming and Binding: Monikers</H3><P>Think for a moment about a standard, mundane filename that refers to some collection of data stored somewhere on a disk. The filename essentially describes the "somewhere," and so the name identifies a file that we could call an object (in a primeval sort of way). But this is somewhat limited—filenames have no intelligence because all the knowledge about how to use and store the name exists elsewhere, in whatever application makes use of that filename. This normally hasn't been a problem because most applications can deal with files quite readily.</P>
<P>Now think about a name that describes the result of a query in a database, or one that describes a range of spreadsheet cells or a paragraph in a document. Then think about a name that identifies a piece of code that executes some operation on a network server. Each different name, if unintelligent, would require each application to understand the use of that name. In a component integration system, this is far too expensive. To solve the problem, OLE has Persistent, Intelligent Names, otherwise known as <I>monikers,</I> the topic of Chapter 9. Monikers are objects that encapsulate a type of name and the intelligence to work with that name behind an interface named <I>IMoniker. </I>Different moniker classes deal with different names, but they are all polymorphic through <I>IMoniker</I>. Furthermore, because <I>IMoniker </I>is itself derived from <I>IPersistStream</I>, monikers know how to store and retrieve the names they manage in a stream.</P>
<P>The primary intellectual operation of a moniker is called <I>binding,</I> which executes whatever operations are necessary to locate the named object and return an interface pointer to that named object. The named object, however, is not in any way related to the moniker itself—the moniker is simply doing the work of locating that object. After a client has been bound to the named object, the moniker falls out of the picture entirely. What actually happens to bind a moniker depends on the type of moniker you have, but regardless of that fact a client never needs to maintain that intelligence in itself.</P>
<P>OLE defines and implements five monikers itself. Four of these are "simple" monikers: File, Item, Pointer, and Anti, which are discussed fully in Chapter 9. As these simple monikers by themselves can only provide trivial names, OLE also implements a "generic composite" moniker, where the composite is a container for any number of other monikers that might themselves be simple or composite. Binding a composite basically means binding its constituent elements. The composite then enables the creation of complex names using any desired combination of other simpler names, greatly reducing the number of simple monikers necessary to create a very large number of complex names. For example, you can use a File and two Item monikers combined in a composite to name a selection of cells in a certain page of a large spreadsheet, as illustrated in Figure 1-12.</P>
<P>    <img src="f01dd12.gif"></P>
<P><B>Figure 1-12.</B></P>
<P><B>A composite moniker that contains a file moniker and two item monikers.</B></P>
<P>Of course, if OLE's standard monikers are not suitable for your naming purposes, you can always implement your own moniker component with <I>IMoniker</I>. Because you encapsulate your functionality behind the interface, your moniker is immediately usable in any other application that knows how to work with <I>IMoniker</I>. Again, this is polymorphism on the object level, thanks to interfaces.</P>
<P>Working with monikers is generally called <I>linking,</I> the moniker's information being the link to some other data. OLE documents use monikers to implement linked compound document objects, which involves other user interface standards for managing links.</P></font></body></HTML>
