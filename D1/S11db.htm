<HTML><HEAD><TITLE>The STGMEDIUM Structure</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The STGMEDIUM Structure</H3><P>FORMATETC is merely half of the picture, of course, because it describes only the data format but says nothing about where the data actually is. This reference is provided by the STGMEDIUM (storage medium) structure, a generalization of the global-memory handle, which holds a mixture of different data references:</P>
<P><BR></P>
<pre><code>typedef struct tagSTGMEDIUM<BR>    {<BR>    DWORD tymed;<BR>    union<BR>        {<BR>        HBITMAP       hBitmap;<BR>        HMETAFILEPICT hMetaFilePict;<BR>        HENHMETAFILE  hEnhMetaFile;<BR>        HGLOBAL       hGlobal;<BR>        LPOLESTR      lpszFileName;<BR>        IStream      *pstm;<BR>        IStorage     *pstg;<BR>        } u;<BR>    IUnknown *pUnkForRelease;<BR>    } STGMEDIUM;<BR><BR>enum tagTYMED<BR>    {<BR>    TYMED_HGLOBAL   = 1,<BR>    TYMED_FILE      = 2,<BR>    TYMED_ISTREAM   = 4,<BR>    TYMED_ISTORAGE  = 8,<BR>    TYMED_GDI       = 16,<BR>    TYMED_MFPICT    = 32,<BR>    TYMED_ENHMF     = 64,<BR>    TYMED_NULL      = 0<BR>    }   TYMED;</code></pre>
<P>The STGMEDIUM fields store the following information:</P>
<P><img src="16bit.gif"></P>
<UL><LI><I>tymed</I>: An identifier for the type of medium used, taken from the TYMED enumeration: TYMED_HGLOBAL for global memory, TYMED_FILE for a traditional disk file, TYMED_ISTREAM for any stream object, TYMED_ISTORAGE for a storage object (it doesn't matter whether the storage medium is a compound file),  TYMED_GDI for a Windows GDI object, TYMED_MFPICT for a METAFILEPICT structure in global memory, TYMED_ENHMF for an enhanced metafile in global memory, or TYMED_NULL for no medium (that is, no data).</LI><LI><I>hBitmap</I>, <I>hMetafilePict</I>, <I>hEnhMetaFile</I>, <I>hGlobal</I>, <I>lpszFileName</I>, <I>pStg</I>,<I> pStm</I>: A union that refers to the actual data.  The meaningful element in the union is determined by <I>tymed</I>.</LI><LI><I>pUnkForRelease</I>: If non-NULL, identifies the pointer through which to call <I>Release </I>and free the data.  This allows control over the ownership of the data, whereby a source can hand out the same data multiple times and track the number of consumer references to that data.  See the following discussion of <I>ReleaseStgMedium</I>.</LI></UL><P>Consumers of data (that is, of a storage medium) are usually responsible for freeing the data after they have finished with it. The richness of STGMEDIUM<I> </I>would typically make this process quite complex—you should have the image of a big ugly <I>switch(stm.tymed)</I> statement floating in your head. Don't bother—OLE itself provides a single cleanup function named <I>ReleaseStgMedium</I>,<I> </I>which does all the right things according to the contents of the structure:</P>
<P><img src="16bit.gif"></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="123pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>tymed</B></P></TD><TD VALIGN="TOP"><P><B>Freeing Mechanism in <I>ReleaseStgMe</I><I>dium</I></B></P></TD></TR><TR><TD VALIGN="TOP"><P>Any</P></TD><TD VALIGN="TOP"><P><I>pUnkForRelease-&gt;Release() </I>if <I>pUnkForRelease </I>is non-NULL</P></TD></TR><TR><TD VALIGN="TOP"><P>TYMED_HGLOBAL</P></TD><TD VALIGN="TOP"><P><I>GlobalFree(hGlobal)</I></P></TD></TR><TR><TD VALIGN="TOP"><P>TYMED_FILE</P></TD><TD VALIGN="TOP"><P><I>DeleteFile(lpszFileName)</I> followed by <I>CoTaskMemFree(lpszFileName)</I>; the filename is assumed to be allocated with the task allocator</P></TD></TR><TR><TD VALIGN="TOP"><P>TYMED_ISTORAGE</P></TD><TD VALIGN="TOP"><P><I>pStg-&gt;Release()</I></P></TD></TR><TR><TD VALIGN="TOP"><P>TYMED_ISTREAM</P></TD><TD VALIGN="TOP"><P><I>pStm-&gt;Release()</I></P></TD></TR><TR><TD VALIGN="TOP"><P>TYMED_GDI</P></TD><TD VALIGN="TOP"><P><I>DeleteObject(hBitmap)</I></P></TD></TR><TR><TD VALIGN="TOP"><P>TYMED_MFPICT</P></TD><TD VALIGN="TOP"><P><I>LPMETAFILEPICT pMFP; pMFP=GlobalLock(hMetaFilePict);DeleteMetaFile(pMFP-&gt;hMF);GlobalUnlock(hMetaFilePict);GlobalFree(hMetaFilePict)</I></P></TD></TR><TR><TD VALIGN="TOP"><P>TYMED_ENHMF</P></TD><TD VALIGN="TOP"><P><I>DeleteEnhMetaFile(hEnhMetaFile)</I></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The <I>ReleaseStgMedium</I> API is exactly the reason why the <I>tymed</I> fields of both STGMEDIUM and FORMATETC differentiate between handles for global memory, GDI objects, and metafile pictures. Only with such precise identification can <I>ReleaseStgMedium</I> know how to perform cleanup correctly.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="540pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>The Practical Impact of FORMATETC and STGMEDIUM</H4><P>The FORMATETC and STGMEDIUM structures open up a wide range of possibilities in data transfer and solve a number of the key problems with previous protocols and data transfer techniques. The most fundamental benefit of these richer descriptions is that data no longer has to live in global memory.<I> </I>If the data is better suited to a disk file, use TYMED_FILE; if a storage or stream element is preferable, use TYMED_ISTORAGE or TYMED_ISTREAM.<I> </I>For example, persistent moniker data—which is easily written to and read from a stream (using <I>OleSaveToStream </I>and <I>OleLoadFromStream</I>)—is ideally exchanged in TYMED_ISTREAM.<I> </I>In fact, we'll see a standard clipboard format for this named "LinkSource" (CFSTR_LINKSOURCE).<I> </I>In addition, you can easily exchange marshaling data for any interface pointer, where the source would write the stream with <I>CoMarshalInterface</I>,<I> </I>and the consumer would call <I>CoUnmarshalInterface</I>.</P>
<P>Very large data sets that do not fit in memory can be kept on disk even during a data transfer operation, either in a traditional file or in an element of a compound file.<I> </I>Data that exists in a database need not be extracted until called for because the act of transferring an <I>IDataObject </I>pointer doesn't transfer any data, only the means to get at the data.<I> </I>If the data itself is stored in a disk file or in a storage or stream element, the consumer has the advantage of incremental access.<I> </I>Overall, these two structures vastly improve data transfer; any particular data can remain on its most optimal medium until the consumer chooses to copy it elsewhere.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="540pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
