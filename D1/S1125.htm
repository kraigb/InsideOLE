<HTML><HEAD><TITLE>Type Library Deployment</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Type Library Deployment</H2><P>The end result of whatever means you use to create a type library is a binary file containing nothing more than the type data structures.6 When you ship a component that depends on this type information you must also ship this type library. You can either attach a type library to the component's server module (EXE or DLL) as a resource, store it in a stream named "\006typelib" (located in the root storage object) in a compound file, or ship the stand-alone TLB file directly.</P>
<P><img src="16bit.gif"></P>
<P>Regardless of how you decide to ship a type library, you have to associate that type library with every component CLSID that uses it so that clients given the CLSID can retrieve your type information. This, of course, involves the registry once again. What we know about the registry so far is that any object that needs to have registry entries should have a ProgID, a Version-IndependentProgID, and a CLSID entry, as described in Chapter 2. There we mentioned that an object that didn't need a CLSID doesn't need any registry information. If you want to associate type information with an object, however, you have to assign the object a CLSID, even if it's not part of a custom component that could be instantiated with that CLSID—you still need it for association purposes.</P>
<P>In Chapter 2, we listed the following entries under the CLSID key for some hypothetical object:</P>
<P><BR></P>
<pre><code>\<BR>    CLSID<BR>        {42754580-16b7-11ce-80eb-00aa003d7352} = Acme Component 3.0<BR>            ProgID = Acme.Component.3<BR>            VersionIndependentProgID = Acme.Component</code></pre>
<P>To associate a type library with this CLSID, you need to add the following subkey (on the same level as ProgID):</P>
<P><BR></P>
<pre><code>            TypeLib = {&lt;LIBID&gt;}</code></pre>
<P>Here <I>{</I><I>&lt;LIBID&gt;</I><I>}</I> is the <I>uuid</I> attribute for the library itself. For example, if I were to assign the GUID <I>a4f8a400-16b7-11ce-80eb-00aa003d7352</I> to the library, this entry would appear as follows:</P>
<P><BR></P>
<pre><code>            TypeLib = {a4f8a400-16b7-11ce-80eb-00aa003d7352}</code></pre>
<P>This GUID now refers to a set of entries that you must also store under the TypeLib section of the registry, which is on the same level as the CLSID section. Here is the format of the entries:</P>
<P><BR></P>
<pre><code>\<BR>    TypeLib<BR>        {&lt;LIBID&gt;} = &lt;name of type library&gt;<BR>            DIR = &lt;path of type library files; no filename!&gt;<BR>            HELPDIR = &lt;path of help files; no filename!&gt;<BR>            &lt;version&gt;<BR>                &lt;LangID&gt;<BR>                    [Win16 | Win32] = &lt;filename&gt;<BR>                &lt;LangID&gt;<BR>                    §<BR>            &lt;version&gt;<BR>                §<BR>            §</code></pre>
<P>Basically you create a key with an LIBID (all spelled out in hex with the hyphens and the braces) with the value of some readable name for the library. Under this key, you store directory information and keys for each version of the type library, demonstrating that different versions of a type library can share the same LIBID. Under each version entry, you create a subkey equal to the language ID (part of an LCID) identifying the national language of the library in question, and then you create another subkey identifying the "bitness" (16 or 32) of the library. The value of this last key is either the name of a raw TLB file, an EXE, or a DLL (in which the library is a resource), or the name of a compound file that contains the library in a stream. Let's now look at each entry in more detail.</P>
<P>The DIR and HELPDIR keys provide the paths on which you installed your type libraries and help files. This means that any filenames you build into code, such as those of TLB files or HLP files named in <I>helpfile</I> attributes, need not include the path because this path is known only at installation time and not at build time. The DIR key identifies the default location of any TLB, EXE, DLL, or compound file referenced farther down in the registry entries. If these files are located in another place, you should store the complete pathnames in those later entries. The HELPDIR key works much the same way, identifying where any HLP file was installed. When anyone asks the type library to return its "documentation," that is, the name of the <I>helpfile</I> attribute for any element and the <I>helpcontext</I>, OLE automatically prepends the HELPDIR pathname to the filename in the library itself.</P>
<P>Each version number entry uses the form <I>major.minor</I>, as in "1.0" or "0.0" and so forth. This allows multiple versions to coexist using the same LIBID, but each registered library must have a major version number that matches the version key under which it is registered. Under each version, you create keys containing the hexadecimal representation of the LANGID of the information. The LANGID is the lower 16 bits of an LCID<I>—</I>that is, the primary-language ID and the sub-language ID. The language identified by this key must match the <I>lcid</I> attribute given to the library itself. The name does not include the "0x" prefix (as with ODL) and is stripped of any leading zeros. If I were writing a specifically American English type library, my language ID would be 0x0409, which is what I'd use in the <I>lcid</I> attribute. In the registry, I would use only the string "409" as the key name. If I were writing a type library in basic English (not specific to a dialect), the language ID would be 0x0009 and the registry entry simply "9" with no leading zeros. If I were writing a language-neutral library, <I>lcid</I> would be 0x0000 to match "0" in the registry.</P>
<P>Finally, underneath the language ID, the Win16 subkey points to a 16-bit type library location and the Win32 subkey points to the 32-bit type library location. The location path is for one of the names mentioned before, a TLB, an EXE, a DLL, or a compound file.</P>
<P>The biggest difficulty in creating registry entries is matching the language, and you want to use the most generic language ID you possibly can, both in the registry and in the <I>lcid</I> attribute. The OLE API functions that load the type library, which we'll see in a moment, take a language ID as an argument. These functions look first for an exact match in the registry, next for a primary language ID entry, and then for a zero ("neutral") entry, before failing completely. The more specifically you register a library, the fewer the cases in which some loading call will succeed. So again, be as generic as possible. It's a good idea to always register something under "0" so that loading will always work in some capacity.</P>
<P>We're now ready to look at some of the loading API functions and the interfaces that they return. Through these interfaces, both the object and any client can browse through the information in the type library.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>6 The <I>OLE Programmer</I><I>'</I><I>s Reference</I> incorrectly states that this file is a compound file. A type library is actually a standard flat binary file.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
