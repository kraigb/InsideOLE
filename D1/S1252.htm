<HTML><HEAD><TITLE>Variation IV: A Dual Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Variation IV: A Dual Interface</H3><P><img src="16bit.gif"></P>
<P>Both Beeper2 and Beeper3 have a dispinterface and a custom interface that provide exactly the same methods and properties. It makes sense to combine them into a dual interface, which we'll do in the Beeper4 sample (CHAP14\BEEPER4).</P>
<P>For the most part, we make a dual interface by pulling the <I>IDispatch</I> member functions that are part of <I>CImpIDispatch</I> in the previous Beepers and making them part of <I>CBeeper</I> along with all the <I>IBeeper</I> functions. (This includes pulling <I>Exception</I> straight from Beeper3 with all the TLS handling intact.) Most of the code in Beeper4's BEEPER.H file looks the same, but it's been reorganized a little and is slightly different in a few ways as well.</P>
<P>The first trick with a dual interface is to define the beast in your ODL file. This step is a little more concise than defining an interface and a dispinterface separately, as shown in the following:</P>
<P><BR></P>
<pre><code>[Attributes]<BR>library BeeperTypeLibrary<BR>    {<BR>    §<BR><BR>    [..., dual]<BR>    interface IBeeper : IDispatch<BR>        {<BR>        //Properties<BR>        [propget, helpstring("The current sound")]<BR>            HRESULT Sound([out, retval] long *plSound);<BR><BR>        [propput]<BR>            HRESULT Sound([in] long lSound);<BR><BR>        //Methods<BR>        [helpstring("Play the current sound")]<BR>            HRESULT Beep([out, retval] long *plSoundPlayed);<BR>        }<BR><BR>    §<BR>    }</code></pre>
<P>The interesting feature of a dual interface is that it is a custom interface and a dispinterface at the same time because the dual interface is polymorphic with <I>IDispatch</I>. You'll also notice that our <I>coclass</I> refers only to <I>IBeeper</I> now because <I>DIBeeper</I> no longer exists.</P>
<P>In making <I>IBeeper</I> a dual interface, however, the most significant change is that all of the member functions are now required to return an HRESULT for OLE's automatic marshaling support to work properly. This means that for methods and property get functions to return a value, they have to declare an extra argument with the attributes <I>out</I> and <I>retval</I>, which becomes, in effect, the actual return value. The <I>retval</I> attribute can apply to only one argument, of course, because it implies a return value from a property or a method.</P>
<P>The function signatures in your ODL file will also end up in a header generated by MKTYPLIB, so the implementations of your custom interface functions will change as well. These are minor changes, however, as you can see in Beeper4's version of <I>get</I><I>_</I><I>Sound</I>, <I>put</I><I>_</I><I>Sound</I>, and <I>Beep</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeper::get_Sound(long *plSound)<BR>    {<BR>    if (NULL==plSound)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    *plSound=m_lSound;<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CBeeper::put_Sound(long lSound)<BR>    {<BR>    if (MB_OK!=lSound &amp;&amp; MB_ICONEXCLAMATION!=lSound<BR>        &amp;&amp; MB_ICONQUESTION!=lSound &amp;&amp; MB_ICONHAND!=lSound<BR>        &amp;&amp; MB_ICONASTERISK!=lSound)<BR>        {<BR>        Exception(EXCEPTION_INVALIDSOUND);<BR>        return ResultFromScode(DISP_E_EXCEPTION);<BR>        }<BR><BR>    m_lSound=lSound;<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CBeeper::Beep(long *plSoundPlayed)<BR>    {<BR>    if (NULL==plSound)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    *plSound=m_lSound;<BR>    MessageBeep((UINT)m_lSound);<BR>    return NOERROR;<BR>    }</code></pre>
<P>The only other point to make about dual interfaces is that you might want to improve the performance of the marshaling of the custom portion of the dual interface. To do this, you can create your own proxy/stub object server DLL, as described in Chapter 6, and register that DLL under your dual interface's IID in the Interface section of the registry. You must list <I>IDispatch</I>, IID <I>{</I><I>00020400-0000-0000-C000-000000000046</I><I>}</I>, as your BaseInterface so that OLE will use its own marshaling for the <I>IDispatch</I> portion and instantiate your proxy/stub objects for the remaining member functions. And just as a reminder, all dual interfaces must be completely automation compatible. Even if you provide your own proxy/stub objects, the dispinterface portion must always be compatible.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>12 At the time of writing, <I>ITypeInfo::Invoke</I> never asks for this interface, let alone calls it: <I>Invoke</I> simply calls <I>GetErrorObject</I>, which could potentially report bogus exceptions if you don't call <I>SetErrorObject(0L, NULL)</I> and if something else in your thread calls <I>SetErrorObject</I> at some point with other garbage.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
