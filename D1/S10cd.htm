<HTML><HEAD><TITLE>Custom Components and COM</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Custom Components and COM</H3><P>The Component Object Model (COM) is a specification (hence "model") that describes, besides the notions of objects, interfaces, and <I>QueryInterface</I>, the mechanisms necessary to access a custom component given only a unique identifier.5 This identifier, called a class identifier (or CLSID), identifies the top-level object within the component, so what COM is really providing is a mechanism to instantiate an object of a given class. This sounds a lot like the C++ <I>new </I>operator, but in OLE the client calls a COM API function <I>CoCreateInstance </I>with the CLSID to obtain an interface pointer to that object rather than calling <I>new </I>with a C++ class name, which results in an object pointer. Of course, we're talking about two different species of objects here, but the analogy still holds.</P>
<P>Not all objects in OLE need to support this sort of creation process, but when support is there, it is the responsibility of the object or component <I>server</I> to package the object appropriately, which is the primary topic of Chapter 5. The mechanics of this depend on whether the server is a DLL or an EXE, but a client always starts the process by calling <I>CoCreateInstance</I> with a CLSID. COM uses information stored with the CLSID in the system registry to locate the server module. It then gets that server into memory (loads the DLL or launches the EXE) and asks the server to create the object, returning an interface pointer. The act of creation involves an object known as a <I>class factory,</I> which implements the interface <I>IClassFactory</I>, whose purpose in life is to manufacture objects of a particular CLSID. This object is part of the server, not part of the component that the client is trying to access, although a client can access the class factory directly if it wants.</P>
<P>In any case, the client is completely isolated from how the object is structured inside a server and from all considerations about the boundaries between it and the object created. The object could be <I>in-proc </I>(in-process, from a DLL server), <I>local </I>(out-of-process, from an EXE server), or even <I>remote </I>(from a DLL or an EXE that is running on another machine).6 In any case, COM's local/remote transparency (see the next section) means that the client doesn't have to care where the object is running—it simply accesses its features through interface pointers, and those calls are transparently routed to other processes or machines as necessary. Clients do, however, have control over what sort of boundaries are involved; for example, a client can specify only in-process or only out-process.</P>
<P>So far I have made no mention about what interfaces the various objects in a component might support, and this is intentional: the custom component facilities in COM make no restrictions on what interfaces an object might have (although local/remote transparency does at times). These facilities can be used anytime and anywhere a client might need to access any sort of component through a CLSID.</P>
<P>As part of these same mechanisms, COM also provides for what is called <I>emulation</I> of one component class by a component from a different class. This is accomplished by mapping one CLSID to another in the system registry. What this does is allow one component to be installed over another and completely replace it without requiring changes to any existing clients that might have hard-coded or persistently stored CLSIDs. When the client instantiates a component of the original CLSID, COM automatically uses the other component that is emulating the first. This is useful for providing alternative implementations of the same component and is a key factor for installing new versions of a component without breaking its existing clients.</P>
<P>Part of the enhancements to OLE that were shipped with the set of technologies called OLE Controls is the ability to license the creation of components. This is handled through an alternative class factory interface named <I>IClassFactory2</I>, which provides a license key that is necessary to create objects later. This class factory would provide such a key only when running on a machine with a fully licensed installation. If the server is illegally copied to another unlicensed machine, the server will refuse outright to create anything.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>5 In dealing with specific COM-related features it is conventional to use the term <I>COM </I>in place of or interchangeably with the term <I>OLE </I>because COM identifies the core part of OLE that pro-vides for object creation and local/remote transparency. COM API functions are all named with a <I>Co</I> prefix.</P></TD></TR><TR><TD VALIGN="TOP"><P>6 Note that at the time of writing OLE/COM does not yet support remote objects also called <I>distributed services </I>as a shipping technology because there are still some things to be worked out.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
