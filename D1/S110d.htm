<HTML><HEAD><TITLE>RectEnumerator in C++: ENUMCPP.CPP</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>RectEnumerator in C++: ENUMCPP.CPP</H3><P>Now let's look at the equivalent implementation of the C object done in C++. First the object can be defined using a C++ class that inherits the function signatures from the interface. Because the interface is an abstract base class, we have to override every member function explicitly (ENUMRECT.H):</P>
<P><BR></P>
<pre><code>class CEnumRect : public IEnumRECT<BR>    {<BR>    private:<BR>        DWORD           m_cRef;         //Reference count<BR>        DWORD           m_iCur;         //Current enum position<BR>        RECT            m_rgrc[CRECTS]; //RECTS we enumerate<BR><BR>    public:<BR>        CEnumRect(void);<BR>        ~CEnumRect(void);<BR><BR>        STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>        STDMETHODIMP_(ULONG) AddRef(void);<BR>        STDMETHODIMP_(ULONG) Release(void);<BR><BR>        //IEnumRECT members<BR>        STDMETHODIMP Next(ULONG, LPRECT, ULONG *);<BR>        STDMETHODIMP Skip(ULONG);<BR>        STDMETHODIMP Reset(void);<BR>        STDMETHODIMP Clone(PENUMRECT *);<BR>    };<BR><BR>typedef CEnumRect *PCEnumRect;</code></pre>
<P>Creating the object, which happens in <I>CreateRectEnumeratorCPP </I>(ENUMCPP.CPP), performs the same steps as <I>CreateRectEnumeratorC</I> by using the C++ <I>new </I>operator to allocate the object, calling its constructor automatically:</P>
<P><BR></P>
<pre><code>BOOL CreateRECTEnumeratorCPP(PENUMRECT *ppEnum)<BR>    {<BR>    PCEnumRect  pER;<BR>    HRESULT     hr;<BR><BR>    if (NULL==ppEnum)<BR>        return FALSE;<BR><BR>    //Create object.<BR>    pER=new CEnumRect();<BR><BR>    if (NULL==pER)<BR>        return FALSE;<BR><BR>    //Get interface, which calls AddRef.<BR>    hr=pER-&gt;QueryInterface(IID_IEnumRECT, (void **)ppEnum);<BR>    return SUCCEEDED(hr);<BR>    }<BR><BR>§<BR><BR>CEnumRect::CEnumRect(void)<BR>    {<BR>    UINT        i;<BR><BR>    //Initialize array of rectangles.<BR>    for (i=0; i &lt; CRECTS; i++)<BR>        SetRect(&amp;m_rgrc[i], i, i*2, i*3, i*4);<BR><BR>    //Ref counts always start at 0.<BR>    m_cRef=0;<BR><BR>    //Current pointer is first element.<BR>    m_iCur=0;<BR><BR>    return;<BR>    }</code></pre>
<P>The big difference is that in C++ you do not have to create the vtable manually: that step is performed automatically by virtue of creating a C++ object that inherits it from an interface. What we did in C is similar to the code that the C++ compiler creates transparently. This is the second reason (apart from concise interface calling) that C++ is more convenient than C: the compiler does some of the work for you.</P>
<P>Let's also look at the implementation of <I>QueryInterface </I>and <I>Release</I> and show how the C++ functions automatically receive a <I>this </I>pointer instead of an extra first parameter to each member call:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CEnumRect::QueryInterface(REFIID riid, PPVOID ppv)<BR>    {<BR>    *ppv=NULL;<BR><BR>    if (IID_IUnknown==riid || IID_IEnumRECT==riid)<BR>        *ppv=this;<BR><BR>    if (NULL==*ppv)<BR>        return ResultFromScode(E_NOINTERFACE);<BR><BR>    ((LPUNKNOWN)*ppv)-&gt;AddRef();<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP_(ULONG) CEnumRect::AddRef(void)<BR>    {<BR>    return ++m_cRef;<BR>    }<BR><BR>STDMETHODIMP_(ULONG) CEnumRect::Release(void)<BR>    {<BR>    if (0!=--m_cRef)<BR>        return m_cRef;<BR><BR>    delete this;<BR>    return 0;<BR>    }</code></pre>
<P>In C++, <I>QueryInterface </I>can use the overloaded == operator for IIDs instead of calling <I>IsEqualIID</I>. In addition, we return our <I>this </I>pointer as the interface pointer because the two are equivalent. If you singly inherit an interface into a C++ object class, you do not need explicit typecasting when assigning <I>this </I>to a <I>void </I>pointer, as we're doing here. The <I>CEnumRECT </I>pointer is an <I>IEnumRECT </I>pointer in such a case.</P>
<P>In the preceding code, the pointer returned for <I>IUnknown </I>is the same as the pointer returned for <I>IEnumRECT</I>, so it is tempting to think that a client that obtained an <I>IUnknown </I>pointer could typecast it into an <I>IEnumRECT </I>type. This is utterly dangerous and entirely illegal because it breaks the idea of <I>QueryInterface </I>completely. Furthermore, it cannot possibly work when a process or machine boundary separates client and object. A client's use of a pointer in this way represents intimate knowledge of the object's implementation. This goes against encapsulation and polymorphism and is a capital crime in object-oriented programming. In short, don't do it.</P>
<P>As we'll see later, you also must be careful with multiple inheritance. But before we look at those issues, notice that the implementation of <I>Release </I>has the odd statement <I>delete this</I>. This is C++ suicide, if you will: the object destroys itself, calling the destructor. This may look strange, but it is perfectly legal and is used frequently in OLE object implementations.</P>
<P><B>Note:</B><B> </B> When an object can have multiple simultaneous clients, it is best to protect Release from reentrancy—that is, if you're already doing delete this, ignore any subsequent Release calls (as well as most other interface members, but this is the important one), just in case. This applies to C implementations as well. The RectEnumerator objects here do not do this because an instance has only one possible client.</P>
<P>Viewing both the C and the C++ implementations, you can see that what is important to OLE is that the interface be a structure that contains a pointer to a vtable that contains pointers to the implementations of the member functions. How you choose to create this structure is irrelevant: C++ is more convenient, but the same thing can be accomplished almost as easily in C. If you examine the C++ code in the ENUMRECT.CPP file, you'll see that a C++ client can make calls to a C object as easily as to a C++ object—language is no barrier in OLE.</P></font></body></HTML>
