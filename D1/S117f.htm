<HTML><HEAD><TITLE>The Custom Marshaling Proxy: KoalaPrx</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Custom Marshaling Proxy: KoalaPrx</H3><P>With custom marshaling, the local object can get away with not implementing any of the interfaces it supposedly provides. However, this is absolutely required for the proxy because it must expose the correct interfaces to the client. The KOALAPRX DLL that manages such a proxy contains much of the same code that we previously had in EKoala4, which means that its Koala object implementation does explicitly implement <I>IAnimal </I>and <I>IKoala</I> to provide the client with the proper entry points. What differs is how the proxy actually implements these functions.</P>
<P>COM loads the proxy DLL and asks it to create an instance of the CLSID returned from the local object's <I>IMarshal::GetUnmarshalClass</I>, just as anything else creates an instance of an in-process object. In calling our DLL's <I>IClassFactory::CreateInstance</I>,<I> </I>however, COM asks for an <I>IMarshal</I> interface, considered to be the initialization interface for a proxy. That pointer in hand, COM calls <I>IMarshal::UnmarshalInterface</I>, which the proxy implements in IMARSHAL.CPP:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIMarshal::UnmarshalInterface(LPSTREAM pstm<BR>    , REFIID riid, LPVOID *ppv)<BR>    {<BR>    KOALAMARSHAL    km;<BR><BR>    pstm-&gt;Read((void *)&amp;km, sizeof(KOALAMARSHAL), NULL);<BR>    m_pObj-&gt;m_hWndLocal=km.hWnd;<BR><BR>    //Get the pointer to return to the client.<BR>    return QueryInterface(riid, ppv);<BR>    }</code></pre>
<P>This function has two responsibilities. First, it extracts the necessary connection information from the marshaling packet stored in the stream (the <I>pstm</I> argument). This contains only the local object's window handle, to which we can post messages. We extract that handle and save it. The second responsibility is that we have to return, in *<I>ppv</I>, the pointer that COM eventually returns to the client, the type of which is specified in <I>riid</I>. All we need to do is call our own <I>QueryInterface </I>to get the correct pointer and call our own <I>AddRef </I>as required.</P>
<P>After you return from <I>UnmarshalInterface</I>,<I> </I>COM calls <I>IMarshal::ReleaseMarshalData</I>, giving you the chance to clean up any resources that the local object might have saved in the stream. No such resources are in this example, so this function just returns NOERROR. In addition, this proxy object also returns E_NOTIMPL from all the other <I>IMarsha</I><I>l </I>member functions, which are called only in the server process. We don't need to worry about them in the proxy.</P>
<P>Let's now look at how this proxy implements the interfaces as seen by the client:</P>
<P><BR></P>
<pre><code>DWORD CKoala::CallLocal(UINT iMsg, LPARAM lParam, BOOL fAsync)<BR>    {<BR>    DWORD   dwRet=0;<BR><BR>    if (fAsync)<BR>        PostMessage(m_hWndLocal, WM_COMMAND, (WPARAM)iMsg, lParam);<BR>    else<BR>        {<BR>        dwRet=SendMessage(m_hWndLocal, WM_COMMAND, (WPARAM)iMsg<BR>            , lParam);<BR>        }<BR><BR>    return dwRet;<BR>    }<BR><BR><BR>STDMETHODIMP_(ULONG) CKoala::Release(void)<BR>    {<BR>    if (0L!=--m_cRef)<BR>        return m_cRef;<BR><BR>    CallLocal(MSG_RELEASE, 0, TRUE);<BR><BR>    if (NULL!=m_pfnDestroy)<BR>        (*m_pfnDestroy)();<BR><BR>    delete this;<BR>    return 0;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIAnimal::Eat(LPTSTR pszFoodRecommended<BR>    , LPTSTR pszFoodEaten, short cchEaten)<BR>    {<BR>    _tcsncpy(pszFoodEaten, TEXT("Eucalyptus Leaves"), cchEaten);<BR>    m_pObj-&gt;CallLocal(MSG_EAT, 0L, FALSE);<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIAnimal::Sleep(short *pcMinutes)<BR>    {<BR>    DWORD       dwRet;<BR><BR>    //Pass the client's value.<BR>    dwRet=m_pObj-&gt;CallLocal(MSG_SLEEP, (LPARAM)*pcMinutes, FALSE);<BR><BR>    if (FAILED((HRESULT)dwRet))<BR>        return (HRESULT)dwRet;<BR><BR>    //Store the return value in the client's variable.<BR>    *pcMinutes=LOWORD(dwRet);<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIAnimal::Procreate(short *pcOffspring)<BR>    {<BR>    DWORD       dwRet;<BR><BR>    dwRet=m_pObj-&gt;CallLocal(MSG_PROCREATE, 0, FALSE);<BR><BR>    if (FAILED((HRESULT)dwRet))<BR>        return (HRESULT)dwRet;<BR><BR>    *pcOffspring=(short)LOWORD(dwRet);<BR>    return ResultFromScode(0==dwRet ? S_FALSE : S_OK);<BR>    }<BR><BR>STDMETHODIMP CImpIAnimal::WhatKindOfAnimal(IID *pIID)<BR>    {<BR>    //No need to ask the local object for something we know.<BR>    *pIID=IID_IKoala;<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIKoala::ClimbEucalyptusTree(short iTree)<BR>    {<BR>    //We know that the server doesn't need this.<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIKoala::PouchOpensDown(void)<BR>    {<BR>    //We know that the server doesn't need this.<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIKoala::SleepAfterEating(short cMinutes)<BR>    {<BR>    DWORD   dwRet;<BR><BR>    dwRet=m_pObj-&gt;CallLocal(MSG_SLEEPAFTEREATING<BR>        , (LPARAM)cMinutes, TRUE);<BR><BR>    if (FAILED((HRESULT)dwRet))<BR>        return (HRESULT)dwRet;<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>You can see in this code how the proxy completely implements some member functions while depending on the local object for others, using the <I>CallLocal </I>function to generate the message to the object's window.</P>
<P><I>IAnimal::Eat </I>is an interesting function because the implementation is split between the proxy and the local object. The proxy knows what Koalas eat, so it fills the client's out-parameter, <I>pszFoodEaten</I>, with the appropriate text. It doesn't bother trying to marshal text back to and from the server. However, because this proxy knows that the local object modifies one of its state variables, it still generates a call to that object. As we saw earlier, the object does nothing more with the call than set its <I>m</I><I>_</I><I>fJustAte</I> variable to TRUE. (See EKoala5's <I>HandleCall </I>code in the previous section.)</P>
<P>All of the other members that generate calls to the local object rely on that object for the full implementation. Two of these, <I>Release </I>and <I>IKoala::SleepA</I><I>fterEating</I>, are implemented as asynchronous calls, for which we use <I>PostMessage </I>instead of the synchronous <I>SendMessage</I>. <I>SleepAfterEating </I>is asynchronous simply for demonstration, whereas <I>Release </I>is asynchronous by design: we have no need to wait for the server to disappear within our own self-destruction code, so we post the message and forget it. This might not work with other designs, however, particularly ones in which a more complex interaction occurs between the proxy and the local object, especially if any synchronization of resources is going on. In that case, you might want to wait for the server to complete its shutdown before finishing the proxy's own cleanup.</P></font></body></HTML>
