<HTML><HEAD><TITLE>IDataObject, DDE,and the Real-Time Market Data Council</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2><I>IDataOb</I><I>ject</I>, DDE,and the Real-Time Market Data Council</H2><P>In the previous section, we saw that much of the <I>IDataObject </I>interface encompasses the capabilities of Dynamic Data Exchange. As a result, OLE is poised to displace DDE as a standard for dynamic interapplication data transfer.5<I> </I>The table below summarizes the parallels between DDE and <I>IDataObject</I>:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>DDE Message</B></P></TD><TD VALIGN="TOP"><P><B><I>IDataObject</I> Member Function</B></P></TD></TR><TR><TD VALIGN="TOP"><P>WM_DDE_POKE</P></TD><TD VALIGN="TOP"><P><I>IDataObject::SetData</I></P></TD></TR><TR><TD VALIGN="TOP"><P>WM_DDE_REQUEST</P></TD><TD VALIGN="TOP"><P><I>IDataObject::GetData</I></P></TD></TR><TR><TD VALIGN="TOP"><P>WM_DDE_ADVISE</P></TD><TD VALIGN="TOP"><P><I>IDataObject::DAdvise</I></P></TD></TR><TR><TD VALIGN="TOP"><P>WM_DDE_UNADVISE</P></TD><TD VALIGN="TOP"><P><I>IDataObject::DUnadvise</I></P></TD></TR><TR><TD VALIGN="TOP"><P>WM_DDE_DATA</P></TD><TD VALIGN="TOP"><P><I>IAdviseSink::OnDataChange</I></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>On the surface, one could seemingly write a simple mapping layer to expose a DDE conversation through <I>IDataObject</I> or to generate DDE messages from events in a data object that could be picked up by some consumer's sink. But there are three differences between DDE and OLE <I>IDataObject</I> members. The first is that everything in DDE is inherently asynchronous, and DDE applications have come to depend on this fact. <I>IDataObject </I>members themselves are synchronous, while only the act of notification through <I>IAdviseSink::OnData</I><I>Change </I>is asynchronous.6</P>
<P>The second difference is in how to obtain an <I>IDataObject</I> pointer for a specific data set. Under DDE, a consumer initiates a conversation using only a general specification for the source, a <I>service</I> and a <I>topic</I> such as the service <I>Excel</I> and the topic <I>NASDAQ.XLS</I>. With OLE, you generally have a file moniker to perform the same process.</P>
<P>Once connected, a DDE consumer can send a WM_DDE_REQUEST message to the source to ask for a rendering of a specific subset or <I>item</I> of the data represented by the topic, such as <I>R4C5:R8C20</I>. In other words, the act of requesting data includes the ability to specify the item of interest. However, the arguments to <I>IDataObject::GetData </I>do not have a concept of item. If you bound a NASDAQ.XLS file moniker asking for <I>IDataObject</I> and then called <I>IDataObject::GetData</I>, the source would need to render the entire spreadsheet. The FORMATETC structure passed to <I>GetData </I>simply does not have an item field. (The <I>lindex </I>member is specifically for graphical renderings that involve multiple disparate parts and cannot be used to specify an item.)</P>
<P>Of course, you could bind a File!Item moniker that specifies the exact data you want, but the data object you get back would know only about that specific cell range in the spreadsheet. If you wanted data from another part of the spreadsheet, you'd have to bind another moniker, thus creating another data object. Obviously, this is expensive with respect to memory for a large number of cell ranges, making the data object solution much more costly than the equivalent DDE connection, because there isn't a way through the <I>IDataObject </I>interface to tell the data object to switch the item it will render in a <I>GetData </I>call.</P>
<P>This really boils down to the third difference in the concept of an item in DDE and OLE. In DDE an item is inherently specified during the act of a data request, but in OLE it's inherently part of creating the data object initially. You can see that there isn't a simple way to map DDE to OLE and vice versa.</P>
<P>Does this mean that it is impossible to create a DDE-type solution using OLE? Not at all—it simply means that the data source has to implement some interface other than <I>IDataObject </I>so that the consumer can have that data object switch to another item at run time. This was precisely the problem faced by the Open Market Data Council, a group of representatives from over 75 software corporations involved with electronic stock market services. They needed an efficient way of using OLE to exchange very sparse subsets of all available quotes in real time. A consumer of such data needed a way to ask for a single quote or for a specific batch of quotes from a single source that knew all market quotes; that consumer also needed to create a notification connection so that it knew when any number of specific values for some set of issues changed. Obviously, it was not agreeable to have the source render the entire market state for each request, which is what it would have to do through <I>IDataObject </I>alone.</P>
<P>The Council's solution, called the WOSA Extensions for Real-Time Market Data Transfer (WOSA/XRT), uses <I>IDataObject </I>and <I>IAdviseSink </I>for all of the data exchange and notification. However, the data source also implements an OLE Automation dispinterface (an implementation of <I>IDispatch</I>, described in more detail in Chapter 14) through which the consumer can specify the current item to watch. Through this dispinterface, the consumer has a way to tell the source to switch items, as shown in Figure 10-1. Not only does this provide all the functionality of the DDE solution, it is also more efficient: once the consumer specifies the item, that item remains in effect until it is changed again. The consumer doesn't need to specify the item in every call, and the source doesn't have to send the item along with every change notification, as happens with DDE. Through OLE Automation dispatch interfaces, the council was able to take advantage of all the capabilities of OLE, greatly improving the overall efficiency of the real-time market data systems.</P>
<P>    <img src="f10dd01.gif"></P>
<P><B>Figure 10-1.</B></P>
<P><B>The WOSA/XRT solution for dynamically specifying items in a data object.</B></P>
<P>It is no crisis then that OLE can't completely supplant DDE. OLE will prove over time to be a more efficient, powerful, and robust means of doing whatever DDE could do but through an object-oriented programming model. For all intents and purposes, consider DDE to be obsolete—the only applications that should be using it are those that need backward compatibility with legacy code. New designs should strive for solutions based on OLE.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="540pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>5 DDE Execute (the WM_DDE_EXECUTE message) is entirely displaced with OLE Automation. However the OLE Documents technology has a low-level DDE layer for the express purpose of communicating with OLE 1 clients and servers as OLE 1 was entirely based on DDE.</P></TD></TR><TR><TD VALIGN="TOP"><P>6 Calling <I>DAdvise </I>with ADVF_ONLYONCE ¦ ADVF_PRIMEFIRST is essentially an asynchronous <I>IDataObject::GetData</I> call but that's a special case and works only for the get direction.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
