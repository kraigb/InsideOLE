<HTML><HEAD><TITLE>A Data Transfer Component</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>A Data Transfer Component</H3><P>An object that would simplify clipboard transfers is essentially a data cache with <I>IDataObject</I> slapped on it, one that you could grab with a quick call to <I>CoCreateInstance. </I>DataTran is a server for such an object; its <I>CLSID</I><I>_</I><I>DataTransferObject </I>is defined in INC\BOOKGUID.H. Be sure to create registry entries for DataTran using the REG file in the sample's directory before you attempt to run Cosmo or Patron from this or any subsequent chapter. Both Cosmo and Patron call <I>CoCreateInstance </I>with this CLSID in place of <I>FunctionToCreateADataObject </I>in the code listed earlier.</P>
<P>DataTran is simply an archetypal in-process component server for a single object, implemented in a C++ class named <I>CDataObject</I> in DATAOBJ.H, DATAOBJ.CPP, and IDATAOBJ.CPP. The FORMATETC enumerator is in IENUMFE.CPP.</P>
<P>During initialization, the data object creates a hidden list box control. In the list, it stores whatever renderings you care to stuff in it using a custom data structure named RENDERING (DATAOBJ.H). This structure manages a FORMATETC,<I> </I>a STGMEDIUM,<I> </I>and an <I>IUnknown </I>pointer to the data's real owner:</P>
<P><BR></P>
<pre><code>typedef struct tagRENDERING<BR>    {<BR>    FORMATETC        fe;             //Format<BR>    STGMEDIUM        stm;            //Actual data<BR>    LPUNKNOWN        pUnkOrg;        //Real owner<BR>    } RENDERING, *PRENDERING;</code></pre>
<P>DataTran allocates and stores a RENDERING structure in each call to its <I>IDataObject::SetData </I>(IDATAOBJ.CPP);<I> </I>the structure holds a copy of the FORMATETC and STGMEDIUM structures passed to <I>SetData</I>, with one exception. DataTran replaces the <I>STGMEDIUM::pUnkForRelease</I> field with its own <I>IUnknown</I> so that DataTran can share that rendering with multiple consumers. It uses its own reference count to keep the data valid. However, we must still preserve the original <I>pUnkForRelease</I>, which ends up in the <I>RENDERING::pUnkOrg</I> field. DataTran restores this pointer before calling <I>ReleaseStgMedium </I>to free the data. Through all of this, DataTran's <I>SetData </I>member acts a lot like the Windows <I>SetClipboardData</I>, with the added feature that calling <I>SetData</I> with NULL pointers cleans out the entire data object:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDataObject::SetData(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM, BOOL fRelease)<BR>    {<BR>    PRENDERING      prn;<BR><BR>    //We have to remain responsible for data.<BR>    if (!fRelease)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    if (NULL==pFE œœ NULL==pSTM)<BR>        {<BR>        m_pObj-&gt;Purge();<BR>        return NOERROR;<BR>        }<BR><BR>    prn=new RENDERING;<BR><BR>    if (NULL==prn)<BR>        return ResultFromScode(E_OUTOFMEMORY);<BR><BR>    prn-&gt;fe=*pFE;<BR>    prn-&gt;stm=*pSTM;<BR>    prn-&gt;pUnkOrg=pSTM-&gt;pUnkForRelease;<BR>    prn-&gt;stm.pUnkForRelease=this;<BR><BR>    SendMessage(m_pObj-&gt;m_hList, LB_ADDSTRING, 0, (LONG)prn);<BR>    return NOERROR;<BR>    }</code></pre>
<P>With a list of RENDERING structures, the implementations of <I>QueryGetData</I> and <I>EnumFormatEtc</I> need only to look in the list for their formats. <I>EnumFormatEtc</I> creates an enumerator object that copies the FORMATETC structures from each RENDERING in the list into its own array for enumeration.</P>
<P>That leaves <I>GetData</I> and <I>Release</I>. <I>GetData</I> walks through the list looking for a match on the requested FORMATETC. (<I>GetDataHere</I> is the same as <I>GetData</I> except that it is restricted to <I>IStorage</I> mediums.) If the format exists, <I>GetData </I>copies the STGMEDIUM structure for that format into the caller's structure and then calls <I>AddRef </I>on itself:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDataObject::GetData(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM)<BR>    {<BR>    UINT        i, cItems;<BR>    PRENDERING  pRen;<BR>    DWORD       cb;<BR>    HWND        hList;<BR><BR>    if (NULL==m_pObj-&gt;m_hList œœ NULL==pFE œœ NULL==pSTM)<BR>        return ResultFromScode(DATA_E_FORMATETC);<BR><BR>    hList=m_pObj-&gt;m_hList;<BR>    cItems=(UINT)SendMessage(hList, LB_GETCOUNT, 0, 0L);<BR><BR>    for (i=0; i &lt; cItems; i++)<BR>        {<BR>        cb=SendMessage(hList, LB_GETTEXT, i, (LPARAM)&amp;pRen);<BR><BR>        if (LB_ERR!=cb)<BR>            {<BR>            if (pFE-&gt;cfFormat==pRen-&gt;fe.cfFormat<BR>                &amp;&amp; (pFE-&gt;tymed &amp; pRen-&gt;fe.tymed)<BR>                &amp;&amp; pFE-&gt;dwAspect==pRen-&gt;fe.dwAspect)<BR>                {<BR>                *pSTM=pRen-&gt;stm;<BR>                AddRef();<BR>                return NOERROR;<BR>                }<BR>            }<BR>        }<BR><BR>    return ResultFromScode(DATA_E_FORMATETC);<BR>    }</code></pre>
<P>The <I>AddRef </I>call accounts for the <I>Release </I>call that will come from inside the consumer's later call to <I>ReleaseStgMedium</I>.1 The consumer doesn't know that we're not giving it an independent copy, but because of the <I>pUnkForRelease </I>field in FORMATETC, we can control the data with a simple reference count. Only when we reset or free the entire data object will we actually free the data. This happens in <I>CDataObject::Purge</I>:</P>
<P><BR></P>
<pre><code>void CDataObject::Purge(void)<BR>    {<BR>    UINT        i, cItems;<BR>    PRENDERING  pRen;<BR>    DWORD       cb;<BR><BR>    if (NULL==m_hList)<BR>        return;<BR><BR>    cItems=(UINT)SendMessage(m_hList, LB_GETCOUNT, 0, 0L);<BR><BR>    for (i=0; i &lt; cItems; i++)<BR>        {<BR>        cb=SendMessage(m_hList, LB_GETTEXT, i, (LPARAM)&amp;pRen);</code></pre>
<P><B>    </B><I>(continued)</I></P>
<P><BR></P>
<pre><code>        if (LB_ERR!=cb)<BR>            {<BR>            pRen-&gt;stm.pUnkForRelease=pRen-&gt;pUnkOrg;<BR>            ReleaseStgMedium(&amp;pRen-&gt;stm);<BR>            delete pRen;<BR>            }<BR>        }<BR><BR>    SendMessage(m_hList, LB_RESETCONTENT, 0, 0L);<BR>    return;<BR>    }</code></pre>
<P>In this way, DataTran shows a good use for <I>pUnkForRelease</I>: to control the ownership of the data, taking over from the real source until the time when the data must really be freed.</P>
<P>DataTran handles probably the most common case in which you need a data object to work with the OLE Clipboard. But in the case of Component Cosmo, having a data object isn't necessary.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 Because <I>ReleaseStgMedium </I>will call DataTran's <I>Release </I>to free the data we do not need to make an extra <I>AddRef </I>call to <I>IStorage </I>or <I>IStream </I>pointers in the medium. The consumer will not call these objects' <I>Release </I>members. Only our call to <I>ReleaseStgMedium </I>in <I>CDataObject::Purge </I>can do it.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
