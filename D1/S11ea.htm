<HTML><HEAD><TITLE>Viewable Objects: IViewObject and IViewObject2</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Viewable Objects: <I>IViewObject</I> and <I>IViewObject2</I></H2><P>Simply put, an object's support of either <I>IViewObject </I>or <I>IViewObject2 </I>makes that object viewable. In other words, when a client queries for these interfaces it is asking whether the object can draw itself directly to a device. These interfaces are often found alongside <I>IDataObject</I>, giving a client the capability of obtaining renderings directly or from a storage medium. <I>IViewObject2</I> is the same as <I>IViewObject </I>with one extra member:</P>
<P><BR></P>
<pre><code>interface IViewObject : IUnknown<BR>    {<BR>    HRESULT Draw(DWORD dwAspect, LONG lindex, void *pvAspect<BR>        , DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hDC<BR>        , LPCRECTL prcBounds, LPCRECTL prcWBounds<BR>        , BOOL (CALLBACK *pfnContinue)(DWORD), DWORD dwContinue);<BR><BR>    HRESULT GetColorSet(DWORD dwAspect, LONG lindex, void *pvAspect<BR>        , DVTARGETDEVICE *ptd, HDC hicTargetDev<BR>        , LPLOGPALETTE *ppColorSet);<BR>    HRESULT Freeze(DWORD dwDrawAspect, LONG lindex, void *pvAspect<BR>        , DWORD *pdwFreeze);<BR>    HRESULT Unfreeze(DWORD dwFreeze);<BR>    HRESULT SetAdvise(DWORD dwAspects, DWORD dwAdvf<BR>        , IAdviseSink *pAdvSink);<BR>    HRESULT GetAdvise(DWORD *pAspects, DWORD *pdwAdvf<BR>        , IAdviseSink *ppAdvSink);<BR>    };<BR><BR>interface IViewObject2 : IViewObject<BR>    {<BR>    HRESULT GetExtent(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd<BR>        , LPSIZEL pszl);<BR>    };</code></pre>
<P>The <I>IViewObject2 </I>interface was created because asking an object for its size—<I>GetExtent</I>—is a common request. The original <I>IViewObject </I>did not have this capability, and the only other interface that does is <I>IOleObject</I>, a large interface found on compound document objects. It is pointless to make an object implement <I>IOleObject </I>simply to tell a client how large it is, so <I>IViewObject2 </I>is a necessity. Objects should always implement <I>IViewObject2</I> where the object's <I>QueryInterface</I> will also return the base interface <I>IViewObject</I>. Any viewable object implemented by OLE itself (such as the data cache) implements <I>IViewObject2</I>, and it is silly for an object to implement <I>IViewObject </I>alone unless for some odd reason its extents make no sense for it. <I>IViewObject </I>is not wholly obsolete, however, because clients that do not need the extents might ask only for this lesser interface. But by virtue of supporting <I>IViewObject2</I>, objects support <I>IViewObject</I>. For all of these reasons, the rest of this chapter (and book) is concerned with <I>IViewObject2</I>.</P>
<P>You probably noticed that a number of the member functions of <I>IViewObject2 </I>take arguments that are found inside the FORMATETC structure that we saw in Chapter 10: an aspect (<I>dwAspect</I>; all DVASPECT_* values are legal), a piece index (<I>lindex</I>), and a target device (<I>ptd</I>).1 These arguments identify the exact data concerned with the member. This means you can ask <I>Draw</I>, for example, to render a thumbnail sketch or an icon for whatever device is appropriate. <I>IViewObject2 </I>doesn't require a FORMATETC because we're not at all concerned with data formats or storage mediums. The format is always "the object's view," and the medium, important only in <I>Draw</I>, is always the <I>hDC </I>device.</P>
<P>The <I>hDC</I> brings up a significant restriction for both of these interfaces. An <I>hDC</I> is not shareable between processes under any Windows operating system, so <I>IViewObject</I> and <I>IViewObject2</I> can be implemented only on in-process objects! In other words, no marshaling support exists for these interfaces because an <I>hDC</I> cannot be marshaled. Only those objects provided from in-process servers and in-process handlers can implement these interfaces. <I>IViewObject2</I> is, in fact, one of the major reasons why you might need to implement an in-process handler that communicates with a local server: the handler implements <I>IViewObject2</I>, delegating all other interfaces to its local server.</P>
<P>Two types, found in <I>Draw </I>and <I>GetExtent</I>, respectively, deserve mention here because we have not yet encountered them, but we will in later chapters. LPCRECTL, used for <I>prcBounds </I>and <I>prcWBounds </I>in <I>Draw</I>, is a pointer to a constant RECTL structure:</P>
<P><BR></P>
<pre><code>typedef struct  _RECTL<BR>    {<BR>    LONG left;<BR>    LONG top;<BR>    LONG right;<BR>    LONG bottom;<BR>    } RECTL;</code></pre>
<P><img src="16bit.gif"></P>
<P>This is a 32-bit version of the standard Windows RECT type, and under 32-bit systems a RECTL is actually identical to a RECT. However, you cannot simply assign a RECTL value to a RECT because the compiler recognizes them as different structures. For this reason, you'll find two macros in INC\INOLE.H to convert one value to the other, as well as a macro to set a RECTL structure, similar to the Windows <I>SetRect </I>function:</P>
<P><BR></P>
<pre><code>RECTLFROMRECT(rcl, rc)<BR>RECTFROMRECTL(rc, rcl)<BR><BR>#define SETRECTL(rcl, l, t, r, b) \<BR>    {\<BR>    (rcl).left=l;\<BR>    (rcl).top=t;\<BR>    (rcl).right=r;\<BR>    (rcl).bottom=b;\<BR>    }</code></pre>
<P>The SETRECTL macro takes a RECTL structure itself, not a pointer, as the first argument.</P>
<P>The <I>pszl </I>argument to <I>GetExtent</I> is a pointer to the SIZEL structure, which has no existing Windows analog but is simply a structure containing general horizontal and vertical dimensions:</P>
<P><BR></P>
<pre><code>typedef struct  tagSIZEL<BR>    {<BR>    LONG cx;<BR>    LONG cy;<BR>    } SIZEL;</code></pre>
<P>The file INC\INOLE.H also includes the macro SETSIZEL (which takes a structure, not a pointer), but because nothing else like it exists, conversion macros aren't necessary:</P>
<P><BR></P>
<pre><code>#define SETSIZEL(szl, h, v) \<BR>    {\<BR>    (szl).cx=h;\<BR>    (szl).cy=v;\<BR>    }</code></pre>
<P>Now that we have some background, let's look at the various <I>IViewObject2 </I>members.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 The <I>pvAspect </I>argument provides extended information for the object according to <I>dwAspect</I>. At the time of writing no definitions for such information exist so this value is always NULL. It does allow future extension however.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
