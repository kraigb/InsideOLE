<HTML><HEAD><TITLE>Implementing Parsing Support</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implementing Parsing Support</H3><P>For the most part, asking a server to parse moniker strings works very similarly to the binding process except that we do, of course, parse the display name from left to right. <I>MkParseDisplayName </I>will check for a filename or a string starting with @ in order to determine the CLSID of the first object in the name. So let's say LinkUser wants to parse "C:\INOLE\CHAP09\LINKSRC\GOOP.LKS!Object 2!Sub-Object 3". <I>MkParseDisplayName </I>will parse out the filename and create a file moniker out of it; this file moniker is the base to which <I>MkParseDisplayName </I>will attempt to add more individual monikers. Somehow it has to take the remaining string, "!Object 2!Sub-Object 3", and find someone to parse it. Well, because it knows that the file object named with the file moniker also understands the items within it, <I>MkParseDisplayName </I>asks that file object to do the parsing. It finds the CLSID for the filename already parsed and calls <I>CoCreateInstance</I> and asks for <I>IParseDisplayName</I>.</P>
<P>In the case of LinkSource, this will once again go all the way through the class factory to instantiate a <I>CFileObject</I>. When LinkSource is queried or when <I>IParseDisplayName</I> is called, we return our <I>IOleItemContainer </I>because the latter is derived from the former. When <I>MkParseDisplayName </I>gets this interface back from <I>CoCreateInstance</I>, it will pass the remaining string to parse to <I>IParseDisplayName::ParseDisplayName</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleItemContainer::ParseDisplayName(LPBC pbc<BR>    , LPOLESTR pszName, ULONG *pchEaten, LPMONIKER *ppmk)<BR>    {<BR>    OLECHAR     ch;<BR>    ULONG       chEaten=0;<BR>    TCHAR       szName[256];<BR>    TCHAR       szComp[15];<BR>    LPTSTR      psz;<BR>    UINT        cch;<BR><BR>    *ppmk=NULL;<BR>    *pchEaten=0;<BR>    psz=szName;<BR><BR>    ch=*pszName++;<BR>    chEaten++;<BR><BR>    if ((OLECHAR)'!'!=ch)<BR>        return ResultFromScode(MK_E_SYNTAX);<BR><BR>    ch=*pszName++;<BR><BR>    while ((OLECHAR)0!=ch &amp;&amp; (OLECHAR)'!' !=ch)<BR>        {<BR>        *psz++=(TCHAR)ch;<BR>        chEaten++;<BR>        ch=*pszName++;<BR>        }<BR><BR>    *psz=(TCHAR)0;<BR><BR>    lstrcpy(szComp, m_fFileObj ? TEXT("Object ")<BR>        : TEXT("Sub-Object "));<BR><BR>    //Does szName start with szComp?<BR>    cch=lstrlen(szComp);<BR><BR>    if (0!=_tcsncicmp(szName, szComp, cch))<BR>        {<BR>        *pchEaten=1;    //Parsed ! at least.<BR>        return ResultFromScode(MK_E_SYNTAX);<BR>        }<BR><BR>    //Check for number in szName.<BR>    if ((TCHAR)'0' != szName[cch])<BR>        {<BR>        if (0==_ttoi(szName+cch))<BR>            {<BR>            *pchEaten=cch;  //Got past name.<BR>            return ResultFromScode(MK_E_SYNTAX);<BR>            }<BR>        }<BR><BR>    *pchEaten=chEaten;<BR>    return CreateItemMoniker(TEXT("!"), szName, ppmk);<BR>    }</code></pre>
<P>LinkSource knows that it separates item monikers with a ! delimiter, so this code needs only to scan for strings between those delimiters. The <I>pszName </I>argument should be initially pointing to a !, so if that is absent we return MK_E_SYNTAX. Otherwise, we copy the remaining characters into a buffer up to the next ! or to the end of the string. We then confirm that this string has the format "Object <I>m</I>" or "Sub-Object <I>n</I>," depending on the <I>m</I><I>_</I><I>fFileObj </I>flag in this interface, return MK_E_SYNTAX in case of error, and ensure that an appropriate value is stored in *<I>pchEaten </I>to indicate where the error occurred. We do not, however, verify that an object exists—parsing is meant to check syntax, leaving binding to check existence.</P>
<P>After we finish parsing and validation, we need to return an appropriate moniker. In this example, that is always an item moniker, but there are no restrictions as to the moniker type. (<I>IParseDisplayName </I>does not depend on <I>IOleItemContainer</I>; it's the other way around.)</P>
<P>The final part of this implementation is the <I>IOleContainer::LockContainer </I>function, which <I>MkParseDisplayName </I>will call to stabilize the object doing the parsing—that is, to ensure that the object doesn't disappear as long as the bind context remains alive. You can implement <I>LockContainer </I>with a simple <I>AddRef </I>and <I>Release</I>,<I> </I>depending on the <I>fLock </I>argument:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleItemContainer::LockContainer(BOOL fLock)<BR>    {<BR>    if (fLock)<BR>        AddRef();<BR>    else<BR>        Release();<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>You might also consider using <I>CoLockObjectExternal </I>in this function if your implementation calls for managing the object on the basis of external connections rather than through a reference count. Because no other strong locks are involved with LinkSource, we can use just a reference count.</P></font></body></HTML>
