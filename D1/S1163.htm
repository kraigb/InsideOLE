<HTML><HEAD><TITLE>Custom Interfaces and Standard Marshaling</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Custom Interfaces and Standard Marshaling</H3><P>We saw earlier how the proxy and stub objects, as COM implements them internally, use registry entries to locate the necessary facelet and stublet implementations for any interface, which are assumed to be found inside an in-process server or handler. The server itself exposes a factory that implements <I>IPSFactory</I>, whereas each facelet implements <I>IRpcProxyBuffer </I>and each stublet implements <I>IRpcStubBuffer.</I></P>
<P>OLE itself provides these implementations for all of its own remotable interfaces, so Local/Remote Transparency works automatically for only those interfaces. If you want to have a client and an object communicate through an interface of your own design, therefore, you must implement and register your own server for Local/Remote Transparency and plug it into the rest of COM's standard remoting facilities. There are hard ways and easy ways to accomplish this, as discussed in the following two sections. Both ways require the same registries, of the form:</P>
<P><BR></P>
<pre><code>\<BR>    Interface<BR>        {&lt;IID&gt;} = &lt;Name of interface&gt;<BR>            NumMethods = &lt;Total number of interface members&gt;<BR>            BaseInterface = &lt;{IID} of base interface&gt;<BR>            ProxyStubClsid32 = &lt;{CLSID} of a server for the marshaler&gt;</code></pre>
<P><img src="16bit.gif"></P>
<P>The NumMethods entry describes the total number of members in this interface, and BaseInterface identifies the IID of the interface from which the interface is derived. If no BaseInterface is given, COM assumes the IID of <I>IUnknown. </I>Finally, ProxyStubClsid32 provides the CLSID of the server whose class factory implements <I>IPSFactoryBuffer</I>,<I> </I>through which COM's standard marshaling can create new facelets and stublets for this interface, as described earlier.</P>
<H4><A NAME="sec0"></A>The Hard Way: Manual Facelet and Stublet Implementation</H4><P>As we learned in Chapter 5, implementing a DLL server is not a big deal. Implementing a server with a PSFactory is no more involved than writing a server with a class factory: you merely change the interface. Nor is it a big deal to create some skeletal facelet and stublet implementations that expose the correct interfaces and that behave properly through <I>QueryInterface. </I>All that remains is to implement the functions in <I>IRpcProxyBuffer </I>and <I>IRpcStubBuffe</I><I>r</I> along with the facelet's implementation of its marshaled interface. When a client calls the interface to marshal, the facelet places arguments in the RPC Channel and calls <I>IRpcChannelBuffer::SendReceive</I>. From here, COM calls the stublet's <I>IRpcStubBuffer::Invoke</I>, which extracts the arguments, calls the object, and sends all the return values back over. (This is described in APPB.WRI on the companion CD.)</P>
<P>How you decide to represent marshaled data for a custom interface is entirely up to you. In COM's remoting architecture, only the facelet and the stublet care about the format of the marshaled argument: therefore, you can write such code in whatever way you want. This works well for remoting within the same machine; in this case, the same server is used for facelet and stublet. When remoting occurs across a network, however, relying on the simultaneous installation of a compatible facelet/stublet server on all the different machines is no longer reasonable. Instead, facelets and stublets that support cross-network marshaling must conform to published standards for data representation. These standards are published along with Microsoft's distributed services for COM. They may or may not be available by the time you read this book.</P>
<P>Well, all of this doesn't sound so bad—only a few simple object implementations, right? Why do I call it the "hard way"? The truth of the matter is that for a reasonably useful and interesting interface, member functions deal with nontrivial arguments, especially when you start dealing with pointers to structures, pointers to strings, and other interface pointers that require you to create a new proxy and a new stub as well. Using the functions <I>CoMarshalInterface</I> and <I>CoUnmarshalInterface</I> along with <I>CoLetMarshalSizeMax</I>, <I>CoMarshalHResult</I>, and <I>CoUnmarshalHResult</I> is described in the <I>OLE Programmer</I><I>'</I><I>s Reference</I>.</P>
<P>That said, implementing custom interface support for standard marshaling manually is entirely possible; it just takes more work. </P>
<H4><A NAME="sec1"></A>The Easy Way: The MIDL Compiler</H4><P><img src="16bit.gif"></P>
<P>Instead of you implementing all the code yourself, Microsoft provides the Microsoft Interface Definition Language, or MIDL, compiler, which can take a simple text description of an interface (including any data structures you need in that interface) and churn out C code for both facelet and stublet, along with the header file that contains the interface definition itself.7 All you have to do afterwards is provide a DEF file and a make file, compile, link, register the server, and BOOM! Instant standard marshaling support! You even have the correct header file to include with any client or object code that you want to write using this interface.</P>
<P>The Microsoft Interface Definition Language itself is a set of extensions to the Open Software Foundation Distributed Computing Environment Interface Definition Language (OSF DCE IDL), the basic industry-standard RPC interface language. IDL is simply a language, and the MIDL compiler a tool, to relieve the tedium of manually creating marshaling support. The IDL documentation, the MIDL compiler, and the header files and import libraries that you need to work with MIDL are officially part of Microsoft RPC, which you'll find in the Win32 SDK. Your specific development environment (for example, Visual C++) might not include Microsoft RPC, so you might need the Win32 SDK to work with MIDL.</P>
<P>The IDL is similar to the Object Description Language (ODL) we saw in Chapter 3, and the two have a similar syntax. However, many keywords available in one are not available in the other to address specific problems. ODL is geared specifically to describing OLE servers and objects. IDL, on the other hand, is geared to cross-process and cross-network RPC and is capable of describing much more than is necessary to create marshaling code for some OLE interface. When describing a custom interface in IDL, you end up using only a small subset of its capabilities. For example, the following is an IDL file for the interface <I>IAnimal</I>, which we'll see later in a custom interface sample:</P>
<P><BR></P>
<pre><code>[uuid(0002114a-0000-0000-c000-000000000046),<BR>    object<BR>]<BR>interface IAnimal : IUnknown<BR>    {<BR>    import "unknwn.idl";<BR><BR>    HRESULT Eat([in] LPTSTR pszFoodRecommended<BR>        , [in, out] LPTSTR pszFoodEaten, [in] short cchEaten);<BR>    HRESULT Sleep([in, out] short *pcMinutes);<BR>    HRESULT Procreate([out] short *pcOffspring);<BR>    HRESULT WhatKindOfAnimal([out] IID *pIID);<BR>    }</code></pre>
<P>Describing an interface is mostly a matter of setting its IID and listing the member functions, their arguments, and the attributes for those arguments. In some cases, you'll also need to describe a data type that you use in the interface. Such structures, as well as any other argument types, must be unambiguous, meaning that the size of the data must be known and pointers must have a known type. See "Marshaling Considerations for Custom Interfaces" on the facing page.</P>
<P>Otherwise, the most important question is whether the arguments are in-parameters, out-parameters, or in/out-parameters. These directional attributes determine what sort of marshaling code is necessary for such an argument. An in-parameter is put into the channel by the facelet and is consumed in the stublet. The opposite is true for an out-parameter. With an in/out-parameter, the facelet sends it through the channel, the stublet sends new contents back, and the facelet extracts those new contents. Of course, the MIDL compiler hides all the details from you, as long as you describe the interface accurately.</P>
<P>Eventually, skipping the compilation step altogether might be possible. Instead, the system could dynamically create facelets and stublets at run time directly from an IDL script.<B><I> </I></B>This would be especially useful in a distributed environment. COM could then pass the IDL script across the network so that you don't have to worry about installing the custom interface marshalers on every system.<B><I> </I></B>It would certainly be a nice feature!</P>
<H4><A NAME="sec2"></A>Marshaling Considerations for Custom Interfaces</H4><P>The process of marshaling, especially for data structures and other pointers to data, means that a function's arguments must be re-created inside the object's address space exactly as they appear in the client's. Doing this on a single machine is relatively easy; when the process involves two different machines with potentially different operating systems and hardware architectures, implementation becomes more complicated, and it demands the unambiguous specification of your interface and associated data structures. In general, you should avoid any hardware-dependent types, such as <I>int</I>,<I> </I>as well as <I>void </I>*<I> </I>pointers, which do not specify exactly what is being pointed to.</P>
<P>To address this, Microsoft has listed a few rules of thumb that you should follow to best support marshaling across network boundaries:</P>
<UL><LI>Do not use <I>int </I>or <I>unsigned int</I>; use <I>short</I>,<I> unsigned short</I>,<I> long</I>,<I> </I>and <I>unsigned long</I>. The MIDL compiler will choke on anything containing <I>int</I>,<I> </I>just to keep you honest.</LI><LI>Do not use <I>void </I>*. If you need a pointer to a generic interface pointer, use <I>IUnknown </I>**. The <I>void </I>**<I> </I>arguments used in <I>QueryInterface </I>are an exception because MIDL inherently understands the semantics of the function, but it doesn't understand the semantics of your own function.</LI><LI>Include as the first field of any data structure a count of bytes that describes the size of the structure itself.<B><I> </I></B>This makes it faster and easier to copy the structure, which will probably become necessary in the course of marshaling.</LI><LI>Be careful with pointers to structures; MIDL assumes that a pointer points to a single data item. MIDL sees a MYSTRUCT *<I> </I>as pointing to a single MYSTRUCT, whereas you might want to pass an array of MYSTRUCT structures; in this case, there are IDL constructs to help you include a length argument to specify the exact length of the referenced data.</LI><LI>Be careful with pointers embedded in structures; they must all be initialized or NULL. Uninitialized pointers will cause problems when a facelet attempts to copy the contents into the RPC Channel.</LI><LI>When using unions, include a description of which part of the union is being passed. This is especially important for unions that mix by-value and by-reference arguments. The facelet must know which piece to marshal. Again, IDL provides ways to describe this.</LI></UL>
<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>7 The Win32 SDK header files for OLE-defined interfaces are defined in this manner.  We saw the output in Chapter 2 for <I>IUnknown</I>.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
