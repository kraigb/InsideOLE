<HTML><HEAD><TITLE>IViewObject2::SetAdvise and GetAdvise</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IViewObject2::SetAdvise</I> and <I>GetAdvise</I></H3><P>The final two members of <I>IViewObject2</I>—<I>SetAdvise</I> and <I>GetAdvise</I>—work with <I>IAdviseSink::OnViewChange</I> independently of <I>IAdviseSink::OnDataChange</I>, which we saw in Chapter 10.<I> SetAdvise </I>establishes or ends a notification loop, and <I>GetAdvise </I>retrieves the last <I>IAdviseSink </I>pointer seen in <I>SetAdvise</I>.</P>
<P><I>IAdviseSink::OnViewChange</I> informs a client that an object's view changed, not necessarily some underlying data.<I> </I>This is why a client calls <I>IDataObject::DAdvise </I>for data change notifications and <I>IViewObject2::SetAdvise </I>for view changes.<I> </I>As an example, consider a data object attached to a spreadsheet whose view is also that spreadsheet.<I> </I>A change in one of the cells would fire <I>OnDataChange </I>but would fire <I>OnViewChange </I>for DVASPECT_CONTENT only if that cell is visible in the rendering. A change to the spreadsheet does not, however, change a DVASPECT_ICON rendering, which is unrelated to the actual data underneath.<I> </I>A change to the actual spreadsheet filename, on the other hand, might change the icon aspect (if the filename is the icon's label) but not the content aspect, which shows only the spreadsheet cells.<I> </I>In addition, a change to the rotation of a chart might fire <I>OnViewChange</I>, although the actual data is the same.<I> </I>When data and view changes occur together, which notification is fired first is variable between objects.<I> </I>Clients should not depend on any particular order.</P>
<P>Clients call <I>IViewObject2::SetAdvise</I> with <I>dwAspect </I>set to whatever aspects it is displaying in an active fashion.<I> </I>A view object that doesn't support notifications at all returns NOTIFY_E_ADVISENOTSUPPORTED.<I> </I>Otherwise, the <I>dwAdvf </I>flags (the same ADVF_* flags as for <I>IDataObject::DAdvise</I>) describe the nature of the notifications desired; 0 means "normal notification," ADVF_PRIMEFIRST generates an <I>OnViewChange </I>call immediately, and ADVF_ONLYONCE will have the object release the advise sink after the first <I>OnViewChange</I> call.<I> </I>No other ADVF_* flags are relevant.<I> </I>Furthermore, <I>pAdvSink </I>points to the client's <I>IAdviseSink</I> implementation.<I> </I>A client will generally invalidate some region of its window inside <I>IAdviseSink::OnViewChange</I> and then call <I>IViewObject2::Draw</I> later during a repaint.<I> </I>A client calls <I>SetAdvise </I>with a NULL in <I>pAdvSink</I> to terminate the advisory connection.</P>
<P>Another point about <I>SetAdvise </I>is that each viewable object maintains only a single <I>IAdviseSink </I>pointer. A viewable object does not support multicasting.<I> </I>Any call to <I>SetAdvise </I>will release the formerly installed sink and install the new one. This will not cause a conflict for multiple clients because <I>IViewObject2 </I>can be implemented only on an in-process object and there will generally be only one client for any one instantiation of such an object.<I> </I>There is no conflict with multiple remote clients.<I> </I>The possibility exists, of course, that multiple components in a process will try to access the same instance of a viewable object, but that has not been shown to be a problem.<I> </I>Because components are usually isolated from one another, each would use its own instance of the viewable object.<I> </I>Only components with intimate knowledge of each other could be in conflict, in which case it is entirely their responsibility to determine how to handle notifications.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>Synchronizing with a Local Server</H4><P>As mentioned earlier, a viewable object must be in-process, and as part of an in-process handler it works in conjunction with a local server.<I> </I>To keep the two synchronized, the handler object needs to know when the local object changes data. The handler object can then generate an <I>IAdviseSink::OnViewChange</I> call to the client if necessary.<I> </I>To do this, the handler object must implement a sink of its own and connect it to the local object through <I>IDataObject::DAdvise</I>.<I> </I>When this handler sink receives <I>IAdviseSink::OnDataChange</I>, it can check whether the change affects any current view for which the client wants a notification.<I> </I>If so, the handler object turns around and calls the client's <I>IAdviseSink::OnViewChange</I>, which it can do directly from within the handler object's own <I>OnDataChange </I>because the handler is in the client process already.<I> </I>The handler's sink is a separate object from the viewable object in that same handler, so they must have separate implementations of <I>QueryInterface.</I></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
