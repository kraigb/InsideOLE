<HTML><HEAD><TITLE>Objects with Type Information: IProvideClassInfo</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Objects with Type Information: <I>IProvideClassInfo</I></H2><P>If a client wants to browse an object's type information without instantiating the object, the client can use the object's registry entries to load the library itself and obtain an <I>ITypeLib</I> pointer. The only complication here is that the client has to know the CLSID of the object in question, and it then has to navigate through the library to find the <I>ITypeInfo</I> pointer for the object's <I>coclass.</I> If the client already has a running instance of that class, it would make sense to simply <I>ask</I> the object for its <I>coclass</I> type information directly.</P>
<P>This is the purpose of the <I>IProvideClassInfo</I> interface, which an object can implement if it wants to provide this feature. The only types of objects that are currently required to implement this interface are those with custom event sets, such as OLE controls. For other objects, it's merely a convenience for interested clients, but it is an interface I strongly recommend.9</P>
<P><I>IProvideClassInfo</I> is actually one of the simplest interfaces you'll find. Besides its <I>IUnknown</I> members, it has only one additional function, named <I>GetClassInfo</I>, which takes a single out-parameter in which it returns the <I>ITypeInfo</I> pointer for the object's <I>coclass</I> information:</P>
<P><BR></P>
<pre><code>interface IProvideClassInfo : IUnknown<BR>    {<BR>    HRESULT GetClassInfo(ITypeInfo **ppITI);<BR>    }</code></pre>
<P>The presence of this interface frees the client from having to load and navigate a type library itself, which is, however, what the object will generally do using code somewhat like the code on the following page to obtain the <I>ITypeInfo</I> pointer to return:</P>
<P><BR></P>
<pre><code>//Try loading from registry information.<BR>if (FAILED(LoadRegTypeLib(LIBID_MyTypeLibrary, 1, 0<BR>    , LANG_NEUTRAL, &amp;pITypeLib)))<BR>    {<BR>    //Try loading directly, fixing registry information.<BR>    if (FAILED(LoadTypeLib(TEXT("MYTYPES.TLB"), &amp;pITypeLib)))<BR>        return FALSE;<BR>    }<BR><BR>//Find ITypeInfo for coclass.<BR>pITypeLib-&gt;GetTypeInfoOfGuid(CLSID_MyObject, &amp;m_pITI);<BR>pITypeLib-&gt;Release();</code></pre>
<P>In the following code, <I>m</I><I>_</I><I>pITI</I> would end up with the <I>ITypeInfo</I> pointer for <I>IProvideClassInfo::GetClassInfo</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CMyObject::GetClassInfo(ITypeInfo **ppITI)<BR>    {<BR>    if (NULL==ppITI)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    *ppITI=m_pITI;<BR><BR>    if (NULL!=m_pITI)<BR>        {<BR>        m_pITI-&gt;AddRef();<BR>        return NOERROR;<BR>        }<BR><BR>    return ResultFromScode(E_FAIL);<BR>    }</code></pre>
<P>In a sense, <I>IProvideClassInfo</I> represents the ability of an object to describe its interfaces and types when everything else about it is unknown. As an example, if a client received through, say, a drag-and-drop operation some arbitrary <I>IUnknown</I> pointer, it would query for <I>IProvideClassInfo</I>, and if that succeeded, it could programmatically analyze the available incoming and outgoing interfaces that the object supports. Based on this analysis, the client might determine what could be done with the object: Is it a control? A compound document content object? An OLE Automation object? Something else? What abilities does it have?</P>
<P>There is one deficiency in this interface that you should note: there is no way to ask the object for type information in a particular language. In other words, the interface assumes that the object will have already loaded type information appropriate to the user's international settings on the current machine. In some cases, however, this may not be adequate for the needs of all clients, so there may, in the future, be something like an <I>IProvideClassInfo2</I> that would have an additional function that takes an LCID as an argument. For the time being, however, this remains a single-locale interface.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="431pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>9 This interface was first defined as part of the OLE Controls specification itself and at the time of writing it is not widely used outside this realm. In addition the initial support for this interface which was the OLE Controls Development Kit (with Microsoft Visual C++ 2.0) did not provide any marshaling support (proxy and stub) for <I>IProvideClassInfo </I>and as a consequence it can be imple-mented only on in-process objects unless you are willing to write your own proxy or stub DLL. I fully expect that this limitation will not be present by the time this book is published or shortly thereafter.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
