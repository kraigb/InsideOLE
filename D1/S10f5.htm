<HTML><HEAD><TITLE>Reference Counting</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Reference Counting</H3><P>In short, reference counting is the way an object controls its own lifetime. Reference counting works on the same principles as memory management. Just as a component frees memory when the memory is no longer in use, objects are destroyed when they are no longer being used. The difference is that destroying an object is not a passive operation: instead of freeing the object directly, a client must tell the object to free itself. The overall difficulty of making this work is that COM objects are dynamically allocated from within the component, yet clients must be allowed to decide when the object is no longer needed. Furthermore, objects can be simultaneously connected to multiple clients, even in different processes, and the object must wait for all clients to release their hold on the object before it can destroy itself.</P>
<P>Hence the reference count, which is a ULONG variable, usually called <I>m</I><I>_</I><I>cRef </I>inside C++ implementations. This reference count maintains the number of independent interface pointers that exist to any of the object's interfaces. If there is only a single client of an object and that client has two different interface pointers on the object, the reference count will be 2. If there are three clients, each with a single interface pointer on the object, the reference count will be 3. While the overall reference count concerns the object, that object might maintain individual interface reference counts so that it creates interfaces only when they are requested from <I>QueryInterface </I>and destroys them when their individual reference counts go to 0, even though the object itself is still around.</P>
<P>The concepts governing reference counting can be distilled into two fundamental rules:</P>
<UL><LI>Creation of a new interface pointer to an object must be followed by an <I>AddRef</I> call through that new pointer.</LI><LI>Destruction of an interface pointer (such as when the pointer variable goes out of scope in the client) must be preceded by a <I>Release</I> call through that pointer.</LI></UL><P>Because some objects internally use interface-specific reference counting, clients must always match <I>AddRef </I>and <I>Release </I>calls through each interface pointer.</P>
<P>The overall implications of these two rules are that whenever you (client or object) assign one pointer to another in some piece of code, you should call <I>AddRef</I> through the new pointer (the left operand). Before overwriting or otherwise destroying that pointer, call <I>Release </I>through it. These implications are illustrated in the client code on the following page.</P>
<P><BR></P>
<pre><code>LPSOMEINTERFACE    pISome1;   //Some1 object<BR>LPSOMEINTERFACE    pISome2;   //Some2 object<BR>LPSOMEINTERFACE    pCopy;<BR><BR>//A function that creates the pointer calls AddRef.<BR>CreateISomeObject(&amp;pISome1);  //Some1 ref count=1<BR>CreateISomeObject(&amp;pISome2);  //Some2 ref count=1<BR><BR>pCopy=pISome1;                //Some1 count=1<BR>pCopy-&gt;AddRef();              //AddRef new copy, Some1=2<BR><BR>[Do things.]<BR><BR>pCopy-&gt;Release();             //Release before overwrite, Some1=1<BR>pCopy=pISome2;                //Some2=1<BR>pCopy-&gt;AddRef();              //Some2=2<BR><BR>[What kinds of things do you do?]<BR><BR>pCopy-&gt;Release();             //Release before overwrite, Some2=1<BR>pCopy=NULL;<BR><BR>[Things that make us go.]<BR><BR>pISome2-&gt;Release();           //Release when done, Some2=0, Some2 freed<BR>pISome2=NULL;<BR>pISome1-&gt;Release();           //Release when done, Some1=0, Some1 freed<BR>pISome1=NULL;</code></pre>
<P>Again, an object's lifetime is controlled by all <I>AddRef</I> and <I>Release</I> calls on all of its interfaces combined. An object might use interface reference counting internally, so it is important that the <I>AddRef </I>and <I>Release </I>calls be matched through the same interface <I>pointer</I> (which can, of course, be in several client <I>variables </I>at once).</P>
<P>In any case, the first fundamental principle of reference counting is that any function that returns a pointer to an interface must call <I>AddRef</I> through that pointer. Functions that create an object and return the first pointer to an interface are such functions, as in the hypothetical <I>CreateISomeObject</I> function in the preceding example. Anytime you create a new copy of a pointer, you must also call <I>AddRef</I> through that new copy because you have two independent references—two independent pointer variables—to the same object. Then, according to the second principle of reference counting, all <I>AddRef</I> calls must be matched with a <I>Release</I> call. So before your pointer variables are destroyed (by an explicit overwrite or by going out of scope), you must call <I>Release</I> through each pointer. This process includes calling <I>Release</I> through any pointer copy (through which you called <I>AddRef</I>) and through the pointer you obtained from the function that created the object (and the pointer) that called <I>AddRef </I>implicitly.</P>
<H4><A NAME="sec0"></A>My Kingdom for Some Optimizations!</H4><P>The stated rules and their effect on the code shown earlier probably seem rather harsh, and in fact, they are. However, when you have <I>dependent </I>pointer variables for the same object's interfaces and you know the relative lifetimes of those variables, you can bypass the majority of explicit <I>AddRef</I> and <I>Release</I> calls. There are two manifestations of such knowledge, nested lifetimes and overlapping lifetimes, which are illustrated in Figure 2-3.</P>
<P><img src="f02dd03.gif"></P>
<P><B>Figure 2-3.</B></P>
<P><B>Nested and overlapping interface pointers.</B></P>
<P>In the code fragment shown earlier, every instance of <I>pCopy</I> is nested within the lifetimes of <I>pISome1</I> and <I>pISome2</I>—that is, the copy lives and dies within the lifetime of the original. After <I>CreateISomeObject</I> is called, both objects have a reference count of 1. The lifetimes of the objects are bounded by these create calls and the final <I>Release</I> calls. Because we know these lifetimes, we can eliminate any other <I>AddRef</I> and <I>Release</I> calls through copies of those pointers:</P>
<P><BR></P>
<pre><code>LPSOMEINTERFACE    pISome1;<BR>LPSOMEINTERFACE    pISome2;<BR>LPSOMEINTERFACE    pCopy;<BR><BR>CreateISomeObject(&amp;pISome1);   //Some1 ref count=1<BR>CreateISomeObject(&amp;pISome2);   //Some2 ref count=1<BR><BR>pCopy=pISome1;                 //Some1=1, pCopy nested in Some1's life<BR><BR>[Do things.]<BR><BR>pCopy=pISome2;                 //Some2=1, pCopy nested in Some2's life<BR><BR>[Do other things.]<BR><BR>pICopy=NULL;                   //No Release necessary<BR><BR>[Do anything, and then clean up.]<BR><BR>pISome2-&gt;Release();           //Release when done, Some2=0, Some2 freed<BR>pISome2=NULL;<BR>pISome1-&gt;Release();           //Release when done, Some1=0, Some1 freed<BR>pISome1=NULL;</code></pre>
<P>In other words, the lifetime of the first object is bounded by <I>CreateISomeObject(</I><I>&amp;</I><I>pISome1) </I>and <I>pISome1-&gt;Release</I>. The lifetime of the second object is bounded by <I>CreateISomeObject(</I><I>&amp;</I><I>pISome2) </I>and <I>pISome2-&gt;Release</I>. Therefore, you can make as many temporary pointers as you need as long as those variables have a scope nested within the object's lifetime. There are three instances in which you can take advantage of this optimization:</P>
<UL><LI>Local variables, whose scope is defined by a function whose scope is contained in the lifetime of an object.</LI><LI>A function that takes an interface pointer as an in-parameter has a scope defined by the caller, who is waiting for this function to return. The called function and any others it calls are nested in the original caller's scope. No <I>AddRef </I>or <I>Release </I>calls are necessary unless the called function has explicit specifications for doing so.</LI><LI>An object that is nested inside another can maintain a backpointer to the outer object without calling <I>AddRef </I>or <I>Release </I>because the nested object's lifetime is contained in the scope of the outer object.</LI></UL><P>Overlapping lifetimes are those in which the original pointer dies after the copy is born but before the copy itself dies. If the copy is alive at the original's funeral, it can inherit ownership of the reference count on behalf of the original:</P>
<P><BR></P>
<pre><code>LPSOMEINTERFACE    pISome1;<BR>LPSOMEINTERFACE    pCopy;<BR><BR>CreateISomeObject(&amp;pISome1);   //Some1 ref count=1<BR><BR>pCopy=pISome1;    //Some1=1, pCopy nested in Some1's life<BR>pISome1=NULL;     //Pointer destroyed, pCopy inherits count, Some1=1<BR><BR>pCopy-&gt;Release(); //Release inherited ref count, Some1=0, Some1 freed<BR>pCopy=NULL;</code></pre>
<P>Again, the lifetime of the object is between <I>CreateISomeObject </I>and <I>pCopy-&gt; Release</I>. <I>Release </I>is still being called through the original interface <I>pointer;</I> it's just that the pointer <I>variable </I>changes.</P>
<P>With both of these optimizations, there are only four specific cases in which an <I>AddRef</I> must be called explicitly for a new copy of a pointer (and thus must have a <I>Release</I> call made through it when destroyed):</P>
<UL><LI>Functions that return a new interface pointer in an out-parameter or as a return value must call <I>AddRef </I>for the object through that pointer before returning. <I>QueryInterface </I>is a primary example, as are object-creation API functions and interface members.</LI><LI>Functions that accept an interface pointer as an in/out-parameter must call <I>Release</I> through the in-parameter before overwriting it and must call <I>AddRef </I>through the out-parameter. If the caller wants to maintain a copy of the pointer passed in this parameter, it must call <I>AddRef </I>through the copy before calling the function.</LI><LI>If two interface pointers to the same object have unrelated lifetimes, <I>AddRef</I> must be called through each. For example, a copy of an interface pointer given to a new thread in a multithreaded application must have an independent reference count.</LI><LI>Call <I>AddRef </I>for each local copy of a global pointer since other functions that also have copies can call <I>Release </I>while your local copy is still valid.</LI></UL><P>In all cases, some piece of code must call <I>Release</I> for every <I>AddRef</I> on a pointer. In the first of the preceding cases, the caller of an interface-creating function is responsible for the new pointer (that is, the object) and must call <I>Release </I>when finished. If the object's reference count is decreased to 0, the object can destroy itself at its leisure, although the client has to consider it gone. If you fail to call <I>Release</I>, you generally doom the object to the boredom of wasteful immortality—memory will not be freed, the object's server might not unload, and so on. Be humane to your objects; let them die with dignity: be sure to release them.</P>
<H4><A NAME="sec1"></A>Call-Use-Release</H4><P>I want to clarify a statement you might see in the <I>OLE Programmer</I><I>'</I><I>s Reference,</I> which describes <I>IUnknown::Release </I>as follows: "If <I>IUnknown::A</I><I>ddRef </I>has been called on this object's interface[s] <I>n </I>times and this is the <I>n+</I>1th call to <I>IUnknown::Release</I>, the [object] will free itself." This might be confusing because <I>n+</I>1 minus <I>n</I> seems like too many calls to <I>Release</I>. This statement refers specifically to explicit <I>AddRef </I>calls from within the <I>client </I>code and implicitly assumes that <I>AddRef </I>was called within the function that initially created the interface pointer. This is a valid assumption because a creation function is required to make the call, but it is unclear in the documentation. In every case, <I>AddRef </I>and <I>Release </I>calls are perfectly paired, even when done in different places.</P>
<P>In addition, although the return value of <I>Release </I>is specified as returning the new reference count of an object, you really cannot use this value for anything other than debugging purposes. <I>Usually,</I> an object will be destroyed when a client's call to <I>Release </I>has returned 0. An object doesn't have to free itself when its reference count is 0, so a client cannot use the zero return value from <I>Release </I>to know whether the object has been destroyed. In cases for which this information is important, a higher-level protocol such as OLE Documents will provide the necessary information, for example an explicit notification that says, "The object has been closed."</P>
<P>In all of OLE, <I>Release </I>is just about the only function you'll see anywhere along the lines of destroy or delete. (There are a few close functions in OLE Documents and OLE Automation.) A very common programming pattern is for a client to call some function to get an interface pointer (which might be <I>QueryInterface</I>), then call interface member functions for whatever purpose, and then call <I>Release </I>when it's finished with that pointer. The point is that there are many interface creation functions—not only <I>QueryInterface</I>,<I> </I>but other interface and API functions that effectively include a <I>QueryInterface</I>. Regardless of how you get the pointer or what you do with it, you must call <I>Release</I> through it when you have finished.</P>
<P>This pattern isn't much different from any other resource manipulation sequences involved with Windows programming, such as <I>CreateWindow</I>, use window, <I>DestroyWindow</I>; <I>CreateFont</I>,<I> </I>use font, <I>DeleteObject</I>;<I> </I>or <I>OpenFile</I>, use file, <I>_</I><I>lclose</I>. But whereas the Windows API is befuddled with many destroy/delete/close functions, the names of which hardly match their respective creation functions (for example, <I>OpenFile </I>and <I>_</I><I>lclose</I>,<I> </I>a truly well-matched pair! &lt;sarcasm&gt;), OLE has only <I>Release</I>. The final <I>Release</I> can do more than simply free the object. For example, releasing the root storage of a compound file effectively closes the file; a memory allocator object that we'll see later in this chapter will free any allocations it has made; a custom component will terminate its own EXE server. Thus, <I>Release </I>makes it much easier to remember how to get rid of something.</P>
<H4><A NAME="sec2"></A>Circular Reference Counts</H4><P>Imagine that human beings' lifetimes are determined by the number of acquaintances they have: as long as you know someone who in turn knows you, you'll both stay alive. At birth, you have an immediate acquaintance with your mother, and throughout your life you meet and befriend other people. Every new relationship is effectively a new reference count on both you and the other person. The only way the count would ever diminish would be for someone you knew to pass on, but that is impossible because you know them. Therefore, we'd all be immortal.</P>
<P>As appealing as this scenario might sound, there is the problem of resources: if no one ever dies, sooner or later there is not enough food, water, land, air, and so forth to maintain everyone. Then what? You simply cannot create more people—you'd need a few lightning bolts from Olympus to abruptly free a few resources.</P>
<P>The same is true on a computer: if objects are never destroyed and their resources are never freed, eventually there will be nothing left from which to create new objects. Hardly a workable situation. This is exactly what can happen, however, if two objects, such as a connectable object and an event sink, as we saw in Chapter 1, hold reference counts on each other! This problem is known as a <I>circular reference count</I> and requires special handling. In all cases in which such circular counts are possible, the interfaces involved are designed to include some other function besides <I>Release </I>that will force one of the two objects to call <I>Release </I>on the other.</P>
<P>For example, in the connectable object/event sink relationship, the client of the connectable object explicitly tells that object to terminate the notification relationship. This means that the object releases its reference to the event sink, thereby allowing the event sink to be destroyed. The client can then release the connectable object, destroying it. Other, slightly different, examples occur in OLE Documents. First, if the end user deletes an embedded or a linked object in the container, the container explicitly tells the object to close, which means that object releases any references it has to the client's site and shuts itself down. Second, if the end user directly closes the object's visible editing window, the object then releases its client references and shuts itself down.</P>
<P>In all cases, there is something other than <I>Release</I>, either another function call or a bolt of lightning from the Almighty End User, that causes one object in a circular relationship to terminate its relationship with another. The circle is broken, and objects can be freed.</P>
<H4><A NAME="sec3"></A>Artificial Reference Counts</H4><P>As a final note about reference counts, let's examine the use of a technique called <I>artificial reference counts</I>. Suppose you're writing the code in method <I>CMyObject::Init</I>, and in the implementation of <I>Init </I>you invoke functions that might call your <I>AddRef</I> and then <I>Release</I>. If your reference count is 0, as happens during the creation of an object before any interfaces exist, a call to <I>AddRef </I>and <I>Release </I>would destroy the object, causing <I>Init </I>to crash. This artificial count means incrementing your reference counter directly at the beginning of the risky code and then decrementing it, usually to 0, directly afterward. Decrementing the counter directly bypasses <I>Release</I> and its potentially destructive behavior:</P>
<P><BR></P>
<pre><code>void CMyObject::Init(void)<BR>    {<BR>    m_cRef++;    //Increment count.<BR><BR>    //Risky code that might call AddRef and Release<BR><BR>    m_cRef--;    //Decrement count.<BR>    return;<BR>    }</code></pre>
<P>The artificial reference count guarantees object stability within this function.</P></font></body></HTML>
