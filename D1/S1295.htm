<HTML><HEAD><TITLE>Invoke the Insert Object Dialog Box and Create an Object</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Invoke the Insert Object Dialog Box and Create an Object</H3><P>We're now at the point at which we can create an object to put in the site. To do so, we need to retrieve a CLSID to pass to the <I>OleCreate </I>function. This is the purpose of the standard Insert Object dialog box provided in the OLE UI Library. As shown in Figure 17-1 on page 818, this dialog box has two modes. The first is Create New, in which the user selects the name of an object type to create. In return, the container receives the appropriate CLSID for that type. The other mode of this dialog box, shown in Figure 17-7, lets the user enter or browse for a filename. In response to this option, the container6 calls <I>OleCreateFromFile </I>to create either an initialized object or a package. (In Chapter 20, we'll enable a Link check box in this part of the dialog box and call <I>OleCreateLinkToFile </I>when that box is checked.)</P>
<P>    <img src="f17dd07p.gif"></P>
<P><B>Figure 17-7.</B></P>
<P><B>The Insert Object dialog box, with Create From File selected.</B></P>
<P>The OLE UI Library once again provides us with the dialog implementation, which is available through the <I>OleUIInsertObject </I>API function. The dialog scans the registry for anything marked "Insertable" and populates its Create New list box with those entries.</P>
<P>Dealing with this dialog means that we first need a menu command for it. Patron adds an Insert Object item on its Edit menu for this purpose. If you have a top-level Insert menu already, make an Object item instead. Now, when the user selects this command, Patron invokes the dialog from within <I>CPatronDoc::InsertObject</I>. On return, it checks to see which option was selected and passes the necessary information down to <I>CPages::TenantCreate</I>, which delegates to <I>CPage::TenantCreate</I>, which creates a new tenant and calls its <I>CTenant::Create </I>function. Inside <I>CTenant::Create</I>, we then call <I>OleCreate </I>or <I>OleCreateFromFile </I>and initialize the object. This initialization also handles iconic aspects when the Display As Icon box is checked in the dialog.</P>
<P>Calling <I>OleUIInsertObject </I>is a matter of filling an OLEUIINSERTOBJECT structure. Most of the work comes in handling what we get back, as you can see in <I>CPatronDoc::InsertObject</I>:7</P>
<P><BR></P>
<pre><code>BOOL CPatronDoc::InsertObject(HWND hWndFrame)<BR>    {<BR>    OLEUIINSERTOBJECT   io;<BR>    DWORD               dwData=0;<BR>    TCHAR               szFile[CCHPATHMAX];<BR>    UINT                uTemp;<BR>    BOOL                fRet=FALSE;<BR><BR>    if (NULL==m_pPG)<BR>        return FALSE;<BR><BR>    memset(&amp;io, 0, sizeof(io));<BR><BR>    io.cbStruct=sizeof(io);<BR>    io.hWndOwner=hWndFrame;<BR><BR>    szFile[0]=0;<BR>    io.lpszFile=szFile;<BR>    io.cchFile=CCHPATHMAX;<BR><BR>    io.dwFlags=IOF_SELECTCREATENEW œ IOF_DISABLELINK;<BR><BR>    uTemp=OleUIInsertObject(&amp;io);<BR><BR>    if (OLEUI_OK==uTemp)<BR>        {<BR>        TENANTTYPE      tType;<BR>        LPVOID          pv;<BR>        FORMATETC       fe;<BR><BR>        SETDefFormatEtc(fe, 0, TYMED_NULL);
        if (io.dwFlags &amp; IOF_SELECTCREATENEW)<BR>            {<BR>            tType=TENANTTYPE_EMBEDDEDOBJECT;<BR>            pv=&amp;io.clsid;<BR>            }<BR>        else<BR>            {<BR>            tType=TENANTTYPE_EMBEDDEDFILE;<BR>            pv=szFile;<BR>            }<BR><BR>        if ((io.dwFlags &amp; IOF_CHECKDISPLAYASICON)<BR>            &amp;&amp; NULL!=io.hMetaPict)<BR>            {<BR>            fe.dwAspect=DVASPECT_ICON;<BR>            dwData=(DWORD)(UINT)io.hMetaPict;<BR>            }<BR><BR>        fRet=m_pPG-&gt;TenantCreate(tType, pv, &amp;fe, NULL, dwData);<BR><BR>        //Free this regardless of what we do with it.<BR>        INOLE_MetafilePictIconFree(io.hMetaPict);<BR><BR>        if (fRet)<BR>            {<BR>            //Disable Printer Setup once we've created a tenant.<BR>            m_fPrintSetup=FALSE;<BR>            FDirtySet(TRUE);<BR>            }<BR>        }<BR><BR>    return fRet;<BR>    }</code></pre>
<P>The <I>lpszFile </I>and <I>cchFile </I>fields in the OLEUIINSERTOBJECT structure describe a buffer in which the dialog will return the filename if Create From File was selected. The IOF_CREATENEW flag forces initial selection of Create New, and IOF_DISABLELINK disables the linking abilities of this dialog (for now). On return, the <I>dwFlags </I>field tells us which option was selected. If it was Create New, we pass the CLSID of the user's selection from the list to <I>CPages::TenantCreate. </I>If Create From File was selected, we pass the filename instead. The TENANTCREATE_* flag differentiates the two cases. In addition, we initialize a FORMATETC<I> </I>structure to indicate whether the user wants an iconic display, in which case the structure field <I>hMetaPict </I>contains a metafile with the iconic representation in it. This data must always be freed when you have finished using it, which the helper function <I>INOLE</I><I>_</I><I>MetafilePictIconFree </I>(INOLE\HELPERS.CPP) does for us.</P>
<P>Down in <I>CPage::TenantCreate</I>, we create a new tenant, have that tenant create the object, position that tenant on the page, repaint it, and select it. In addition, we activate that new object immediately if it was created in response to the Create New option in the dialog. This means that we ask the tenant to call the object's <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>PRIMARY)</I> function and immediately update the object's storage. We do this because a new blank object is worthless and the first thing a user will do is activate the object to put some data in it. This step does exactly that. We'll see how the tenant performs this step later. We're interested here in what <I>CTenant::Create </I>does to create the new embedded object.</P>
<P><BR></P>
<pre><code>UINT CTenant::Create(TENANTTYPE tType, LPVOID pvType<BR>    , LPFORMATETC pFE, PPOINTL pptl, LPSIZEL pszl<BR>    , LPSTORAGE pIStorage, PPATRONOBJECT ppo, DWORD dwData)<BR>    {<BR>    HRESULT             hr;<BR>    LPUNKNOWN           pObj;<BR>    UINT                uRet=CREATE_GRAPHICONLY;<BR><BR>    [Validate arguments and determine placement using ppo.]<BR><BR>    hr=ResultFromScode(E_FAIL);<BR><BR>    //Now create object based specifically on type.<BR>    switch (tType)<BR>        {<BR>        case TENANTTYPE_NULL:<BR>            break;<BR><BR>        case TENANTTYPE_STATIC:<BR>            hr=CreateStatic((LPDATAOBJECT)pvType, pFE, &amp;pObj);<BR>            break;<BR><BR>        case TENANTTYPE_EMBEDDEDOBJECT:<BR>            hr=OleCreate(*((LPCLSID)pvType), IID_IUnknown<BR>                , OLERENDER_DRAW, NULL, NULL, m_pIStorage<BR>                , (PPVOID)&amp;pObj);<BR>            break;<BR><BR>        case TENANTTYPE_EMBEDDEDFILE:<BR>            hr=OleCreateFromFile(CLSID_NULL, (LPTSTR)pvType<BR>                , IID_IUnknown, OLERENDER_DRAW, NULL, NULL<BR>                , m_pIStorage, (PPVOID)&amp;pObj);<BR>            break;<BR><BR>        case TENANTTYPE_EMBEDDEDOBJECTFROMDATA:<BR>            hr=OleCreateFromData((LPDATAOBJECT)pvType, IID_IUnknown<BR>                , OLERENDER_DRAW, NULL, NULL, m_pIStorage<BR>                , (PPVOID)&amp;pObj);<BR>            break;<BR><BR>        default:<BR>            break;<BR>        }<BR><BR>    //If creation didn't work, get rid of the element Open created.<BR>    if (FAILED(hr))<BR>        {<BR>        Destroy(pIStorage);<BR>        return CREATE_FAILED;<BR>        }<BR><BR>    //We don't get size if PatronObject data was seen already.<BR>    if (!ObjectInitialize(pObj, pFE, dwData))<BR>        {<BR>        Destroy(pIStorage);<BR>        return CREATE_FAILED;<BR>        }<BR><BR>    if (0==pszl-&gt;cx &amp;&amp; 0==pszl-&gt;cy)<BR>        {<BR>        SIZEL   szl;<BR><BR>        //Try to get real size of object; default to 2" x 2".<BR>        SETSIZEL((*pszl), 2*LOMETRIC_PER_INCH, 2*LOMETRIC_PER_INCH);<BR>        hr=ResultFromScode(E_FAIL);<BR><BR>        //Try IViewObject2 first and then IOleObject as a backup.<BR>        if (NULL!=m_pIViewObject2)<BR>            {<BR>            hr=m_pIViewObject2-&gt;GetExtent(m_fe.dwAspect, -1, NULL<BR>                , &amp;szl);<BR>            }<BR>        else<BR>            {<BR>            if (NULL!=m_pIOleObject)<BR>                hr=m_pIOleObject-&gt;GetExtent(m_fe.dwAspect, &amp;szl);<BR>            }<BR><BR>        if (SUCCEEDED(hr))<BR>            {<BR>            //Convert HIMETRIC to our LOMETRIC mapping.<BR>            SETSIZEL((*pszl), szl.cx/10, szl.cy/10);<BR>            }<BR>        }<BR><BR>    return uRet;<BR>    }</code></pre>
<P>A tenant can create an embedded object in three ways: <I>OleCreate</I>, <I>OleCreateFromFile</I>, and <I>OleCreateFromData</I>. The first, <I>OleCreate</I>, creates a new embedded object from a CLSID. We pass to it the CLSID from the Insert Object dialog box, the interface we want (<I>IUnknown</I>), a render option (OLERENDER_DRAW), a pointer to a FORMATETC structure (NULL because we're using OLERENDER_DRAW), a pointer to an <I>IOleClientSite</I> interface (NULL because we'll give it to the object later), the storage element for this object (<I>m</I><I>_</I><I>pIStorage</I>), and the address in which to store the interface pointer that we want in return.</P>
<P>The second way to create an object, <I>OleCreateFromFile</I>, creates a new embedded object or a Package object using the file contents. You always pass CLSID_NULL along with the filename from the Insert Object dialog; the other arguments are the same.</P>
<P>The third way to create an object is from existing data in a data object through <I>OleCreateFromData</I>. We'll use this function when pasting a new object from the clipboard or accepting one through drag and drop. In this case, the data identifies the object to create, but otherwise the arguments are the same.</P>
<P>In all three cases, we get back the first interface pointer to a new and loaded object. We must now initialize the object. This event occurs in <I>CTenant::ObjectInitialize</I>, which happens to be the same initialization we need to do when loading an object again later:</P>
<P><BR></P>
<pre><code>BOOL CTenant::ObjectInitialize(LPUNKNOWN pObj, LPFORMATETC pFE<BR>    , DWORD dwData)<BR>    {<BR>    HRESULT         hr;<BR>    LPPERSIST       pIPersist=NULL;<BR>    DWORD           dw;<BR>    PCDocument      pDoc;<BR>    TCHAR           szFile[CCHPATHMAX];<BR><BR>    if (NULL==pObj œœ NULL==pFE)<BR>        return FALSE;<BR><BR>    m_pObj=pObj;<BR>    m_fe=*pFE;<BR>    m_fe.ptd=NULL;<BR>    m_dwState=TENANTSTATE_DEFAULT;<BR><BR>    m_tType=TENANTTYPE_EMBEDDEDOBJECT;<BR><BR>   [Code to handle static objects omitted]<BR><BR>    m_pIViewObject2=NULL;<BR>    hr=pObj-&gt;QueryInterface(IID_IViewObject2<BR>        , (PPVOID)&amp;m_pIViewObject2);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    m_pIViewObject2-&gt;SetAdvise(m_fe.dwAspect, 0, m_pImpIAdviseSink);<BR><BR>    //We need an IOleObject most of the time, so get one here.<BR>    m_pIOleObject=NULL;<BR>    hr=pObj-&gt;QueryInterface(IID_IOleObject<BR>         , (PPVOID)&amp;m_pIOleObject);<BR><BR>    if (FAILED(hr))<BR>        return TRUE;<BR><BR>    m_pIOleObject-&gt;GetMiscStatus(m_fe.dwAspect, &amp;m_grfMisc);<BR><BR>    if (OLEMISC_ONLYICONIC &amp; m_grfMisc)<BR>        m_fe.dwAspect=DVASPECT_ICON;<BR><BR>    m_pIOleObject-&gt;SetClientSite(m_pImpIOleClientSite);<BR>    m_pIOleObject-&gt;Advise(m_pImpIAdviseSink, &amp;dw);<BR><BR>    OleSetContainedObject(m_pIOleObject, TRUE);<BR><BR>    pDoc=(PCDocument)SendMessage(GetParent(m_hWnd), DOCM_PDOCUMENT<BR>        , 0, 0L);<BR><BR>    if (NULL!=pDoc)<BR>        pDoc-&gt;FilenameGet(szFile, CCHPATHMAX);<BR>    else<BR>        szFile[0]=0;<BR><BR>    NotifyOfRename(szFile, NULL);<BR><BR>    if (DVASPECT_ICON &amp; m_fe.dwAspect)<BR>        {<BR>        DWORD           dw=DVASPECT_CONTENT;<BR>        IAdviseSink    *pSink;<BR><BR>        pSink=(NULL==dwData) ? NULL : m_pImpIAdviseSink;<BR><BR>        INOLE_SwitchDisplayAspect(m_pIOleObject, &amp;dw<BR>            , DVASPECT_ICON, (HGLOBAL)(UINT)dwData, FALSE<BR>            , (NULL!=dwData), pSink, NULL);<BR>        }<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>Initialization consists of the following steps:</P>
<P>Remember the type of the object (static, embedded, linked, and so on).</P>
<P>Establish a view change notification by calling <I>IViewObject::SetAdvise</I>, passing your <I>IAdviseSink </I>pointer and the aspect of interest. By doing this, you'll receive notifications for view changes in whatever you have displayed.</P>
<P>Pass your <I>IOleClientSite</I> pointer to the object by calling <I>IOleObject::SetClientSite</I>. You can also pass the pointer as an argument to <I>OleCreate</I>* functions, but you also need to call <I>SetClientSite</I> when loading an object with <I>OleLoad</I>, and <I>OleLoad</I> does not take such an argument. So to keep it all central (as well as explicit), the call is made here.</P>
<P>Pass your <I>IAdviseSink </I>pointer to <I>IOleObject::Advise</I> to receive other notifications. This is necessary for proper operation of the handler.</P>
<P>Call <I>OleSetContainedObject</I> to mark the object as stored in a container. This is generally to facilitate linking to embeddings that we'll support in Chapter 21, but calling it now does no harm. This function is really just a wrapper for <I>IRunnableObject::SetContainedObject.</I></P>
<P>Provide the object with strings for its user interface by sending your application and document names to <I>IOleObject::SetHostNames</I>. Patron does this through <I>CTenant::NotifyOfRename</I>, which passes "Patron" as the application name and the filename of the document or "Untitled" as the document name (no path). </P>
<P>Handle iconic displays, which we'll look at later in this chapter.</P>
<P>In addition to these steps, Patron holds on to the object's <I>IOleObject</I> and <I>IViewObject2</I> pointers simply because we'll use them often and would like to avoid excess <I>QueryInterface</I> calls.</P>
<P>At this point, Patron has created and initialized an object. When we get back into <I>CPage::TenantCreate</I>, Patron will activate the object, which runs the server and displays the new object in its user interface. As changes occur to that object, they'll be reflected in the container when someone next calls <I>IViewObject2::Draw</I>,<I> </I>as happens in <I>CTenant::Draw</I>. Keep in mind that <I>CTenant::Draw </I>remembers whether the object is open, so it draws the site shading when necessary.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>Resizing Objects: IOleObject::SetExtent and IOleObject::GetExtent</H4><P>While managing objects, your container might resize the site in which the object lives, as Patron does. In this situation, you should call <I>IOleObject::SetExtent</I> to let it know the exact size of its display. If the object is marked with OLEMISC_RECOMPOSEONRESIZE, you must also call <I>OleRun </I>before calling <I>IOleObject::SetExtent</I>. You then call <I>IOleObject::Update </I>and <I>IOleObject::Close </I>to bring the object back to the running state if it wasn't originally running. This sequence, which you can see in <I>CTenant::SizeSet</I>,<I> </I>allows even objects in local servers to redraw themselves for new scaling as best they can. In-process objects receive this call directly, so they are automatically optimized. In some cases, a container might not want to control an object's size, letting it be whatever size it wants. In this case, <I>IOleObject::GetExtent</I> asks the object how large it would like to be. Patron calls <I>GetExtent</I> after creating a new object to set the initial size of the site, but thereafter it will always tell the object the new extents when the site is resized by calling <I>SetExtent</I>.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>6 Note again that a server must implement basic file moniker binding support for <I>OleCreateFromFile</I> to create something other than a package. Cosmo, for example, doesn't have this capability until Chapter 21.</P></TD></TR><TR><TD VALIGN="TOP"><P>7 When I create an object, I disable Patron's Printer Setup command. This has nothing to do with OLE and is here only because I'm lazy and didn't want to write code to reposition every object on a page after changing the paper size. In Patron, you can change the printer setup until you put something on a page, and then you're locked into that configuration.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
