<HTML><HEAD><TITLE>Support Binding for Linking to Embeddings</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Support Binding for Linking to Embeddings</H3><P>Because we are familiar with class factories, <I>IPersistFile</I>,<I> </I>and <I>IOleItemContainer</I> already, we don't need to examine all of Patron's code related to these matters. Instead, we'll just take a peek at those parts that are unique to a container.</P>
<P>The first of these is that the Patron's page implementation of <I>IOleItemContainer::GetObject </I>returns not a pointer to the tenant named by the item in question but an interface pointer for the embedded object in that tenant. The following code is taken from <I>CImpIOleItemContainer::GetObject </I>in IOLECONT.CPP:</P>
<P><BR></P>
<pre><code>if (TenantFromName(pszItem, &amp;pTenant))<BR>    {<BR>    pTenant-&gt;ObjectGet(&amp;pObj);<BR><BR>    /*<BR>     * If we're asked for immediate or moderate, work only<BR>     * if object is already running.<BR>     */<BR>    hr=IsRunning(pszItem);  //This is the function below.<BR><BR>    if ((BINDSPEED_IMMEDIATE==dwSpeed<BR>        œœ BINDSPEED_MODERATE==dwSpeed) &amp;&amp; NOERROR!=hr)<BR>        hr=ResultFromScode(MK_E_EXCEEDEDDEADLINE);<BR>    else<BR>        {<BR>        //IMPORTANT:  Be sure that this object is running first.<BR>        OleRun(pObj);<BR>        hr=pObj-&gt;QueryInterface(riid, ppv);<BR>        }<BR><BR>    pObj-&gt;Release();<BR>    }<BR>else<BR>    hr=ResultFromScode(MK_E_NOOBJECT);</code></pre>
<P>You can see that Patron first checks whether the embedded object is already running when BINDSPEED_IMMEDIATE and BINDSPEED_MODERATE are specified in the bind context. If not, we return MK_E_EXCEEDEDDEADLINE. Otherwise, if the object is already running or if we have as much time as we want, we run the object and query for whatever interface the external container linking to this embedding has asked for. The call to <I>OleRun </I>(which doesn't affect an already running object) is vital, especially for objects from in-process servers. This call ensures that the object will be completely registered in the running object table and that any necessary remoting stubs and proxies will be created for it when we return an interface pointer to the remote container.</P>
<P>It is also important for a container to implement <I>IOleItemContainer::LockContainer</I>, which Patron does in the same manner as <I>IClassFactory::LockServer</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleItemContainer::LockContainer(BOOL fLock)<BR>    {<BR>    if (fLock)<BR>        g_cLock++;<BR>    else<BR>        {<BR>        g_cLock--;<BR>        g_cObj++;<BR>        ObjectDestroyed();<BR>        }<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>When an embedded object is activated as a link through our container, it will call <I>LockContainer(TRUE)</I> to ensure that the container—and thus, the embedded object itself—remains in memory as long as the other linking container requires it. When that linking container has finished with the object, it will release that object's interface pointers. The object then has to tell the embedding container (which is Patron here) that it no longer needs to stay in memory if all it's doing is servicing the link to the embedding. This is the same behavior that we implemented in a simple embedding server in Chapter 18: when the user closes the embedded object, the server terminates itself. Here Patron is acting as a server in the same manner, only for some other server's embedded objects. So when the server closes itself, it will call <I>LockC</I><I>ontainer(FALSE) </I>to tell the container that it too can terminate. Patron increments its global object count and then fakes an object destruction by calling <I>ObjectDestroyed </I>(in PATRON.CPP), which checks for the necessary shutdown conditions as usual:</P>
<P><BR></P>
<pre><code>void ObjectDestroyed(void)<BR>    {<BR>    g_cObj--;<BR><BR>    //No more objects, no locks, no user control; shut down application.<BR>    if (0==g_cObj &amp;&amp; 0==g_cLock &amp;&amp; IsWindow(g_hWnd) &amp;&amp; !g_fUser)<BR>        PostMessage(g_hWnd, WM_CLOSE, 0, 0L);<BR><BR>    return;<BR>    }</code></pre></font></body></HTML>
