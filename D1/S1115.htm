<HTML><HEAD><TITLE>Aggregation: Inner Object (ANIMAL.CPP)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Aggregation: Inner Object (ANIMAL.CPP)</H3><P>We can now look at those parts of the Animal object that specifically concern aggregation: creation and <I>IUnknown </I>implementation. Even if you were using multiple inheritance as an implementation technique, you must still have a separate implementation of <I>IUnknown </I>functions. For Animal, we'll have its object class <I>CAnimal</I> inherit only from <I>IUnknown</I>, the implementation of which controls the object as a whole. Animal then manages an interface implementation class, <I>CImpIAnimal</I>, for the <I>IAnimal </I>interface. Notice that you could also have <I>CAnimal </I>inherit from <I>IAnimal </I>and make a <I>CImpIUnknown </I>if you wanted. This would work great if you were using multiple inheritance for multiple interfaces on <I>CAnimal</I>. Either way you have two classes: one that delegates its <I>IUnknown </I>calls and one that controls the object as a whole. In the sample, <I>CAnimal </I>implements <I>IUnknown</I>, and <I>CImpIAnimal</I><I>_</I><I>A </I>implements <I>IAnimal</I>. Both classes have a pointer, <I>m</I><I>_</I><I>pUnkOuter</I>, with which to store the outer unknown.</P>
<P>This arrangement allows you to play a rather elegant trick on any delegating <I>IUnknown </I>functions. In the Object1 and Object2 samples described earlier, the interface implementations held a backpointer to the main object for the purpose of both <I>IUnknown </I>delegation and access to any object members as necessary. (The samples didn't show this, but that's what backpointers are for.) When creating an aggregatable object, you can separate these two roles of the backpointer and instead pass each interface implementation a backpointer and some <I>IUnknown </I>pointer to which that interface must delegate all of its calls. The trick is this: if the object is not being used in aggregation, the object passes its own <I>IUnknown </I>to the interface implementations. In aggregation, the object instead passes the outer unknown it receives at creation time. As a result, the interface implementations are oblivious to aggregation concerns: they blindly delegate to someone else's <I>IUnknown</I>, which can be easily switched as needed.</P>
<P>We can now see how the Animal object uses the outer unknown passed to its creation function. If the pointer is NULL, the aggregation is not happening, and it passes its own <I>IUnknown </I>to its interface implementation and allows the caller to request any interface pointer. If the pointer is non-NULL, it passes its <I>IUnknown</I> on to the interface and checks to be sure that the caller is asking for Animal's <I>IUnknown </I>in return:</P>
<P><BR></P>
<pre><code>HRESULT CreateAnimal(IUnknown *pUnkOuter, REFIID riid, void **ppv)<BR>    {<BR>    CAnimal    *pObj;<BR><BR>    if (NULL!=pUnkOuter &amp;&amp; riid!=IID_IUnknown)<BR>        return ResultFromScode(CLASS_E_NOAGGREGATION);<BR><BR>    pObj=new CAnimal(pUnkOuter);<BR><BR>    if (NULL==pObj)<BR>        return FALSE;<BR><BR>    if (!pObj-&gt;Init())<BR>        return FALSE;<BR><BR>    return pObj-&gt;QueryInterface(riid, (PPVOID)ppv);<BR>    }<BR><BR><BR>BOOL CAnimal::Init(void)<BR>    {<BR>    IUnknown   *pUnkOuter=m_pUnkOuter;<BR><BR>    //Set up the right unknown for delegation.<BR>    if (NULL==pUnkOuter)<BR>        pUnkOuter=this;<BR><BR>    m_pImpIAnimal=new CImpIAnimal_A(this, pUnkOuter);<BR><BR>    if (NULL==m_pImpIAnimal)<BR>        return FALSE;<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>We can also see how <I>CImpIAnimal </I>simply stores whatever unknown it is given (no <I>AddRef </I>because the interface is always nested) so that it can delegate its <I>IUnknown </I>calls appropriately:</P>
<P><BR></P>
<pre><code>CImpIAnimal_A::CImpIAnimal_A(PCAnimal pObj, IUnknown *pUnkOuter)<BR>    {<BR>    m_cRef=0;<BR>    m_pObj=pObj;<BR>    m_pUnkOuter=pUnkOuter;  //No AddRef; we're nested.<BR>    return;<BR>    }</code></pre>
<P>Supporting aggregation is not a tremendous amount of work, for both outer and inner objects, but it must be consciously supported. Remember that if the Animal object itself created additional objects, it would pass the <I>pUnkOuter </I>argument it receives on creation down to the creation functions it calls, so KoalaA's pointer is propagated through the entire aggregation.</P></font></body></HTML>
