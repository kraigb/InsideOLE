<HTML><HEAD><TITLE>Up Close with the IMoniker Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Up Close with the <I>IMoniker</I> Interface</H2><P>In our discussion of OLE's naming and binding architecture, we've seen some of the member functions of <I>IMoniker </I>and the parts of the architecture that use those members. We're now in a position to look at the entirety of this rather large interface, which, again, is derived from <I>IPersistStream</I>:7</P>
<P><BR></P>
<pre><code>interface IMoniker : IPersistStream<BR>    {<BR>    HRESULT BindToObject(IBindContext *pbc, IMoniker *pmkToLeft<BR>        , REFIID riid, VOID **ppvResult);<BR>    HRESULT BindToStorage(IBindContext *pbc, IMoniker pmkToLeft<BR>        , REFIID riid, void **ppvObj);<BR>    HRESULT Reduce (IBindContext *pbc, DWORD dwReduceHowFar<BR>        , IMoniker **ppmkToLeft, IMoniker **ppmkReduced);<BR>    HRESULT ComposeWith(IMoniker **pmkRight, BOOL fOnlyIfNotGeneric<BR>        , IMoniker **ppmkComposite);<BR>    HRESULT Enum(BOOL fForward, IEnumMoniker **ppEnum);<BR>    HRESULT IsEqual(IMoniker *pmkOtherMoniker);<BR>    HRESULT Hash(DWORD *pdwHash);<BR>    HRESULT IsRunning(IBindContext *pbc, IMoniker *pmkToLeft<BR>        , IMoniker *pmkNewlyRunning);<BR>    HRESULT GetTimeOfLastChange(IBindContext *pbc, IMoniker *pmkToLeft<BR>        , FILETIME *pFileTime);
    HRESULT Inverse(IMoniker **ppmk);<BR>    HRESULT CommonPrefixWith(IMoniker *pmkOther, IMoniker **ppmkPrefix);<BR>    HRESULT RelativePathTo(IMoniker *pmkOther, IMoniker **ppmkRelPath);<BR>    HRESULT GetDisplayName(IBindContext *pbc, IMoniker *pmkToLeft<BR>        , LPOLESTR *ppszDisplayName);<BR>    HRESULT ParseDisplayName(IBindContext *pbc, IMoniker *pmkToLeft<BR>        , LPOLESTR pszDisplayName, ULONG *pchEaten, IMoniker **ppmkOut);<BR>    HRESULT IsSystemMoniker(DWORD pdwMksys);<BR>    };</code></pre>
<P>Holy cow! <I>IMoniker </I>alone has 15 specific members and as many as 23 members if you count all the base interfaces. This makes <I>IMoniker </I>one of the largest interfaces in all of OLE. Fortunately, we can group the specific <I>IMoniker </I>members so that looking at them in detail isn't such a drag.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="84pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Group</B></P></TD><TD VALIGN="TOP"><P><B>Related Members</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Binding</P></TD><TD VALIGN="TOP"><P><I>BindToObject</I>, <I>BindToStorage</I></P></TD></TR><TR><TD VALIGN="TOP"><P>Composite</P></TD><TD VALIGN="TOP"><P><I>Reduce</I>, <I>ComposeWith</I>, <I>Inverse</I>, <I>Enum</I>, <I>CommonPrefixWith</I>, <I>RelativePathTo</I>, <I>IsSystemMoniker</I></P></TD></TR><TR><TD VALIGN="TOP"><P>Table</P></TD><TD VALIGN="TOP"><P><I>IsEqual</I>, <I>Hash</I>, <I>IsRunning</I>, <I>GetTimeOfLastChange</I></P></TD></TR><TR><TD VALIGN="TOP"><P>Display Name</P></TD><TD VALIGN="TOP"><P><I>GetDisplayName</I>, <I>ParseDisplayName</I></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>We've already explored the members of the Binding group except to note that not all named objects have storage, so the function <I>BindToStorage </I>can easily fail with MK_E_NOSTORAGE. That said, the following sections look in more detail at the functions in the Table, Composite, and Display Name groups. Do note that understanding <I>IMoniker</I> is generally necessary only if you are developing custom monikers and sophisticated clients. If this is not what you plan to be doing, feel free to skip the rest of this detailed section.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>7 The OLE architects admit that a moniker might benefit from a more flexible choice of per-sistence model, so they have at times regretted using <I>IPersistStream </I>as a base interface for <I>IMoniker</I>, chaining monikers to stream persistence. At the time they were designed, interfaces and monikers were so scary that trying to explain a multiple-interface component as complicated as a moniker was simply not acceptable. At that time, it was easier to understand objects with single interfaces, so that's what a moniker came out to be. Of course, in hindsight and with a better understanding of interfaces, this is not an optimal design.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
