<HTML><HEAD><TITLE>IPersistFile</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IPersistFile</I></H3><P>Another simple persistence model for an object is for it to read and write its information from a separate file, be it a traditional file or a compound file. Components that support linking through a file moniker (as many do when supporting linked objects with OLE Documents) will implement this interface. Through it a client can ask a component to load or save a file that might contain other instances of object data of interest to that client. As we'll see in practice in Chapter 9, when we deal with file moniker binding, the <I>IPersistFile </I>interface describes load and save semantics for a separate file, illustrated in the following:</P>
<P><BR></P>
<pre><code>interface IPersistFile : IPersist<BR>    {<BR>    //IUnknown members and GetClassID from IPersist<BR>    HRESULT IsDirty(void);<BR>    HRESULT Load(LPCOLESTR pszFile, DWORD dwMode);<BR>    HRESULT Save(LPCOLESTR pszFile, BOOL fRemember);<BR>    HRESULT SaveCompleted(LPCOLESTR pszFile);<BR>    HRESULT GetCurFile(LPCOLESTR *ppszFile);<BR>    };</code></pre>
<P>These functions behave as follows:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Member<BR>Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>IsDirty</P></TD><TD VALIGN="TOP"><P>Indicates whether the object considers itself dirty. If the object is dirty, the client should call <I>Save</I> before releasing the object, as with <I>IPersistStream[Init]</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>Load</P></TD><TD VALIGN="TOP"><P>Instructs the object to load its persistent data from the file with the given filename, using the given access flags. The object is allowed to keep this file open, and if the file is a compound file, the object can open and hold pointers to any storage and stream elements for incremental access.</P></TD></TR><TR><TD VALIGN="TOP"><P>Save</P></TD><TD VALIGN="TOP"><P>Instructs the object to save its persistent data in the file of the given name. If <I>pszFile</I> is NULL, this works like a File Save operation: the object saves data into the file opened in <I>Load</I>. Otherwise, the call is equivalent to Save As or Save Copy As, where the <I>fRemember</I> flag distinguishes the behavior: TRUE saves the file under a new name, which becomes the current file for the object; FALSE saves a copy but doesn't change the current file. For any operation other than the Save Copy As case, <I>Save</I> must clear the object's dirty flag (as returned from <I>IsDirty</I>) and release any open pointers or handles to the file. See also <I>SaveCompleted</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>SaveCompleted</P></TD><TD VALIGN="TOP"><P>Informs the object that the calling client has completed its overall save procedure and that the object can reopen files and storage or stream elements. The relationship of <I>Save</I> and <I>SaveCompleted</I> allows a client to manipulate the file itself between the two calls without having to worry about sharing violations that might arise because the object has kept the file open. If the <I>pszFile</I> argument is NULL, the object reopens its known file; if it is non-NULL, the object opens the named file as the current file.</P></TD></TR><TR><TD VALIGN="TOP"><P>GetCurFile</P></TD><TD VALIGN="TOP"><P>Returns a copy of the object's current absolute pathname, allocated with the task memory allocator (<I>CoTaskMemAlloc</I>). The caller becomes responsible for the memory.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>As mentioned earlier, <I>IPersistFile </I>can act as an initialization interface, with <I>Load </I>being the only member available for this purpose.</P>
<P>The relationship between <I>Save </I>and <I>SaveCompleted </I>deserves a little more clarification. After a persistent object is initialized through <I>IPersistFile::Load</I>, it is allowed to scribble into that file—that is, read and write incrementally as it sees fit. If the object wants to scribble, it can keep a file open and hold as many handles or pointers as it needs. When the object is told to save (in the current file or a new current file), it must write its current state and turn off this scribbling mode until <I>SaveCompleted </I>is called. Turning off scribbling means releasing any open handles or pointers that the object can reopen only during <I>SaveCompleted.</I> In this way, a client can avoid sharing violations or other access problems with that file, especially if the client needs to move that file or rename it. The <I>pszFile </I>argument to <I>SaveCompleted </I>is the way the client identifies the file that the object can reopen; a NULL means "current file," and a non-NULL name can identify the same file that has been moved to another location or a different file altogether.</P>
<P>Keep in mind that if the client calls <I>Save(pszFile</I>, <I>FALSE)</I>, it is simply making a new copy of the data in another file and will always call <I>SaveCompleted(NULL) </I>afterward. In this case, the object need not close the original file.</P></font></body></HTML>
