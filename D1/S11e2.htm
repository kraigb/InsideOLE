<HTML><HEAD><TITLE>Implementing a Data Object: DDataObj and EDataObj</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Implementing a Data Object: DDataObj and EDataObj</H2><P>This section explores the concepts of Uniform Data Transfer through code samples, looking at data objects (single objects in a component server) based on both a DLL and an EXE. (These samples are found in CHAP10\DDATAOBJ and CHAP10\EDATAOBJ.) The next section, "Implementing a Consumer: DataUser," looks at a sample (CHAP10\DATAUSER) that works in conjunction with the data objects here.</P>
<P>Both DDataObj and EDataObj servers share a common object implementation in the C++ class <I>CDataObject</I>, which has only the <I>IDataObject </I>interface. Its implementation is found in the files DATAOBJ.CPP (the object's core), IDATAOBJ.CPP (the <I>IDataObject </I>interface), and RENDER.CPP (specific code for rendering individual formats). This data object, which is independent of the DLL or EXE server structure (like the Koala objects of Chapter 5), uses the <I>CEnumFormatEtc </I>implementation mentioned earlier in this chapter for its handling of <I>IDataObject::EnumFormatEtc</I> and also uses OLE's data advise holder service.</P>
<P>The data object itself supports full-content renderings (DVASPECT_CONTENT) for the formats of CF_TEXT, CF_BITMAP, and CF_METAFILEPICT. The text is a certain number of characters, the bitmap is an image (see CHAP10\RES for the BMP files), and each metafile is a series of rectangles filled with various shades of blue. Both DDataObj and EDataObj actually support three CLSIDs corresponding to three sizes of data:</P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="108pt" VALIGN="TOP"><COL WIDTH="80pt" VALIGN="TOP"><COL WIDTH="78pt" VALIGN="TOP"><COL WIDTH="99pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>CLSID</B></P></TD><TD VALIGN="TOP"><P><B>Text<BR>(Characters)</B></P></TD><TD VALIGN="TOP"><P><B>Bitmap<BR>(<I>x * y</I>)</B></P></TD><TD VALIGN="TOP"><P><B>Metafile<BR>(<I>FillRect</I> Records)</B></P></TD></TR><TR><TD VALIGN="TOP"><P>CLSID_DataSmall</P></TD><TD VALIGN="TOP"><P>64</P></TD><TD VALIGN="TOP"><P>16 * 16</P></TD><TD VALIGN="TOP"><P>16</P></TD></TR><TR><TD VALIGN="TOP"><P>CLSID_DataMedium</P></TD><TD VALIGN="TOP"><P>1024</P></TD><TD VALIGN="TOP"><P>64 * 64</P></TD><TD VALIGN="TOP"><P>128</P></TD></TR><TR><TD VALIGN="TOP"><P>CLSID_DataLarge</P></TD><TD VALIGN="TOP"><P>16,384</P></TD><TD VALIGN="TOP"><P>256 * 256</P></TD><TD VALIGN="TOP"><P>1024</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>All three classes are handled with the same class factory, named <I>CDataObjectClassFactory</I>, which tells each data object it creates about which data set to render for the consumer. The servers described here are good examples of supporting multiple CLSIDs—DDataObj creates a different class factory instance for each CLSID, whereas EDataObj creates all three of them on startup, registering them separately.</P>
<P>The <I>CDataObject </I>implementation (DATAOBJ.CPP) has a number of features worth mentioning. First, only the get direction is supported. <I>SetData </I>always returns E_NOTIMPL, as does <I>GetDataHere</I>,<I> </I>because <I>CDataObject </I>doesn't support any variable-length formats:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDataObject::GetData(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM)<BR>    {<BR>    UINT            cf=pFE-&gt;cfFormat;<BR><BR>    //Check aspects we support.<BR>    if (!(DVASPECT_CONTENT &amp; pFE-&gt;dwAspect))<BR>        return ResultFromScode(DATA_E_FORMATETC);<BR><BR>    switch (cf)<BR>        {<BR>        case CF_METAFILEPICT:<BR>            if (!(TYMED_MFPICT &amp; pFE-&gt;tymed))<BR>                break;<BR><BR>            return m_pObj-&gt;RenderMetafilePict(pSTM);<BR><BR>        case CF_BITMAP:<BR>            if (!(TYMED_GDI &amp; pFE-&gt;tymed))<BR>                break;<BR><BR>            return m_pObj-&gt;RenderBitmap(pSTM);<BR><BR>        case CF_TEXT:<BR>            if (!(TYMED_HGLOBAL &amp; pFE-&gt;tymed))<BR>                break;<BR><BR>            return m_pObj-&gt;RenderText(pSTM);<BR><BR>        default:<BR>            break;<BR>        }<BR><BR>    return ResultFromScode(DATA_E_FORMATETC);<BR>    }<BR><BR>STDMETHODIMP CImpIDataObject::GetDataHere(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM)<BR>    {<BR>    return ResultFromScode(E_NOTIMPL);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIDataObject::SetData(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM, BOOL fRelease)<BR>    {<BR>    return ResultFromScode(DATA_E_FORMATETC);<BR>    }</code></pre>
<P>The <I>CDataObject </I>member functions <I>RenderText</I>, <I>RenderBitmap</I>, and <I>RenderMetafilePict </I>are found in RENDER.CPP. The first function allocates global memory and writes a stream of characters into it, the second loads a bitmap from the server's resources, and the third creates a metafile device context into which it makes a number of <I>FillRect </I>calls. Again, the number of characters in the text, the dimensions of the bitmap, and the number of <I>FillRect </I>calls made into the metafile depend on the size of the data object as determined by the CLSID that was used to create it in the first place (a DOSIZE_* value as defined in DATAOBJ.H). The large metafile, for example, looks much like the shaded blue background you see in Microsoft's standard setup program; each rectangle is only a few pixels high, and each rectangle's color differs only slightly from the previous one. The small metafile, on the other hand, has only four rectangles of very different shades.</P>
<P>It is very important for <I>GetData</I> to fill the entire STGMEDIUM structure. It's easy to forget to fill the <I>tymed</I> field and to set the <I>pUnkForRelease</I> field to NULL when necessary. If you forget to set <I>tymed</I>,<I> </I>OLE will not marshal the data rendering between processes correctly—it has to know the exact nature of that data to copy it correctly. If you place an invalid pointer in <I>pUnkForRelease</I>, OLE can cause a fault inside <I>ReleaseStgMedium</I>, especially with an in-process data object.</P>
<P>By definition, <I>GetDataHere</I> tries to render data into a caller-allocated storage medium but does not attempt to reallocate space itself. Generally the only storage mediums you need to support in this function are TYMED_ISTORAGE, TYMED_ISTREAM, and TYMED_FILE. If you don't support these mediums, you don't need to support this function; if you do, return STG_E_MEDIUMFULL if writing to such storage fails.</P>
<P>The implementation of <I>QueryGetData </I>in the samples responds only to CF_TEXT, CF_BITMAP, and CF_METAFILEPICT, as you might expect, and <I>GetCanonicalFormatEtc </I>always returns DATA_S_SAMEFORMATETC, indicating that all renderings are identical for each format:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDataObject::QueryGetData(LPFORMATETC pFE)<BR>    {<BR>    UINT            cf=pFE-&gt;cfFormat;<BR>    BOOL            fRet=FALSE;<BR><BR>    //Check aspects we support.<BR>    if (!(DVASPECT_CONTENT &amp; pFE-&gt;dwAspect))<BR>        return ResultFromScode(DATA_E_FORMATETC);<BR><BR>    switch (cf)<BR>        {<BR>        case CF_METAFILEPICT:<BR>            fRet=(BOOL)(pFE-&gt;tymed &amp; TYMED_MFPICT);<BR>            break;<BR><BR>        case CF_BITMAP:<BR>            fRet=(BOOL)(pFE-&gt;tymed &amp; TYMED_GDI);<BR>            break;<BR><BR>        case CF_TEXT:<BR>            fRet=(BOOL)(pFE-&gt;tymed &amp; TYMED_HGLOBAL);<BR>            break;<BR><BR>        default:<BR>            fRet=FALSE;<BR>            break;<BR>        }<BR><BR>    return fRet ? NOERROR : ResultFromScode(S_FALSE);<BR>    }<BR><BR>STDMETHODIMP CImpIDataObject::GetCanonicalFormatEtc<BR>    (LPFORMATETC pFEIn, LPFORMATETC pFEOut)<BR>    {<BR>    if (NULL==pFEOut)<BR>        return ResultFromScode(E_INVALIDARG);<BR><BR>    pFEOut-&gt;ptd=NULL;<BR>    return ResultFromScode(DATA_S_SAMEFORMATETC);<BR>    }</code></pre>
<P>For the purposes of <I>EnumFormatEtc</I>, <I>CDataObject </I>keeps its supported formats ordered in the array <I>m</I><I>_</I><I>rgfeGet</I>, which is initialized in the object's constructor. This array is passed to the <I>CEnumFormatEtc </I>constructor from within <I>EnumFormatEtc</I>. (We could, of course, achieve the same end with registry entries.)</P>
<P><BR></P>
<pre><code>CDataObject::CDataObject(LPUNKNOWN pUnkOuter<BR>    , PFNDESTROYED pfnDestroy, UINT iSize)<BR>    {<BR>    UINT        i;<BR><BR>    [Other initialization omitted]<BR>    m_cfeGet=CFORMATETCGET;<BR><BR>    SETDefFormatEtc(m_rgfeGet[0], CF_METAFILEPICT, TYMED_MFPICT);<BR>    SETDefFormatEtc(m_rgfeGet[1], CF_BITMAP, TYMED_GDI);<BR>    SETDefFormatEtc(m_rgfeGet[2], CF_TEXT, TYMED_HGLOBAL);<BR><BR>    [Other code omitted]<BR>    }<BR><BR>STDMETHODIMP CImpIDataObject::EnumFormatEtc(DWORD dwDir<BR>    , LPENUMFORMATETC *ppEnum)<BR>    {<BR>    switch (dwDir)<BR>        {<BR>        case DATADIR_GET:<BR>            *ppEnum=new CEnumFormatEtc(m_pObj-&gt;m_cfeGet<BR>                , m_pObj-&gt;m_rgfeGet);<BR>            break;<BR><BR>        case DATADIR_SET:<BR>            *ppEnum=NULL;<BR>            break;<BR><BR>        default:<BR>            *ppEnum=NULL;<BR>            break;<BR>        }<BR><BR>    if (NULL==*ppEnum)<BR>        return ResultFromScode(E_FAIL);<BR>    else<BR>        (*ppEnum)-&gt;AddRef();<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>You can see how this implementation supports only the get direction through <I>EnumFormatEtc</I>, failing requests for the set direction. In addition, it uses the <I>CEnumFormatEtc </I>class found in IENUMFE.CPP for the enumerator implementation.</P>
<P>The object then uses <I>CreateDataAdviseHolder </I>and the <I>IDataAdviseHolder </I>interface to implement the members of <I>IDataObject </I>related to notification, creating the advise holder once inside <I>DAdvise </I>and releasing it in the object's destructor:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDataObject::DAdvise(LPFORMATETC pFE, DWORD dwFlags<BR>    , LPADVISESINK pIAdviseSink, LPDWORD pdwConn)<BR>    {<BR>    HRESULT         hr;<BR><BR>    if (NULL==m_pObj-&gt;m_pIDataAdviseHolder)<BR>        {<BR>        hr=CreateDataAdviseHolder(&amp;m_pObj-&gt;m_pIDataAdviseHolder);<BR><BR>        if (FAILED(hr))<BR>            return ResultFromScode(E_OUTOFMEMORY);<BR>        }<BR><BR>    hr=m_pObj-&gt;m_pIDataAdviseHolder-&gt;Advise((LPDATAOBJECT)this, pFE<BR>        , dwFlags, pIAdviseSink, pdwConn);<BR><BR>    return hr;<BR>    }<BR><BR>STDMETHODIMP CImpIDataObject::DUnadvise(DWORD dwConn)<BR>    {<BR>    HRESULT         hr;<BR><BR>    if (NULL==m_pObj-&gt;m_pIDataAdviseHolder)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    hr=m_pObj-&gt;m_pIDataAdviseHolder-&gt;Unadvise(dwConn);<BR><BR>    return hr;<BR>    }<BR><BR>STDMETHODIMP CImpIDataObject::EnumDAdvise(LPENUMSTATDATA *ppEnum)<BR>    {<BR>    HRESULT         hr;<BR><BR>    if (NULL==m_pObj-&gt;m_pIDataAdviseHolder)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    hr=m_pObj-&gt;m_pIDataAdviseHolder-&gt;EnumAdvise(ppEnum);<BR>    return hr;<BR>    }<BR><BR>CDataObject::~CDataObject(void)<BR>    {<BR>    [Other cleanup omitted]<BR><BR>    ReleaseInterface(m_pIDataAdviseHolder);<BR><BR>    [Other code omitted]<BR>    }</code></pre>
<P>Finally, each data object creates a small visible window, as shown in Figure 10-2, for the purposes of demonstrating data change notifications and comparable exchange rates for in-process and local data objects. Each window has only a caption bar (specifying the server as a DLL or an EXE) and an Iterations menu, but no system menu. (The window is destroyed only when the object is destroyed.) From the Iterations menu, you can tell the data object to fire off a small number to a large number of <I>IAdviseSink::O</I><I>nData-Change </I>calls to any connected consumer. The data object counts the time it takes to make all of the calls and reports that time along with an average time per call in a message box when the iterations are complete.</P>
<P>    <img src="f10dd02p.gif"></P>
<P><B>Figure 10-2.</B></P>
<P><B>A window created by an instance of <I>CDataObject</I> for the small data set.</B></P>
<P>All the notifications are sent through <I>IDataAdviseHolder::SendOnDataChange </I>inside <I>AdviseWndProc </I>in DATAOBJ.CPP:</P>
<P><BR></P>
<pre><code>LRESULT APIENTRY AdvisorWndProc(HWND hWnd, UINT iMsg<BR>    , WPARAM wParam, LPARAM lParam)<BR>    {<BR>    PCDataObject    pDO;<BR>    DWORD           i;<BR>    DWORD           iAdvise;<BR>    DWORD           dwTime;<BR>    DWORD           dwAvg;<BR>    TCHAR           szTime[128];<BR>    TCHAR           szTitle[80];<BR>    HCURSOR         hCur, hCurT;<BR><BR>    pDO=(PCDataObject)GetWindowLong(hWnd, 0);<BR><BR>    switch (iMsg)<BR>        {<BR>        case WM_NCCREATE:<BR>            pDO=(PCDataObject)(((LPCREATESTRUCT)lParam)<BR>                -&gt;lpCreateParams);<BR>            SetWindowLong(hWnd, 0, (LONG)pDO);<BR>            return (DefWindowProc(hWnd, iMsg, wParam, lParam));<BR><BR>        case WM_CLOSE:<BR>            //Forbid task manager to close us.<BR>            return 0L;<BR><BR>        case WM_COMMAND:<BR>            if (NULL==pDO-&gt;m_pIDataAdviseHolder)<BR>                break;<BR><BR>            //Send IAdviseSink::OnDataChange many times.<BR>            i=(DWORD)(LOWORD(wParam)-IDM_ADVISEITERATIONSMIN+1);<BR>            iAdvise=(i*i)*16;<BR><BR>            hCur=LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));<BR>            hCurT=SetCursor(hCur);<BR>            ShowCursor(TRUE);<BR><BR>            dwTime=GetTickCount();<BR><BR>            i=0;<BR>            while (TRUE)<BR>                {<BR>                [A PeekMeesage loop in the 16-bit EXE server only]<BR>                pDO-&gt;m_pIDataAdviseHolder-&gt;SendOnDataChange<BR>                    (pDO-&gt;m_pImpIDataObject, 0, ADVF_NODATA);<BR><BR>                if (++i &gt;= iAdvise)<BR>                    break;<BR>                }<BR><BR>            dwTime=GetTickCount()-dwTime;<BR>            dwAvg=dwTime/iAdvise;<BR><BR>            SetCursor(hCurT);<BR>            ShowCursor(FALSE);<BR><BR>            wsprintf(szTime<BR>                , TEXT("Total\t=%lu ms\n\rAverage\t=%lu ms")<BR>                , dwTime, dwAvg);<BR><BR>            GetWindowText(hWnd, szTitle, sizeof(szTitle));<BR>            MessageBox(hWnd, szTime, szTitle, MB_OK);<BR>            break;<BR><BR>        default:<BR>            return (DefWindowProc(hWnd, iMsg, wParam, lParam));<BR>        }<BR><BR>    return 0L;<BR>    }</code></pre>
<P><img src="16bit.gif"></P>
<P>These iterations give you the chance to test the relative performance of data change notifications between DLL and EXE servers. As you'd expect, the DLL rates are much faster because nothing exists between the object and the consumer with the in-process case. In this sample, <I>CDataObject </I>accepts only ADVF_NODATA advises, so we can determine the flat-out notification time independently and not have to include the time it actually takes to render the data, which would skew the results.</P></font></body></HTML>
