<HTML><HEAD><TITLE>Managing Servers and CoFreeUnusedLibraries</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Managing Servers and <I>CoFreeUnusedLibraries</I></H3><P>What you do with an object after you have obtained an interface pointer depends entirely on the object itself and is really what most of the chapters in the book are about. You must, in any case, be absolutely sure to call <I>R</I><I>elease</I> through that interface pointer when you have finished with the object. Otherwise, you doom the object to live in memory for all eternity—or until the universe collapses (power off or the jolly three-finger reset).</P>
<P>Releasing the object is not the only consideration when in-process modules (servers and handlers) are involved. Local servers, remember, will terminate themselves when they're no longer in use. DLLs, however, must wait for COM to call <I>DllCanUnloadNow </I>from within the <I>CoFreeUnusedLibraries </I>function. As a client, you are responsible for periodically calling this COM function because COM does not make the call itself. A good time to call the function is immediately after releasing what you consider to be the last interface pointer to an object. Another good choice is to call the function every minute or two during any idle-time processing your application might do.</P>
<P>Remember that a reference count on a class factory does not guarantee that the server will stay in memory and that you can use the class factory later. If you want to hold the class factory's pointer across function calls (especially across iterations through your message loop if you have one), you must call <I>IClassFactory::LockServer(TRUE)</I> when you save the pointer and <I>IClassFactory::LockServer(FALSE) </I>before calling its <I>Release</I>.</P>
<P>One additional function that a client might find useful in managing servers is <I>CoFreeAllLibraries</I>, a much more brutal version of <I>CoFreeUnusedLibraries </I>that forcibly dumps all DLLs out of memory without regard to their object counts or lock counts. This isn't a good function to call in the course of normal processing, but it exists so that a client can clean up its address space during an abnormal termination. <I>CoFreeAllLibraries </I>is called from within <I>CoUninitialize</I>, so clients generally don't need to call this function directly during shutdown.</P></font></body></HTML>
