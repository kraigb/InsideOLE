<HTML><HEAD><TITLE>UI Activation and Deactivation</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>UI Activation and Deactivation</H3><P>After we have the in-place–activation state handled, we can add the UI-active state. Cosmo handles the state through <I>CFigure::UIActivate </I>and <I>CFigure::UIDeactivate</I>,<I> </I>which are called from <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>UIACTIVATE) </I>and <I>IOleInPlaceObject::UIDeactivate</I>:</P>
<P><BR></P>
<pre><code>HRESULT CFigure::UIActivate(void)<BR>    {<BR>    if (NULL!=m_pIOleIPSite)<BR>        m_pIOleIPSite-&gt;OnUIActivate();<BR><BR>    SetFocus(m_pHW-&gt;Window());<BR><BR>    if (NULL!=m_pIOleIPFrame)<BR>        {<BR>        m_pIOleIPFrame-&gt;SetActiveObject(m_pImpIOleIPActiveObject<BR>            , PSZ(IDS_INPLACETITLE));<BR>        }<BR><BR>    if (NULL!=m_pIOleIPUIWindow)<BR>        {<BR>        m_pIOleIPUIWindow-&gt;SetActiveObject(m_pImpIOleIPActiveObject<BR>            , PSZ(IDS_INPLACETITLE));<BR>        }<BR><BR>    InPlaceToolsCreate();<BR>    InPlaceMenuCreate();<BR>    return NOERROR;<BR>    }<BR><BR>void CFigure::UIDeactivate(void)<BR>    {<BR>    InPlaceToolsDestroy();<BR>    InPlaceMenuDestroy();<BR><BR>    if (NULL!=m_pIOleIPFrame)<BR>        m_pIOleIPFrame-&gt;SetActiveObject(NULL, NULL);<BR><BR>    if (NULL!=m_pIOleIPUIWindow)<BR>        m_pIOleIPUIWindow-&gt;SetActiveObject(NULL, NULL);<BR><BR>    if (NULL!=m_pIOleIPSite)<BR>        m_pIOleIPSite-&gt;OnUIDeactivate(FALSE);<BR><BR>    return;<BR>    }</code></pre>
<P>The most critical parts of these functions are the calls to <I>IOleInPlaceSite::OnUIActivate</I> and <I>OnUIDeactivate</I>, which let the container know when to initialize or uninitialize its own UI-active state. The next step is to pass your <I>IOleInPlaceActiveObject </I>implementation to both <I>IOleInPlaceFrame::SetActiveObject</I> and <I>IOleInPlaceUIWindow::SetActiveObject </I>(if applicable)3 during UI activation, passing NULL pointers to deactivate. In addition, UI activation should include setting the focus to your in-place window so that you can receive keyboard accelerators. The call to <I>SetFocus</I> here gives the hatch window the focus, which in turn gives it to Cosmo's Polyline window.</P>
<H4><A NAME="sec0"></A>Assemble and Disassemble the Menu</H4><P>Cosmo encapsulates menu creation and destruction in <I>CFigure::InPlaceMenuCreate </I>and <I>CFigure::InPlaceMenuDestroy</I>.<I> </I>As described in Chapter 22, creation of the menu involves these steps:</P>
<P>Create a new menu with the Windows API function <I>CreateMenu</I>.</P>
<P>Call <I>IOleInPlaceFrame::InsertMenus</I> to have the container make its contribution, also passing it the OLEMENUGROUPWIDTHS array, in which the container stores the number of items in each of its groups.</P>
<P>Call the Windows API <I>InsertMenu</I> to add your own menu items to the shared menu in the appropriate places and to fill in the remainder of the OLEMENUGROUPWIDTHS array.</P>
<P>Call <I>OleCreateMenuDescriptor</I> with the menu handle and the OLEMENUGROUPWIDTHS array.</P>
<P>Call <I>IOleInPlaceFrame::SetMenu</I>, passing the menu handle, the menu descriptor from step 4, and the handle of the window to receive messages generated from your items on this menu, typically your frame window.</P>
<P>If you have an object that doesn't need a shared menu at all, which is the case for this chapter's version of Polyline, you need to call only <I>IOleInPlaceFrame::SetMenu(NULL, NULL, hWnd)</I>,<I> </I>in which <I>hWnd </I>is the object's window. This call tells the container to keep its own menu active.</P>
<P>Cosmo, however, does use a shared menu. It assembles the menu as shown in the following:</P>
<P><BR></P>
<pre><code>BOOL CFigure::InPlaceMenuCreate(void)<BR>    {<BR>    HMENU               hMenu, hMenuT;<BR>    UINT                uTemp=MF_BYPOSITION œ MF_POPUP;<BR>    UINT                i;<BR>    OLEMENUGROUPWIDTHS  mgw;<BR><BR>    for (i=0; i&lt;6; i++)<BR>        mgw.width[i]=0;<BR><BR>    //We already have pop-up menu handles in m_pFR-&gt;m_phMenu[].<BR><BR>    //Create new shared menu and let container do its thing.<BR>    hMenu=CreateMenu();<BR>    m_pIOleIPFrame-&gt;InsertMenus(hMenu, &amp;mgw);<BR><BR>    //Add our menus, remembering that container <BR>    //has already added its menus.<BR>    InsertMenu(hMenu, (WORD)mgw.width[0]<BR>       , uTemp, (UINT)m_pFR-&gt;m_phMenu[1], PSZ(IDS_MENUEDIT));<BR><BR>    //Add Open item to Edit menu.<BR>    AppendMenu(m_pFR-&gt;m_phMenu[1], MF_SEPARATOR, 0, NULL);<BR>    AppendMenu(m_pFR-&gt;m_phMenu[1], MF_STRING, IDM_EDITOPEN<BR>        , PSZ(IDS_MENUOPEN));<BR><BR>    InsertMenu(hMenu, (WORD)mgw.width[0]+1+(WORD)mgw.width[2]<BR>       , uTemp, (UINT)m_pFR-&gt;m_phMenu[2], PSZ(IDS_MENUCOLOR));<BR><BR>    InsertMenu(hMenu, (WORD)mgw.width[0]+1+(WORD)mgw.width[2]+1<BR>       , uTemp, (UINT)m_pFR-&gt;m_phMenu[3], PSZ(IDS_MENULINE));<BR><BR>    //Window menu position changes between MDI and SDI.<BR>   #ifdef MDI<BR>    hMenuT=m_pFR-&gt;m_phMenu[5];<BR>   #else<BR>    hMenuT=m_pFR-&gt;m_phMenu[4];<BR>   #endif<BR><BR>    InsertMenu(hMenu, (WORD)mgw.width[0]+1+(WORD)mgw.width[2]+2<BR>        +(WORD)mgw.width[4], uTemp, (UINT)hMenuT, PSZ(IDS_MENUHELP));<BR><BR>    //Tell OLE how many items in each group are ours.<BR>    mgw.width[1]=1;<BR>    mgw.width[3]=2;<BR>    mgw.width[5]=1;<BR><BR>    m_hMenuShared=hMenu;<BR>    m_hOLEMenu=OleCreateMenuDescriptor(m_hMenuShared, &amp;mgw);<BR><BR>    m_pIOleIPFrame-&gt;SetMenu(m_hMenuShared, m_hOLEMenu, m_pFR-&gt;Window());<BR>    return TRUE;<BR>    }</code></pre>
<P>You can see how Cosmo uses the container's group widths in OLEMENUGROUPWIDTHS to position our own Edit, Object, and Window groups correctly. Also, we complete this array by filling elements 0, 2, and 4.</P>
<P>Cosmo takes advantage of the capability of Windows to have multiple menus share the same pop-up handles. During an in-place session, Cosmo puts the same Edit, Color, Line, and Help menus on the shared menus that it displays on its own menu bar, using the same pop-up handles that are stored in its <I>CCosmoFrame::m</I><I>_</I><I>phMenu</I> array. This saves us the trouble of re-creating each pop-up menu all over again, but it means that we have to be very careful when we disassemble the menu, as we'll see shortly.</P>
<P>Cosmo also makes a small addition to the Edit menu for in-place uses: an Open item, which causes the in-place–active object to deactivate and open in a full window. We'll see how to process this command later, but it is a nice addition for an object to provide.4</P>
<P>The object is responsible for maintaining the menu it creates here, so remember to save the handle with the object, as Cosmo does in <I>CFigure::m</I><I>_</I><I>hMenuShared</I>. The object must also save the menu descriptor, a variable of type HOLEMENU (such as <I>CFigure</I><I>::m</I><I>_</I><I>hOLEMenu</I>) that it gets back from <I>OleCreateMenuDescriptor</I> so that it can destroy the descriptor later. But, of course, we still have to send the descriptor to the container through <I>IOleInPlaceFrame::SetMenu</I>, along with the handle of the window to which you want menu messages sent. Generally, this window is your frame window because it's already set up to receive menu messages.</P>
<P>When we deactivate the object's user interface, we'll need to disassemble this shared menu. If you have no menu in the first place, the object (Polyline, for example) has nothing to do. Cosmo, however, performs the following steps to dismantle the menu created in the code above:</P>
<P>Calls <I>IOleInPlaceFrame::SetMenu</I> with NULLs.</P>
<P>Calls <I>OleDestroyMenuDescriptor</I> to free the menu descriptor.</P>
<P>Removes each of its menu items from the shared menu.</P>
<P>Calls <I>IOleInPlaceFrame::RemoveMenus</I> to remove the container menus.</P>
<P>Calls the Windows API function <I>DestroyMenu</I> to free the menu itself.</P>
<P>Here's the code to do it:</P>
<P><BR></P>
<pre><code>BOOL CFigure::InPlaceMenuDestroy(void)<BR>    {<BR>    int         cItems, i, j;<BR>    HMENU       hMenuT;<BR><BR>    //If we don't have shared menu, nothing to do.<BR>    if (NULL==m_hMenuShared)<BR>        return TRUE;<BR><BR>    //Stop container frame from using this menu.<BR>    m_pIOleIPFrame-&gt;SetMenu(NULL, NULL, NULL);<BR><BR>    //Clean up what we got from OleCreateMenuDescriptor.<BR>    OleDestroyMenuDescriptor(m_hOLEMenu);<BR>    m_hOLEMenu=NULL;<BR><BR>    cItems=GetMenuItemCount(m_hMenuShared);<BR><BR>    /*<BR>     * Walk backward down the menu. For each popup, see whether it <BR>     * matches any other popup we know about, and if so, remove it <BR>     * from shared menu.<BR>     */<BR>    for (i=cItems; i&gt;=0; i--)<BR>        {<BR>        hMenuT=GetSubMenu(m_hMenuShared, i);<BR><BR>        for (j=0; j&lt;=CMENUS; j++)<BR>            {<BR>            /*<BR>             * If submenu matches any we have, remove it; don't <BR>             * delete. Because we're walking backward, this <BR>             * affects only positions of those menus after us, so <BR>             * GetSubMenu call above is not affected.<BR>             */<BR><BR>            if (hMenuT==m_pFR-&gt;m_phMenu[j])<BR>                RemoveMenu(m_hMenuShared, i, MF_BYPOSITION);<BR>            }<BR>        }<BR><BR>    //Remove Open item and separator from Edit menu.<BR>    RemoveMenu(m_pFR-&gt;m_phMenu[1], 6, MF_BYPOSITION);<BR>    RemoveMenu(m_pFR-&gt;m_phMenu[1], 5, MF_BYPOSITION);<BR><BR>    if (NULL!=m_pIOleIPFrame)<BR>        m_pIOleIPFrame-&gt;RemoveMenus(m_hMenuShared);<BR><BR>    DestroyMenu(m_hMenuShared);<BR>    m_hMenuShared=NULL;<BR>    return TRUE;<BR>    }</code></pre>
<P>The trick here is to <I>remove</I> each menu item that you added before. I emphasize this because you will generally be sharing menu handles between this menu and your normal server's menu, so destroying those pop-up items is not a good idea. Cosmo ensures that it removes all of its items by removing any popup it recognizes in the shared menu (that is, any handle that is also stored in <I>m</I><I>_</I><I>phMenu</I>). It also removes the extra Open item we added in the assembly phase. After we've called the <I>IOleInPlaceFrame::RemoveMenus</I> function, we can call <I>DestroyMenu</I> to free the resource. Then we're finished.</P>
<P>It's extremely important that you remove all your menu items properly before calling <I>DestroyMenu</I> because that function also destroys any popups on that menu as well. If you experience weird problems when assembling or disassembling your shared menu, comment out your call to <I>DestroyMenu</I> and see whether the problem still exists. If it does, you are not cleaning up your menu properly. If you missed it earlier, go back and read the sidebar "EXPERIENCE: Menu Destruction—Just Do It (Right)!" in Chapter 22 on page 1046 for a description of what happened when I didn't do it right. I had one major-league hair-puller with this one, and it all turned out to be a bug in my make file, of all things.</P>
<H4><A NAME="sec1"></A>Create and Destroy In-Place Tools</H4><P>To complete full UI activation, we now need to create any in-place tools we want, including toolbars or toolboxes on any side of the container's frame or document window. We can also create floating pop-up windows as needed. Again, be sure that none of these windows send unexpected messages to the container, which will be the parent window in many cases, and that any tools added to the frame or document windows use WS_CLIPSIBLINGS.</P>
<P>Cosmo demonstrates this part of UI activation by using a single toolbar. The toolbar is created in <I>CFigure::InPlaceToolsCreate</I>, which executes these steps:</P>
<P>Negotiate tool space with the container by calling the <I>RequestBorderSpace</I> function in <I>IOleInPlaceFrame</I> for frame-level tools and in <I>IOleInPlaceUIWindow</I> for document windows.</P>
<P>When the container accepts your requests, send those same numbers to the <I>SetBorderSpace</I> members of the appropriate interface.</P>
<P>Create your tools either as child windows of the container's frame or document window or as pop-up windows, and then make them visible. You can use the rectangle from the <I>GetBorder</I> function of the appropriate container interface to set the initial dimensions of the tools if necessary.</P>
<P>All units used here are device units (pixels) because we're dealing with windows whose dimensions are always in device units. Don't use HIMETRIC, which is used almost everywhere else in OLE. Anyway, here's Cosmo's implementation of its in-place tools:</P>
<P><BR></P>
<pre><code>BOOL CFigure::InPlaceToolsCreate(void)<BR>    {<BR>    BORDERWIDTHS    bw;<BR>    HWND            hWnd;<BR>    UINT            uState=GIZMO_NORMAL;<BR>    UINT            utCmd =GIZMOTYPE_BUTTONCOMMAND;<BR>    UINT            utEx  =GIZMOTYPE_BUTTONATTRIBUTEEX;<BR>    UINT            i;<BR>    HBITMAP         hBmp;<BR>    RECT            rc;<BR><BR>    //We don't need anything on document, so send zeros.<BR>    SetRectEmpty((LPRECT)&amp;bw);<BR><BR>    if (NULL!=m_pIOleIPUIWindow)<BR>        m_pIOleIPUIWindow-&gt;SetBorderSpace(&amp;bw);<BR><BR>    if (NULL==m_pIOleIPFrame)<BR>        return FALSE;<BR><BR>    //Reserve frame space.<BR>    if (!InPlaceToolsRenegotiate())<BR>        {<BR>        //If container doesn't allow us any, don't ask for any.<BR>        m_pIOleIPFrame-&gt;SetBorderSpace(&amp;bw);<BR>        return FALSE;<BR>        }<BR><BR>    //Create toolbar window.<BR>    m_pIOleIPFrame-&gt;GetWindow(&amp;hWnd);<BR><BR>    //If we already have a toolbar, just show it again.<BR>    if (NULL!=m_pTB)<BR>        {<BR>        ShowWindow(m_pTB-&gt;Window(), SW_SHOW);<BR>        return TRUE;<BR>        }<BR><BR>    m_pTB=new CToolBar(m_pFR-&gt;m_hInst);<BR><BR>    if (NULL==m_pTB)<BR>        {<BR>        SetRectEmpty((LPRECT)&amp;bw);<BR>        m_pIOleIPFrame-&gt;SetBorderSpace(&amp;bw);<BR>        return FALSE;<BR>        }<BR><BR>    m_pTB-&gt;Init(hWnd, ID_GIZMOBAR, m_cyBar);<BR>    g_pInPlaceTB=m_pTB;<BR><BR>    //Ensure that tools are initially invisible.<BR>    ShowWindow(m_pTB-&gt;Window(), SW_HIDE);<BR><BR>    //Tell toolbar whom to send messages to.<BR>    m_pTB-&gt;HwndAssociateSet(m_pFR-&gt;m_hWnd);<BR><BR>    [Omitted code to create all individual tools]<BR><BR>    //Make tools visible.<BR>    ShowWindow(m_pTB-&gt;Window(), SW_SHOW);<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>Because we don't want any document tools, we tell this to the container by calling <I>IOleInPlaceUIWindow::SetBorderSpace </I>with a BORDERWIDTHS structure full of zeros. (Because the structure is the same as a RECT, we can use <I>SetRectEmpty </I>here.) This call means, "We want no space and no tools showing." If we call <I>SetBorderSpace</I> with a NULL pointer, however, that tells the container, "We don't want any space, and you can leave your tools showing." An object that does nothing for the UI-active state should call <I>SetBorderSpace</I> with NULLs for the container's document and frame window as necessary.</P>
<P>Cosmo wants a toolbar in the frame window, so it negotiates for space in <I>CFigure::InPlaceToolsRenegotiate. </I>This separate function exists because we'll need it later in <I>IOleIn</I><I>PlaceActiveObject::ResizeBorder</I>:</P>
<P><BR></P>
<pre><code>BOOL CFigure::InPlaceToolsRenegotiate(void)<BR>    {<BR>    HRESULT         hr;<BR>    BORDERWIDTHS    bw;<BR><BR>    SetRect((LPRECT)&amp;bw, 0, m_pFR-&gt;m_cyBar, 0, 0);<BR><BR>    hr=m_pIOleIPFrame-&gt;RequestBorderSpace(&amp;bw);<BR><BR>    if (NOERROR!=hr)<BR>        return FALSE;<BR><BR>    //Safety net: RequestBorderSpace can modify values in bw.<BR>    SetRect((LPRECT)&amp;bw, 0, m_pFR-&gt;m_cyBar, 0, 0);<BR><BR>    m_pIOleIPFrame-&gt;SetBorderSpace(&amp;bw);<BR>    return TRUE;<BR>    }</code></pre>
<P>If this function returns FALSE, the container will not allow us space for our toolbar. In this case, Cosmo merely lives without the tools because everything is still available on the shared menu. Some other objects might not want to activate in place in such a situation and should deactivate everything done to this point (including the shared menu) and open as a normal embedded object. Still other objects can elect to place those same tools in a floating pop-up window, which the container cannot restrict.</P>
<P>If the container does allow us space, we create our toolbar using the window from <I>IOleInPlaceFrame::GetWindow</I> as the parent and the dimensions from <I>IOleInPlaceFrame::GetBorder</I>.5 Cosmo's toolbar stretches across the container's frame window, so we use the horizontal extent from <I>GetBorder </I>for this dimension with the vertical extent that we negotiated for previously. In general, tools on the top or bottom of a window should be created with the horizontal extent from <I>GetBorder </I>and the negotiated height. Tools on the side of the window should use their negotiated width and the vertical dimension from <I>GetBorder.</I></P>
<P>After executing this code, the toolbar should be visible in the container. To remove it, we need only to destroy the toolbar because the container will reinstate its own when we call <I>IOleInPlaceSite::OnUIDeactivate</I>. Cosmo's <I>CFigure::InPlaceToolsDestroy </I>is straightforward:</P>
<P><BR></P>
<pre><code>BOOL CFigure::InPlaceToolsDestroy(void)<BR>    {<BR>    //Nothing to do if we never created anything.<BR>    if (NULL==m_pTB)<BR>        return TRUE;<BR><BR>    if (NULL!=m_pTB)<BR>        {<BR>        delete m_pTB;<BR>        m_pTB=NULL;<BR>        g_pInPlaceTB=NULL;<BR>        }<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>It is perfectly reasonable to simply hide your tools at this point in case the object becomes UI active again, but remember that you must always negotiate for space whenever the object becomes UI active. You can't assume that the container will allow the same tool space for each activation.</P>
<P>If you compile and run your object at this point, you'll see the user interface created and destroyed as necessary. Pretty cool! Now resize the frame or document windows in which these tools appear. Ugly, huh? Your tools didn't resize with the container windows. We have to implement the <I>IOleInPlaceActiveObject</I> interface to handle this. But before we do this, let's finish up the last major modification—accelerator support.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>3 Cosmo includes a title string for itself to remain backward compatible with older containers that still use the string for changing the caption bar. All in-place–capable objects should do this.</P></TD></TR><TR><TD VALIGN="TOP"><P>4 If your application is an MDI multiple-use server, you should <I>not</I> modify a pop-up menu that is used from two top-level menus (that is, the shared menu and the server's normal menu) because you'll be modifying the menu anywhere it's used. Either abstain from such modifications or create a separate pop-up menu for the shared menu and make your modifications to it alone. Remember also that you need to save this menu handle so that you can enable or disable items in it while processing WM_INITMENUPOPUP.</P></TD></TR><TR><TD VALIGN="TOP"><P>5 Cosmo saves a copy of the in-place toolbar in <I>g</I><I>_</I><I>pInPlaceTB</I> in such a way that when the user selects a line style from the menu, the <I>CCosmoFrame::CheckLineSelection</I> function can activate the appropriate button on the in-place toolbar as it does on the normal toolbar. You will see extra code in COSMO.CPP to handle this.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
