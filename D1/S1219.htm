<HTML><HEAD><TITLE>Register and Revoke the Drop Target Object</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Register and Revoke the Drop Target Object</H3><P>The last step for making Cosmo a full target is to register the drop target object to associate it with the document window. Cosmo both creates and registers the object in <I>CCosmoDoc::Init</I>:</P>
<P><BR></P>
<pre><code>m_pDropTarget=new CDropTarget(this);<BR><BR>if (NULL!=m_pDropTarget)<BR>    {<BR>    m_pDropTarget-&gt;AddRef();<BR>    CoLockObjectExternal(m_pDropTarget, TRUE, FALSE);<BR>    RegisterDragDrop(m_hWnd, m_pDropTarget);<BR>    }</code></pre>
<P>The <I>hWnd</I> passed to <I>RegisterDragDrop</I> identifies the target window for the drop target object. If creation of the object fails or if registration fails, Cosmo does without drag and drop.</P>
<P>But what in tarnation is <I>CoLockObjectExternal</I> here for? <I>RegisterDragDrop </I>is another example of a weak registration function—OLE will create a stub that holds the <I>IDropTarget </I>pointer but does not call <I>AddRef </I>through it. Without <I>CoLockObjectExternal</I>, when <I>DoDragDrop </I>accesses the target pointer from the source's process, everything works fine until <I>DoDragDrop </I>releases the pointer. This destroys the proxy in the source process and also destroys the stub in the target's process. The next time you drag into the same target window, no stub is available, so <I>DoDragDrop</I> quits—it doesn't simply ignore the window; it fails with an error. As we learned in Chapter 6, <I>CoLockObjectExternal </I>will force a strong lock and keep a stub in memory, so Cosmo needs to call this function here. It is unfortunate that <I>RegisterDragDrop </I>doesn't do this itself.</P>
<P>Of course, the process must be reversed when the document isn't a target any longer. This means removing the strong lock, revoking the registration, and releasing the target object, which happens in the processing for the WM_DESTROY case in <I>CCosmoDoc::FMessageHook</I>:</P>
<P><BR></P>
<pre><code>if (NULL!=m_pDropTarget)<BR>    {<BR>    RevokeDragDrop(m_hWnd);<BR>    CoLockObjectExternal(m_pDropTarget, FALSE, TRUE);<BR>    ReleaseInterface(m_pDropTarget);<BR>    }</code></pre>
<P>Cosmo removes the strong lock on WM_DESTROY and not in the document destructor because by the time the destructor is called, the window is long gone and <I>RevokeDragDrop </I>cannot remove its property from that window.</P></font></body></HTML>
