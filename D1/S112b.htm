<HTML><HEAD><TITLE>The ITypeComp Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The <I>ITypeCom</I><I>p </I>Interface</H3><P>If you've ever looked into type information before reading this chapter, you're probably still confused to death about this <I>ITypeComp</I> interface—like, what it's for in the first place and what you're supposed to do with it.8 The name of the interface implies the type of client that might use it: "Comp" stands for "compiler." A compiler can use type information as a sort of header file or as an import library.</P>
<P>During the compilation process, compilers need to quickly access information about user-defined types, exported module functions, global variables and constants, and interfaces within <I>coclass</I> objects. The optimization, which works through <I>ITypeComp::BindType</I> and <I>ITypeComp::Bind</I> (the only two members besides those in <I>IUnknown</I>), allows the compiler to quickly locate this information without having to navigate through all the elements over and over, which would be tremendously slow. <I>Bind</I> is also what gets you the FUNCDESC or VARDESC structure for a variable, constant, or exported function.</P>
<P>Navigation through the entire library according to its structure makes perfect sense for a type information browser, for which the locations of the data in question are important. But for a compiler, location in the structure isn't of any concern—it's the data itself that's important. For example, if you wanted to locate an exported function named <I>arctan</I> in some modules that are described in a type library, you could call <I>ITypeLib::GetTypeComp</I> and then <I>ITypeComp::Bind</I>. This procedure is much easier and faster than calling <I>ITypeLib::FindName,</I> <I>ITypeLib::GetTypeInfo,</I> <I>ITypeInfo::GetIDsOfNames,</I> and <I>ITypeInfo::AddressOfMember</I>, which would accomplish the same end. If you wanted to restrict the search to a single object class, you can call <I>ITypeInfo::GetTypeComp</I> by using the <I>ITypeInfo</I> for that <I>coclass</I>. The <I>ITypeComp</I> you get in this case would ignore everything else in the library, for an even faster search.</P>
<P>Both <I>Bind</I> and <I>BindType</I>, as well as <I>ITypeLib::FindName</I> and <I>ITypeLib::IsName</I>, involve the use of a hash value for the name in question. The OLE API function <I>LHashValOfName</I> does the actual hashing. <I>LHashValOfName</I> is a macro that is converted to a call to <I>LHashValOfNameSys</I> inside the OLE header files, so you don't have to care what system you're working on. (The system is hard-coded into the header files for each system, which is appropriate.) In any case, before calling <I>Bind</I> or <I>BindType,</I> you hash the name you're looking for by using this function and pass it as an argument to the <I>ITypeComp</I> functions, which then race through the library looking for a match, bypassing all the tedious navigation through the various elements.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>8 I am indebted to Burt Harris for greatly clarifying the purpose of this interface to me.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
