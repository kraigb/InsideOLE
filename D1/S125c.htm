<HTML><HEAD><TITLE>Notes on Implementation of Cosmo</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Notes on Implementation of Cosmo</H3><P>As mentioned earlier, the Cosmo sample in this chapter implements a three-level automation object hierarchy: application–figures (collection)–figure. Rather than labor over the code here, take a look at the list beginning on the following page, which details the major points of interest in the implementation. You can look through the source code for all the details.</P>
<UL><LI>Cosmo's type information is provided only in English in COSMO000.ODL, although the structure of the code would allow a multilingual version quite easily.</LI><LI>The automation objects are implemented by C++ classes named <I>CAutoApp</I> (AUTOAPP.CPP), <I>CAutoFigures</I> (AUTOFIGS.CPP), and <I>CAutoFig</I> (AUTOFIG.CPP). These classes all inherit from the common abstract base class <I>CAutoBase</I> (AUTOBASE.CPP), which provides the <I>IDispatch</I> and <I>IExternalConnection</I> implementations but forces the derived class to implement <I>IUnknown</I> members. <I>IDisp</I><I>atch</I> is implemented through the technique shown in Beeper2 using <I>ITypeInfo::Invoke</I> and other functions; Cosmo does not raise exceptions.</LI><LI>Each automation object is attached to one of Cosmo's existing framework classes: <I>CAutoApp</I> to <I>CCosmoFrame</I>, <I>CAutoFigures</I> to <I>CCosmoClient</I>, and <I>CAutoFigure</I> to <I>CCosmoDocument.</I> <I>CAutoBase</I> maintains a backpointer from the automation object to the framework object so that the automation implementation can call the various framework member functions to implement the correct automation behavior.</LI><LI>Cosmo is registered as the server for two CLSIDs: CLSID_CosmoApplication and CLSID_CosmoFigure. The registry entries for the application object include the <I>/Automation</I> switch. This switch tells <I>CCosmoFrame::Init</I> (COSMO.CPP) whether to register a class factory for CLSID_CosmoApplication on startup: only if the switch is present does a single-use registration happen because that's the only instance in which anyone should ever have access to the class factory. If <I>/Automation</I> is not present but <I>/</I><I>Embedding</I> is, Cosmo was launched to serve an instance of CLSID_CosmoFigure. In this case, Cosmo's main window is hidden until told otherwise (through <I>CAutoApp::put</I><I>_</I><I>Visible</I> if the caller navigates up through <I>CAutoFigure::get</I><I>_</I><I>Application</I>). Otherwise, Cosmo is being launched as a stand-alone. In any launch scenario, Cosmo always registers a multiple-use class factory for CLSID_CosmoFigure.</LI><LI>Regardless of how Cosmo is launched, it always instantiates <I>CAutoApp</I> on startup and registers it as active (that is, running) with <I>RegisterActiveObject</I>. Cosmo removes this registration during shutdown with <I>RevokeActiveObject</I>. To control reference-counting problems with active-object registration, Cosmo registers using a strong reference and exposes <I>IExternalConnection</I> through <I>CAutoApp</I>. (See AUTOBASE.CPP.) This interface simply calls <I>CAutoApp::Release</I> when the last external connection goes away. This reverses the <I>AddRef</I> from <I>RegisterActiveObject</I> and starts shutdown. <I>CAutoApp</I> is not destroyed until the <I>CCosmoFrame</I> destructor is called, so <I>RevokeActiveObject</I> will have no problem calling <I>Release</I> itself.</LI><LI>A document always instantiates <I>CAutoFigure</I> on creation and deletes it on closure. This automation object is also registered with a strong lock with <I>RegisterActiveObject</I> and uses the same <I>IExternalConnection</I> device to close the document when necessary (just as <I>CAutoApp</I> uses it). If Cosmo was launched to create a figure object, the communication from <I>CAutoFigure::Release</I> to the <I>Obj</I><I>ectDestroyed</I> function in COSMO.CPP initiates full shutdown of the application when the last OLE-controlled document is closed.</LI><LI>Both <I>CAutoApp</I> and <I>CAutoFigure</I> have an additional private member function named <I>MoveSize</I>. This function handles all the variations with the <I>Left</I>, <I>Top</I>, <I>Width</I>, and <I>Height</I> properties.</LI><LI><I>CAutoFigures</I> uses a list box of current documents maintained in <I>CCosmoClient</I> (through its base class <I>CClient</I> in CLASSLIB) to maintain the documents in the collection. The class <I>CEnumFigures</I> (AUTOFIGS.CPP) handles enumerations using the copy of this list that it makes when the enumerator is instantiated from <I>CAutoFigures::</I><I>_</I><I>NewEnum</I>.</LI><LI><I>CAutoFigures::Item</I> gives a good example of handling multiple optional arguments because it accepts either no arguments, a <I>long</I> index, or a BSTR name of the document to return. <I>CAutoFigure::Close</I> is another example of optional arguments.</LI><LI><I>CAutoFigures::AddPoint</I>, which adds another point to the figure and repaints it, is implemented by converting the (32,767, 32,767) scaled point to the size of the figure window itself. It then sends the figure (class <I>CPolyline</I>, in POLYLINE.CPP and POLYWIN.CPP) a WM_LBUTTONDOWN message with the scaled coordinates in <I>lParam</I>. This simulates a user's mouse click exactly, in response to which the figure adds the point to its data and repaints.</LI><LI>The only code changes to Cosmo's framework classes that were necessary to support Automation concerned object creation, management, and shutdown. No changes were necessary to implement the member functions of any automation interface. Again, this is utterly noninvasive, made possible by the fact that Cosmo's framework was already structured in a parallel fashion with the automation object hierarchy it exposes.</LI><LI>For a non-debug Win32 compilation, the executable increased from 68,608 bytes to 84,432 bytes, an increase of 23 percent. This is roughly the amount of code added to support Automation, but the larger an application and the more complex its functionality, the smaller this percentage will be. In Cosmo, the non-OLE functionality is so simple that another set of objects to access that functionality is a significant addition. If Cosmo were much more complex in terms of internal computation, for example, the percentage would be quite a bit smaller. This measure of Cosmo is possibly the worst- case scenario for code expansion.</LI></UL><P>If you want to give Cosmo a whirl, you can use test programs in the COSMOTST directory.</P></font></body></HTML>
