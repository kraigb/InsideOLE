<HTML><HEAD><TITLE>Synchronized Swimming with Your Local Server</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Synchronized Swimming with Your Local Server</H2><P>So now everything looks great and is less filling too, until you activate the object and start making changes in the server. Wait a minute! The changes you make in the server are not reflected in the container as they were before. What's going on? Well, you have a handler, and whenever the container calls <I>OleDraw</I> or <I>IViewObject2::Draw</I>, it's going to the handler. The handler, however, doesn't know about the changes you've been making, so how do you keep the handler and the running server in sync?</P>
<P>When we implemented Cosmo in Chapter 18, we sent <I>IAdviseSink::OnDataChange</I> notifications to all advise sinks that came into our local object's <I>IDataObject</I> implementation. Where do these notifications go? The simple answer is that they go to any advise sink with a connection to the running object. By default, the only advise sink with a connection to the running server is the cache. Well, the handler can also connect itself to data change notifications. This means that it can request a new copy of the object's native data rather than a new graphical rendering from the server, as the cache does. (Thus, the local object must support the native format through <I>IDataObject::GetData.</I>) As I mentioned in Chapter 11, we don't worry about <I>IAdviseSink::OnViewChange </I>notifications because they matter only in the relationship between the handler and the container.</P>
<P>However you decide to implement the <I>IAdviseSink</I> interface to pass to the local object's <I>IDataObject::DAdvise </I>function is up to you, but its <I>QueryInterface </I>should supply only <I>IUnknown </I>and <I>IAdviseSink</I> pointers. In HCosmo, I actually make this interface part of <I>CFigure </I>itself, but I hobble its <I>QueryInterface </I>to return only its own interface pointer.</P>
<P>Now, this <I>IAdviseSink </I>pointer is the same one we passed to the default handler's <I>IDataObject::DAdvise </I>in <I>CFigure::Init</I>. We did not specify ADVF_NODATA, however, so our implementation of <I>OnDataChange </I>will automatically receive new renderings from a running instance of the object in Cosmo. We use the data passed to update our data in the handler so the new call to <I>IViewObject2::Draw </I>will work properly:</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(void) CImpIAdviseSink::OnDataChange(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM)<BR>    {<BR>    //Get new data first, and then notify container to repaint.<BR>    if ((pFE-&gt;cfFormat==m_pObj-&gt;m_cf)<BR>        &amp;&amp; (TYMED_HGLOBAL &amp; pSTM-&gt;tymed))<BR>        {<BR>        PPOLYLINEDATA      ppl;<BR><BR>        ppl=(PPOLYLINEDATA)GlobalLock(pSTM-&gt;hGlobal);<BR>        memcpy(&amp;m_pObj-&gt;m_pl, ppl, CBPOLYLINEDATA);<BR>        GlobalUnlock(pSTM-&gt;hGlobal);<BR><BR>        /*<BR>         * Now tell container that view changed, but only<BR>         * if view is not frozen.<BR>         */<BR>        if (pFE-&gt;dwAspect &amp; m_pObj-&gt;m_dwAdviseAspects<BR>            &amp;&amp; !(pFE-&gt;dwAspect &amp; m_pObj-&gt;m_dwFrozenAspects))<BR>            {<BR>            //Pass this on to container.<BR>            if (NULL!=m_pObj-&gt;m_pIAdvSinkView)<BR>                {<BR>                m_pObj-&gt;m_pIAdvSinkView-&gt;OnViewChange(pFE-&gt;dwAspect<BR>                    , pFE-&gt;lindex);<BR>                }<BR>            }<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>Remember that because all calls to <I>IAdviseSink </I>are asynchronous, you cannot call back to the local object from within this function (or you'll see RPC_E_CANTCALLOUT_INASYNCCALL).</P>
<P>Another point to remember is that the container will pass its own <I>IAdviseSink </I>pointer to our very own <I>IViewObject2::SetAdvise. </I>We kept this pointer for those aspects we care about. We are therefore responsible for calling the site's <I>IAdviseSink::OnViewChange</I> when we have new data to draw. Thus, we must make that call within our own <I>IAdviseSink::OnD</I><I>ataChange</I>, as shown in the preceding code.</P>
<P>Finally, be sure to use the best storage medium for sending data between a handler and a local server. If the data is small, TYMED_HGLOBAL is fine, but large data should use a shareable medium such as TYMED_ISTORAGE or TYMED_ISTREAM to minimize the amount of data that must be copied.</P></font></body></HTML>
