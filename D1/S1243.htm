<HTML><HEAD><TITLE>Variation I: A Raw Multilingual IDispatch</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Variation I: A Raw Multilingual <I>IDispatch</I></H3><P>The first technique for implementing <I>IDispatch</I> is to implement the entire interface yourself. You process all the arguments to <I>Invoke</I> for each method and property, manually implement <I>GetIDsOf</I><I>Names</I>, and implement degenerate <I>GetTypeInfoCount</I> and <I>GetTypeInfo</I> functions. This <I>IDispatch</I> technique involves no type information and requires that the controller call <I>GetIDsOfNames</I> to convert names to dispIDs. Of course, this requires the controller to assume that the name exists until the controller tries to invoke the name. If <I>GetIDsOfNames</I> fails, the invocation fails. In addition, the controller cannot perform any type or argument checking prior to making a call to <I>Invoke</I> and has to pass whatever it has from the script that it's executing. So the controller depends on <I>Invoke</I> to return errors if there is a problem. This is, in fact, exactly how Visual Basic 3 and DispTest work: they don't make direct use of an object's type information, and they depend on the object's <I>IDispatch</I> to provide dispIDs as well as type checking.</P>
<P>The Beeper1 sample (CHAP14\BEEPER1) implements <I>IDispatch</I> in this way and contains no type information. The interface is implemented in a separate class, <I>CImpIDispatch</I>, which is defined in BEEPER.H and implemented in BEEPER.CPP. This class maintains a backpointer to the <I>CBeeper</I> object and delegates all <I>IUnknown</I> calls to <I>CBeeper</I>'s <I>IUnknown</I> members. <I>CBeeper</I> itself instantiates <I>CImpIDispatch</I> in the <I>Init</I> function, storing the pointer in a field <I>m</I><I>_</I><I>pImpIDispatch</I>; this pointer is deleted in <I>CBeeper</I><I>'</I><I>s</I> destructor.</P>
<H4><A NAME="sec0"></A><I>QueryInterface</I> Behavior</H4><P>Take a look at <I>CBeeper::QueryInterface</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeper::QueryInterface(REFIID riid, PPVOID ppv)<BR>    {<BR>    *ppv=NULL;<BR><BR>    if (IID_IUnknown==riid)<BR>        *ppv=this;<BR><BR>    if (IID_IDispatch==riid œœ DIID_DIBeeper==riid)<BR>        *ppv=m_pImpIDispatch;<BR><BR>    if (NULL!=*ppv)<BR>        {<BR>        ((LPUNKNOWN)*ppv)-&gt;AddRef();<BR>        return NOERROR;<BR>        }<BR><BR>    return ResultFromScode(E_NOINTERFACE);<BR>    }</code></pre>
<P>For the most part, this is a typical <I>QueryInterface</I> implementation except that it recognizes two IIDs as our <I>IDispatch</I> implementation: <I>IID</I><I>_</I><I>IDispatch</I> and <I>DIID</I><I>_</I><I>DIBeeper</I>. The latter IID is the one that the Beeper object assigns to its dispinterface, hence the extra <I>D</I>s in the name. You can find this IID defined in INC\BOOKGUID.H as <I>{</I><I>00021127-0000-0000-C000-000000000046</I><I>}</I>. Because an object can implement multiple dispinterfaces, each interface must be available through <I>QueryInterface</I> given the specific DIID of that dispinterface. Only one, however, is considered the default dispinterface, and only that one is available through a query for <I>IID</I><I>_</I><I>IDispatch</I>. Because this Beeper object has only one dispinterface, both IIDs can be used to query for that dispinterface. If Beeper implemented a second interface—something such as <I>DIID</I><I>_</I><I>DITweeter</I>—we would add only the following line of code to <I>QueryInterface</I>:</P>
<P><BR></P>
<pre><code>    if (DIID_DITweeter==riid)<BR>        *ppv=m_pImpIDispTweeter;</code></pre>
<P>Here <I>m</I><I>_</I><I>pImpIDispTweeter</I> would be a separate <I>IDispatch</I> implementation from <I>m</I><I>_</I><I>pImpIDispatch.</I></P>
<H4><A NAME="sec1"></A><I>IDispatch::GetTypeInfo</I> and <I>IDispatch::GetTypeInfoCount</I></H4><P>When an automation object doesn't support type information, implementing <I>GetTypeInfo</I> and <I>Get</I><I>TypeInfoCount</I> is a snap:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)<BR>    {<BR>    *pctInfo=0;<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itinfo, LCID lcid<BR>    , ITypeInfo **pptInfo)<BR>    {<BR>    *pptInfo=NULL;<BR>    return ResultFromScode(E_NOTIMPL);<BR>    }</code></pre>
<P>Because there's no type information, <I>GetTypeInfoCount</I> honestly returns a 0 in the <I>pctInfo</I> out-parameters. Because the count is 0, a controller cannot expect <I>GetTypeInfo</I> to succeed, and, in fact, our implementation fails here (although according to the out-parameter rules, we have to set the return pointer to NULL anyway).</P>
<H4><A NAME="sec2"></A><I>IDispatch::GetIDsOfNames</I></H4><P>As we learned earlier, <I>GetIDsOfNames</I> is used to convert the names of properties and methods, as well as arguments to those methods, to the dispIDs that refer to those elements. <I>GetIDsOfNames</I> has the following signature:</P>
<P><BR></P>
<pre><code>STDMETHOD IDispatch::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames<BR>    , UINT cNames, LCID lcid, DISPID *rgDispID)</code></pre>
<P>Here <I>riid</I> must always be <I>IID</I><I>_</I><I>NULL</I>, <I>rgszNames</I> is an array of pointers to the strings to convert to dispIDs, <I>cNames</I> indicates the size of the <I>rgszNames</I> array, <I>lcid</I> is the language to use in translation, and <I>rgDispID</I> is an array of dispIDs (of size <I>cNames</I> as well) in which this function returns the converted dispIDs.</P>
<P>When <I>cNames</I> is 1, this function needs only to convert a method or a property name to a dispID. When <I>cNames</I> is greater than 1, the additional names are for arguments to a method. All the Beeper objects in this chapter bother only with the first name because the <I>Beep</I> method doesn't have any arguments. In any case, if any name in <I>rgszNames</I> cannot be converted, we store DISPID_UNKNOWN in the same position in <I>rgDispID</I> and return DISP_E_UNKNOWNNAME from this function. This way the controller knows which names were unrecognized.</P>
<P>Beeper1's implementation of <I>GetIDsOfNames</I> supports both English and German names. More precisely, Beeper1 supports primary German, primary English, and a neutral language, which is the same as English. If any other locale is given in <I>lcid</I>, we return DISP_E_UNKNOWNLCID, as required. Otherwise, we iterate through the known method and property names in the appropriate language and look for a match (case insensitive). If one is found, the dispID is stuffed into <I>rgDispID[0]</I>, and we return with NOERROR. Otherwise, we return with DISP_E_UNKNOWNNAME. Here's the actual code:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid<BR>    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)<BR>    {<BR>    HRESULT     hr;<BR>    int         i;<BR>    int         idsMin;<BR>    LPTSTR      psz;<BR><BR>    if (IID_NULL!=riid)<BR>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);<BR><BR>    //Set up idsMin to the right stringtable in our resources.<BR>    switch (PRIMARYLANGID(lcid))<BR>        {<BR>        case LANG_NEUTRAL:<BR>        case LANG_ENGLISH:<BR>            idsMin=IDS_0_NAMESMIN;<BR>            break;<BR><BR>        case LANG_GERMAN:<BR>            idsMin=IDS_7_NAMESMIN;<BR>            break;<BR><BR>        default:<BR>            return ResultFromScode(DISP_E_UNKNOWNLCID);<BR>        }<BR><BR>    /*<BR>     * The index in this loop happens to correspond to the DISPIDs<BR>     * for each element and also matches the stringtable entry<BR>     * ordering, where i+idsMin is the string to compare. If we<BR>     * find a match, i is the DISPID to return.<BR>     */<BR>    rgDispID[0]=DISPID_UNKNOWN;<BR>    hr=ResultFromScode(DISP_E_UNKNOWNNAME);<BR><BR>    psz=m_pObj-&gt;m_pszScratch;<BR><BR>    for (i=0; i &lt; CNAMES; i++)<BR>        {<BR>        LoadString(g_hInst, idsMin+i, psz, 256);<BR>        if (0==lstrcmpi(psz, rgszNames[0]))<BR>            {<BR>            //Found a match; return the DISPID.<BR>            rgDispID[0]=i;<BR>            hr=NOERROR;<BR>            break;<BR>            }<BR>        }<BR><BR>    return hr;<BR>    }</code></pre>
<P>The buffer <I>m</I><I>_</I><I>pszScratch</I> is a 256-character array preallocated in <I>CBeeper::Init.</I> This improves the performance of <I>GetIDsOfNa</I><I>mes</I> and reduces the number of error conditions that might occur. The strings for each language are contained in separate stringtables in the DLL's resources, DBEEPER.RC:</P>
<P><BR></P>
<pre><code>STRINGTABLE<BR>    BEGIN<BR>        §<BR>        IDS_0_SOUND,                   "Sound"<BR>        IDS_0_BEEP,                    "Beep"<BR>    END<BR><BR>STRINGTABLE<BR>    BEGIN<BR>        §<BR>        IDS_7_SOUND,                   "Ton"<BR>        IDS_7_BEEP,                    "Piep"<BR>    END</code></pre>
<P>There are a few other strings in each stringtable for exceptions, as we'll see shortly. The symbols used for the strings also indicate the language so that we can keep them straight.</P>
<P>Now, after the controller translates names into dispIDs (0 for <I>Sound</I> and 1 for <I>Beep</I>, the same as in other languages), there are no more locale-specific concerns anywhere in this object, as we'll see by looking at <I>Invoke</I>.</P>
<H4><A NAME="sec3"></A><I>IDispatch::Invoke</I></H4><P><I>Invoke</I> is the real workhorse of Automation. Because we already know the purpose of all the arguments to this function, let's start with Beeper1's implementation code:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid<BR>    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams<BR>    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)<BR>    {<BR>    HRESULT     hr;<BR><BR>    //riid is supposed to be IID_NULL always.<BR>    if (IID_NULL!=riid)<BR>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);<BR><BR>    switch (dispID)<BR>        {<BR>        case PROPERTY_SOUND:<BR>            if (DISPATCH_PROPERTYGET &amp; wFlags<BR>                œœ DISPATCH_METHOD &amp; wFlags)<BR>                {<BR>                if (NULL==pVarResult)<BR>                    return ResultFromScode(E_INVALIDARG);<BR><BR>                VariantInit(pVarResult);<BR>                V_VT(pVarResult)=VT_I4;<BR>                V_I4(pVarResult)=m_pObj-&gt;m_lSound;<BR>                return NOERROR;<BR>                }<BR>            else<BR>                {<BR>                //DISPATCH_PROPERTYPUT<BR>                long        lSound;<BR>                int         c;<BR>                VARIANT     vt;<BR><BR>                if (1!=pDispParams-&gt;cArgs)<BR>                    return ResultFromScode(DISP_E_BADPARAMCOUNT);<BR><BR>                c=pDispParams-&gt;cNamedArgs;<BR>                if (1!=c œœ (1==c &amp;&amp; DISPID_PROPERTYPUT<BR>                    !=pDispParams-&gt;rgdispidNamedArgs[0]))<BR>                    return ResultFromScode(DISP_E_PARAMNOTOPTIONAL);<BR><BR>                VariantInit(&amp;vt);<BR>                hr=VariantChangeType(&amp;vt, &amp;pDispParams-&gt;rgvarg[0]<BR>                    , 0, VT_I4);<BR><BR>                if (FAILED(hr))<BR>                    {<BR>                    if (NULL!=puArgErr)<BR>                        *puArgErr=0;<BR><BR>                    return hr;<BR>                    }<BR><BR>                lSound=vt.lVal;<BR><BR>                if (MB_OK!=lSound &amp;&amp; MB_ICONEXCLAMATION!=lSound<BR>                    &amp;&amp; MB_ICONQUESTION!=lSound &amp;&amp; MB_ICONHAND!=lSound<BR>                    &amp;&amp; MB_ICONASTERISK!=lSound)<BR>                    {<BR>                    if (NULL==pExcepInfo)<BR>                        return ResultFromScode(E_INVALIDARG);<BR><BR>                    pExcepInfo-&gt;wCode=EXCEPTION_INVALIDSOUND;<BR>                    pExcepInfo-&gt;scode=<BR>                        (SCODE)MAKELONG(EXCEPTION_INVALIDSOUND<BR>                        , PRIMARYLANGID(lcid));<BR><BR>                    FillException(pExcepInfo);<BR>                    return ResultFromScode(DISP_E_EXCEPTION);<BR>                    }<BR><BR>                //Everything checks out: save new value.<BR>                m_pObj-&gt;m_lSound=lSound;<BR>                }<BR><BR>            break;<BR><BR>        case METHOD_BEEP:<BR>            if (!(DISPATCH_METHOD &amp; wFlags))<BR>                return ResultFromScode(DISP_E_MEMBERNOTFOUND);<BR><BR>            if (0!=pDispParams-&gt;cArgs)<BR>                return ResultFromScode(DISP_E_BADPARAMCOUNT);<BR><BR>            MessageBeep((UINT)m_pObj-&gt;m_lSound);<BR><BR>            //The result of this method is the sound we played.<BR>            if (NULL!=pVarResult)<BR>                {<BR>                VariantInit(pVarResult);<BR>                V_VT(pVarResult)=VT_I4;<BR>                V_I4(pVarResult)=m_pObj-&gt;m_lSound;<BR>                }<BR><BR>            break;<BR><BR>        default:<BR>            ResultFromScode(DISP_E_MEMBERNOTFOUND);<BR>        }<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>One argument we didn't see earlier is <I>riid</I>. This must always be IID_NULL, or else you must return DISP_E_UNKNOWNINTERFACE. In other words, <I>riid</I> doesn't do anything for us. When OLE Automation was first being developed, the specifications indicated that the dispinterface ID was passed in this argument to support multiple dispinterfaces. But because you can query for secondary dispinterfaces using a DIID directly, this is not used. It wasn't removed from the specifications because Automation was already in beta at the time of the decision. It was left in and specified as a reserved value that must be IID_NULL.</P>
<P>The next few steps in our implementation are pretty intuitive: check which dispID is being invoked, check and coerce the types, and then attempt to get or put the property or execute the method, raising exceptions if necessary. You should not coerce types in <I>pDispParams</I>-&gt;<I>rgvarg</I> in place—use a local variable as shown here.</P>
<P>PROPERTY_SOUND, which is defined as dispID 0 (in BEEPER.H), can be invoked with the DISPATCH_PROPERTYGET, DISPATCH_METHOD, or DISPATCH_PROPERTYPUT flag. Because some controllers cannot differentiate a property get from a method call, we have to treat these as equivalent. In either case, we set the return VARIANT in <I>pVarResult</I> to contain the current value of <I>m</I><I>_</I><I>lSound</I>, and we're done. Easy!</P>
<P>To invoke METHOD_BEEP (defined as dispID 1 in BEEPER.H), we need first to ensure that the caller is actually trying to use this dispID as a method. Otherwise, we return DISP_E_MEMBERNOTFOUND. (This is, incidentally, the same error we return for an unrecognized dispID, as is the default case.) We also want to tell the controller that we don't take any parame-ters. If <I>pDispParams-&gt;cArgs</I> is nonzero, we fail with DISP_E_BADPARAMCOUNT; otherwise, we pass our <I>m</I><I>_</I><I>lSound</I> to <I>MessageBeep</I> to execute the method, store the sound played in <I>pVarResult</I> (just as a property get), and return successful.</P>
<P>With a property put operation, first protect any read-only properties you have, returning DISP_E_MEMBERNOTFOUND. I know this error isn't terribly informative, so it's likely that you'll see a DISP_E_ACCESSDENIED error added to OLE in the near future. You might also raise an exception as described on the following pages.</P>
<P><I>Sound</I> is a writable property, so we first verify that we received one and only one argument in <I>pDispParams</I>, that the argument is named, and that the dispID of that argument is DISPID_PROPERTYPUT. If these conditions are not met, we return DISP_E_PARAMNOTOPTIONAL.</P>
<P>Next we attempt to coerce the argument we did get into a <I>long</I> because we require the use of <I>VariantChangeType</I>. The nice thing about using <I>VariantChangeType</I> is that if coercion doesn't work, this function returns the error code that we can return immediately to the controller to describe the error. In the case of an error, we have to specify which argument is in error in *<I>puArgErr</I> before returning. This example has only one argument, so the problem is always with the 0th position argument.</P>
<P>If we get this far, we have the right type of data, but we need to be sure that it is a value we can accept. This sample extracts the argument's value from the VARIANT through a direct dereferencing of <I>pDispParams-&gt;rgvarg[0].lVal.</I> This works fine for simple arguments. For more complex arguments to method calls, it is advisable to use the helper <I>DispGetParam</I> to address each argument by position in the method's argument list and combine the type coercion step. In other words, <I>DispGe</I><I>tParam</I> hides the grunge; a call to it would look like the following:</P>
<P><BR></P>
<pre><code>VARIANT    vtNew;<BR><BR>hr=DispGetParam(pDispParams, 0, VT_I4, &amp;vtNew, puArgErr));<BR><BR>if (FAILED(hr))<BR>    return hr;<BR><BR>lSound=V_I4(vtnew);    //Same as lSound=vtNew.lVal</code></pre>
<P>In any case, we get the new value of the property and compare it against the possible MB_* values that allow for this property. If this checks out, we save the new value in <I>m</I><I>_</I><I>lSound</I> and return successful. If the validation fails, we have two choices: either fail <I>Invoke</I> trivially (with some useful error such as DISP_E_OVERFLOW or E_INVALIDARG) or raise an exception.</P>
<P>Raising an exception means filling the EXCEPINFO structure that the controller gave us and returning DISP_E_EXCEPTION. If the controller passes a NULL in <I>pExcepInfo</I>, you <I>cannot</I> raise exceptions and can only fail trivially. Fortunately, even DispTest asks for exception information, as do all versions of Visual Basic. You can choose to fill the exception structure at that time or fill in either the <I>wCode</I> or <I>scode</I> field and the <I>pfnDeferredFillIn</I> field for delayed filling. DispTest and Visual Basic 3 do not support deferred filling, but later versions do. You'll need a better controller than DispTest to try this feature. The code used in this sample to perform such a test is as follows:</P>
<P><BR></P>
<pre><code>INITEXCEPINFO(*pExcepInfo);<BR>pExcepInfo-&gt;scode=(SCODE)MAKELONG(EXCEPTION_INVALIDSOUND<BR>    , PRIMARYLANGID(lcid));<BR>pExcepInfo-&gt;pfnDeferredFillIn=FillException;</code></pre>
<P>INITEXCEPINFO is a macro in INC\INOLE.H that clears an EXCEPINFO structure in one nice tidy line of code.</P>
<P>In both this code fragment and the previous listing of <I>Invoke</I>, I'm playing with fire by storing a 16-bit exception code and a 16-bit language ID in the <I>scode </I>field because there is no easy way to pass a locale to a deferred filling function. This is risky because I'm using <I>scode </I>in an unapproved way—it would be better if I had <I>Invoke </I>return different filling functions, depending on the language, or if I defined a set of error codes for each language so that the filling function knew what language to use. In any case, you can take a look at my shortcut lazy man's <I>FillException </I>function beginning on the following page.</P>
<P><BR></P>
<pre><code>HRESULT STDAPICALLTYPE FillException(EXCEPINFO *pExcepInfo)<BR>    {<BR>    SCODE       scode;<BR>    LANGID      langID;<BR>    USHORT      wCode;<BR>    HRESULT     hr;<BR>    LPTSTR      psz;<BR>    LPOLESTR    pszHelp;<BR>    UINT        idsSource<BR>    UINT        idsException;<BR><BR>    if (NULL==pExcepInfo)<BR>        return ResultFromScode(E_INVALIDARG);<BR><BR>    /*<BR>     * Parts of our implementation that raise exceptions; put the<BR>     * WORD exception code in the loword of scode and the LANGID<BR>     * in the hiword.<BR>     */<BR>    scode=pExcepInfo-&gt;scode;<BR>    langID=HIWORD(scode);<BR>    wCode=LOWORD(scode);<BR><BR>    //Allocate BSTRs for source and description strings.<BR>    psz=(LPTSTR)malloc(1024*sizeof(TCHAR));<BR><BR>    if (NULL==psz)<BR>        return ResultFromScode(E_OUTOFMEMORY);<BR><BR>    hr=NOERROR;<BR><BR>    switch (wCode)<BR>        {<BR>        case EXCEPTION_INVALIDSOUND:<BR>            //Fill in unused information; macro in inole.h.<BR>            INITEXCEPINFO(*pExcepInfo);<BR>            pExcepInfo-&gt;wCode=wCode;<BR>            pExcepInfo-&gt;dwHelpContext=HID_SOUND_PROPERTY_LIMITATIONS;<BR><BR>            //Set defaults.<BR>            pszHelp=OLETEXT("c:\\inole\\chap14\\beephelp\\beep0000.hlp");<BR>            idsSource=IDS_0_EXCEPTIONSOURCE;<BR>            idsException=IDS_0_EXCEPTIONINVALIDSOUND;<BR><BR>            //Get the localized source and exception strings.<BR>            switch (langID)<BR>                {<BR>                case LANG_GERMAN:<BR>                    idsSource=IDS_7_EXCEPTIONSOURCE;<BR>                    idsException=IDS_7_EXCEPTIONINVALIDSOUND;<BR>               pszHelp=OLETEXT("c:\\inole\\chap14\\beephelp\\beep0007.hlp");<BR>                    break;<BR><BR>                case LANG_ENGLISH:<BR>                case LANG_NEUTRAL:<BR>                default:<BR>                    break;<BR>                }<BR><BR>            break;<BR><BR>        default:<BR>            hr=ResultFromScode(E_FAIL);<BR>        }<BR><BR>    if (SUCCEEDED(hr))<BR>        {<BR>        pExcepInfo-&gt;bstrHelpFile=SysAllocString(pszHelp);<BR><BR>        LoadString(g_hInst, idsSource, psz, 1024);<BR>        pExcepInfo-&gt;bstrSource=SysAllocString(psz);<BR>        LoadString(g_hInst, idsException, psz, 1024);<BR>        pExcepInfo-&gt;bstrDescription=SysAllocString(psz);<BR>        }<BR><BR>    free(psz);<BR>    return hr;<BR>    }</code></pre>
<P>We store all the information necessary to describe the exception, including a help file, in the EXCEPINFO structure. The source and description strings for each language we support are in the stringtables in DBEEPER.RC:</P>
<P><BR></P>
<pre><code>//English<BR>IDS_0_EXCEPTIONSOURCE:  "Beeper.Object"<BR>IDS_0_EXCEPTIONINVALIDSOUND:  "The 'Sound' property can be set only\<BR>to MB_OK (0), MB_ICONHAND (16), MB_ICONQUESTION (32)\<BR>, MB_ICONEXCLAMATION (48), or MB_ICONASTERISK (64)."<BR><BR>//German<BR>IDS_7_EXCEPTIONSOURCE:  "Pieper.Objekt"<BR>IDS_7_EXCEPTIONINVALIDSOUND:  "Das 'Ton' Property kann nur die Werte\<BR>MB_OK (0), MB_ICONHAND(16), MB_ICONQUESTION (32)\<BR>, MB_ICONEXCLAMATION (48), oder MB_ICONASTERISK (64) erhalten."</code></pre>
<P>Keep in mind that DispTest and Visual Basic 3 (but not later versions) ignore the help file and context ID that you provide through the exception. Controllers that pay attention to these fields will display a Help button in the same message box that displays the exception source and the description string that you also return from here. If the user clicks Help, the controller launches WinHelp with the help file and the context ID to display the correct help topic. If you run Beeper1 with the AutoCli sample from Chapter 15, you can see this working. The BEEPHELP directory in this chapter has the sources for the small help files (English and German) used with this example.</P>
<P>As a final note, an object should generally store only "&lt;filename&gt;.hlp" in <I>bstrHelpFile</I>, depending on the HELPDIR registry entry under the object's TypeLib entry to give controllers the installation path of the help files. Because Beeper1 doesn't have type information, there's no registry entry for the directory. Thus, we store the full path, and Chapter 15's AutoCli checks for a path before prepending the HELPDIR value.</P></font></body></HTML>
