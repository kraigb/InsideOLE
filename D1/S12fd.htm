<HTML><HEAD><TITLE>Implement Partial In-Place Container Interfaces</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement Partial In-Place Container Interfaces</H3><P>To build any other in-place–activation code, we'll need at least stub implementations of <I>IOleInPlaceSite</I>,<I> IOleInPlaceFrame</I>,<I> </I>and, if applicable, <I>IOleInPlaceUIWindow</I>. Each interface is part of the appropriate container-side object. Patron implements the first as a contained class in <I>CTenant</I> (through <I>CImpIOleInPlaceSite </I>in IIPSITE.CPP),<I> </I>the second as part of <I>CPatronFrame </I>(in PATRON.CPP), and the third as a contained class in <I>CPatronDoc </I>(<I>CImpIOleInPlaceUIWindow</I> in IIPUIWIN.CPP). The <I>GetWindow </I>member of the site interface returns the pages window that occupies a document's client area—in other containers this might be simply the document window itself. The same member function in the other two interfaces returns the frame and document window handles as appropriate.</P>
<P>We don't need to implement every part of these interfaces right away. We'll get to everything in turn. At this point in our implementation, we need to do the following:</P>
<P>Implement the trivial <I>GetWindow</I> function of each interface.</P>
<P>Implement <I>SetActiveObject</I> in the frame and document interfaces to save the <I>IOleInPlaceActiveObject</I> pointer passed to each.</P>
<P>Implement the <I>IOleInPlaceSite</I> members of <I>CanInPlaceActivate</I>, <I>OnInPlaceActivate</I>, <I>OnInPlaceDeactivate</I>, and <I>GetWindowContext</I>.</P>
<P>Return E_NOTIMPL from everything else for the time being.</P>
<P>The following sections will look at steps 2 and 3 in more detail. You'll also need to ensure that each object, site, document, and frame supports the correct interfaces in <I>QueryInterface. </I>Each object will need to respond to <I>IOleWindow </I>as well as to the specific interface in question. In addition, the frame's implementation will need to respond to <I>IOleInPlaceUIWindow </I>because that is the base interface of <I>IOleInPlaceFrame.</I></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>EXPERIENCE: The Site Requires Access to the Frame and the Document</H4><P>A site object will generally need access both to frame and document variables and to member functions because the interaction between the in-place object and the site will involve user interface elements for the frame and the document. This is especially true because <I>IOleInPlaceSite::GetWindowContext </I>must return interface pointers for the frame and document windows. For this reason, Patron stores its <I>CPatronFrame </I>pointer in a global variable, <I>g</I><I>_</I><I>pFR</I>. Not the best design, but it works.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec1"></A>Implement <I>SetActiveObject</I> for the Frame and the Document</H4><P>The <I>SetActiveObject </I>member in <I>IOleInPlaceUIWindow </I>(and thus <I>IOleInPlaceFrame</I>) is the function that the container uses to obtain the UI-active object's <I>IOleInPlaceActiveObject </I>interface, which the container must hold for later calls that we'll make to it. In Patron, both <I>CPatronFrame</I> and <I>CPatronDoc</I> have a member variable <I>m</I><I>_</I><I>pIOleIPActiveObject</I> for this purpose.</P>
<P><I>SetActiveObject </I>will be called with both NULL and non-NULL pointers.5 When NULL is passed, release whatever interface pointer you have. When non-NULL is passed, release the old pointer, save a copy of the new one, and call <I>AddRef </I>through that new pointer, as shown in the code at the top of the following page.</P>
<P><BR></P>
<pre><code>if (NULL!=m_pIOleIPActiveObject)<BR>    m_pIOleIPActiveObject-&gt;Release();<BR><BR>//NULLs m_pIOleIPActiveObject if pIIPActiveObj is NULL<BR>m_pIOleIPActiveObject=pIIPActiveObj;<BR><BR>if (NULL!=m_pIOleIPActiveObject)<BR>    m_pIOleIPActiveObject-&gt;AddRef();</code></pre>
<H4><A NAME="sec2"></A>Implement Crucial <I>IOleInPlaceSite</I> Members</H4><P><I>IOleInPlaceSite </I>is the critical path of communication between an in-place object and the container, so for now we'll need to do most of our work in this interface. In Patron, the three members <I>CanInPlaceActivate</I>, <I>OnInPlaceActivate</I>, and <I>OnInPlaceDeactivate</I> are typical and rather short:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceSite::CanInPlaceActivate(void)<BR>    {<BR>    if (DVASPECT_CONTENT!=m_pTen-&gt;m_fe.dwAspect)<BR>        return ResultFromScode(S_FALSE);<BR><BR>    if (TENANTTYPE_EMBEDDEDOBJECT!=m_pTen-&gt;m_tType)<BR>        return ResultFromScode(S_FALSE);<BR><BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceActivate(void)<BR>    {<BR>    //m_pIOleIPObject is our in-place flag.<BR>    m_pTen-&gt;m_pObj-&gt;QueryInterface(IID_IOleInPlaceObject<BR>        , (PPVOID)&amp;m_pTen-&gt;m_pIOleIPObject);<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceDeactivate(void)<BR>    {<BR>    m_pTen-&gt;Activate(OLEIVERB_DISCARDUNDOSTATE, NULL);<BR>    ReleaseInterface(m_pTen-&gt;m_pIOleIPObject);<BR>    return NOERROR;<BR>    }</code></pre>
<P>For most containers, <I>CanInPlaceActivate</I> will not be too complex. Patron disallows in-place activation (returning S_FALSE) when the object is not embedded or is being displayed using an aspect other than DVASPECT_CONTENT. Other containers can use other conditions, of course.</P>
<P><I>OnInPlaceActivate</I> and <I>OnInPlaceDeactivate</I> tell the container to put itself in or take itself out of an in-place state. Patron's state consists entirely of the object's <I>IOleInPlaceObject </I>pointer (saved in <I>CTenant::m</I><I>_</I><I>pIOleIPObject</I>),<I> </I>which is managed in these two functions. Patron queries for and saves the pointer when the object is activated, releasing it when the object is deactivated. The pointer, which we need for making other function calls later, doubles as a flag to tell us whether we are handling an in-place session at the time. We'll come back to the <I>IOleObject::DoVerb </I>call later when we discuss Undo operations.</P>
<P><I>IOleInPlaceSite::GetWindowContext</I> is the hairy beast of the group, requiring more code because it has more arguments to mess with. This function stores pointers to the container's <I>IOleInPlaceFrame</I> and <I>IOleInPlaceUIWindow</I> interfaces in two out-parameters (<I>ppIIPFrame</I> and <I>ppIIPUIWindow</I>), specifies the initial position and clipping rectangles for the object (in <I>prcPos</I> and <I>prcClip</I>), and fills an OLEINPLACEFRAMEINFO structure with accelerator information:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceSite::GetWindowContext<BR>    (LPOLEINPLACEFRAME *ppIIPFrame, LPOLEINPLACEUIWINDOW<BR>    *ppIIPUIWindow, LPRECT prcPos, LPRECT prcClip<BR>    , LPOLEINPLACEFRAMEINFO pFI)<BR>    {<BR>    PCPatronDoc     pDoc;<BR>    RECTL           rcl;<BR><BR>    *ppIIPUIWindow=NULL;<BR><BR>    *ppIIPFrame=(LPOLEINPLACEFRAME)g_pFR;<BR>    g_pFR-&gt;AddRef();<BR><BR>    pDoc=(PCPatronDoc)SendMessage(GetParent(m_pTen-&gt;m_hWnd)<BR>        , DOCM_PDOCUMENT, 0, 0L);<BR><BR>    if (NULL!=pDoc)<BR>        {<BR>        pDoc-&gt;QueryInterface(IID_IOleInPlaceUIWindow<BR>            , (PPVOID)ppIIPUIWindow);<BR>        }<BR><BR>    //Now get rectangles and frame information.<BR>    m_pTen-&gt;RectGet(&amp;rcl, TRUE);<BR>    RECTFROMRECTL(*prcPos, rcl);<BR><BR>    //Include scroll position here.<BR>    OffsetRect(prcPos, -(int)m_pTen-&gt;m_pPG-&gt;m_xPos<BR>        , -(int)m_pTen-&gt;m_pPG-&gt;m_yPos);<BR><BR>    SetRect(prcClip, 0, 0, 32767, 32767);<BR><BR>    pFI-&gt;cb=sizeof(OLEINPLACEFRAMEINFO);<BR>   #ifdef MDI<BR>    pFI-&gt;fMDIApp=TRUE;<BR>   #else<BR>    pFI-&gt;fMDIApp=FALSE;<BR>   #endif<BR><BR>    pFI-&gt;hwndFrame=g_pFR-&gt;Window();<BR><BR>    pFI-&gt;haccel=g_pFR-&gt;m_hAccelIP;<BR>    pFI-&gt;cAccelEntries=CINPLACEACCELERATORS;<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>Patron stores the global <I>CPatronFrame</I> pointer <I>g</I><I>_</I><I>pFR</I> as the <I>IOleInPlaceFrame</I> pointer (calling <I>AddRef</I>, of course) because <I>CPatronFrame</I> inherits from the interface directly. We have to ask the document for its <I>IOleInPlaceUIWindow</I>, however.</P>
<P>The container is responsible for returning two rectangles here. The position rectangle tells the object exactly which rectangle it occupies in the container in <I>device units </I>(pixels). In Patron's case, this is the rectangle for the tenant implementing this site, offset for the current scroll position. The object will use this position rectangle as the area in which it displays its data, surrounding that area with any adornments it wants. If this area is not the same as the object's own extents, the ratio of the two determines the scaling factor. An object can choose to resize itself to fit in this rectangle, or it can choose to not change its scale and provide scrollbars or other devices as necessary.</P>
<P>The second rectangle, the clipping rectangle, specifies where the object can legally display anything—including adornments outside the object's data area. The object is downright criminal if it dares to place anything outside the clipping rectangle. This is the law to prevent the object from overlapping parts of the container's own UI—such as sibling toolbars—that are visibly outside the document area itself. Patron actually makes no restrictions because the object's window will be clipped to the pages window that occupies the usable client area of the document (and which is moved to accommodate any document tools the object creates). So we store the maximum rectangle (0–32,767 in both extents) in <I>prcClip</I>, again in device units. Keep in mind that the position rectangle can be larger than or extend outside the clipping rectangle. The object will scale to the position rectangle, but it will be displayed only in the intersection of the position and clipping rectangles.</P>
<P>The OLEINPLACEFRAMEINFO structure that you fill here provides the object, if it comes from a local server, with the information it requires for calling <I>OleTranslateAccelerator</I>. In-process objects do not use this information. <I>OleTranslateAccelerator</I> needs to know whether the container uses MDI (so that it can call <I>TranslateMDISysAccel</I> appropriately), as well as the window to receive accelerator commands. The accelerators you include here should be only those you want active during an in-place session. (Patron's accelerators are listed for the identifier IDR_INPLACEACCELERATORS in PATRON.RC.)</P>
<P>The <I>cb </I>field in OLEINPLACEFRAMEINFO indicates the version of the structure itself. (Later revisions of OLE might change the structure.) The object will fill this field before calling <I>GetWindowContext</I>. This means that the container must not modify the field but rather use it to store the right information in the right part of the structure.</P>
<P>With only this level of implementation, a container can activate an object to the point shown in Figure 22-7 on page 1024. Trouble is, we have no code in the container to deactivate the object! So we'd better add support for the rest of an object's activation needs.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>5 Again, ignore the <I>pszObjName </I>argument, which is no longer used.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
