<HTML><HEAD><TITLE>The Container Site</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Container Site</H3><P>However a container decides to provide storage elements, it will also need some sort of data structure or internal C++ object to manage that storage and all the other information about the content object itself. This structure or object is called a <I>client site,</I> or <I>container site</I>. For every content object in a compound document, the container creates a site to manage that content object. The site itself also exposes container-side functionality to the content object in question through two interfaces of its own: <I>IOleClientSite </I>and <I>IAdviseSink</I>, as illustrated in Figure 17-4.</P>
<P>    <img src="f17dd04.gif"></P>
<P><B>Figure 17-4.</B></P>
<P><B>The structure of a container site. The container creates one site for each content object in the compound document.</B></P>
<P>The member functions of both of these interfaces are either notifications or requests. <I>IAdviseSink </I>is full of notifications, as we saw in Chapters 10 and 11. <I>IOleClientSite </I>has a few notifications, a few requests, and a few members that simply provide information about the container:</P>
<P><BR></P>
<pre><code>interface IOleClientSite : IUnknown<BR>    {<BR>    HRESULT SaveObject(void);<BR>    HRESULT GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker<BR>        , IMoniker **ppmk);<BR>    HRESULT GetContainer(IOleContainer **ppContainer);<BR>    HRESULT ShowObject(void);<BR>    HRESULT OnShowWindow(BOOL fShow);<BR>    HRESULT RequestNewObjectLayout(void);<BR>    };</code></pre>
<P><I>SaveObject </I>is a request that allows the object to ask the container to fully save all the object's information. Why can't the object save itself? Well, the object's storage includes not only the object's native data but also the entire cache, various other OLE-managed streams, and any private streams that the container might want to save. Much of this information, especially when the object is running in another process, is not available to the object at all. This request tells the container not only to save the object's native data through <I>IPersistStorage::Save </I>but also to update the cache and save container streams.</P>
<P><I>GetMoniker </I>and <I>GetContainer </I>are specific requests for information about the container itself. <I>GetMoniker </I>asks the container for either the name of the compound document or the name of the object in the container. (We'll see more of this when we discuss linking.) <I>GetContainer </I>provides the object with an <I>IOleContainer </I>interface through which one can enumerate other objects in the container and lock the container in memory if necessary. This too applies mostly in linking, so we'll come back to it in later chapters.</P>
<P><I>ShowObject </I>is a request that tells the container to make the object's presentation area visible in the compound document. For example, if the object image is currently scrolled out of view, <I>ShowObject </I>must scroll it back into view. A content object will call <I>ShowObject </I>in the course of activation before the object's own user interface becomes visible. When that UI does become visible, the object will send the notification <I>OnShowWindow(TRUE).</I> At this time, the container draws a hatch pattern across the image of the object in the compound document to indicate that the content is active, as shown in Figure 17-5 on the following page. (When in-place activation is used, the object does not appear in a separate window for editing, so a thin hatch border appears around the object in the document itself, as discussed in Chapter 22.)</P>
<P>    <img src="f17dd05p.gif"></P>
<P><B>Figure 17-5.</B></P>
<P><B>Activating a content object will bring the object's image into view in the container and will draw a hatch pattern across it to indicate its active status.</B></P>
<P>When the user closes or otherwise hides the object's user interface, the object calls <I>OnShowWindow(FALSE)</I>, at which time the container removes the hatching.</P>
<P>The final member of <I>IOleClientSite</I> is <I>RequestNewObjectLayout</I>, which OLE Documents does not currently use. It is, however, used with OLE Controls, so we'll examine this member in Chapter 24.</P>
<P>As for <I>IAdviseSink</I>, we've already seen the use of its <I>OnDataChange </I>and <I>OnViewChange </I>members. A container will receive these notifications for a content object if it wants. <I>OnDataChange </I>is actually not all that interesting to a container because a container generally doesn't deal with the object's native data directly. This member is useful only when a container has more intimate knowledge about the object type and can understand the object's private formats. <I>OnViewChange </I>is of more interest. This function tells the container to redraw the object in the compound document. Doing so results in a call to the object's <I>IViewObject2::Draw</I>, causing the image of the object to be updated in the document. The primary use of this notification in OLE Documents is to synchronize the image of the object in the document with its image in whatever editing user interface the object displays when active. If we added another point to Cosmo's polyline data in Figure 17-5, Cosmo would send <I>OnViewChange </I>to Patron, which would then redraw the object to reflect the change. In this way, the user always sees the same data in both the document (with the hatching) and the object's own user interface.</P>
<P>The other members of <I>IAdviseSink </I>also notify the container of important events in the object's user interface. <I>OnSave </I>tells the container that the object has been completely saved and is always sent after the object calls <I>IOleClientSite::SaveObject</I>. <I>OnClose </I>tells the container that the user has closed the object's user interface, at which time the container can clean up whatever state it manages for an active object as opposed to a loaded object. Finally, <I>OnRename </I>tells the container that a linked object was saved to a different location, as we'll see in Chapter 20.</P></font></body></HTML>
