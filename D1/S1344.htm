<HTML><HEAD><TITLE>Notes on Polyline as an OLE Control</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Notes on Polyline as an OLE Control</H2><P>The Polyline component that we've been creating in this book is the closest thing we have already to an OLE control: it is in-place capable, supports outgoing interfaces, and even has a custom interface that exposes its specific properties. It requires only a few specific additions, primarily involving additional interfaces. As with Patron, this chapter's Polyline sample (CHAP24\POLYLINE) should not be considered a complete control. I'm providing it merely to illustrate how some of the control mechanisms appear in code. I'll leave it to the development tools to create truly complete implementations.</P>
<P>So what are Polyline's limitations? First of all, it's not a terribly useful control—it is much better suited to being a content object in a compound document. Nevertheless, we can use it to demonstrate control-like behavior. Second, Polyline has no accelerators and no mnemonics, so it doesn't demonstrate those aspects of control development. Third, none of its properties are bindable, so Polyline doesn't implement <I>IPropertyNotifySink </I>as an outgoing interface. Fourth, it doesn't support Save As Text. And finally, Polyline is not marked for self-registration as shipping controls should be—you'll need to use its REG file to properly register it. This REG file includes the Control key but does not include a ToolboxBitmap entry or mark Polyline with any of the control-specific MiscStatus flags.</P>
<P>These limitations do not mean that Polyline demonstrates nothing of interest. It already supports the connection point mechanism for outgoing interfaces, for example, which we added in Chapter 5. Polyline also demonstrates the handling of both storage-based and stream-based persistence, a feature we added in Chapter 8. Of course, it already implements <I>IDataObject</I>, <I>IViewObject2</I>, <I>IOleObject</I>, <I>IOleInPlaceObject</I>, <I>IOleInPlaceActiveObject</I>, <I>IRunnableObject</I>, <I>IExternalConnection</I>, and <I>IOleCache2</I>. To Polyline's existing implementation, I've added the features listed on the following pages; implementation of the additional interfaces can be found in CONTROL.CPP.</P>
<P>Polyline now supports OLE Automation through a dispinterface named <I>DIPolylineControl</I>. This interface exposes the properties <I>BackColor</I>, <I>LineColor</I>, and <I>LineStyle</I>, with the custom methods <I>Clear </I>and <I>RemoveLastPoint</I>. These properties and methods reflect the relevant parts of the custom interface <I>IPolyline10</I>, which Polyline has carried throughout much of this book. This dispinterface is implemented using a custom interface, <I>IPolylineControl</I>,<I> </I>which is now another custom interface alongside <I>IPolyline10. </I>The addition of automation support, of course, means that Polyline also has type information. This is described in POLYLINE.ODL and exposed through the addition of <I>IProvide</I><I>ClassInfo</I>.</P>
<P>Polyline has always supported a custom outgoing interface named <I>IPolylineAdviseSink10</I>, with members such as <I>OnPointChange </I>and <I>OnColorChange.</I> For the purposes of becoming a control, a dispatch version of this interface, <I>DIPolylineAdviseSink10</I>, is defined in POLYLINE.ODL and is marked as the default source interface for the control. This interface is Polyline's primary event set. <I>IPolylineAdviseSink10 </I>is itself marked as a source interface.</P>
<P>Polyline implements <I>ISpecifyPropertyPages </I>through which it returns only CLSID_PolylinePropPage (INC\BOOKGUID.H). This property page, shown in Figure 24-5, is implemented in CHAP24\POLYPROP and is structurally identical to the Beeper property page sample from Chapter 16. PolyProp simply uses a different set of controls and communicates with a different object. In particular, the property page applies changes through Polyline's custom interface, <I>IPolylineControl</I>. (This interface is also used to implement Polyline's incoming dispinterface through <I>ITypeInfo::Invoke.</I>)</P>
<P><img src="f24dd05p.gif"></P>
<P><B>Figure 24-5.</B></P>
<P><B>Polyline</B><B>'</B><B>s property page.</B></P>
<P>Polyline now supports a Properties verb in <I>IOleObject::DoVerb </I>(IOLEOBJ.CPP), which first attempts to call <I>IOleControlSite::ShowPropertyFrame.</I> Failing that, Polyline displays its own property page by calling <I>OleCreatePropertyFrame</I>. Polyline supports not only OLEIVERB_PROPERTIES but also its own custom verb with the text "Properties…". It does this because the standard Properties verb has a negative value and will therefore not show up on verb menus by design.</P>
<P>Polyline implements <I>IOleControl </I>to round out its set of interfaces. Polyline has no accelerators, so <I>OnMnemonic </I>does nothing and <I>GetControlInfo</I> returns a structure containing no accelerators at all. However, Polyline does support event freezing and does reload ambient properties in <I>OnAmbientPropertyChange.</I></P>
<P>On creation, Polyline retrieves the ambient properties <I>BackColor</I> and <I>Fore</I><I>Color</I> (which are applied to the line color) along with <I>UIDead </I>and <I>ShowHatching</I>. Polyline's implementation of <I>IOleControl::OnAmbientPropertyChange </I>will reload <I>UIDead </I>and<I> ShowHatching</I> when they change. The function <I>CPolyline::AmbientGet </I>is simply a wrapper for <I>IDispatch::Invoke(</I><I>…</I><I>, DISP</I><I>ATCH</I><I>_</I><I>PROPERTYGET,</I><I>…</I><I>)</I>, which is<I> </I>called on the container's ambient properties dispatch interface. The function <I>CPolyline::AmbientsInitialize </I>retrieves ambient properties and updates <I>CPolyline </I>variables as necessary. This latter function is called from within <I>IOleObject::SetClientSite</I>—in which the control first becomes aware of its container—and from within <I>IOleControl::OnAmbientPropertyChange </I>when it is called with DISPID_UNKNOWN.</P>
<P>Polyline supports the <I>UIDead </I>ambient property by ignoring WM_LBUTTONDOWN and WM_COMMAND messages that come into <I>PolyWndProc </I>(POLYWIN.CPP).</P>
<P>To support the <I>ShowHatching </I>ambient property, Polyline tells its hatch window, <I>CHatchWin</I> (implemented in CLASSLIB), to show or hide its hatching by calling <I>CHatchWin::ShowHatch</I>. To hide hatching, the hatch window resizes itself so that it is the same exact size of the Polyline window it contains. This effectively hides the hatching. When told to show hatching again, the hatch window resizes itself to be slightly larger than the Polyline window within it, effectively making that hatch border visible once again.</P>
<P>Polyline implemented its outgoing dispinterface for events by playing a little trick on the rest of its code. In a number of places in its source code, Polyline is written to send notifications through its custom interface <I>IPolylineAdviseSink10</I>. Since Chapter 5, this interface was the only one supported through <I>IConnectionPointContainer. </I>In making Polyline an OLE control, I had to add support for another outgoing interface that would call the container's <I>IDispatch::Invoke</I>. To do this, I added a class, <I>CAdvi</I><I>seRouter </I>(CONTROL.CPP), that implements the custom interface <I>IPolylineAdviseSink10</I>. When members of that interface are called, <I>CAdviseRouter </I>turns around and calls <I>IDispatch::Invoke. </I>So when a control container asks to hook up its own event sink to Polyline, we simply give that sink's <I>IDispatch</I> pointer to an instance of <I>CAdviseRouter</I> and install that object as the sink that the rest of Polyline's code will notify. Not only was I able to make this change without modifying most of Polyline's existing code, but I also had a central place (<I>CAdviseRouter::Invoke</I>) to detect whether events were frozen (as flagged in the variable <I>CPolyline::m</I><I>_</I><I>fFreezeEvents</I>). If events are frozen, this notification router object will not bother to call the container, discarding the event instead.</P>
<P>We have seen almost all of the other features in one capacity or another in previous chapters, so there is little else for us to discuss. Polyline illustrates how an OLE control really brings many of the separate OLE technologies into one coherent package. An OLE control is the combination of a COM object with incoming and outgoing interfaces, a persistent object with multiple persistence models, a data object, a viewable object (that supports caching), an automation object with type information, an object with property pages, an embeddable in-place–capable content object, and an implementation of <I>IOleControl </I>to round out the feature set.</P>
<P>Technically speaking, an OLE control is rather complex. With all those interfaces and the protocols that a control must obey, you might think that controls would be fat and slow. On the contrary, Microsoft's engineers have found that an OLE control will consistently outperform a similar control written using straight Windows SDK techniques or using the VBX standard. The primary reason is that interface function calls, especially between a container and an in-process control, are almost always faster than sending or posting messages to a window. This really makes a difference in the core operations of a control: sending events, manipulating properties, and receiving method calls from a container. All of these operations have used Windows messages in the past. With OLE Controls, these operations are accomplished through <I>IDispatch::Invoke</I>, which is faster overall. Certainly, other aspects of OLE Controls are slower—creation, for example—but what matters most is run-time performance once the control is loaded.</P>
<P>These performance gains, combined with the benefits of multiple interfaces, licensing, self-registration, object-controlled persistence, and all of the other features we've seen, promises to make OLE Controls the control standard for the future. Microsoft is hedging its bets on this technology in many areas of its business, and as time goes by we'll see that OLE Controls will become even more powerful, more flexible, and more pervasive. It is a technology to watch, along with the rest of OLE.</P></font></body></HTML>
