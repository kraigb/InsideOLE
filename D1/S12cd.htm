<HTML><HEAD><TITLE>IOleLink and the Links Dialog</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IOleLink </I>and the Links Dialog</H3><P>The <I>IOleLink </I>interface is the essence of linked objects. It defines what a linked object can do differently from an embedded object.</P>
<P><BR></P>
<pre><code>interface IOleLink : IUnknown<BR>    {<BR>    HRESULT SetUpdateOptions(DWORD dwUpdateOpt);<BR>    HRESULT GetUpdateOptions(DWORD *pdwUpdateOpt);<BR><BR>    HRESULT SetSourceMoniker(IMoniker  *pmk, REFCLSID rclsid);<BR>    HRESULT GetSourceMoniker(IMoniker **ppmk);<BR><BR>    HRESULT SetSourceDisplayName(LPCOLESTR pszStatusText);<BR>    HRESULT GetSourceDisplayName(LPOLESTR *ppszDisplayName);<BR><BR>    HRESULT BindToSource(DWORD bindflags, IBindCtx *pbc);<BR>    HRESULT BindIfRunning(void);<BR><BR>    HRESULT GetBoundSource(IUnknown **ppunk);<BR>    HRESULT UnbindSource(void);<BR>    HRESULT Update(IBindCtx *pbc);<BR>    };</code></pre>
<P>With what you know about monikers, you can probably guess what half of these functions do. Both <I>SetSourceMoniker </I>and <I>GetSourceMoniker</I> allow the container to change the link,<I> </I>which is necessary if the link is broken. <I>SetSourceDisplayName </I>and <I>GetSourceDisplayName </I>are more or less wrappers for <I>MkParseDisplayName </I>and <I>IMoniker::GetDisplayName</I>. <I>BindToSource </I>is a wrapper for<I>IMoniker::BindToObject</I>, and <I>BindIfRunning </I>first checks the running object table and binds only if the moniker is already there. <I>GetBoundSource </I>extracts a running object's pointer from the running object table, and <I>UnbindSource </I>simply disconnects the linked object from a running object to stop the flow of automatic updates.</P>
<P><I>SetUpdateOptions </I>and <I>GetUpdateOptions </I>deal with the flags OLEUPDATE_ALWAYS and OLEUPDATE_ONCALL, which are mutually exclusive. OLEUPDATE_ALWAYS means that the link is an <I>automatic</I> or <I>hot link,</I> a link for which changes in the source are reflected in the linked object's presentation in the container. In other words, the linked object will actively send <I>IAdviseSink::OnViewChange </I>notifications to the container when this option is set. OLEUPDATE_ONCALL makes a <I>manual</I> or <I>warm link.</I> Here the user must manually ask to update the linked object's presentation. This is exactly what <I>IOleLink::Update </I>is for.</P>
<P>Almost all code that calls this interface is concentrated in the standard Links dialog, shown in Figure 20-4. Using this dialog, the user can view the links in the compound document, modify the update options, force an update, run the server and have it open the linked data, change the moniker (by entering a new display name in a File Open type of dialog), or even break the link entirely, converting the linked object to a static one.</P>
<P>    <img src="f20dd04p.gif"></P>
<P><B>Figure 20-4.</B></P>
<P><B>The standard Links dialog box provided by the OLE UI Library.</B></P>
<P>The majority of a container's linking support is found in its support for this dialog. What isn't there, besides linked object creation and the Show Objects command, are two other conveniences for the end user. First, when opening a compound document, the container should update, if necessary, all linked objects marked OLEUPDATE_ALWAYS, displaying the Links dialog box if one or more of those links cannot be updated. The second convenience is that the container should ensure that all linked objects are automatically reconnected to their running sources, if possible, by calling <I>IOleLink::BindIfRunning </I>when loading those linked objects.</P>
<P>I said "update, if necessary," so how does OLE or a container determine whether a linked object is actually up-to-date with its source? This is probably the hardest problem to solve as far as linking is concerned. Also, with today's operating systems, in which we have at best file time stamps with which to guess when data might have changed, the solution is imperfect. Determining whether a linked object is up-to-date can be as expensive as simply updating it anyway. It is often necessary to run the source server itself and ask it about the update status.</P>
<P>That aside, most of the container's handling of a linked object is otherwise identical to its handling of an embedded object. Linked objects have verbs that are the same as any others, and activating the object results in the same thing. Activation, however, occurs through moniker binding; specifically, the default link handler calls the moniker's <I>BindToObject </I>and asks for <I>IOleObject</I>. Through this interface, it can then ask the object to execute a verb. If for some reason the link is broken, however, the binding process will fail, and the user has to repair the link.</P></font></body></HTML>
