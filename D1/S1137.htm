<HTML><HEAD><TITLE>Implementing a Connectable (Source) Object</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implementing a Connectable (Source) Object</H3><P>The complete implementation of a source with even a single connection point is a little more complicated than the implementation of a sink because several different independent objects are on the scene. Each C++ class for the object part of the Connect sample is defined in OBJECT.H. Those dealing with the object as a whole are implemented in OBJECT.CPP, and those dealing with connection points themselves are in CONNPT.CPP. Each object class singly inherits from the interface it implements, as follows:</P>
<UL><LI>The connectable object, in this case <I>CConnObject</I>, provides <I>IConnectionPointContainer</I> and maintains a reference count and an array of <I>CConnectionPoint </I>pointers (see the third item) in <I>m</I><I>_</I><I>rgpConnPt. </I>It has a member function named <I>TriggerEvent </I>that is called from <I>ConnectWndProc </I>when any Trigger menu item is selected. In the Connect sample, this object manages only a single connection point, but the code is written to handle an array of such contained objects for your reference.</LI><LI>The enumerator created from <I>IConnectionPointContainer::EnumConnectionPoints </I>is implemented using <I>CEnumConnectionPoints</I>, a typical enumerator implementation that deals with the type <I>IConnectionPoint </I>*. This is written to manage an arbitrarily large array of pointers.</LI><LI>Each connection point (of which there is only one in this sample at any time) is an instance of the generic class named <I>CConnectionPoint</I>. This class manages an array of <I>IUnknown </I>pointers passed to it through <I>IConnectionPoint::Advise </I>and is completely generic (that is, it contains nothing specific to any outgoing interface). Its one limitation is that it fixes the number of allowed connections at compile time (to the constant CCONNMAX) instead of dynamically allocating space to store connection information. In any case, it is written to be quite usable in your own work.</LI><LI>The enumerator created from <I>IConnectionPoint::EnumConnections</I> is implemented using <I>CEnumConnections</I>, another typical enumerator based on the OLE-defined type CONNECTDATA that contains an <I>IUnknown </I>pointer and a DWORD connection key—everything needed to describe any single connection.</LI></UL><P>The following sections look at each piece of the implementation in more detail.</P>
<H4><A NAME="sec0"></A>The Source Object</H4><P>We've seen how the client side of the Connect sample creates an instance of <I>CConnObject</I>,<I> </I>to which it later makes connections. It instantiates the connection points (only one of them in this case, defined by the constant CCONNPOINTS) during initialization in <I>CConnObject::Init</I>:</P>
<P><BR></P>
<pre><code>BOOL CConnObject::Init(void)<BR>    {<BR>    UINT    i;<BR><BR>    //Create our connection points.<BR>    for (i=0; i &lt; CCONNPOINTS; i++)<BR>        {<BR>        m_rgpConnPt[i]=new CConnectionPoint(this, IID_IDuckEvents);<BR><BR>        if (NULL==m_rgpConnPt[i])<BR>            return FALSE;<BR><BR>        m_rgpConnPt[i]-&gt;AddRef();<BR>        }<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>Remember that external clients must always see these contained connection points as separate objects, which means that your source's <I>QueryInterface </I>never returns a pointer to these connection points, even if some client asks for <I>IConnectionPoint</I>. In the Connect sample, <I>CConnObject::QueryInterface</I> responds only to <I>IUnknown </I>and <I>IConnectionPointContainer.</I> If you have only a single connection point in your object, you can cheat and implement <I>IConnectionPoint </I>as an interface of the whole object itself, provided you supply the proper <I>QueryInterface </I>behavior through all the interfaces. (You can share <I>AddRef </I>and <I>Release </I>implementations as long as they all affect a single reference count.) But I find it more explicit (and easier for you to understand) to keep them as separate objects.</P>
<P>The implementation of <I>IConnectionPointContainer </I>is now simply a matter of returning pointers from the <I>m</I><I>_</I><I>rgpConnPt</I> array either singly through <I>FindConnectionPoint </I>or as a set through <I>EnumConnectionPoints.</I> The first approach is simplest. Using it, you query the connection point for its <I>IConnectionPoint</I>, which has the added and desirable effect of calling <I>AddRef </I>on that pointer:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CConnObject::FindConnectionPoint(REFIID riid<BR>    , IConnectionPoint **ppCP)<BR>    {<BR>    *ppCP=NULL;<BR><BR>    if (IID_IDuckEvents==riid)<BR>        {<BR>        return m_rgpConnPt[0]-&gt;QueryInterface(IID_IConnectionPoint<BR>            , (PPVOID)ppCP);<BR>        }<BR><BR>    return ResultFromScode(E_NOINTERFACE);<BR>    }</code></pre>
<P>You can see how easily this code would expand to serve additional connection points, by adding additional conditions for other IIDs. <I>EnumConnectionPoints</I>, however, is a little more involved. We have to instantiate the enumerator by giving it copies of all the pointers:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CConnObject::EnumConnectionPoints<BR>    (LPENUMCONNECTIONPOINTS *ppEnum)<BR>    {<BR>    IConnectionPoint       *rgCP[CCONNPOINTS];<BR>    UINT                    i;<BR>    PCEnumConnectionPoints  pEnum;<BR><BR>    *ppEnum=NULL;<BR><BR>    for (i=0; i &lt; CCONNPOINTS; i++)<BR>        rgCP[i]=(IConnectionPoint *)m_rgpConnPt[i];<BR><BR>    //Create the enumerator:  we have only one connection point.<BR>    pEnum=new CEnumConnectionPoints(this, CCONNPOINTS, rgCP);<BR><BR>    if (NULL==pEnum)<BR>        return ResultFromScode(E_OUTOFMEMORY);<BR><BR>    pEnum-&gt;AddRef();<BR>    *ppEnum=pEnum;<BR>    return NOERROR;<BR>    }</code></pre>
<P>The constructor for <I>CEnumConnectionPoints </I>takes a pointer to the object (for reference counting), a pointer to the number of connection points in the enumeration (in this case only one, but the enumerator is generic to handle any number), and a pointer to an array of <I>IConnectionPoint </I>pointers. The constructor makes a copy of this array and keeps a reference count on each connection point and is released in the destructor, as shown on the following page.</P>
<P><BR></P>
<pre><code>CEnumConnectionPoints::CEnumConnectionPoints(LPUNKNOWN pUnkRef<BR>    , ULONG cPoints, IConnectionPoint **rgpCP)<BR>    {<BR>    UINT        i;<BR><BR>    m_cRef=0;<BR>    m_pUnkRef=pUnkRef;<BR><BR>    m_iCur=0;<BR>    m_cPoints=cPoints;<BR>    m_rgpCP=new IConnectionPoint *[(UINT)cPoints];<BR><BR>    if (NULL!=m_rgpCP)<BR>        {<BR>        for (i=0; i &lt; cPoints; i++)<BR>            {<BR>            m_rgpCP[i]=rgpCP[i];<BR>            m_rgpCP[i]-&gt;AddRef();<BR>            }<BR>        }<BR><BR>    return;<BR>    }<BR><BR>CEnumConnectionPoints::~CEnumConnectionPoints(void)<BR>    {<BR>    if (NULL!=m_rgpCP)<BR>        {<BR>        UINT        i;<BR><BR>        for (i=0; i &lt; m_cPoints; i++)<BR>            m_rgpCP[i]-&gt;Release();<BR><BR>        delete [] m_rgpCP;<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>To ensure that the object whose connection points are being enumerated sticks around as long as the enumerator itself, any <I>AddRef </I>or <I>Release </I>call to the enumerator is forwarded to the object as well. Circular references don't occur, however, because the object doesn't hold any reference to the enumerator; that responsibility belongs to the client.</P>
<P>One final remark about this enumerator: because it enumerates interface pointers, the reference-counting rules stipulate that any pointer returned from the <I>Next </I>member receives a reference count as well. Keep this in mind when you implement and use pointer enumerators. As far as <I>CEnumConnection </I>is concerned, the <I>Next </I>function has to call <I>AddRef </I>for any pointer it's about to return:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CEnumConnectionPoints::Next(ULONG cPoints<BR>    , IConnectionPoint **ppCP, ULONG *pulEnum)<BR>    {<BR>    ULONG               cReturn=0L;<BR><BR>    [Validation code omitted]<BR><BR>    while (m_iCur &lt; m_cPoints &amp;&amp; cPoints &gt; 0)<BR>        {<BR>        *ppCP=m_rgpCP[m_iCur++];<BR><BR>        if (NULL!=*ppCP)<BR>            (*ppCP)-&gt;AddRef();<BR><BR>        ppCP++;<BR>        cReturn++;<BR>        cPoints--;<BR>        }<BR><BR>    [Other code omitted]<BR>    return NOERROR;<BR>    }</code></pre>
<P>So besides the typical <I>IUnknown </I>members, that's all there is to <I>IConnectionPointContainer</I>. Even with the enumerator, the implementation is not terribly involved, not terribly difficult, nor terribly tricky.</P>
<H4><A NAME="sec1"></A>The Connection Point Object</H4><P>Creating an object to implement a connection point is really no more complicated than creating a connection point container, as you can see in the implementation of <I>CConnectionPoint</I>,<I> </I>found in CONNPT.CPP. Let's first look at the definition of this class in OBJECT.H:</P>
<P><BR></P>
<pre><code>class CConnectionPoint : public IConnectionPoint<BR>    {<BR>    private:<BR>        ULONG           m_cRef;     //Object reference count<BR>        PCConnObject    m_pObj;     //Containing object<BR>        IID             m_iid;      //Our relevant interface<BR><BR>        IUnknown       *m_rgpIUnknown[CCONNMAX];<BR>        DWORD           m_rgdwCookies[CCONNMAX];<BR><BR>        UINT            m_cConn;<BR>        DWORD           m_dwCookieNext; //Counter<BR><BR>    [Constructor, destructor, IConnectionPoint members omitted]<BR>    };</code></pre>
<P>This implementation of a connection point, as I mentioned before, is slightly crippled because it is limited to maintaining a fixed number of connections determined at compile time through the CCONNMAX value. In the Connect sample, the number is two because that's all we'll need. A really robust and flexible connection point should maintain some kind of variable-length list for maintaining connections, if it needs to. But if your design won't require as many connections, feel free to limit their number as necessary.</P>
<P><I>CConnectionPoint </I>also maintains the IID (<I>m</I><I>_</I><I>iid</I>) that it can connect to, the <I>IUnknown </I>interface pointers it receives through <I>Advise</I> (<I>m</I><I>_</I><I>rgpIUnknown</I>), the connection cookies assigned to them (<I>m</I><I>_</I><I>rgdwCookies</I>), the current number of connections (<I>m</I><I>_</I><I>cConn</I>), and the cookie to assign in the next <I>Advise </I>call (<I>m</I><I>_</I><I>dwCookieNext</I>). The variable <I>m</I><I>_</I><I>dwCookieNext </I>is basically a counter that starts at some arbitrary value (100) and is incremented in every <I>Advise </I>call. This increment is not by itself thread safe, and it must be controlled with a semaphore if you are planning to do multithreaded work. Remember also that none of these variables—and nothing in this object class or its associated enumerator—are specific to <I>IDuckEvents</I>, making this a nicely usable class in whatever connection point implementations you might run into.</P>
<P>Now, besides the ubiquitous <I>IUnknown </I>members, which have yet another typical implementation, we have five connection point–specific members. The first two, <I>GetConnectionInterface </I>and <I>GetConnectionPointContainer</I>, are trivial:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID)<BR>    {<BR>    if (NULL==pIID)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    *pIID=m_iid;<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CConnectionPoint::GetConnectionPointContainer<BR>    (IConnectionPointContainer **ppCPC)<BR>    {<BR>    return m_pObj-&gt;QueryInterface(IID_IConnectionPointContainer<BR>        , (void **)ppCPC);<BR>    }</code></pre>
<P><I>QueryInterface </I>works nicely in <I>GetConnecti</I><I>onPointContainer</I> because it retrieves the pointer, calls <I>AddRef</I>, and returns an HRESULT in one stroke. The <I>m</I><I>_</I><I>iid </I>value returned from <I>GetConnectionInterface</I> is actually stored in the <I>CConnectionPoint </I>constructor as it is passed from the source that creates this connection point. This is another means of making this implementation generic.</P>
<P>The <I>Advise</I> function, which receives an <I>IUnknown </I>pointer to the sink to connect,<I> </I>now executes the following steps:</P>
<P>Checks that there is space for another connection if space is limited. If there is no space, returns CONNECT_E_ADVISELIMIT. Otherwise, adds another space to whatever list the connection point maintains.</P>
<P>Queries the sink's <I>IUnknown</I> interface for the expected outgoing interface, which is identified in this implementation with <I>m</I><I>_</I><I>iid</I>. If this fails, returns CONNECT_E_CANNOTCONNECT. Otherwise, you have a pointer, at least an <I>IUnknown </I>pointer, with a reference count on it that you can store. (The implementation doesn't actually need to know the outgoing interface type; it can treat the result of the query as an <I>IUnknown</I>, which is perfectly safe.)</P>
<P>Finds an open space in whatever connection list this connection point maintains and stores the pointer from step 2. This pointer already has an <I>AddRef </I>on it, so there's no need for another.</P>
<P>Stores a new unique cookie in the out-parameter named <I>pdwCookie</I>. You should remember the value stored here along with the pointer saved in step 3 so you can correctly match the cookie to the pointer in <I>Unadvise </I>later on.</P>
<P>Increments your connection count and returns NOERROR.</P>
<P>We can see this process implemented in <I>CConnectionPoint::Advise</I>, as shown on the following page.</P>
<P><BR></P>
<pre><code>STDMETHODIMP CConnectionPoint::Advise(LPUNKNOWN pUnkSink<BR>    , DWORD *pdwCookie)<BR>    {<BR>    UINT            i;<BR>    IUnknown       *pSink;<BR><BR>    *pdwCookie=0;<BR><BR>    //Check whether we're already full of sink pointers.<BR>    if (CCONNMAX==m_cConn)<BR>        return ResultFromScode(CONNECT_E_ADVISELIMIT);<BR><BR>    if (FAILED(pUnkSink-&gt;QueryInterface(m_iid, (PPVOID)&amp;pSink)))<BR>        return ResultFromScode(CONNECT_E_CANNOTCONNECT);<BR><BR>    for (i=0; i &lt; CCONNMAX; i++)<BR>        {<BR>        if (NULL==m_rgpIUnknown[i])<BR>            {<BR>            m_rgpIUnknown[i]=pSink;<BR>            m_rgdwCookies[i]=++m_dwCookieNext;<BR>            *pdwCookie=m_dwCookieNext;<BR>            break;<BR>            }<BR>        }<BR><BR>    m_cConn++;<BR>    return NOERROR;<BR>    }</code></pre>
<P>Here again, the code to increment the cookie counter, <I>m</I><I>_</I><I>rgdwCookies[i]- </I><I>=++</I><I>m</I><I>_</I><I>dwCookieNext</I>, is not thread safe. Also, this counter, which is initialized to 100, is a DWORD and doesn't have much chance of rolling over anytime soon, so it's not anything to worry about. Finally, you might think that the sink pointer value itself might be a great way to uniquely identify the sink and be tempted to return it as the cookie. Bad idea. It is possible that a connection point is given the same exact interface pointer for the sink more than once. The connection point cannot make any assumptions about this sort of thing, especially because the pointer could be for a proxy that is talking to an out-of-process object elsewhere. A pointer value is not necessarily unique, so a counter is the easiest solution, albeit not entirely perfect.<I> </I>I hope that we're not still using the same instance of an object by the time it's made more than 4 billion connections!</P>
<P>Now that we've seen how <I>Advise </I>stores a pointer and a cookie, <I>Unadvise</I>, which receives a cookie as an argument,<I> </I>needs to find the matching pointer, release it, clear out that entry in the connection list, and decrement the connection count:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)<BR>    {<BR>    UINT        i;<BR><BR>    if (0==dwCookie)<BR>        return ResultFromScode(E_INVALIDARG);<BR><BR>    for (i=0; i &lt; CCONNMAX; i++)<BR>        {<BR>        if (dwCookie==m_rgdwCookies[i])<BR>            {<BR>            ReleaseInterface(m_rgpIUnknown[i]);<BR>            m_rgdwCookies[i]=0;<BR>            m_cConn--;<BR>            return NOERROR;<BR>            }<BR>        }<BR><BR>    return ResultFromScode(CONNECT_E_NOCONNECTION);<BR>    }</code></pre>
<P>The <I>ReleaseInterface </I>macro is found in INC\INOLE.H. This macro calls <I>Release </I>through the given pointer and sets that pointer to NULL.</P>
<P>What's left to see in the <I>&nbsp;</I><I>IConnectionPoint </I>interface is <I>EnumConnections. </I>The enumerator created through this function deals with OLE's CONNECTDATA:</P>
<P><BR></P>
<pre><code>typedef struct tagCONNECTDATA<BR>    {<BR>    LPUNKNOWN pUnk;<BR>    DWORD dwCookie;<BR>    } CONNECTDATA;</code></pre>
<P>Everything you'd want to know about a connection! Anyway, the implementation of <I>EnumConnections</I> creates an array of such structures, and then it passes that array to the constructor for <I>CEnumConnections</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CConnectionPoint::EnumConnections<BR>    (LPENUMCONNECTIONS *ppEnum)<BR>    {<BR>    LPCONNECTDATA       pCD;<BR>    UINT                i, j;<BR>    PCEnumConnections   pEnum;<BR><BR>    *ppEnum=NULL;<BR><BR>    if (0==m_cConn)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    pCD=new CONNECTDATA[(UINT)m_cConn];<BR><BR>    if (NULL==pCD)<BR>        return ResultFromScode(E_OUTOFMEMORY);<BR><BR>    for (i=0, j=0; i &lt; CCONNMAX; i++)<BR>        {<BR>        if (NULL!=m_rgpIUnknown[i])<BR>            {<BR>            pCD[j].pUnk=(LPUNKNOWN)m_rgpIUnknown[i];<BR>            pCD[j].dwCookie=m_rgdwCookies[i];<BR>            j++;<BR>            }<BR>        }<BR><BR>    pEnum=new CEnumConnections(this, m_cConn, pCD);<BR>    delete [] pCD;<BR><BR>    if (NULL==pEnum)<BR>        return ResultFromScode(E_OUTOFMEMORY);<BR><BR>    //This does an AddRef for us.<BR>    return pEnum-&gt;QueryInterface(IID_IEnumConnections, (PPVOID)ppEnum);<BR>    }</code></pre>
<P>Be aware that the array passed to <I>CEnumConnections </I>is only temporary and that the connection point itself doesn't call <I>AddRef </I>on any of the pointers. This is because the enumerator will make a complete copy of this array in its own constructor, as you can see in the following code.</P>
<P><BR></P>
<pre><code>CEnumConnections::CEnumConnections(LPUNKNOWN pUnkRef, ULONG cConn<BR>    , LPCONNECTDATA prgConnData)<BR>    {<BR>    UINT        i;<BR><BR>    m_cRef=0;<BR>    m_pUnkRef=pUnkRef;<BR><BR>    m_iCur=0;<BR>    m_cConn=cConn;<BR><BR>    m_rgConnData=new CONNECTDATA[(UINT)cConn];<BR><BR>    if (NULL!=m_rgConnData)<BR>        {<BR>        for (i=0; i &lt; cConn; i++)<BR>            {<BR>            m_rgConnData[i]=prgConnData[i];<BR>            m_rgConnData[i].pUnk-&gt;AddRef();<BR>            }<BR>        }<BR><BR>    return;<BR>    }<BR><BR>CEnumConnections::~CEnumConnections(void)<BR>    {<BR>    if (NULL!=m_rgConnData)<BR>        {<BR>        UINT        i;<BR><BR>        for (i=0; i &lt; m_cConn; i++)<BR>            m_rgConnData[i].pUnk-&gt;Release();<BR><BR>        delete [] m_rgConnData;<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>Why go to all the trouble to make a copy? Because of the <I>IEnumConnections::Clone</I> member. Any clone of this enumerator needs its own copy in case the first enumerator is released before this clone or any later clone. Because this implementation doesn't tie all clones together with a common reference count, a copy is necessary.</P>
<P>Finally, like the <I>Next </I>function in <I>CEnumConnectionPoints </I>shown earlier, the <I>Next </I>function in this enumerator also needs to call <I>AddRef </I>on the pointers in each CONNECTDATA<I> </I>structure it enumerates:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CEnumConnections::Next(ULONG cConn<BR>    , LPCONNECTDATA pConnData, ULONG *pulEnum)<BR>    {<BR>    [Other code omitted]<BR><BR>    while (m_iCur &lt; m_cConn &amp;&amp; cConn &gt; 0)<BR>        {<BR>        *pConnData++=m_rgConnData[m_iCur];<BR>        m_rgConnData[m_iCur++].pUnk-&gt;AddRef();<BR>        cReturn++;<BR>        cConn--;<BR>        }<BR><BR>    [Other code omitted]<BR>    return NOERROR;<BR>    }</code></pre>
<P>This is a complete connection point implementation. How then can we use this implementation to assist in firing events?</P>
<H4><A NAME="sec2"></A>Triggering Events</H4><P>I mentioned earlier that the Connect sample makes some compromises because the client, the object, and the sink are all part of the same program. The primary reason for these compromises is that in order for events to be demonstrated, something has to trigger them. In real sources, triggers are usually events that happen to the object directly, such as a mouse click in a window, a change in some data, or an event or a notification sent from some other source altogether. In this sample, however, the triggers are menu items that come as WM_COMMAND messages into the main <I>ConnectWndProc</I> function. To turn these messages into events, <I>ConnectWndProc </I>calls <I>CConnObject::TriggerEvent</I>, passing an ID of the event that has been triggered. Again, an actual client-object relationship in OLE would not have this kind of a C++ mechanism; it could, however, call a trigger function that is part of some other incoming interface on the source. That's perfectly legal.</P>
<P>Regardless of how the trigger reaches the source, the source has to call each and every connected sink that is interested in the corresponding event. This is a perfect time for the source to call <I>IConnectionPoint::EnumConnections </I>on the appropriate connection point. It can iterate over each <I>IUnknown </I>pointer in the CONNECTDATA structures, query each pointer for the right outgoing interface, call the appropriate member function, and then call <I>Release </I>on that pointer as well as on the <I>IUnknown</I> pointer in the CONNECTDATA structures. We can see this exact process in <I>CConnObjec</I><I>t::TriggerEvent</I>,<I> </I>which can fire any of the three events in <I>IDuckEvents</I>:</P>
<P><BR></P>
<pre><code>BOOL CConnObject::TriggerEvent(UINT iEvent)<BR>    {<BR>    IEnumConnections   *pEnum;<BR>    CONNECTDATA         cd;<BR><BR>    if (FAILED(m_rgpConnPt[0]-&gt;EnumConnections(&amp;pEnum)))<BR>        return FALSE;<BR><BR>    while (NOERROR==pEnum-&gt;Next(1, &amp;cd, NULL))<BR>        {<BR>        IDuckEvents    *pDuck;<BR><BR>        if (SUCCEEDED(cd.pUnk-&gt;QueryInterface(IID_IDuckEvents<BR>            , (PPVOID)&amp;pDuck)))<BR>            {<BR>            switch (iEvent)<BR>                {<BR>                case EVENT_QUACK:<BR>                    pDuck-&gt;Quack();<BR>                    break;<BR><BR>                case EVENT_FLAP:<BR>                    pDuck-&gt;Flap();<BR>                    break;<BR><BR>                case EVENT_PADDLE:<BR>                    pDuck-&gt;Paddle();<BR>                    break;<BR>                }<BR><BR>            pDuck-&gt;Release();<BR>            }<BR><BR>        cd.pUnk-&gt;Release();<BR>        }<BR><BR>    pEnum-&gt;Release();<BR>    return TRUE;<BR>    }</code></pre>
<P>It is likely that any source will have some similar sort of event-triggering mechanism for the rest of its code to call when the right things happen. You could also make a custom interface for your own internal use with a bunch of member functions named <I>Fire&lt;EventName&gt;</I>. This is especially useful when your events also have arguments. A simple dispatching function such as <I>TriggerEvent</I> doesn't allow for arguments to the events, although separate functions to each event would. This is all quite unimportant, however, because the key to working with connection points is calling the right member function of any connected sink. That's what makes integration work.</P></font></body></HTML>
