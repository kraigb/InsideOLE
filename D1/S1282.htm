<HTML><HEAD><TITLE>Using and Implementing IPropertyNotifySink</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Using and Implementing <I>IPropertyNotifySink</I></H2><P>An interface as simple as <I>IPropertyNotifySink </I>is not that complicated to work with in code. In fact, the bulk of the code within this interface exists for the purpose of working with <I>IConnectionPointContainer </I>and <I>IConnectionPoint</I>,<I> </I>as we saw in Chapter 4. The samples AutoCli2 (CHAP16\AUTOCLI2) and Beeper6 (CHAP16\BEEPER6) provide a quick demonstration of this interface. (Be sure to register Beeper6 before running AutoCli2.) Beeper6 is a modification of Beeper2 from Chapter 14. The first change is to include a few of the necessary flags in type information, as we can see in BEEP0000.ODL, where the interface <I>IBeeper </I>is defined:</P>
<P><BR></P>
<pre><code>§<BR>interface IBeeper : IUnknown<BR>    {<BR>    [propget, helpstring("The current sound")<BR>        , bindable, defaultbind, displaybind, requestedit<BR>    ]<BR>        long Sound(void);<BR><BR>    [propput<BR>        , bindable, defaultbind, displaybind, requestedit<BR>    ]<BR>        void Sound([in] long lSound);<BR><BR>    [helpstring("Play the current sound")]<BR>        long Beep(void);<BR>    }</code></pre>
<P>When you define an interface in which specific member functions represent properties, you must mark both <I>propget </I>and <I>propput </I>members with the same attributes. MKTYPLIB will complain that you've defined a duplicate property name otherwise.</P>
<P>Supporting a bindable or request edit property from within the object itself is first a matter of implementing the necessary connection point support. Beeper6 uses the same sort of code that we've seen in other samples (such as CHAP05\POLYLINE). When Beeper6 does have an <I>IPropertyNotifySink </I>pointer in hand, it calls <I>OnRequestEdit </I>and <I>OnChanged </I>as appropriate from within its <I>IBeeper:</I><I>:put</I><I>_</I><I>Sound </I>method (BEEPER.CPP):</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(void) CBeeper::put_Sound(long lSound)<BR>    {<BR>    if (MB_OK!=lSound &amp;&amp; MB_ICONEXCLAMATION!=lSound<BR>        &amp;&amp; MB_ICONQUESTION!=lSound &amp;&amp; MB_ICONHAND!=lSound<BR>        &amp;&amp; MB_ICONASTERISK!=lSound)<BR>        {<BR>        m_pImpIDispatch-&gt;Exception(EXCEPTION_INVALIDSOUND);<BR>        return;<BR>        }<BR><BR>    if (NULL!=m_pIPropNotifySink)<BR>        {<BR>        //If we didn't get permission, stop now.<BR>        if (NOERROR!=m_pIPropNotifySink-&gt;OnRequestEdit(PROPERTY_SOUND))<BR>            return;<BR>        }<BR><BR>    m_lSound=lSound;<BR><BR>    if (NULL!=m_pIPropNotifySink)<BR>        m_pIPropNotifySink-&gt;OnChanged(PROPERTY_SOUND);<BR><BR>    return;<BR>    }</code></pre>
<P>Because the <I>Sound</I> property is marked <I>requestedit</I>, we must first call <I>OnRequestEdit </I>for permission to change. Because the request returns S_OK or S_FALSE, we have to compare the return value against NOERROR directly. If the request is denied, we stop processing at this point and do not change the property at all. Otherwise, we make the change and follow it up with a call to <I>OnChanged.</I></P>
<P>For Beeper6, this is all there is to it. This sample, of course, is simple—more complex components that support <I>IPropertyNotifySink</I> will have many more places where they must make requests and send change notifications. The process of sending the request before changing a property and then sending a notification after changing it, however, is always the same. Remember also that the object can send the request and notification with DISPID_UNKNOWN to specify multiple objects.</P>
<P>On the client side, AutoCli2 provides a sink object with the necessary interface. Its two specific member functions are implemented in AUTOCLI2.CPP as follows, using the class <I>CPropertyNotifySink</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CPropertyNotifySink::OnChanged(DISPID dispID)<BR>    {<BR>    TCHAR       szTemp[200];<BR><BR>    wsprintf(szTemp<BR>        , TEXT("OnChanged notification received for DISPID=%lu")<BR>        , dispID);<BR><BR>    m_pApp-&gt;Message(szTemp);<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CPropertyNotifySink::OnRequestEdit(DISPID dispID)<BR>    {<BR>    TCHAR       szTemp[200];<BR><BR>    wsprintf(szTemp<BR>        , TEXT("OnRequestEdit received for DISPID=%lu"), dispID);<BR>    m_pApp-&gt;Message(szTemp);<BR><BR>    return ResultFromScode(m_pApp-&gt;m_fReadOnly ? S_FALSE : S_OK);<BR>    }</code></pre>
<P>AutoCli2 displays a message in its client area within <I>OnChanged</I> to show that it received the notification. When you change the Beeper object's <I>Sound</I> property from AutoCli2's menu, you'll see change notifications come through. The return value for <I>OnRequestEdit </I>is controlled through another menu item, named Enforce Read-Only, which toggles the value of the <I>m</I><I>_</I><I>fReadOnly </I>flag in the code above. If you activate this option, <I>OnRequestEdit </I>will deny changes, so setting a new sound value in the Beeper object will not actually change anything, and no <I>OnChanged </I>notifications will occur.</P></font></body></HTML>
