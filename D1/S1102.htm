<HTML><HEAD><TITLE>Using an Object in C and C++</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Using an Object in C and C++</H2><P>We're now at the point in this chapter where we've covered the theoretical and mechanical matters and we can take a look at some sample code. This first section will illustrate how to call interface member functions in both C and C++, illuminating the role of a client and the differences between the languages, using the context of COM's memory management facilities. As a prelude to this discussion, we'll also look into basic requirements such as COM initialization for all COM/OLE applications or components that make up a task. The next major section, "Implementing an Object in C and C++," describes an object's perspective on creating interfaces in both languages and introduces the idea of <I>enumerator</I> <I>objects</I>. If you are reading this book to gain an architectural understanding of OLE, you'll want to read the first parts of that section to understand these types of objects and skip the code discussion. The section "Implementing Multiple Interfaces" will examine three different ways in C++ to implement an object with multiple interfaces, giving you some options for your own work. "Implementing Reusability" will illustrate containment and aggregation in the form of sample code. "Interfaces and OLE API Functions" describes the differences among and functionality of the various OLE interfaces and API functions.</P>
<P>So again, this first section is primarily concerned with what it means to be a client in COM and OLE—that is, how one goes about calling interface functions, which is generally relevant to objects as well.</P></font></body></HTML>
