<HTML><HEAD><TITLE>Implement IDataObject</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement <I>IDataObject</I></H3><P>We saw in Chapter 17 how the data cache maintains a presentation cache in the container's storage. Somehow, however, that cache must obtain presentations to store in itself. For that reason, a content object in a local server must implement <I>IDataObject</I>, through which the cache can retrieve rendering in at least the CF_METAFILEPICT format (TYMED_MFPICT) and preferably in CF_DIB (or CF_BITMAP) as well. Technically speaking, implementing <I>IDataObject::GetData </I>for one of these formats is the absolute bare minimum support an object must have for OLE Documents.</P>
<P>An object will, however, also want to support its native data format through both <I>GetData</I> and <I>SetData</I>. A container that knows more about your object might ask for your object's data or might give your object some data to integrate into it. If you don't foresee a reason why someone would want to use <I>GetData</I> or <I>SetData</I> for your private format, you have no reason to support such functionality in <I>IDataObject</I>. One case in which you must support <I>GetData</I> on your native format occurs when you have your own object handler. The object handler can then synchronize its data with that of the local object. (We'll cover this in Chapter 19.)</P>
<P>It is best to also include support for CFSTR_EMBEDSOURCE through both <I>GetData </I>and <I>GetDataHere.</I> In the former, you create a new storage object and save the object's data to it, using your own <I>IPersistStorage::Save </I>if you want. In the latter case, the container has provided a storage object already, so you can save the object directly to it. Either way, you should write your object's exact persistent representation to the storage. A container can use this data to create a new copy of the object, and the storage is passed that new instance through <I>IPersistStorage::Load</I>. You really do want to be sure it's the same data.</P>
<P>Here's how Cosmo's figure handles all supported formats through <I>GetData </I>and <I>GetDataHere</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDataObject::GetData(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM)<BR>    {<BR>    UINT      cf=pFE-&gt;cfFormat;<BR>    BOOL      fRet=FALSE;<BR><BR>    //Another part of us already knows whether the format is good.<BR>    if (NOERROR!=QueryGetData(pFE))<BR>        return ResultFromScode(DATA_E_FORMATETC);<BR><BR>    if (CF_METAFILEPICT==cf œœ CF_BITMAP==cf œœ m_pObj-&gt;m_cf==cf)<BR>        {<BR>        if (CF_METAFILEPICT==cf)<BR>            {<BR>            pSTM-&gt;tymed=TYMED_MFPICT;<BR>            }<BR>        else<BR>            pSTM-&gt;tymed=TYMED_HGLOBAL;<BR><BR>        pSTM-&gt;pUnkForRelease=NULL;<BR>        pSTM-&gt;hGlobal=m_pObj-&gt;m_pDoc-&gt;RenderFormat(cf);<BR>        fRet=(NULL!=pSTM-&gt;hGlobal);<BR>        }<BR>    else<BR>        fRet=m_pObj-&gt;m_pDoc-&gt;RenderMedium(cf, pSTM);<BR><BR>    return fRet ? NOERROR : ResultFromScode(DATA_E_FORMATETC);<BR>    }<BR><BR><BR>STDMETHODIMP CImpIDataObject::GetDataHere(LPFORMATETC pFE<BR>    , LPSTGMEDIUM pSTM)<BR>    {<BR>    UINT    cf;<BR>    LONG    lRet;<BR><BR>    cf=RegisterClipboardFormat(CFSTR_EMBEDSOURCE);<BR><BR>    //Aspect is unimportant to us here, as are lindex and ptd.<BR>    if (cf==pFE-&gt;cfFormat &amp;&amp; (TYMED_ISTORAGE &amp; pFE-&gt;tymed))<BR>        {<BR>        //We have an IStorage we can write to.<BR>        pSTM-&gt;tymed=TYMED_ISTORAGE;<BR>        pSTM-&gt;pUnkForRelease=NULL;<BR>        lRet=m_pObj-&gt;m_pPL-&gt;WriteToStorage(pSTM-&gt;pstg<BR>            , VERSIONCURRENT);<BR><BR>        if (lRet &gt;= 0)<BR>            return NOERROR;<BR><BR>        return ResultFromScode(STG_E_WRITEFAULT);<BR>        }<BR><BR>    return ResultFromScode(DATA_E_FORMATETC);<BR>    }</code></pre>
<P><I>GetDataHere </I>is implemented entirely by calling <I>CPolyline::WriteToStorage</I>—that's all there is to it. In <I>GetData</I>,<I> </I>we use the function <I>CPatronDoc::RenderFormat </I>to generate the necessary rendering. The document turns around and uses code in <I>CPolyline </I>to fulfill the request because the Polyline object already knows how to copy its data into global memory and how to draw itself into metafiles and bitmaps. We can see this in the code on the following page.</P>
<P><BR></P>
<pre><code>HGLOBAL CCosmoDoc::RenderFormat(UINT cf)<BR>    {<BR>    HGLOBAL   hMem;<BR><BR>    if (cf==m_cf)<BR>        {<BR>        m_pPL-&gt;DataGetMem(VERSIONCURRENT, &amp;hMem);<BR>        return hMem;<BR>        }<BR><BR>    switch (cf)<BR>        {<BR>        case CF_METAFILEPICT:<BR>            return m_pPL-&gt;RenderMetafilePict();<BR><BR>        case CF_BITMAP:<BR>            return (HGLOBAL)m_pPL-&gt;RenderBitmap();<BR>        }<BR><BR>    return NULL;<BR>    }</code></pre>
<P>This is another example of how an embedded object implementation can be built on top of existing code. The implementation of <I>SetData </I>is much the same because it passes the data on to <I>CPolyline::DataSetMem</I>.</P>
<P>The other member functions have trivial implementations. <I>GetCanonicalFormatEtc</I> is the standard "all formats are the same" implementation that we saw in Chapter 10. <I>EnumFormatEtc </I>is implemented as follows:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDataObject::EnumFormatEtc(DWORD dwDir<BR>    , LPENUMFORMATETC *ppEnum)<BR>    {<BR>    return ResultFromScode(OLE_S_USEREG);<BR>    }</code></pre>
<P>Because this interface is implemented on a local content object, it is always some part of OLE that is calling us, never the container directly. By returning OLE_S_USEREG, we tell OLE to implement this function for us using our own registry entries. In other words, OLE calls <I>OleRegEnumFormatEtc</I> on our behalf. Things are so easy around here!</P>
<P>Finally, we implement the three amigos—<I>DAdvise</I>, <I>DUnadvise</I>, and <I>EnumDAdvise</I><I>—</I>using an OLE-provided data advise holder. The advise holder is created in <I>DAdvise </I>with <I>CreateDataAdviseHolder. </I>All of these members simply delegate to the advise holder, as we've seen before.</P></font></body></HTML>
