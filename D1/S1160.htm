<HTML><HEAD><TITLE>Basic Marshaling Architecture (Custom Marshaling)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Basic Marshaling Architecture (Custom Marshaling)</H2><P>The most fundamental operation in Local/Remote Transparency is to take an interface pointer to an object in one process and somehow create the structures that allow a client in another process to call member functions through that interface pointer.<I> </I>Marshaling, in its most literal form, is the process for making this interface pointer available.<I> </I>Again, OLE's standard marshaling is simply one way to achieve this.<I> </I>Custom marshaling is essentially the generic mechanism that lets any object specify exactly how it communicates with a proxy in another process, if such communication is even necessary.</P>
<P>To understand this mechanism and how standard marshaling uses it, let's begin with a server process that has an <I>IClassFactory </I>pointer that it has just passed to <I>CoRegisterClassObject</I>.<I> </I>We start here because the class factory is the first object that any<I> </I>server process will create and the class factory's interface pointer is the first pointer that requires marshaling.<I> </I>Inside <I>CoRegisterClassObject </I>(and within <I>CoGetClassObject </I>in the client's process), the exact sequence of operations that occurs for the first interface pointer is the same for the first interface pointer to any other object in the server—for example, the one returned from <I>IClassFactory::CreateInstance</I>.4<I> </I>In short, the basic marshaling process is used whenever a function in one interface returns the first interface pointer to a new and separate object, which must then be marshaled independently.<I> </I>Because custom marshaling happens on an object-by-object basis, we need the capability for an object that uses one form of marshaling to return an interface pointer to an object that might use a different form.<I> </I>Each object has the right to control whatever sort of marshaling it wants to use. If it wants no control, OLE's standard marshaling is used as a default.</P>
<P>Inside <I>CoRegisterClassObject</I>,<I> </I>COM has an <I>IClassFactory </I>pointer that it must somehow marshal to the other process.<I> </I>This happens through the following steps, which are the same for any interface pointer to any object regardless of the form of marshaling:</P>
<P>Inside <I>CoRegisterClassObject</I>,<I> </I>COM asks the object for the CLSID of the proxy it requires in the client's process.<I> </I>If the object does not provide a specific CLSID, COM will use a standard marshaling proxy.</P>
<P>COM attempts to ask the object for a <I>marshaling packet,</I> which is a stream of bytes containing whatever information the proxy needs to create the interprocess connection to the object.<I> </I>If the object does not provide a packet, COM creates one appropriate for standard marshaling.</P>
<P>COM passes the proxy CLSID and the marshaling packet to the client process, where it shows up inside <I>CoGetClassObject</I>.</P>
<P>In the client's process, COM creates an instance of the proxy using the CLSID retrieved in step 1 and passes to it the marshaling packet retrieved in step 2.</P>
<P>The proxy uses whatever means necessary to connect with the object and returns an interface pointer to COM. COM then returns that pointer to the client on return from <I>CoGetClassObject</I>.<I> </I>This pointer is the one through which the client can now make calls that the proxy will forward to the object as necessary.</P>
<P>Steps 1 and 2 are wrapped inside the COM API function named <I>CoMarshalInterface. </I>Steps 4 and 5 are wrapped inside <I>CoUnmarshalInterface. </I>These two functions represent the core of marshaling.</P>
<P>Step 3 is entirely internal to COM. The transfer of the marshaling packet is the responsibility of the <I>service control manager </I>(SCM), which is what launched the server in the first place. In this sense, the SCM knows exactly what sort of barrier lies between the client and the server. It describes the barrier through a <I>marshaling context,</I> a combination of flags taken from the MSHCTX enumeration. This enumeration currently contains MSHCTX_NOSHAREDMEM (shared memory is not available between processes on this machine) and MSHCTX_DIFFERENTMACHINE (a network boundary exists between client and server). Obviously, these flags can restrict the form of marshaling that an object might want to employ. For example, an object that typically uses shared memory as an IPC mechanism could not do so when the context includes MSHCTX_NOSHAREDMEM. It might then use Microsoft Windows messages instead because window handles are shareable on the same machine. If MSHCTX_DIFFERENTMACHINE is also specified, the object would need to use named pipes, RPC, or some other appropriate network IPC.</P>
<P>Step 3 addresses the reason marshaling is happening in the first place. It depends on the design of whatever code calls <I>CoMarshalInterface</I>. The reason is described by a single flag taken from the MSHLFLAGS enumeration. MSHLFLAGS_NORMAL specifies marshaling that is being carried out to hook up a client and object immediately, as would happen in a client's call to <I>IClassFactory::CreateInstance </I>(to connect to the new object)<I>. </I>MSHLFLAGS_TABLESTRONG and MSHLFLAGS_TABLEWEAK, on the other hand, specify that the marshaling packet is only being stored in a global object table and that marshaling isn't happening immediately.<I> </I>Registering a class factory is an example of this:<I> CoRegisterClassObject </I>merely stores the object's marshaling packet and its proxy CLSID in a global table so that <I>CoGetClassObject </I>in the client's process can access it. (This might not happen at all.)<I> </I>This sort of registration makes the object available to other processes because the necessary marshaling information is accessible through the table.<I> Strong</I> means that COM has called <I>AddRef </I>on the object when storing its marshaling packet in the table, whereas <I>weak</I> means that COM has not made the call.5<I> </I>We'll see more about strong and weak references in the section "Strong and Weak Connections" later in this chapter.</P>
<P>The marshaling context and the marshaling flags are known within code such as <I>CoRegisterClassObject</I>, which has, at this point, an <I>IClassFactory </I>pointer to marshal.<I> </I>It passes this pointer to <I>CoMarshalInterface</I> along with the other necessary arguments, described as follows:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Argument</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>pstm</P></TD><TD VALIGN="TOP"><P>An <I>IStream</I> pointer to a stream (see Chapter 7) into which the object being marshaled should store its marshaling packet. This information is given to an appropriate proxy in the destination process.</P></TD></TR><TR><TD VALIGN="TOP"><P>riid</P></TD><TD VALIGN="TOP"><P>The IID of the interface pointer being marshaled. The interface itself must be derived from <I>IUnknown</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>pUnk</P></TD><TD VALIGN="TOP"><P>The interface pointer (cast to <I>IUnknown</I>) to marshal.</P></TD></TR><TR><TD VALIGN="TOP"><P>dwDestContext</P></TD><TD VALIGN="TOP"><P>DWORD flags from the MSHCTX enumeration.</P></TD></TR><TR><TD VALIGN="TOP"><P>pvDestContext</P></TD><TD VALIGN="TOP"><P>A <I>void</I> * pointing to additional information based on <I>dwDestContext</I>. (Currently this argument has no defined uses and must be set to NULL.)</P></TD></TR><TR><TD VALIGN="TOP"><P>mshlflags</P></TD><TD VALIGN="TOP"><P>DWORD flags from the MSHFLAGS enumeration.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The implementation of <I>CoMarshalInterface </I>works in conjunction with an interface named <I>IMarshal</I>. Arguments to <I>IMarshal</I>'s member functions are named similarly to those in the preceding table and also have the same usage, as shown in the following code. (<I>pvInterface </I>is the same as <I>pUnk.</I>)</P>
<P><BR></P>
<pre><code>interface IMarshal : IUnknown<BR>    {<BR>    HRESULT GetUnmarshalClass(REFIID iid, void *pvInterface<BR>        , DWORD dwDestContext, void *pvDestContext, DWORD mshlflags<BR>        , CLSID *pclsid);<BR>    HRESULT GetMarshalSizeMax(REFIID iid, void *pvInterface<BR>        , DWORD dwDestContext, void *pvDestContext, DWORD mshlflags<BR>        , DWORD *pcb);<BR>    HRESULT MarshalInterface(IStream *pstm, REFIID iid, void *pvInterface<BR>        , DWORD dwDestContext, void *pvDestContext, DWORD mshlflags);<BR>    HRESULT UnmarshalInterface(IStream *pstm, REFIID iid, void **ppv);<BR>    HRESULT DisconnectObject(DWORD dwReserved);<BR>    HRESULT ReleaseMarshalData(IStream *pstm);<BR>    };</code></pre>
<P>Through this interface, an object can control its own marshaling:<I> GetUnmarshalClass </I>returns the proxy CLSID to use, and <I>GetMarshalSizeMax </I>and <I>MarshalInterface </I>create the marshaling packet.<I> </I>If the object does not choose to implement this interface, it says, in effect, "Use standard marshaling."<I> </I>Here are the steps performed within <I>CoMarshalInterface</I>:</P>
<P>Query the object for <I>IMarshal. </I>If this interface is unavailable, standard marshaling will be used, in which case we query the object for <I>IPersist</I> in an attempt to call <I>IPersist::GetClassID</I>.<I> </I>The CLSID returned here still allows the object to specify which object handler to use in the client process, although that handler continues to use a standard marshaling proxy underneath.<I> </I>If <I>IPersist </I>is unavailable, COM defaults to a generic proxy CLSID (specifically, <I>CLSID</I><I>_</I><I>StdMarshal</I>, whose server is the COM Library itself).</P>
<P>If <I>IMarshal </I>is available, call <I>IMarshal::GetUnmarshalClass </I>to obtain the proxy CLSID. The proxy must understand the object's marshaling packet.</P>
<P>Call <I>IMarshal::GetMarshalSizeMax </I>to retrieve the maximum size of the marshaling packet. COM can then preallocate the stream to the appropriate size. (Some streams, as described in Chapter 7, cannot automatically extend themselves.)</P>
<P>Call <I>IMarshal::MarshalInterface</I>,<I> </I>in which the object creates its marshaling packet by writing information into the stream (using <I>IStream::Write</I>).</P>
<P>At the end of this sequence, we're left with a proxy CLSID and a marshaling packet in a stream that can be either stored in a global table or passed directly to COM in a client process, depending on the marshaling flags.<I> </I>The former happens in the case of <I>CoRegisterClassObject</I>;<I> </I>the latter in most other cases.<I> </I>Depending on what operation is being performed, COM now picks up the marshaling packet in the client process.<I> </I>This might happen from within <I>CoGetClassObject</I>, which periodically checks the global class factory table for the new factory, or from within the proxy for whatever object created the new object being marshaled.6<I> </I>One way or the other, code in the client process retrieves the new proxy CLSID and the marshaling packet.</P>
<P>The job of this code is to turn the information into an interface pointer that can be given back to the client. After the client receives the pointer, it can transparently make function calls into the local or remote object, wherever it happens to be.<I> </I>This is the purpose of <I>CoUnmarshalInterface</I>. This function takes the following arguments, two of which imply a call to <I>QueryInterface </I>to return the interface pointer to give to the client:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="71pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Argument</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>pstm</P></TD><TD VALIGN="TOP"><P>An <I>IStream</I> pointer to the stream containing the marshaling packet</P></TD></TR><TR><TD VALIGN="TOP"><P>riid</P></TD><TD VALIGN="TOP"><P>The IID of the interface pointer required</P></TD></TR><TR><TD VALIGN="TOP"><P>ppv</P></TD><TD VALIGN="TOP"><P>A <I>void</I> ** in which to return the client-process pointer through which the client can make calls</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><I>CoUnmarshalInterface </I>then executes the following steps to create the proxy and have it establish communication with the local or remote object:</P>
<P>Call <I>CoCreateInstance </I>with the proxy CLSID, asking for <I>IMarshal </I>in return.<I> </I>A proxy must implement <I>IMarshal </I>in all circumstances.<I> </I>At this point, it doesn't matter what sort of marshaling is being used; the CLSID might be <I>CLSID</I><I>_</I><I>StdMarshal</I> as easily as it can be a CLSID for a custom marshaling proxy.</P>
<P>Pass the marshaling packet to <I>IMarshal::UnmarshalInterface</I>.<I> </I>The proxy reads the information using <I>IStream::Read </I>and uses it to establish whatever connection the proxy requires to the local or remote object through the interface in question.<I> </I>From this function, the proxy returns in <I>ppv </I>the requested interface pointer specified in <I>riid.</I></P>
<P>Call <I>IMarshal::ReleaseMarshalData </I>to free whatever data might be stored in the marshaling packet (for example, a piece of shared memory whose handle is in the stream or the handle to a file or a named pipe).</P>
<P>Return the pointer from <I>IMarshal::UnmarshalInterface </I>to the caller.<I> </I>This pointer is ultimately returned to the client.</P>
<P>Through the steps in <I>C</I><I>oMarshalInterface </I>and <I>CoUnmarshalInterface, </I>a local or remote object is able to specify what proxy to create in the client process and to provide that proxy with the information necessary to establish a connection to the object through <I>all </I>of the object's interfaces, whatever those might be. This will often, of course, involve standard marshaling, as usually happens for a server's class factory.<I> </I>As we'll see in the next section, standard marshaling creates a generic proxy in the client process and a generic stub in the server process, where that stub maintains the object's actual interface pointers.<I> </I>Using this setup, we can follow the sequence of operations that occurs when a client calls <I>IClassFactory::CreateInstance</I> for an object that does use custom marshaling, as illustrated in Figure 6-1 on the next page.<I> </I>From the client's point of view, an object that uses custom marshaling (proxy) is no different from one that uses standard marshaling:<I> </I>both are transparent.<I> </I>Basic marshaling architecture gives an object control over its own marshaling for all of its interfaces, allowing it to make optimizations as it deems necessary.</P>
<P>    <img src="f06dd01.gif"></P>
<P><B>Figure 6-1.</B></P>
<P><B>The process of establishing custom marshaling between an object and its proxy in the client's process.</B></P>
<P>Keep in mind that this entire process can work both ways in a client-object relationship.<I> </I>For example, when a client passes a sink interface pointer to <I>IConnectionPoint::Advise, </I>the proxy itself is now in the position of any other remote object in that it has an interface pointer to make available to another process. The proxy calls <I>CoMarshalInterface</I> to create a client-side stub for the sink interface and passes the resulting marshaling packet to the remote process. There the <I>IConnectionPoint</I> stub will itself call <I>CoUnmarshalInterface</I> to create a proxy for the (now remote) sink object, handing an interface pointer of that new proxy to the object. The object can now call members of the remote sink in the client's process as transparently as the client calls the object's own members.</P>
<P>We have yet to mention <I>IMarshal::Disconnect</I>.<I> </I>COM uses this function to inform the custom marshaling object that some other code (in that object's server) has called <I>CoDisconnectObject </I>for it.<I> </I>The object must then notify its connected proxy of this disconnection so that the proxy will no longer attempt to call the object itself, returning RPC_E_NOTCONNECTED to the client instead.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H3><A NAME="sec0"></A>Four Reasons to Choose Custom Marshaling</H3><UL><LI>If the remote object itself is a proxy to some other object, custom marshaling allows you to short-circuit this middle proxy and let the second client connect directly to the remote object. This procedure can increase performance and improve robustness—it'd be silly to have a proxy to a proxy to a proxy to a proxy, and so on.</LI><LI>Some objects keep their entire state in shared memory or in some other shareable storage medium (such as a disk). In this case, custom marshaling enables the proxy to access that shared storage directly, eliminating the need to call the remote object at all and avoiding context switches. Storage and stream objects in OLE's structured storage implementation (Chapter 7) are great examples of this.</LI><LI>After creation, some objects have an immutable state, which means no changes ever occur to their state data. Monikers (Chapter 9) are an example. With custom marshaling, such objects can make a complete copy of their internal states in both client and server processes; being immutable, the two copies are indistinguishable.</LI><LI>Some designs can cut down interprocess or network traffic by grouping several remote calls into one, thus optimizing performance. An example might be some sort of transactioning system with a commit operation, by which the proxy could cache changes until the commit is made, at which time it passes all the changes to a remote object across the network in a single call.</LI></UL>
<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="431pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>4 Other examples include <I>IProvideClassInfo::GetClassInfo, IStorage::OpenStream </I>(Chapter 7), <I>IMoniker::BindToObject</I> (Chapter 9), <I>IDataObject::EnumFormatEtc</I> (Chapter 10), and many other standard and custom interfaces that you might use or design. All of these return new interface pointers to separate objects.</P></TD></TR><TR><TD VALIGN="TOP"><P>5 A weak reference means that the object might disappear while its marshaling packet still appears in the table where the object is responsible for revoking the registration. <I>CoRegisterClassObject </I>always uses MSHLFLAGS_TABLESTRONG which is why you cannot control server lifetime with a class factory as discussed in Chapter 5. Only <I>CoRevokeClassObject </I>can remove the extra reference counts. However other mechanisms such as the running object table described in Chapter 9 give the object the choice between strong and weak registration.</P></TD></TR><TR><TD VALIGN="TOP"><P>6 Specifically, a stub that has an out-parameter containing an interface pointer will return a marshaling packet to the proxy for that pointer, not a pointer itself.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
