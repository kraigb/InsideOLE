<HTML><HEAD><TITLE>Property Sheets, Property Pages</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Property Sheets, Property Pages</H2><P>Most likely, you've already seen the user interface known as the <I>tabbed dialog box</I> or <I>property sheet,</I> a dialog box containing one or more individual <I>property pages,</I> in which each page itself works as a single dialog box. The collection of pages in a single place allows the end user to work with different properties of one kind or another without having to skip around between different, singular dialog boxes. In a property sheet, each page is displayed as an individual tab; clicking on a tab brings the various controls on that page to the foreground.</P>
<P>You'll see property sheets employed quite often in the Windows 95 user interface, not only in applications but also in the system shell and in development tools. For example, let's say I'm using a programming tool to create a push-button control on a form. When I ask to view the properties of that button, I get a Button Control Properties property sheet, as shown in Figure 16-1. The General page is currently displayed. I can use this page to set the button's caption. If I click the Fonts tab, I see a different page, shown in Figure 16-2 on the following page. And if I click on the Colors tab, that page comes to the foreground, as shown in Figure 16-3 on the following page. So within the context of the button control object, I can manipulate its different groups of related properties within a single dialog box. Keep in mind that in all these figures, the OK, Cancel, Apply Now, and Help buttons—as well as the labeled tabs—are owned by the frame dialog. All other controls belong to the pages themselves.</P>
<P>    <img src="f16dd01p.gif"></P>
<P><B>Figure 16-1.</B></P>
<P><B>A General property page in a Button Control Properties property sheet.</B></P>
<P>Usability testing has shown that end users work well with the grouping of related sets of properties in the same top-level dialog box. One dialog box with multiple pages reinforces the fact that all the properties apply to the same underlying object, and in many ways, factoring properties in a user interface is much like factoring an object's functionality into multiple programmatic interfaces, as we've seen throughout this book.</P>
<P>    <img src="f16dd02p.gif"></P>
<P><B>Figure 16-2.</B></P>
<P><B>A Fonts property page in a Button Control Properties property sheet.</B></P>
<P>    <img src="f16dd03p.gif"></P>
<P><B>Figure 16-3.</B></P>
<P><B>A Colors property page in a Button Control Properties property sheet.</B></P>
<P>Windows 95 introduced the capability to create property sheets as part of the system API, allowing applications to create this user interface for their own properties. In general, each property sheet represents some conceptual object as the user sees it. For example, the Windows 95 Control Panel is a conceptual system-settings object that has groups of properties for the display, device drivers, peripherals, the network, and so on. Within the property sheet for these system settings, each group of related settings has its own page.</P>
<P>In a component integration environment such as OLE, we want OLE components to be able to specify which property pages they want displayed for themselves and to be able to supply the implementation of those pages. This allows a client to display the appropriate property sheet for an object being maintained in that client—or even for multiple objects simultaneously. The Windows 95 API for creating property sheets is not wholly sufficient for OLE's purposes because that API is oriented toward a single application displaying its own properties. In OLE, we need a client to display the properties of any group of objects and have changes in the property pages applied directly to those objects without the client's intervention.</P>
<P>The group of technologies introduced with OLE Controls includes a number of new interfaces and an API function that creates and manages component-specific property sheets. We call this set of interfaces and functions the <I>OLE Property Pages</I> technology. This technology is oriented toward a client that has <I>IUnknown </I>pointers for one or more objects and that wants to display the appropriate property sheet for any subset of those objects. (<I>Client</I> here also applies to an object that wants to display its own property pages in response to a programmatic request such as a method call to its primary dispinterface.) In any case, the property sheet manages to communicate property changes in the user interface to the objects being affected. The mechanism that makes this possible between arbitrary objects involves four parts:</P>
<P>Each object specifies which property pages should appear in its own property sheet through the interface <I>ISpecifyPropertyPages</I>, where each property page is identified by its own CLSID. This interface is necessary only to support the display of a property sheet within an object's external client—objects that want exclusive control over the display of properties should not implement this interface.</P>
<P>Whoever wants to display the property sheet (the client or the object) calls the OLE API function <I>OleCreatePropertyFrame </I>(or <I>OleCreatePropertyFrameIndirect</I>), passing an array of property page CLSIDs along with an array of <I>IUnknown </I>pointers (one for each affected object). This function creates the modal dialog frame and manages the individual property page objects themselves until the user closes the dialog box.</P>
<P>Each property page is an in-process object that implements <I>IPropertyPage</I>. Through this interface, the frame tells each page when to show or hide itself as the user selects different tabs. In addition, the frame passes the client's array of <I>IUnknown </I>pointers to each page so that those pages can send changes directly to the affected objects.</P>
<P>Each tab in the frame dialog is a <I>page site</I> that appears to each property page as the interface <I>IPropertyPageSite</I>. The pages use <I>IPropertyPageSite</I> to retrieve information about the property sheet as a whole.</P>
<P>The relationship between these parts is illustrated in Figure 16-4. Be aware that property changes are communicated directly from the property pages to the affected objects; they require no interaction on behalf of whoever invokes the dialog box. Because each object specifies exactly which property pages to display, those pages expect to communicate changes through specific interfaces or dispinterfaces. In some cases, having a standard property page for common properties (such as Fonts and Colors) makes sense. A standard page expects objects to support standard dispIDs for related properties through their <I>IDispatch </I>interfaces.</P>
<P>    <img src="f16dd04.gif"></P>
<P><B>Figure 16-4.</B></P>
<P><B>The architecture of OLE Property Pages.</B></P>
<P>The following four sections take a closer look at each part of OLE Property Pages. In addition, we'll look at a few other interfaces, namely <I>IPerPropertyBrowsing </I>and <I>IPropertyPage2</I>, that provide for more specific user interface access to an object's properties.</P></font></body></HTML>
