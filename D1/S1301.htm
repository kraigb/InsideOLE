<HTML><HEAD><TITLE>Activate and Deactivate the Object</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Activate and Deactivate the Object</H3><P>As described earlier, any call to <I>IOleObject::DoVerb</I>, except for OLEIVERB_OPEN, can start in-place activation. To fully support in-place objects, a container needs to include a MSG structure telling the object what mouse message caused the activation. In Patron, activating an object with a double click occurs in <I>CPage::OnLeftDoubleClick </I>(in PAGEMOUS.CPP), which creates a MSG structure with WM_LBUTTONDBLCLK in it. This structure is sent to <I>CTenant::ActivateObject </I>along with OLEIVERB_PRIMARY, which then sends the structure to <I>IOleObject::DoVerb. </I>Because Patron also supports inside-out objects, it sends a WM_LBUTTONDOWN message with OLEIVERB_UIACTIVATE within <I>CTenant::Select </I>(which is called whenever the user clicks on a tenant to select it).</P>
<P>In other activation cases, such as those in response to menu commands, we don't need to send a message structure at all. This also applies for objects marked OLEMISC_ACTIVATEWHENVISIBLE. As you can see in <I>CTenant::Load</I>, Patron will call <I>DoVerb(OLEIVERB</I><I>_</I><I>INPLACEACTIVATE) </I>for such an object so that it is always at least in-place active. In this case, we do not need to send a message to <I>DoVerb </I>either.</P>
<P>So now how do we deactivate the object? This should happen whenever the user clicks <I>either </I>mouse button outside the object. Patron picks up these events in <I>CPage::OnLeftDown </I>or <I>CPage::O</I><I>nRightDown </I>(in PAGEMOUS.CPP). The appropriate function then calls <I>CTenant::DeactivateInPlaceObject</I>, which in turn calls <I>IOleInPlaceObject:: InPlaceDeactivate</I>, as shown in the code on the following page.</P>
<P><BR></P>
<pre><code>void CTenant::DeactivateInPlaceObject(BOOL fFull)<BR>    {<BR>    if (NULL!=m_pIOleIPObject)<BR>        {<BR>        if ((OLEMISC_ACTIVATEWHENVISIBLE &amp; m_grfMisc) &amp;&amp; !fFull)<BR>            m_pIOleIPObject-&gt;UIDeactivate();<BR>        else<BR>            m_pIOleIPObject-&gt;InPlaceDeactivate();<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P><I>InPlaceDeactivate</I>, unless told otherwise, only deactivates the UI for an object marked OLEMISC_ACTIVATEWHENVISIBLE, which leaves it in-place active only. Otherwise, we deactivate the object, returning it to the running state. (See the following sidebar.)</P>
<P>Clicking outside the object is not the only event that can cause deactivation. Basically, you should deactivate if any event occurs that would create or activate a different object (such as a drag-and-drop operation) or that would require the object to be in the loaded state (such as closing the document or application). This latter case is handled in <I>CTenant::Close</I>, which calls <I>CTenant::DeactivateInPlaceObject</I> before calling <I>IOleObject::Close</I>.</P>
<P>When the user clicks inside an object with the activate-when-visible property, the object will call the container's <I>IOleInPlaceSite::OnUIActivate </I>function, at which time you should deactivate the object that was UI active. If that other object has the activate-when-visible property, you call only its <I>IOleInPlaceObjec</I><I>t::UIDeactivate</I> function, as shown in the preceding code<I>.</I></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec0"></A>EXPERIENCE: The Object Is Still Running</H4><P>After you deactivate an in-place object, that object will still be in the running state, not the loaded state. <I>IOleObject::Close</I> is required to change the state. OLE does this to ensure quick reactivation by eliminating server load time. Therefore, the object's state is not reset between in-place activations. If you crash your container while debugging it, a local server might remain in memory with an undetermined state and a hidden window. You'll need to use a tool such as PVIEW to terminate the server so that you can run your container again with a fresh state.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
