<HTML><HEAD><TITLE>The Malloc1 and Malloc2 Samples</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Malloc1 and Malloc2 Samples</H3><P>Let's now use <I>CoGetMalloc </I>and the <I>IMalloc </I>interface to illustrate the differences between C and C++ interface calls. The samples of interest here are in CHAP02\MALLOC1 and CHAP02\MALLOC2. Malloc1 is written in C and Malloc2 in C++, serving as side-by-side examples of equivalent functionality and equivalent code structures. Both samples call <I>CoInitialize </I>and <I>CoUninitialize </I>as necessary and create a small main window with a menu from which you can access the allocator, ask it to perform various functions, release the allocator, and exit the program. Both allocate a number of consecutively larger blocks (from 100 bytes up to tens of thousands of bytes), storing the ASCII character <I>a</I> in the first block, <I>b</I> in the second, and so forth. You can use a debugging tool to look at memory and see where the allocations ended up.</P>
<P>Both samples call <I>CoGetMalloc </I>when you select the Allocator/CoGetMalloc menu item. They save the pointer in a variable named <I>m</I><I>_</I><I>pIMalloc</I>, which is part of the application structure (in C) or the C++ object. When you select the Allocator/Alloc or Realloc menu item, you'll end up in the IDM_ALLOC (or IDM_REALLOC) case of each sample's window procedure, which verifies that you've selected CoGetMalloc already and calls a <I>DoAllocation</I> function. Malloc1's C code for this is in <I>App</I><I>_</I><I>DoAllocations</I>,<I> </I>which appears as follows:</P>
<P><BR></P>
<pre><code>BOOL App_DoAllocations(PAPP pApp, BOOL fRealloc)<BR>    {<BR>    UINT        i;<BR>    ULONG       iByte;<BR>    BOOL        fResult=TRUE;<BR>    ULONG       cb;<BR>    LPVOID      pv;<BR><BR>    if (!fRealloc)<BR>        App_FreeAllocations(pApp, FALSE);<BR><BR>    for (i=0; i &lt; CALLOCS; i++)<BR>        {<BR>        //cb is set in the code below for later initialization.<BR>        if (fRealloc)<BR>            {<BR>            pApp-&gt;m_rgcb[i]+=128;<BR>            cb=pApp-&gt;m_rgcb[i];<BR><BR>            //Old memory is not freed if Realloc fails.<BR>            pv=pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;Realloc(pApp-&gt;m_pIMalloc<BR>                , pApp-&gt;m_rgpv[i], cb);<BR>            }<BR>        else<BR>            {<BR>            cb=pApp-&gt;m_rgcb[i];<BR>            pv=pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;Alloc(pApp-&gt;m_pIMalloc, cb);<BR>            }<BR><BR>        pApp-&gt;m_rgpv[i]=pv;<BR><BR>        [Code to fill allocations with letters]<BR>        fResult &amp;= (NULL!=pv);<BR>        }<BR><BR>    [Other cleanup code]<BR>    return fResult;<BR>    }</code></pre>
<P>Here's the equivalent code from Malloc2's (MALLOC.CPP) <I>CApp::DoAllocations</I>:</P>
<P><BR></P>
<pre><code>BOOL CApp::DoAllocations(BOOL fRealloc)<BR>    {<BR>    UINT        i;<BR>    ULONG       iByte;<BR>    BOOL        fResult=TRUE;<BR>    ULONG       cb;<BR>    LPVOID      pv;<BR><BR>    if (!fRealloc)<BR>        FreeAllocations(FALSE);<BR><BR>    for (i=0; i &lt; CALLOCS; i++)<BR>        {<BR>        //cb is set in the code below for later initialization.<BR>        if (fRealloc)<BR>            {<BR>            m_rgcb[i]+=128;<BR>            cb=m_rgcb[i];<BR><BR>            //Old memory is not freed if Realloc fails.<BR>            pv=m_pIMalloc-&gt;Realloc(m_rgpv[i], cb);<BR>            }<BR>        else<BR>            {<BR>            cb=m_rgcb[i];<BR>            pv=m_pIMalloc-&gt;Alloc(cb);<BR>            }<BR><BR>        m_rgpv[i]=pv;<BR><BR>        [Code to fill allocations with letters]<BR>        fResult &amp;= (NULL!=pv);<BR>        }<BR><BR>    [Other cleanup code]<BR>    return fResult;<BR>    }</code></pre>
<P>In each case, the array <I>m</I><I>_</I><I>rgcb </I>contains a bunch of integer values to determine the size of the allocations. Each <I>Realloc </I>operation increases the size. The array <I>m</I><I>_</I><I>rgpv</I> holds the allocated pointers that are freed in the samples' <I>FreeAllocations </I>functions.</P>
<P>To closely compare C and C++ function calls, look at the calls to <I>Alloc</I>:</P>
<P><BR></P>
<pre><code>C:    pv=pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;Alloc(pApp-&gt;m_pIMalloc, cb);<BR>C++:    pv=m_pIMalloc-&gt;Alloc(cb);</code></pre>
<P>In C++, you need to call only the function through the interface pointer using a single indirection, as you would when making a member function call to any C++ object. This is because OLE interfaces are designed to have the same structure as C++ objects have in memory, and because interfaces are defined in C++ abstract base classes, the compiler hides all the complexities of making the call. In C, however, these complexities are explicit: you must state the double indirection to the function using the <I>lpVtbl</I> field of the interface structure, and you must pass the interface pointer itself as the first parameter. C++ performs this last step automatically to generate the <I>this</I> pointer inside the member function.</P>
<P>In even a simple client implementation, you will easily have 50 calls to interface member functions. You don't even need to multiply to see why C++ is the more convenient language in which to work with OLE, although it is no more functional. If you are using other languages, the compiler or programming environment should support some sort of language construct that represents interfaces and making calls to interfaces.</P>
<P>If you want to take advantage of the convenience of C++ but don't want to rewrite your existing C code, I have a suggestion. Simply rename your C files to CPP and recompile. Three weeks later, when you've added the necessary <I>extern </I><I>"</I><I>C</I><I>"</I><I> </I>statements around include files and have fixed all the type warnings that you'll get, you effectively have C++ code. Remember that C is a subset of C++. You can use this fact to your advantage to make the compiler understand that you are writing C++ code so that when you use an interface pointer you can benefit from the more concise calling structure. Investing some time up front to recompile your code as C++ is, believe me, well worth it. I've written code both ways, and it gets painful to write <I>lpVtbl</I> all over the place. If you really can't recompile your code as C++, try making sets of macros for each interface that will turn an interface call into <I>MACRO(&lt;interface pointer&gt;, &lt;arguments&gt;);</I>. It will make your source code smaller, your code more readable, and your programmers happier.</P></font></body></HTML>
