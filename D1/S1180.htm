<HTML><HEAD><TITLE>Summary</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Summary</H2><P>The most important concept in COM's Local/Remote Transparency is that somehow a server process has an interface pointer that it wants to make available to other processes. The mechanism called <I>marshaling</I> is the means to make this pointer available and to pass arguments from the client's process to the server's process through whatever interprocess communication is established. In all cases, a client calls interface member functions that are located inside a <I>proxy</I> object. The proxy then forwards those calls to a local or remote object as necessary.</P>
<P>An object can use custom marshaling by implementing the <I>IMarshal </I>interface. Through this interface, the object specifies exactly which proxy should be created in the client process (using a CLSID) and provides a <I>marshaling packet</I> for that proxy. The packet contains whatever information is necessary to connect to the remote object—a window handle, a named pipe handle, and so on. The entire sequence of operations involved is neatly encapsulated inside the COM API functions <I>CoMarshalInterface </I>and <I>CoUnmarshalInterface.</I> If an object doesn't want to control its own marshaling, it can simply not implement <I>IMarshal</I>. In this case, COM establishes a connection using standard marshaling, which involves a client-side generic proxy that communicates with a server-side generic stub, which in turn communicates with the local or remote objects.</P>
<P>The generic proxy and stub objects are nothing more than containers, or managers, of marshalers: individual interface proxy and interface stub objects are called <I>facelets</I> and <I>stublets</I> in this book. To support standard marshaling of a custom interface, the interface provider must also provide an implementation of the marshalers for that interface, a process that is nearly automated using the Microsoft-supplied MIDL compiler.</P>
<P>Within the context of standard marshaling, both client and object can perform what is called <I>message filtering,</I> or <I>concurrency management</I>. Message filtering gives an object a single entry point through which it can process, reject, or delay all calls coming to it from other processes. Message filtering gives clients the capability to process pending messages while a synchronous call is being completed as well as the capability to time-out and fail the call when it takes too long. This latter facility involves the standard OLE busy dialog box, provided in the OLE UI Library.</P>
<P>Concurrency management, the busy dialog box, standard marshaling of custom interfaces, and custom marshaling, are all topics demonstrated in this chapter's samples.</P></font></body></HTML>
