<HTML><HEAD><TITLE>Displaying Property Pages</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Displaying Property Pages</H2><P>Playing with AutoCli2, you will notice a Properties menu item. When you select this item, AutoCli2 asks the Beeper object within it for a list of property page CLSIDs and then calls <I>OleCreatePropertyFrame </I>to display those property pages. As we saw earlier in this chapter, property pages involve the client, one or more objects, and the property page objects themselves. AutoCli2 and Beeper6 supply the first two pieces of the picture, and the sample BeepProp (CHAP16\BEEPPROP) contains the property page implementation, which we'll cover in the next section. (Before attempting to ask AutoCli2 to display the property pages, be sure to compile and register BeepProp.)</P>
<P>When we select the Properties menu item in AutoCli2, we end up in the function <I>CApp::ShowProperties </I>in AUTOCLI2.CPP:</P>
<P><BR></P>
<pre><code>void CApp::ShowProperties(void)<BR>    {<BR>    ISpecifyPropertyPages  *pISPP;<BR>    CAUUID                  caGUID;<BR>    HRESULT                 hr;<BR><BR>    if (FAILED(m_pIDispatch-&gt;QueryInterface<BR>        (IID_ISpecifyPropertyPages, (void **)&amp;pISPP)))<BR>        {<BR>        Message(TEXT("Object has no property pages."));<BR>        return;<BR>        }<BR><BR>    hr=pISPP-&gt;GetPages(&amp;caGUID);<BR>    pISPP-&gt;Release();<BR><BR>    if (FAILED(hr))<BR>        {<BR>        Message(TEXT("Failed to retrieve property page GUIDs."));<BR>        return;<BR>        }<BR><BR>    hr=OleCreatePropertyFrame(m_hWnd, 10, 10, OLETEXT("Beeper")<BR>        , 1, (IUnknown **)&amp;m_pIDispatch, caGUID.cElems<BR>        , caGUID.pElems, m_lcid, 0L, NULL);<BR><BR>    if (FAILED(hr))<BR>        Message(TEXT("OleCreatePropertyFrame failed."));<BR><BR>    //Free GUIDs.<BR>    CoTaskMemFree((void *)caGUID.pElems);<BR>    return;<BR>    }</code></pre>
<P>Here we execute the steps described earlier: query for <I>ISpecifyPropertyPages</I>, call <I>ISpecifyPropertyPages::GetPages</I>,<I> </I>pass those page CLSIDs and the object pointers to <I>OleCreatePropertyFrame</I>, and on return from that function free the CLSID array allocated in <I>GetPages</I>. That's it. Barring failure at one point or another, you'll see the Beeper object's private property page. (See Figure 16-7 on page 799.)</P>
<P>In AutoCli2, you'll notice that the Properties menu item is always enabled and that we first check for the presence of <I>ISpecifyPropertyPages </I>in this series of operations. A slightly more sophisticated client would query for this interface within WM_INITMENUPOPUP processing to enable or disable the menu item accordingly. If the client also allowed the user to select multiple objects, it would query each selected object and enable the menu item only when everything in the selection supports property pages. A sophisticated client could also retrieve the property page CLSIDs from each object at the same time and verify that at least one property page exists in common before enabling the menu item. As stated earlier, a client should display only the set of property pages common to every object in a selection so as not to display pages that could send unexpected information to unsuspecting objects.</P>
<P>There are, of course, many algorithms through which the client determines the common subset of property pages for multiple objects. If you need to determine this in your own work, realize that you don't need to compare an <I>entire </I>CLSID to initially determine equality. You can make a significant optimization by comparing only the first DWORD of any two CLSIDs (the <I>Data1 </I>field in the GUID structure). Even sequentially allocated GUIDs differ in that first DWORD, although they are identical everywhere else. If those DWORDs are different, the CLSIDs must be different. You will usually eliminate most of the unmatched CLSIDs in this manner. Only when a match exists in the first DWORD should you worry about comparing the entire structure for perfect equality.</P>
<P>As for Beeper6's implementation of <I>ISpecifyPropertyPages</I>, it needs only to allocate an array of GUIDs, store the CLSIDs of the pages it wants, and return as shown in the following code, from BEEPER.CPP:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpISpecifyPP::GetPages(CAUUID *pPages)<BR>    {<BR>    GUID   *pGUID;<BR><BR>    pPages-&gt;cElems=0;<BR>    pPages-&gt;pElems=NULL;<BR><BR>    pGUID=(GUID *)CoTaskMemAlloc(CPROPPAGES*sizeof(GUID));<BR><BR>    if (NULL==pGUID)<BR>        return ResultFromScode(E_OUTOFMEMORY);<BR><BR>    //Fill array now that we allocated it.<BR>    pGUID[0]=CLSID_BeeperPropertyPage;<BR><BR>    //Fill structure and return.<BR>    pPages-&gt;cElems=CPROPPAGES;<BR>    pPages-&gt;pElems=pGUID;<BR>    return NOERROR;<BR>    }</code></pre>
<P>No great challenges here. <I>CLSID</I><I>_</I><I>BeeperPropertyPage </I>is defined in INC\BOOKGUID.H. BeepProp is the server for that CLSID, as we'll see shortly.</P>
<P>If you are creating a client that supports per-property browsing, you will skip all this business with arrays of CLSIDs. Instead, you'll query the object in question for <I>IPerPropertyBrowsing </I>and pass the dispID of the single property to its <I>MapPropertyToPage</I>. You'll stuff the single CLSID that you get back into an OCPFIPARAMS structure along with the dispID and then throw the entire structure at <I>OleCreatePropertyFrameIndirect.</I></P>
<P>As you can see, the responsibilities of both a client and an object displaying property pages are minimal, even when per-property browsing is involved. The bulk of the work happens between the property frame and the property page itself.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H3><A NAME="sec0"></A>The Standard Font, Color, and Picture Property Pages</H3><P>The run-time library for OLE Controls (shipped with the OLE Control Development Kit) provides three standard property pages: one for font selection, one for color selection, and one for manipulating picture types. The Font and Color pages were shown in Figures 16-2 and 16-3. The predefined CLSIDs for these pages are <I>CLSID</I><I>_</I><I>CFontPropPage</I>, <I>CLSID</I><I>_</I><I>CColorPropPage</I>, and <I>CLSID</I><I>_</I><I>CPicturePropPage</I>, which are defined in the CDK header file OLECTLID.H. These property pages are designed to be generic implementations for any objects that might have such properties. As standard pages, they send changes to the affected objects through <I>IDispatch::Invoke</I>,<I> </I>using standard (negative) dispIDs to identify the various properties involved. This means that you can use these pages for your own objects as long as you support these standard dispIDs. For more information on the specific values involved, see the documentation provided with the CDK.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
