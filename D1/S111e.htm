<HTML><HEAD><TITLE>The Hard Way: CreateTypeLib</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Hard Way: <I>CreateTypeLib</I></H3><P>In Chapter 2, we learned how the provider of a component gives access to the objects and interfaces of that component through one of four mechanisms, such as a specific API function that creates one type of component and gives you back one type of interface. This is exactly the means through which OLE exposes its type library creation service.</P>
<P>The API function of interest here is <I>CreateTypeLib</I>, which has the arguments you see at the top of the following page.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Argument</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>syskind</P></TD><TD VALIGN="TOP"><P>A value from the SYSKIND enumeration to describe the target operating system, such as SYS_WIN16, SYS_WIN32, or SYS_MAC.</P></TD></TR><TR><TD VALIGN="TOP"><P>szFile</P></TD><TD VALIGN="TOP"><P><I>OLECHAR</I> *, which provides the name of the disk file in which OLE stores the type library data structures. Type library files conventionally use TLB for the extension.</P></TD></TR><TR><TD VALIGN="TOP"><P>ppCTLib</P></TD><TD VALIGN="TOP"><P><I>ICreateTypeLib</I> *, in which the function returns the interface pointer representing the new type library.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><I>CreateTypeLib</I> doesn't really do much more than create a disk file with one top-level data structure, which happens to be empty. At this point you have, in terms of the children's poem, a vacant lot. You have a place to put the house—the type information—but there isn't anything there but rocks, weeds, and crummy fill dirt.</P>
<P>Building something in that vacant lot is the purpose of the <I>ICreateTy</I><I>peLib </I>pointer you get back from calling <I>CreateTypeLib.</I> The member functions of this interface, described in Table 3-3, deal mostly with setting the library's attributes that we saw earlier—that is, building the basic shell of a house. As with any pointer you obtain for any object, you must call <I>Release</I> when you're finished with the type library.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="123pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Member Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>SetName, SetGuid,<BR>SetVersion, SetLcid,<BR>SetLibFlags</P></TD><TD VALIGN="TOP"><P>Assigns the name, GUID, version numbers, locale, and flags to a type library.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetDocString,<BR>SetHelpFileName,<BR>SetHelpContext</P></TD><TD VALIGN="TOP"><P>Assigns help-related attributes to a type library.</P></TD></TR><TR><TD VALIGN="TOP"><P>SaveAllChanges</P></TD><TD VALIGN="TOP"><P>Commits all changes made to the type library (to any element within it) to the disk file. If this is not called before <I>Release</I>, the changes are lost.</P></TD></TR><TR><TD VALIGN="TOP"><P>CreateTypeInfo</P></TD><TD VALIGN="TOP"><P>Creates an element in the type library and returns an <I>ICreateTypeInfo</I> pointer through which that element is constructed.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 3-3.</B></P>
<P><B>Member functions of the <I>ICreateTypeLib</I> interface.</B></P>
<P>The two functions in the interface that don't have to do with attributes—<I>CreateTypeInfo</I> and <I>SaveAllChanges</I>—are the most critical. Everything you do to the library before calling <I>SaveAllChanges</I> is the same as drawing an architectural blueprint and planning everything else that should go in a house, but the house exists only on paper. Calling <I>SaveAllChanges</I> is similar to taking those plans and giving them to a builder who will actually create something tangible. In the case of a type library, it means writing everything to disk.</P>
<P><I>ICreateTypeLib::CreateTypeInfo</I> is what you use to create a <I>coclass,</I> <I>interface,</I> <I>dispinterface,</I> <I>module,</I> or <I>typedef</I> (<I>struct, union, enum</I>) element in the library. The type of element is identified with a value from the enumeration TYPEKIND, which can be TKIND_ALIAS (a simple <I>typedef</I> to name a new type), TKIND_COCLASS, TKIND_DISPATCH (<I>dispinterface</I>), TKIND_ENUM (<I>typedef enum</I>), TKIND_INTERFACE, TKIND_MODULE, TKIND_RECORD (<I>typedef struct</I>), and TKIND_UNION (<I>typedef union</I>). Along with the type identifier, this function also takes a name attribute (text string) for the new element.4 <I>CreateTypeInfo</I> then returns an <I>ICreateTypeInfo</I> pointer.</P>
<P>The member functions of <I>ICreateTypeInfo</I> described in Table 3-4 allow you to build the rooms, the walls, and the mouse holes in your house.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Member Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>SetGuid, SetVersion</P></TD><TD VALIGN="TOP"><P>Assigns a GUID or version to the element.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetDocString,<BR>SetHelpContext</P></TD><TD VALIGN="TOP"><P>Assigns help-related attributes to the element.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetTypeDescAlias</P></TD><TD VALIGN="TOP"><P>Creates an alias for a type (a simple <I>typedef</I>).</P></TD></TR><TR><TD VALIGN="TOP"><P>SetAlignment</P></TD><TD VALIGN="TOP"><P>Specifies byte alignment for a data structure.</P></TD></TR><TR><TD VALIGN="TOP"><P>DefineFuncAsDllEntry</P></TD><TD VALIGN="TOP"><P>Defines an exported DLL function by name or by ordinal; applicable only to module elements.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetTypeFlags</P></TD><TD VALIGN="TOP"><P>Sets additional flags for <I>coclass</I> elements, such as whether or not a <I>coclass</I> element is licensed, instantiable, or restricted from browsing.</P></TD></TR><TR><TD VALIGN="TOP"><P>AddImplType,<BR>SetImplTypeFlags</P></TD><TD VALIGN="TOP"><P>Creates information about the interfaces in a <I>coclass</I> element. <I>AddImplType</I> adds the description of the interface; <I>SetImplTypeFlags</I> assigns default, source, and restricted attributes to those interfaces. Both require information returned from <I>AddRefTypeInfo</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>AddRefTypeInfo</P></TD><TD VALIGN="TOP"><P>Creates an HREFTYPE that refers to a <I>coclass</I> and is necessary for calling <I>AddImplType</I> to add interfaces and dispinterfaces to a <I>coclass</I> description. This function requires an <I>ITypeInfo</I> pointer, which is obtained by calling <I>ICreateTypeInfo::QueryInterface</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>AddFuncDesc,<BR>SetFuncAndParamNames,<BR>SetFuncDocString,<BR>SetFuncHelpContext</P></TD><TD VALIGN="TOP"><P>Creates information about a member function in interface or dispinterface elements only. <I>AddFuncDesc</I> takes a pointer to a FUNCDESC structure, which contains the identifier, calling convention, return type, argument types, and permitted return codes. <I>SetFuncParamsAndNames</I> assigns names to the function and its arguments. <I>SetFuncDocString</I> and <I>SetFuncHelpContext</I> save help attributes for a function. With all of these functions you identify the member function in question by a common index.</P></TD></TR><TR><TD VALIGN="TOP"><P>AddVarDesc, SetVarName,<BR>SetVarDocString,<BR>SetVarHelpContext</P></TD><TD VALIGN="TOP"><P>Creates information about a global variable description to a module or a property to a dispinterface. <I>AddVarDesc</I> adds a variable through the VARDESC structure. The other functions set the variable's name and help information.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetTypeIdlDesc, SetMops</P></TD><TD VALIGN="TOP"><P>Defines cross-process marshaling information for an interface or dispinterface.</P></TD></TR><TR><TD VALIGN="TOP"><P>LayOut</P></TD><TD VALIGN="TOP"><P>Assigns vtable positions for an interface element, dispatch identifiers for methods and properties in a dispinterface element, and offsets for exported global variables from a module element. This function should only be called for an element after all other information is stored and just before calling <I>ICreateTypeLib::SaveAllChanges</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetSchema</P></TD><TD VALIGN="TOP"><P>Reserved.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 3-4.</B></P>
<P><B>Member functions of the <I>ICreateTypeInfo</I> interface.</B></P>
<P>The overall process of creating a type library is illustrated in Figure 3-1. The illustration shows the steps of creating the library, then creating the elements within it (you can create as many elements of each type as desired), and then saving the changes on disk through <I>ICreateTypeLib::SaveAllChanges.</I></P>
<P>    <img src="f03dd01.gif"></P>
<P><B>Figure 3-1.</B></P>
<P><B>The type library creation process.</B></P>
<P>You can see that through <I>ICreateTypeLib</I> and <I>ICreateTypeInfo</I> you can create whatever type information structures you want. These interfaces and OLE's direct type library creation service are useful mostly for development tools, but some applications or other components may find these functions useful for creating some type information on the fly. The whole process, however, is somewhat involved, and this book will not get into any other details. For more information about these functions, see the <I>OLE</I> <I>Programmer</I><I>'</I><I>s Reference</I>.</P>
<P><B>Note:</B><B> </B> You might encounter references to some data structures called INTERFACEDATA, PARAMDATA, and METHODDATA, which are an archaic way to create type information for a single dispinterface that existed before OLE's type library services were complete. Ignore these structures: they are obsolete.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>4 This is only a convenience for coclass interface and dispinterface elements but necessary for typedefs and modules. The former three are programmatically identified with a GUID which is optional for a typedef but not allowed on a module.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
