<HTML><HEAD><TITLE>The IDispatch Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The <I>IDispatch </I>Interface</H3><P>The magic mapping function that invokes a method or a property according to a dispID is <I>IDispatch::Invoke</I>. When a controller has a pointer to a dispinterface, it really has a pointer to an implementation of <I>IDispatch</I> that responds to a set of dispIDs specific to that implementation. If a controller has two <I>IDispatch </I>pointers for two different objects, for example, dispID 0 may mean something completely different to each object. So while a controller will have compiled code to call <I>IDispatch::Invoke</I>, the actual method or property invoked is not determined until run time. This is the nature of late binding.</P>
<P><I>IDispatch::Invoke </I>is the workhorse of OLE Automation, and besides a dispID it takes a number of other arguments to pass on to the object's implementation, as shown in Figure 14-3 on the following page. The other member functions of <I>IDispatch </I>exist to assist the controller in determining the dispIDs and types for methods and properties through type information.</P>
<P>    <img src="f14dd03.gif"></P>
<P><B>Figure 14-3.</B></P>
<P><B>The accessing of methods and properties in a dispinterface is routed through <I>IDispatch::Invoke</I>. This calls the object's internal functions as necessary based on the dispID passed from the controller.</B></P>
<P>Because a controller is usually a programming environment, it is generally a script or program running in that controller that determines which dispID gets passed to which object's <I>IDispatch</I>. The controller, however, needs only <I>one </I>piece of code that knows how to call <I>IDispatch </I>members polymorphically, letting its interpreter or processing engine provide the appropriate arguments for <I>IDispatch </I>members on the basis of the running script. This processing will generally involve all four of the specific <I>IDispatch </I>members:</P>
<P><BR></P>
<pre><code>interface IDispatch : IUnknown<BR>    {<BR>    HRESULT GetTypeInfoCount(unsigned int *pctinfo);<BR>    HRESULT GetTypeInfo(unsigned int itinfo, LCID lcid<BR>        ITypeInfo **pptinfo);<BR>    HRESULT GetIDsOfNames(REFIID riid, OLECHAR **rgszNames<BR>        , unsigned int cNames, LCID lcid, DISPID *rgdispid);<BR>    HRESULT Invoke(DISPID dispID, REFIID riid, LCID lcid<BR>        , unsigned short wFlags, DISPPARAMS *pDispParams<BR>        , VARIANT *pVarResult, EXCEPINFO *pExcepInfo<BR>        , unsigned int *puArgErr);<BR>    };</code></pre>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="111pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Member Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Invoke</P></TD><TD VALIGN="TOP"><P>Given a dispID and any other necessary parameters, calls a method or accesses a property in this dispinterface</P></TD></TR><TR><TD VALIGN="TOP"><P>GetIDsOfNames</P></TD><TD VALIGN="TOP"><P>Converts text names of properties and methods (including arguments) to their corresponding dispIDs</P></TD></TR><TR><TD VALIGN="TOP"><P>GetTypeInfoCount</P></TD><TD VALIGN="TOP"><P>Determines whether there is type information available for this dispinterface, returning 0 (unavailable) or 1 (available)</P></TD></TR><TR><TD VALIGN="TOP"><P>GetTypeInfo</P></TD><TD VALIGN="TOP"><P>Retrieves the type information for this dispinterface if <I>GetTypeInfoCount</I> returned successfully</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>You can implement the <I>IDispatch </I>interface in various ways (as we'll see later in this chapter), including the use of OLE API functions such as <I>DispInvoke</I>, <I>DispGetIDsOfNames</I>, and <I>CreateStdDispatch</I>. Regardless of the implementation technique, <I>Invoke </I>always requires the same arguments, which include the following:</P>
<UL><LI><I>dispID</I>, a DISPID, to identify the method or the property to invoke.</LI><LI><I>wFlags</I>, an unsigned short identifying the <I>Invoke </I>call as a property get (DISPATCH_PROPERTYGET), a property put (DISPATCH_PROPERTYPUT), a property put by-reference (DISPATCH_PROPERTYPUTREF), or a method invocation (DISPATCH_METHOD).</LI><LI><I>pDispParams</I>, a pointer to a DISPPARAMS structure, which contains the new property value in a property put, array indices for a property get, or method arguments in VARIANTARG structures (same as a VARIANT). Each argument is an element in an array of VARIANTARGs contained inside DISPPARAMS. Arguments to a method can be optional as well as named.</LI><LI><I>lcid</I>, a locale identifier (<I>LCID</I>) identifying the national language in use at the time of the call so sensitive methods and properties can behave appropriately to the locale.</LI><LI><I>VarResult</I>, a pointer to a VARIANT structure, a union of many different types along with a value identifying the actual type in which is stored the value of a property get or the return value of a method. This return value is separate  from the return value of <I>Invoke </I>and is only meaningful if <I>Invoke </I>succeeds.</LI><LI><I>ExcepInfo</I>, a pointer to a structure named EXCEPINFO through which the object can raise custom errors above and beyond the failure codes that <I>Invoke </I>can return.</LI><LI><I>puArgErr</I>, in which <I>Invoke </I>stores the index of the first mismatched argument in <I>pDispParams </I>if a type mismatch occurs.</LI></UL><P>Given the dispID of a dispinterface member and the necessary information about property types and method arguments, a controller can access everything in the dispinterface. But how does a controller obtain the dispID and the arguments in the first place?</P>
<P>Using our Beeper object as an example, consider a little fragment of code in a Basic-oriented automation controller (DispTest or Visual Basic). This code sets Beeper's <I>Sound </I>property and instructs the object to play that sound by calling the <I>Beep </I>method. (Obviously, this is not the only way to access an automation object through a controller language; Basic is just an example.)</P>
<P><BR></P>
<pre><code>Beeper.Sound = 32   '32=MB_ICONHAND, a system sound<BR>Beeper.Beep</code></pre>
<P>The controller has to turn both of these pieces of code into <I>IDispatch::Invoke </I>calls with the right dispID and other parameters. To convert the names "Sound" and "Beep" to their dispIDs, the controller can pass those names to <I>IDispatch::GetIDsOfNames</I>. Passing "Sound," for example, to our Beeper's implementation of this function would return a dispID of 0. Passing "Beep" would return a dispID of 1.</P>
<P>You must also give the right type of data to the Beeper object to assign to the <I>Sound </I>property. The value 32 (defined for C/C++ programmers, at least, as MB_ICONHAND in WINDOWS.H) is an integer. The Basic interpreter must perform type checking to ensure that the type of the argument is compatible with the <I>Sound </I>property. This is accomplished either at run time (pass the arguments to <I>Invoke </I>and see whether the object rejects it) or through the object's type information as obtained through <I>IDispatch::GetTypeInfo </I>(if <I>IDispatch::GetTypeInfoCount </I>returns a 1). A well-behaved controller wants to use type information when it is available. If it is not, <I>IDispatch::Invoke </I>will perform type coercion and type checking itself, returning type mismatch errors as necessary.</P>
<H4><A NAME="sec0"></A>Standard dispIDs</H4><P>The same dispID passed to different objects may result in a completely different method or property invocation. In general, specific dispinterfaces themselves are not polymorphic, although Microsoft has standardized a few dispIDs with defined semantics, as described in Table 14-1. We'll see a number of these throughout the rest of this chapter. Each of these standard dispIDs has a zero or negative value, and Microsoft reserves all negative dispID values (those with the high bit set) for future use.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="152pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>dispID (Value)*</B></P></TD><TD VALIGN="TOP"><P><B>Value and Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>DISPID_VALUE (0)</P></TD><TD VALIGN="TOP"><P>The default member for the dispinterface—that is, the property or method invoked if the object name is specified by itself without a property or a method in a controller script.</P></TD></TR><TR><TD VALIGN="TOP"><P>DISPID_UNKNOWN (<FONT FACE="Symbol">-</FONT>1)</P></TD><TD VALIGN="TOP"><P>Value returned by <I>IDispatch::GetIDsOfNames </I>to indicate that a member or parameter name was not found.</P></TD></TR><TR><TD VALIGN="TOP"><P>DISPID_PROPERTYPUT (<FONT FACE="Symbol">-</FONT>3)</P></TD><TD VALIGN="TOP"><P>Indicates the parameter that receives the value of an assignment in a prop-erty put.</P></TD></TR><TR><TD VALIGN="TOP"><P>DISPID_NEWENUM (<FONT FACE="Symbol">-</FONT>4)</P></TD><TD VALIGN="TOP"><P>The <I>_</I><I>NewEnum </I>method of a collection. (See "Collections" later in this chapter.)</P></TD></TR><TR><TD VALIGN="TOP"><P>DISPID_EVALUATE (<FONT FACE="Symbol">-</FONT>5) </P></TD><TD VALIGN="TOP"><P>A method named <I>Evaluate </I>that a controller implicitly invokes when it encounters arguments in square brackets. For example, the following two lines are equivalent:<BR>x.[A1:C1].value = 10<BR>x.Evaluate("A1:C1").value = 10</P></TD></TR><TR><TD VALIGN="TOP"><P>DISPID_CONSTRUCTOR (<FONT FACE="Symbol">-</FONT>6)</P></TD><TD VALIGN="TOP"><P>The method that acts as the object's constructor. Reserves for future use.</P></TD></TR><TR><TD VALIGN="TOP"><P>DISPID_DESTRUCTOR (<FONT FACE="Symbol">-</FONT>7)</P></TD><TD VALIGN="TOP"><P>The method that acts as the object's destructor. Reserves for future use.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>*    The dispID <FONT FACE="Symbol">-</FONT>2 ran off and became a gypsy. You might see it at a rest stop along some European motorway someday. Actually, <FONT FACE="Symbol">-</FONT>2 is called ID_DEFAULTINST and is used specifically in <I>ITypeComp::Bind </I>to identify an implicitly created or default variable. The value was assigned from the dispID pool at a time when member IDs of arguments and interface members were not clearly distinct from dispIDs of methods and properties in a dispinterface.</P>
<P><B>Table 14-1.</B></P>
<P><B>Standard dispID values and their meanings.</B></P>
<H4><A NAME="sec1"></A>The BSTR and the Safe Array</H4><P>Two special data types are specified as part of OLE Automation, although like much else, they are usable outside an <I>IDispatch </I>implementation. These types are the BSTR and the Safe Array.</P>
<P>A BSTR is a Basic STRing in which the string is stored as a DWORD count of characters followed by the characters themselves, as illustrated below. In OLE Automation, these strings are NULL-terminated, so a pointer to the beginning of the character array is the same as a C string pointer; in C or C++, a BSTR type always points to the characters, but the character count always precedes it in memory.</P>
<P><img src="fig14-3a.gif"></P>
<P>OLE provides a special set of API functions to allocate, manage, and free BSTR types: <I>SysAllocString</I>, <I>SysAllocStringLen</I>, <I>SysFreeString</I>, <I>SysReAllocString</I>, <I>SysReAllocStringLen</I>, and <I>SysStringLen.</I> You can easily guess what each function does. (The <I>OLE Programme</I><I>r</I><I>'</I><I>s Reference </I>holds the complete documentation for these functions.)</P>
<P>An important reason why Automation employs BSTR types for strings is that Automation was designed and implemented for the most part in the group at Microsoft that also produces Visual Basic, and Basic stores strings in a BSTR format. In addition, a BSTR is faster to copy across a process boundary because the length of the string is already known. As we'll see later in this chapter, it is quite simple to deal with BSTR variables. In fact, it can often be more convenient than working with C strings.</P>
<P>A Safe Array is an array of other types. The reason they are <I>safe</I> is that the array itself is a data structure that contains boundary information for the array as well as the actual reference to the data. Here's how the SAFEARRAY type is defined in the Automation header files:</P>
<P><BR></P>
<pre><code>typedef struct tagSAFEARRAY<BR>    {<BR>    USHORT    cDims;      //Count of array dimensions<BR>    USHORT    fFeatures;  //Flags describing array<BR>    USHORT    cbElements; //Size of each element<BR>    USHORT    cLocks;     //Number of locks on array<BR>    HANDLE    handle;     //HGLOBAL to actual array<BR>    void *    pvData;     //Pointer to data valid when cLocks &gt; 0<BR>    SAFEARRAYBOUND    rgsabound[]; //One bound for each dimension<BR>    } SAFEARRAY;<BR><BR>typedef struct tagSAFEARRAYBOUND<BR>    {<BR>    ULONG    cElements; //Number of elements in dimension<BR>    long     LBound;    //Lower bound of dimension<BR>    } SAFEARRAYBOUND</code></pre>
<P>The various flags, symbols prefixed with FADF_, identify the array elements as BSTRs, <I>IDispatch </I>or <I>IUnknown </I>pointers, or VARIANT structures (see the following section). There are two flags that also indicate whether the array is allocated on the stack or allocated statically, which means that the array does not need to be freed explicitly when the SAFEARRAY structure is freed.</P>
<P>As with BSTRs, OLE provides a number of API functions, 19 in all, for creating, accessing, and releasing safe arrays: <I>SafeArrayAccessData</I>, <I>SafeArrayAllocData</I>, <I>SafeArrayAllocDesc</I><I>riptor</I>, <I>SafeArrayCopy</I>, <I>SafeArrayCreate</I>, <I>SafeArrayDestroy</I>, <I>SafeArrayDestroyData</I>, <I>SafeArrayDestroyDescriptor</I>, <I>SafeArrayGetDim</I>, <I>SafeArrayGetElement</I>, <I>SafeArrayGetElemsize</I>, <I>SafeArrayGetLBound</I>, <I>SafeArrayGetUBound</I>, <I>SafeArrayLock</I>, <I>SafeArrayPtrOfIndex</I>, <I>SafeArrayPutElement</I>, <I>SafeArrayRedim</I>, <I>SafeArrayUnaccessData</I>, and <I>SafeArrayUnlock.</I> Again, see the <I>OLE Programmer</I><I>'</I><I>s Reference </I>for more information about all of these functions.</P>
<H4><A NAME="sec2"></A>The VARIANT and VARIANTARG Structures</H4><P>The VARIANT is a structure that can contain any kind of data. With <I>IDispatch::Invoke</I>, a VARIANT carries the return value from a property get or a method call; a VARIANTARG carries the arguments to a property put or a method call. Both structures have exactly the same format, shown in the following, and you'll often see the two types used interchangeably:</P>
<P><BR></P>
<pre><code>typedef struct tagVARIANT VARIANT;<BR>typedef struct tagVARIANT VARIANTARG;<BR><BR>typedef struct tagVARIANT<BR>    {<BR>    VARTYPE           vt;        //Identifies the type<BR>    unsigned short    wReserved1;<BR>    unsigned short    wReserved2;<BR>    unsigned short    wReserved3;<BR>    union<BR>        {<BR>        //by-value fields<BR>        short             iVal;<BR>        long              lVal;<BR>        float             fltVal;<BR>        double            dblVal;<BR>        VARIANT_BOOL      bool;<BR>        SCODE             scode;<BR>        CY                cyVal;    //Currency<BR>        DATE              date;<BR>        BSTR              bstrVal;<BR>        IUnknown FAR *    punkVal;<BR>        IDispatch FAR*    pdispVal;<BR>        SAFEARRAY FAR*    parray;<BR><BR>        //by-reference fields<BR>        short FAR*          piVal;<BR>        long FAR*           plVal;<BR>        float FAR*          pfltVal;<BR>        double FAR*         pdblVal;<BR>        VARIANT_BOOL FAR*   pbool;<BR>        SCODE FAR*          pscode;<BR>        CY  FAR*            pcyVal;<BR>        DATE FAR*           pdate;<BR>        BSTR FAR*           pbstrVal;<BR>        IUnknown FAR* FAR*  ppunkVal;<BR>        IDispatch FAR* FAR* ppdispVal;<BR>        VARIANT FAR*        pvarVal;<BR>        void FAR*           byref;<BR>        };<BR>    };</code></pre>
<P>You can see that while this structure is actually quite small—16 bytes—it can hold just about any type of value or pointer within it. We've already seen the BSTR and SAFEARRAY types, which leaves the CY (currency) and DATE structures as the only newcomers. These two are very simple:</P>
<P><BR></P>
<pre><code>typedef struct tagCY<BR>    {<BR>    unsigned long Lo;<BR>    long          Hi;<BR>    } CY;<BR><BR>typedef double DATE;</code></pre>
<P>On systems that use big-endian microprocessors—like the Macintosh—the ordering of the CY structure's fields is reversed. In any case, the currency type is an 8-byte fixed-point number, and the DATE type is a <I>double </I>that contains the number of days since December 30, 1899, in the whole part and the time in the fractional part. The time is expressed as a fraction of a day.2</P>
<P>The VARTYPE field, an <I>unsigned short,</I> at the beginning of the structure identifies the actual type that is held in the structure itself—that is, which one of the many fields of the <I>union </I>has meaning. The value in <I>vt </I>is drawn from the enumeration VARENUM, which defines not only the possible VARIANT types but also the types that are used in type information and persistent property sets, which we'll see in a Chapter 16. (See Table 16-1 on page 784.) The following is the comment for VARENUM, taken from the OLE header files, that describes the enumeration (the actual values of the symbols are unimportant):</P>
<P><BR></P>
<pre><code>/*<BR> * VARENUM usage key,<BR> *<BR> * * [V] - may appear in a VARIANT<BR> * * [T] - may appear in a TYPEDESC<BR> * * [P] - may appear in an OLE property set<BR> * * [S] - may appear in a Safe Array<BR> *<BR> *<BR> *  VT_EMPTY            [V]   [P]     nothing<BR> *  VT_NULL             [V]           SQL-style Null<BR> *  VT_I2               [V][T][P][S]  2-byte signed int<BR> *  VT_I4               [V][T][P][S]  4-byte signed int<BR> *  VT_R4               [V][T][P][S]  4-byte real<BR> *  VT_R8               [V][T][P][S]  8-byte real<BR> *  VT_CY               [V][T][P][S]  currency<BR> *  VT_DATE             [V][T][P][S]  date<BR> *  VT_BSTR             [V][T][P][S]  binary string<BR> *  VT_DISPATCH         [V][T]   [S]  IDispatch FAR*<BR> *  VT_ERROR            [V][T]   [S]  SCODE<BR> *  VT_BOOL             [V][T][P][S]  True=-1, False=0<BR> *  VT_VARIANT          [V][T][P][S]  VARIANT FAR*<BR> *  VT_UNKNOWN          [V][T]   [S]  IUnknown FAR*<BR> *  VT_I1                  [T]        signed char<BR> *  VT_UI1              [V][T]   [S]  unsigned char<BR> *  VT_UI2                 [T]        unsigned short<BR> *  VT_UI4                 [T]        unsigned short
 *  VT_I8                  [T][P]     signed 64-bit int<BR> *  VT_UI8                 [T]        unsigned 64-bit int<BR> *  VT_INT                 [T]        signed machine int<BR> *  VT_UINT                [T]        unsigned machine int<BR> *  VT_VOID                [T]        C-style void<BR> *  VT_HRESULT             [T]<BR> *  VT_PTR                 [T]        pointer type<BR> *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)<BR> *  VT_CARRAY              [T]        C-style array<BR> *  VT_USERDEFINED         [T]        user-defined type<BR> *  VT_LPSTR               [T][P]     null-terminated string<BR> *  VT_LPWSTR              [T][P]     wide null-terminated string<BR> *  VT_FILETIME               [P]     FILETIME<BR> *  VT_BLOB                   [P]     Length-prefixed bytes<BR> *  VT_STREAM                 [P]     Name of the stream follows<BR> *  VT_STORAGE                [P]     Name of the storage follows<BR> *  VT_STREAMED_OBJECT        [P]     Stream contains an object<BR> *  VT_STORED_OBJECT          [P]     Storage contains an object<BR> *  VT_BLOB_OBJECT            [P]     Blob contains an object<BR> *  VT_CF                     [P]     Clipboard format<BR> *  VT_CLSID                  [P]     A Class ID<BR> *  VT_VECTOR                 [P]     simple counted array<BR> *  VT_ARRAY            [V]           SAFEARRAY*<BR> *  VT_BYREF            [V]<BR> */</code></pre>
<P><img src="16bit.gif"></P>
<P>You'll notice that the types you can specify in a VARIANT are mostly the generic types. The others are useful in describing type information or in describing persistent binary data such as a BLOB. The VT_BYREF flag is what differentiates a VARIANTARG from a VARIANT: only a VARIANTARG is allowed to use this flag in order to pass parameters by reference. In that case, all of the by-reference fields in the VARIANTARG structure have no meaning in the VARIANT itself. For all intents and purposes, however, the two structures are otherwise the same.</P>
<P>OLE provides a few functions to initialize and otherwise manage both structures. These generally simplify your work with these structures and reduce the need for you to access fields of the structures directly.</P>
<P>In addition, OLE provides a host of functions to deal with the conversion between types, the topic of the next section. There are also a great number of macros that eliminate the need to refer to individual fields in a VARIANT or a VARIANTARG. V_I2(<I>var</I>) performs the equivalent of <I>var-&gt;iVal</I>, and V_BSTRREF(<I>var</I>) is the same as <I>var-&gt;pbstrVal</I>. The macro V_VT extracts the <I>vt </I>field, V_ISBYREF checks whether <I>vt </I>has the VT_BYREF flag, and V_ISARRAY and V_ISVECTOR do the same check for VT_ARRAY and VT_VECTOR. Using these macros isn't necessary; there is no magic here. They are provided simply to make your source code more readable if you prefer this sort of syntax.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="95pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>VariantClear</P></TD><TD VALIGN="TOP"><P>Clears the VARIANT[ARG] by releasing any resources within it and setting the type to VT_EMPTY. If the structure contains a BSTR or SAFEARRAY, that element is freed with <I>SysFreeString</I>, <I>SafeArrayDestroyData</I>, or <I>SafeArrayDestroy</I>; if the element is an <I>IUnknown</I> or an<I> IDispatch</I> pointer, this calls <I>IUnknown::Release</I>. It does not recurse deeper if the type is VT_VARIANT.</P></TD></TR><TR><TD VALIGN="TOP"><P>VariantCopy</P></TD><TD VALIGN="TOP"><P>Copies the contents from one VARIANT[ARG] to another. The destination structure is cleared with <I>VariantClear</I>; BSTRs and SAFEARRAYs are copied in their entirety, and <I>AddRef</I> is called through any <I>IUnknown</I> or <I>IDispatch</I> pointers.</P></TD></TR><TR><TD VALIGN="TOP"><P>VariantCopyInd</P></TD><TD VALIGN="TOP"><P>Indirect version of <I>VariantCopy</I> that copies a by-reference VARIANTARG to a by-value VARIANT. The contents of the destination VARIANT are cleared with <I>Variant</I><I>Clear</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>VariantInit</P></TD><TD VALIGN="TOP"><P>Initializes the fields of a VARIANT[ARG], for example a field declared as a stack variable. It sets <I>vt</I> to VT_EMPTY and the <I>wReserved</I>* fields to 0, but it does not change the union value.</P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec3"></A>Type Coercion of VARIANTs and VARIANTARGs</H4><P>Inside an implementation of <I>IDispatch::Invoke</I>, an object will generally find it necessary to <I>coerce</I> into the necessary type the variables passed to a method or put in a property. The reason is that a controller, because of its language structure (especially for weakly typed languages such as Basic), may pass arguments or properties in a type other than that specified in an object's type information. Certainly a sophisticated controller can provide some type checking before calling <I>Invoke </I>at run time, but this is not required. Ultimately it is the object's responsibility to ensure that the information it receives is converted to the type that it needs.</P>
<P>Now <I>Invoke </I>will receive in its DISPPARAMS argument an array of VARIANTARG structures. These structures hold every argument to a method or the value to put in a property. Where <I>Invoke </I>might expect a BSTR it gets a <I>long</I>, or a BOOL where it needs a <I>double</I>, or even an <I>IDispatch </I>pointer where it really wants CY or DATE. Type coercion is the process of converting one type to a compatible type. This might include conversion of strings to numbers and vice versa, and it may even involve getting or setting a property through another object's <I>IDispatch</I>.</P>
<P>To assist with this process, OLE comes with two basic functions, <I>Vari</I><I>antChangeType </I>and <I>VariantChangeTypeEx</I>. (The <I>Ex </I>brand is sensitive to localization concerns such as date and currency formats.) You can throw a VARIANT to one of these functions and see whether OLE can convince it to become a different type (inside another VARIANT). Of course, OLE is not so heavy-handed that it will try to force a square peg through a round hole, so some types simply cannot be converted to others. How, for example, does one convert an array of <I>IUnknown </I>pointers to a currency value? If I were dealing with my bank account, I'd be happy for it to max out the currency value, but I don't think my bank would appreciate that. In the interests of honesty, OLE doesn't convert incompatible types; it returns the programmer's nemesis, a type mismatch error. Rats.</P>
<P>In any case, OLE can coerce many types into many others. Each conversion actually has its own function with a name like <I>Var&lt;type&gt;From&lt;type&gt;</I>, as in <I>VarR4FromI2</I>, which is used internally inside <I>VariantChangeType[Ex] </I>through one massive double switch statement. There are conversion functions for every combination of <I>short</I>, <I>long</I>, <I>float</I>, <I>double</I>, BOOL, CY, DATE, BSTR, and <I>IDispatch</I> *, as is accurately documented in the <I>OLE Programmer</I><I>'</I><I>s Reference</I>. These conversions are not necessarily trivial either; converting a BOOL to a BSTR, for example, gives you the string "True" or "False" as appropriate; converting dates and currency values with BSTRs does all the formatting and parsing according to the user's international settings.</P>
<P>What is most interesting is that you can often convert between these types and an <I>IDispatch </I>pointer. What the <I>IDispatch </I>pointer really represents is another object whose DISPID_VALUE property is the value to convert. The conversion functions that work with <I>IDispatch </I>pointers—named <I>Var&lt;type&gt;FromDisp</I><I>—</I>call that interface's <I>Invoke </I>with a property get on DISPID_VALUE and then attempt to coerce any simple value to another type. "Simple" means that if <I>Invoke </I>returns another <I>IDispatch </I>pointer, for example, and we're trying to coerce into a <I>long</I>,<B> </B>the final converted value will be the numeric value of that pointer, losing any sense of it being a pointer to anything. If we were converting to a <I>short</I>, we'd end up with only the lower 16 bits of that pointer. In other words, this final conversion does not recurse into <I>VariantChangeType</I>—it just extracts the value to return out of the VARIANT that comes back from <I>Invoke</I>. This simple conversion will always work, but it may result in a useless value.</P>
<P>As a further assistance to implementation of <I>IDispatch::Invoke</I>, OLE offers the function <I>DispGetParam</I>, which retrieves a value from a VARIANTARG buried within <I>Invoke</I>'s DISPPARAMS argument. To use this function, you pass the DISPPARAMS pointer, the position of the argument, and the type you want to retrieve. <I>DispGetParam </I>will extract the appropriate argument and try to coerce it into the type you want by using <I>VariantChangeType</I>. If this function fails, it gives you back the error information to return to the controller that originally called <I>Invoke</I>.</P>
<P>I'm sure you'd like to know of a way to avoid messing with VARIANTs and performing all this tedious muck with type coercion, with or without <I>DispGetParam</I>. You might figure that because all the argument and property types you support through an implementation of <I>IDispatch::Invoke </I>are described in an object's type information, OLE can handle all this coercion automatically. In fact, you are absolutely correct. OLE provides automatic type coercion and checking directly through the <I>ITypeInfo </I>interface, specifically the function <I>ITypeInfo::Invoke</I>. We'll see how to use this feature later in this chapter, when we look at the various techniques for implementing <I>IDispatch.</I></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H5><A NAME="sec4"></A>Using Variant Coercion Outside Automation and OLE</H5><P>Shhhh! Wanna hear a secret? You can use all the VARIANT functions as nothing more than a rich type conversion API. Nowhere in the Win32 API will you find functions to parse a date or time or currency string into an actual numeric value using the current international settings or to convert a value to a string. Nowhere else will you find functions to conveniently convert an integer to a "True" or "False" string. All the VARIANT manipulation functions are essentially a stand-alone library of useful functions that require only a prior call to <I>CoInitialize</I> as the BSTR and SAFEARRAY types use COM's memory allocation service.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec5"></A>DISPPARAMS: Optional and Named Arguments</H4><P>Now that we know about the VARIANT[ARG] and about coercing one type of VARIANT[ARG] into another, we can understand the DISPPARAMS structure that is passed as <I>pDispParams </I>to <I>IDispatch::Invoke. </I>This structure contains all the arguments for a method call or a property put and has the following structure:</P>
<P><BR></P>
<pre><code>typedef struct tagDISPPARAMS<BR>    {<BR>    VARIANTARG FAR*  rgvarg;            //Array of arguments<BR>    DISPID FAR*      rgdispidNamedArgs; //dispIDs of named arguments<BR>    unsigned int     cArgs;             //Number of total arguments<BR>    unsigned int     cNamedArgs;        //Number of named arguments<BR>    } DISPPARAMS;</code></pre>
<P>In the simplest cases, the <I>rgvarg </I>array has the VARIANTARG structures that make up the arguments to the method or property. For a property put, there is only one argument; for a method invocation, there may be zero or more arguments. Every VARIANTARG element in <I>rgvarg </I>is considered read-only unless it has VT_BYREF set in its <I>vt </I>field. In that case, the argument can be used as an out-parameter when necessary. Simple enough.</P>
<P>But of course, there are some tricks involved with DISPPARAMS that introduce more complications. First of all, any strings or other pointers to possibly allocated resources that are passed as arguments in this structure are always the <I>caller</I><I>'</I><I>s </I>responsibility. In other words, <I>Invoke </I>should never free arguments itself. If <I>Invoke </I>wants to hold a copy of a by-reference value, for example a BSTR or an <I>IUnknown </I>or <I>ID</I><I>ispatch </I>pointer, it must copy the data or call <I>AddRef </I>through the pointer, respectively.</P>
<P>The order of the arguments inside the <I>rgvarg </I>array is from last to first—that is, a right to left stacking order. Say, for example, that you invoke a method with three arguments as follows:</P>
<P><BR></P>
<pre><code>Object.Method(arg1, arg2, arg3)</code></pre>
<P>You would then have the value 3 in <I>pDispParams-&gt;cArgs</I>, with <I>arg1</I> at <I>rgvarg[2]</I>, <I>arg2</I> at <I>rgvarg[1]</I>, and <I>arg3</I> at <I>rgvarg[0]</I>.</P>
<P>Next, a method can support optional arguments. Such arguments are specifically marked in a dispinterface's type information as optional, but they must always be sent to <I>Invoke </I>inside the DISPPARAMS structure. To check whether an optional argument was sent or not, an implementation of <I>Invoke </I>checks whether the VARIANTARG has type VT_ERROR and the contents of DISP_E_PARAMNOTFOUND in the <I>scode </I>field. If so, the controller didn't provide the argument; otherwise, the argument is there and the object has to coerce it to the proper type. A method always gets its full complement of arguments, but some of them may not be available. Also, some older controllers might set the type of a nonexistent optional argument to VT_EMPTY instead of VT_ERROR.</P>
<P>If any argument cannot be coerced into a usable type, <I>Invoke </I>must return DISP_E_TYPEMISMATCH. Of course, it is highly useful for a controller, and ultimately the programmer or user of that controller, to know which argument was mismatched. To provide that information, the automation object must store the <I>rgvarg </I>index or the bad argument in the location pointed to by the <I>Invoke </I>parameter <I>puArgErr.</I></P>
<P>Both the required and optional arguments mentioned so far are called <I>positional</I> arguments—they always appear in the same position in the <I>rgvarg </I>array. <I>IDispatch::Invoke</I>, more appropriately an automation object, can also support <I>named</I> arguments that appear first in the <I>rgvarg </I>array. In other words, they occupy the low positions in the array where the positional arguments come at the end. The <I>pDispParams-&gt;cNamedArgs </I>field tells you whether you have any named arguments. If this value is 0, everything is positional.</P>
<P>What are named arguments? They are arguments that can be placed anywhere in a method's argument list and are identified by a name that has meaning to the method itself. For example, consider a method named <I>FindRockBand</I> for a music database. The method has one positional argument containing the number of members in the band and three named arguments, named <I>LeadGuitar</I>, <I>BassGuitar</I>, and <I>Percussion</I>, which are strings possessing the last names of the band members. (To complete this type of query function, we might add optional parameters such as <I>Vocals </I>and <I>RhythmGuitar</I>, which would be noted with the count argument being higher than 3,<I> </I>but we don't need to complicate matters here.) This method, which might return a <I>long </I>identifier to the database record, would be declared in the object's type information as follows:</P>
<P><BR></P>
<pre><code>LONG FindRockBand(int cMembers, BSTR LeadGuitar, BSTR BassGuitar<BR>    , BSTR Percussion)</code></pre>
<P>MKTYPLIB will assign each argument its own <I>member identifier</I> in the order declared, starting with 0. So <I>cMembers </I>would be ID 0, <I>LeadGuitar </I>ID 1, <I>BassGuitar </I>ID 2, and <I>Percussion </I>ID 3. Do not confuse these member ID values with the dispID values of methods and properties: the identifiers simply mark the argument.</P>
<P>With named arguments, you can invoke <I>FindRockBand </I>in a controller such as Visual Basic as follows:</P>
<P><BR></P>
<pre><code>id=Database.FindRockBand(3, LeadGuitar="Lifeson", BassGuitar="Lee"<BR>    , Percussion="Peart")</code></pre>
<P>Because named arguments are used, you can employ any other permutation as an exact equivalent, as in the following: </P>
<P><BR></P>
<pre><code>id=Database.FindRockBand(3, Percussion="Peart", LeadGuitar="Lifeson"<BR>    , BassGuitar="Lee")</code></pre>
<P>or</P>
<P><BR></P>
<pre><code>id=Database.FindRockBand(3, BassGuitar="Lee", Percussion="Peart"<BR>    , LeadGuitar="Lifeson")</code></pre>
<P>Inside <I>Invoke</I>, the DISPPARAMS structure for any of these calls will have <I>cArgs</I>=4 (the total count) and <I>cNamedArgs</I>=3. The first (and in this case the only) positional argument in <I>rgvarg </I>would be <I>rgvarg[3]</I>—that is, at the end of the array.<B> </B>The three named arguments will occupy <I>rgvarg[3</I><FONT FACE="Symbol"><I>-</I></FONT><I>cNamedArgs</I><I>+</I><I>0]</I>, <I>rgvarg[3</I><FONT FACE="Symbol"><I>-</I></FONT><I>cNamedArgs</I><I>+</I><I>1]</I>, and <I>rgvarg[3</I><FONT FACE="Symbol"><I>-</I></FONT><I>cNamedArgs</I><I>+</I><I>2]</I>. I'm using <I>3 </I>here to denote the last element in the array, subtracting <I>cNamedArgs </I>to get the beginning of the named arguments, and then adding 0, 1, and 2 to get to the first, second, and third named arguments.</P>
<P>Keep in mind, that you cannot depend at all on the ordering of the named arguments inside <I>rgvarg</I>. Generally the controller will just throw them in DISPPARAMS in the order they appear in the controller code, but to an automation object the order is not an order at all, only a random sequence. How you actually determine which element in <I>rgvarg </I>contains which named argument is the purpose of the final field of DISPPARAMS, <I>rgdispidNamedArgs</I>.<B> </B>This is an array of member identifiers, those dispIDs assigned to arguments based on their order in the method declaration.<B> </B>This is how an implementation of <I>Invoke </I>identifies the arguments because only the IDs, not the names themselves, are passed in DISPPARAMS. The <I>rgdispidNamedArgs[0]</I> field will always contain the ID of the argument in <I>rgvarg[0]</I>, <I>rgdispidNamedArgs[1]</I> will contain the ID of the argument in <I>rgvarg[1]</I>, and so on.<B> </B>So if the controller executes the following code:</P>
<P><BR></P>
<pre><code>id=Database.FindRockBand(3, LeadGuitar="Lifeson", BassGuitar="Lee"<BR>    , Percussion="Peart")</code></pre>
<P>the <I>rgvarg </I>and <I>rgdispidNamesArgs </I>arrays will appear as follows (lower memory to the left):</P>
<P><img src="fig14-3b.gif"></P>
<P>If the controller executes the following:</P>
<P><BR></P>
<pre><code>id=Database.FindRockBand(3, Percussion="Peart", LeadGuitar="Lifeson"<BR>    , BassGuitar="Lee")</code></pre>
<P>the <I>rgvarg </I>and <I>rgdispidNamesArgs </I>arrays will instead appear as this:</P>
<P><img src="fig14-3c.gif"></P>
<P>It is up to the automation object supporting named arguments to match elements in <I>rgvarg </I>with the proper argument value.<B> </B>The object itself can reject any attempt to pass named arguments by failing <I>Invoke </I>with DISP_E_NONAMEDARGS if <I>cNamedArgs </I>is nonzero.</P>
<P>There is one special case with named arguments.<B> </B>Any property put operation is considered to involve a named argument when the argument is the property itself.<B> </B>Inside <I>Invoke</I>, you'll see <I>cArgs</I><I>=</I><I>1</I>, <I>cNamedArgs</I><I>=</I><I>1</I>, and <I>rgdispidNamedArgs[0]</I> with DISPID_PROPERTYPUT, and <I>rgvarg[0] </I>with the VARIANT containing the new property value.<B> </B>A controller is responsible for generating this specific DISPPARAMS structure, and an automation object considers it an error to see a property put with anything different, returning DISP_E_PARAMNOTOPTIONAL to tell the controller so. This is required because some controllers, as a result of their language structure, cannot differentiate between a property get or put and a method call. This means the <I>wFlags </I>parameter to <I>Invoke </I>will indicate both operations.<B> </B>The object must use this special named argument case to determine what is actually going on.</P>
<H4><A NAME="sec6"></A>Method and Property Return Values and Out-Parameters</H4><P>Whereas the DISPPARAMS argument to <I>Invoke </I>handles all the arguments to a method or the new value for a property put, the VARIANT named <I>pVarResult </I>handles the return value of a method or the return value of a property get. This <I>pVarResult </I>exists because <I>Invoke </I>returns an HRESULT so it can describe errors; only if <I>Invoke </I>returns NOERROR does the result in <I>pVarResult</I> have meaning.</P>
<P>If the result is an allocated type such as a BSTR or an interface pointer, the object is responsible for allocating the resource or calling <I>AddRef</I>, whereas the controller must free the resource or call <I>Release</I>. You can see from this that combined with the rule that the object never frees arguments passed in DISPPARAMS, an automation object never frees any resources it shares with its controller, with the exception of in/out-parameters involved in a method invocation. As I mentioned earlier, arguments in DISPPARAMS are read-only unless they are passed by reference, and then they are read/write only if the method knows that they are, in fact, in/out-parameters themselves.<B> </B>With such in/out-parameters, the object must be sure to free whatever arguments were passed by calling <I>VariantClear</I> on those arguments, before overwriting them and returning from <I>Invoke</I>.</P>
<P>Because <I>Invoke </I>can return only a limited number of SCODEs, how can it give information to a controller about why an operation failed above and beyond a simple error code?<B> </B>How can you get <I>Invoke</I> to say, "This property set failed because the allowable range for this value is 1 through 5," instead of returning DISP_E_OVERFLOW or some terribly undetailed information such as E_FAIL?<B> </B>The answer is that the object can raise an OLE Automation exception.</P>
<H4><A NAME="sec7"></A>Exceptions</H4><P>In OLE Automation, an exception is really a form of rich and detailed error reporting.<B> </B>It's not the same thing as structured exception handling in C++, Win32, and so on. Although the controller can do what it wants with automation exceptions—having chains of exception handlers, for example—raising an exception from an automation object simply involves filling the fields of the EXCEPINFO structure passed to <I>Invoke </I>in the <I>pExcepInfo </I>argument and having <I>Invoke </I>return DISP_E_EXCEPTION.<B> </B>Controllers that don't handle exceptions will pass a NULL in <I>pExcepInfo</I>.</P>
<P>The EXCEPINFO itself is defined as follows:</P>
<P><BR></P>
<pre><code>typedef struct tagEXCEPINFO<BR>    {<BR>    unsigned short wCode;    //Object exception code, excludes scode<BR>    unsigned short wReserved;<BR>    BSTR           bstrSource;      //ProgID of object<BR>    BSTR           bstrDescription; //Text description of error<BR>    BSTR           bstrHelpFile;    //Full path to a help file<BR>    unsigned long  dwHelpContext;   //Help context ID to display<BR>    void FAR*      pvReserved;<BR><BR>    //An object function for delayed filling of structure<BR>    HRESULT (STDAPICALLTYPE *pfnDeferredFillIn)<BR>        (struct tagEXCEPINFO FAR*);<BR><BR>    SCODE          scode;   //scode for error, excludes wCode<BR>    } EXCEPINFO, FAR* LPEXCEPINFO;</code></pre>
<P>When an object raises an exception, it stores an error code inside either <I>wCode </I>or <I>scode</I> but not in both.<B> </B>A 0 in <I>wCode </I>means that the <I>scode </I>has the error.<B> </B>After storing the code, the object can choose either to fill in the rest of the fields as necessary except for <I>pfnDeferredFillIn</I> or to set everything to NULL and store a function pointer in <I>pfnDeferredFillIn. </I>If the controller sees an exception with a pointer in this field, it calls (*<I>pfnDeferredFillIn</I>)(<I>&amp;</I><I>excepInfo</I>) when it wants the information. This allows the object to defer all of the potential costs of loading strings for the source and description fields until the controller actually wants it. The structure passed to this deferred filling function will have the <I>wCode </I>or <I>scode </I>originally stored within <I>Invoke </I>so that the filling function knows which exception was raised.3</P>
<P>The other four fields in the structure—however the controller obtains them—are used to display information about the exception to the user of that controller. The <I>bstrSource </I>string should contain the object's VersionIndependentProgID. If the field is non-NULL, the controller can then extract the value of this VersionIndependentProgID (a readable name) from the registry and display a message box with a message in the form "Error &lt;<I>code&gt; </I>in <I>&lt;readable name&gt; </I>: <I>&lt;bstrDescription&gt;</I>" provided <I>bstrDescription </I>is also valid. For example, the Beeper object we used before had a <I>Sound </I>property that is played through <I>MessageBeep </I>when the object's <I>Beep </I>method is invoked. Because this sound has to be meaningful to <I>MessageBeep</I>, it can have only the value MB_OK (0), MB_ICONHAND (16), MB_ICONQUESTION (32), MB_ICONEXCLAMATION (48), or MB_ICONASTERISK (64). If a controller attempts to give this object a value outside this range, the object raises an exception because there is no SCODE sufficiently rich to describe the actual error. The object will store its error code in <I>wCode </I>or <I>scode</I>, its VersionIndependentProgID of "Beeper.Object" in <I>bstrSource</I>, and the error description in <I>bstrDescription</I>. The controller will then display this information as shown in Figure 15-2 on page 755.</P>
<P>This message box will have an OK button by default, but if the object provides a non-NULL <I>bstrHelpFile</I>, the message box will also have a Help button. Pressing the Help button tells the controller to launch WinHelp, specifying the help file and context ID in the EXCEPINFO structure:</P>
<P><BR></P>
<pre><code>WinHelp(NULL, pExcepInfo-&gt;bstrHelpFile, HELP_CONTEXT<BR>    , pExcepInfo-&gt;dwHelpContext);</code></pre>
<P>The result is that the user can get even more detailed information on the exception, as shown in Figure 14-4.</P>
<P>    <img src="f14dd04p.gif"></P>
<P><B>Figure 14-4.</B></P>
<P><B>Exception information displayed in a help file.</B></P>
<P>It is the controller's responsibility to call <I>SysFreeString </I>for all the BSTR fields of the EXCEPINFO structure.</P>
<P><img src="16bit.gif"></P>
<P>As we explore various means of implementing <I>IDispatch</I> later in this chapter, we'll employ another error-reporting mechanism involving error objects. These are created with the API function <I>CreateErrorInfo </I>and the interface <I>ICreateErrorInfo</I>, set with the function <I>SetErrorInfo</I>, and accessed using <I>GetErrorInfo </I>and <I>IErrorInfo.</I> An object identifies its support for error objects by implementing <I>ISupportErrorInfo</I>. These functions and interfaces are basically a thread-safe mechanism for returning the same exception information to a controller that also ties into parts of OLE Automation itself.</P>
<H4><A NAME="sec8"></A>Supporting Locales</H4><P>In Chapter 3, we saw how a locale identifier serves as the basis for performing case mapping, string comparison, sorting, and conversion of date, time, and currency formats to and from strings. In addition, a locale identifier can form the basis for localized method, property, and event names for an automation object. For example, a user in Germany who would like to use our Beeper object would not necessarily understand what the <I>Sound </I>property really was or what action the <I>Beep </I>method would perform. In German, the object is better described as a <I>Pieper</I> (pronounced "peeper")with the property <I>Ton </I>(as in <I>tone</I>) and the method <I>Piep</I>. Instead of writing an automation script in English, a German user could write it in German:</P>
<P><BR></P>
<pre><code>Pieper.Ton = 32<BR>Pieper.Piep</code></pre>
<P>The <I>lcid </I>argument passed to the <I>IDispatch </I>members <I>GetTypeInfo</I>, <I>GetIDsOfNames</I>, and <I>Invoke</I> makes it possible for an <I>IDispatch </I>implementation to know which language is in use. It can use that information to return localized type information, convert localized member names to dispIDs, and invoke those members with the understanding that certain parameters, especially strings and time, date, or currency values, will be expressed in the language or format appropriate for that locale. In addition, it makes sense that any exception raised inside <I>Invoke </I>will provide information that is also sensitive to <I>lcid</I>—a user would not appreciate seeing an otherwise informative error message and help file show up in the wrong language!</P>
<P>You can support different locales from within an <I>IDispatch </I>implementation in a number of ways. We'll see some later in this chapter. The most flexible method of implementation is to have an automation object accept and support any locale from within a single version of the code. Then the object can be installed on any machine in the world and be immediately useful to any user.</P>
<P>This is, of course, the ideal case for an automation object, but it takes the most work. You can also choose an alternative approach that would not take as much time to implement and localize but that would still be flexible. The next-best technique, which is easily extensible to an arbitrary number of languages, is to support two languages—one localized, one neutral. (I'll illustrate this technique later with code.) An object like this allows a user to write a script in his or her own language while allowing the object to work with scripts written in the neutral language. This comes into play most often for automation objects that are useful to corporate or other developers. From what I've heard, programmers want to program in English, and this is understandable because all the system APIs are in English and all the lower-level programming tools and languages express their capabilities in English. As far as I know, the neutral language of choice is basic English (without a specific sublanguage).</P>
<P>Two-language support becomes very important with automation objects that can be accessed by multiple controllers at once. This means that the same instance of the object, one that is tied to a running application, for example, can be driven by two different controllers in two languages at the same time. One call to <I>Invo</I><I>ke </I>might use German, the next English, the next German, and so on. This would happen in the case in which the object was being driven both from an end-user script written in his or her local lang-uage and from a corporate developer's script written in English (the neutral language).</P>
<P>In my mind, the two-language approach is the best option because it's relatively easy to implement as well as to localize, and it addresses almost all of the important localization scenarios. Even so, there are two other techniques for handling locales; they are somewhat less flexible, but they might be the right choice in certain circumstances. In the first, an object can choose to support only a single locale, whatever the default is for the user or the machine, and return an error (DISP_E_UNKNOWNLCID) if a controller attempts to use it through any other language. This is fairly easy to implement, but it means that a script written for one language cannot be used on a machine that is operating with a different language, which, of course, shows why supporting a neutral language is advantageous. But if the automation object you're implementing is designed much more for an end user and not for corporate developers, this may be a reasonable choice.</P>
<P>On the other hand, you can implement an automation object that is not targeted to end users at all but targeted only to other developers (or perhaps advanced users). In that case, you can write an object that supports only one language, usually English, but also accepts any locale. This means you ignore any and all localization concerns, which is perfectly acceptable for objects that don't deal with time, date, or currency formats or with text that is displayed in a user interface or that would otherwise need translation. An automation object that performs 3-D graphics rendering, for example, is a good candidate for such an implementation. The more an implementation is potentially useful to an end user, the more important it becomes to support localization.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 There are two functions for converting an OLE Automation DATE type to the same informa-tion stored in an MS-DOS–compatible format (that is, the format used in the file system): <I>DosDateTimeToVariantDateTime </I>and <I>VariantTimeToDosDateTime</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>3 DispTest and Visual Basic 3.0 do not support deferred exception filling, but later versions of Visual Basic and other controllers do. If you want to make a flexible object that fills the exception structure now for potential Visual Basic 3 customers, it is very useful to still write a deferred filling function and call it from within your <I>Invoke </I>to fill a structure. When customers shift to a newer controller, you can, if you want to support deferred filling, replace that call from inside <I>Invoke </I>and simply store the function pointer in <I>pExcepInfo-&gt;pfnDeferredFillIn.</I></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
