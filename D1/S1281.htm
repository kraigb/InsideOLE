<HTML><HEAD><TITLE>Property Set Wrap-Up</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Property Set Wrap-Up</H3><P>You can imagine that a structure as detailed as a property set is not all that easy to write into a single stream, not to mention managing one that spans multiple streams. Figuring out how to serialize or deserialize every last data type and how to handle all cases robustly is not trivial. You learned how to work with stream and storage elements in Chapter 7, so this book will not describe other sample code that attempts to read and write property sets such as Summary Information. There are two reasons for this.</P>
<P>First, Microsoft Visual C++ and the Microsoft Developer's Library service have sufficient samples and facilities to simplify your dealings with property sets. For example, the OLE Control Development Kit (CDK) includes a few classes as part of the Microsoft Foundation Classes (MFC), namely <I>CPropertySet</I>,<I> CPropertySection</I>,<I> </I>and <I>CProperty. </I>These classes wrap the functionality in the major pieces of any property set, sheltering you from the complexities of messing with seek offsets and byte ordering. The CDK is the source of the data structures we've seen in this section. Using these classes, you should not have to touch the structures yourself.</P>
<P>These same products also contain sample code for a Summary Information dialog box along with code to read and write this specific stream (as opposed to the general classes that work with any property set). If you have an application that already maintains the type of information you would store in the Summary Information property set, integrating a user interface and storage code around that information won't be too much work. You may already have code to do something similar. The only two samples in this book that write files, Patron and Cosmo, do not maintain any of the information described in the property set, nor do they have the capacity for half of it. Because there are sufficient external samples, we will not add the Summary Information feature to these samples themselves.</P>
<P>The second reason we'll eschew specific property set samples is that one of the future enhancements to OLE will be an OLE-provided service to encapsulate property sets behind specific interfaces related to property storage. You can easily think of how one might wrap a property set into an <I>IPropertySet </I>interface along with <I>IPropertySection </I>and <I>IPropertyStorage</I>. When this service is available, you'll have as little need to worry about the guts of a property set as you do now with type information—let OLE take care of all the picky details.</P>
<P>As you might have noticed, OLE currently contains no services that deal with property sets, either to generate them or to make use of them in any way. The format described here is as far as it goes. An OLE service for manipulating property sets will be a welcome addition to all the other technologies we have.</P>
<P>That said, we can look at some implementation details concerning the other parts of this chapter, namely property change notifications and property pages.</P></font></body></HTML>
