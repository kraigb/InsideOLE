<HTML><HEAD><TITLE>Implementing a Property Page</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Implementing a Property Page</H2><P>When Beeper6 is asked for its list of property page CLSIDs, it specifies only <I>CLSID</I><I>_</I><I>BeeperPropertyPage</I>, whose server is BEEPPROP.DLL. BeepProp is a normal in-process server for an object that implements <I>IPropertyPage</I> and supports both English and German in its user interface. Its registry entries are extremely simple; we require only an entry for <I>InprocServer32 </I>under the appropriate CLSID subkey. Because a property page is always specified by its CLSID, there is no need to assign a ProgID or VersionIndependentProgID or to create registry entries for them. A property page also has no need for type information (at least at this point in time).</P>
<P>The source code for BeepProp is contained in BEEPPROP.CPP, including the class factory, required in-process server exports, and the property page object. In addition, BEEPPROP.RC contains the dialog templates for the property page itself, in both English and German, as well as the title strings that appear in the frame's tab for this page:</P>
<P><BR></P>
<pre><code>//From BEEPPROP.RC
STRINGTABLE<BR>    BEGIN<BR>     IDS_0_PAGETITLE,         "General"<BR>     IDS_7_PAGETITLE,         "Allgemein"<BR>    END<BR><BR>IDD_BEEPERPROPS_0 DIALOG DISCARDABLE  0, 0, 172, 88<BR>STYLE WS_CHILD<BR>FONT 8, "MS Sans Serif"<BR>BEGIN<BR>    CONTROL         "&amp;Default",IDC_BEEPDEFAULT,"Button",<BR>                    BS_AUTORADIOBUTTON œ WS_GROUP,13,8,84,12<BR>    CONTROL         "&amp;Hand",IDC_BEEPHAND,"Button",BS_AUTORADIOBUTTON,<BR>                    13,23,84,12<BR>    CONTROL         "&amp;Question",IDC_BEEPQUESTION,"Button",<BR>                    BS_AUTORADIOBUTTON,13,38,84,12<BR>    CONTROL         "&amp;Exclamation",IDC_BEEPEXCLAMATION,"Button",<BR>                    BS_AUTORADIOBUTTON,13,53,84,12<BR>    CONTROL         "&amp;Asterisk",IDC_BEEPASTERISK,"Button",<BR>                    BS_AUTORADIOBUTTON,13,68,84,12<BR>    DEFPUSHBUTTON   "&amp;Test",IDOK,118,8,50,14<BR>END<BR><BR><BR>IDD_BEEPERPROPS_7 DIALOG DISCARDABLE  0, 0, 172, 88<BR>STYLE WS_CHILD<BR>FONT 8, "MS Sans Serif"<BR>BEGIN<BR>    CONTROL         "&amp;Standard",IDC_BEEPDEFAULT,"Button",<BR>                    BS_AUTORADIOBUTTON œ WS_GROUP,13,8,84,12<BR>    CONTROL         "&amp;Hand",IDC_BEEPHAND,"Button",BS_AUTORADIOBUTTON,<BR>                    13,23,84,12<BR>    CONTROL         "&amp;Frage",IDC_BEEPQUESTION,"Button",<BR>                    BS_AUTORADIOBUTTON,13,38,84,12<BR>    CONTROL         "&amp;Ausruf",IDC_BEEPEXCLAMATION,"Button",<BR>                    BS_AUTORADIOBUTTON,13,53,84,12<BR>    CONTROL         "Ste&amp;rn",IDC_BEEPASTERISK,"Button",<BR>                    BS_AUTORADIOBUTTON,13,68,84,12<BR>    DEFPUSHBUTTON   "&amp;Test",IDOK,118,8,50,14<BR>END</code></pre>
<P>Notice the inclusion of WS_CHILD and the conspicuous lack of WS_CAPTION and WS_THICKFRAME styles on both dialog templates—creating a dialog box from either of the templates will create a window displaying the listed controls, but the dialog window itself will have no other embellishments. We can then create a dialog from a template as a child window of the frame dialog itself. This results in the proper user interface, as shown in Figure 16-7.</P>
<P>    <img src="f16dd07p.gif"></P>
<P><B>Figure 16-7.</B></P>
<P><B>The Beeper property page inside a property frame. The page itself is a modeless dialog created inside the frame dialog.</B></P>
<P>Deciding which template to load (and which page title string to use) occurs at run time within BeepProp's implementation of <I>IPropertyPage::SetPageSite</I>, the page's initialization function. Here it saves the LCID returned from <I>IPropertyPageSite::GetLocaleID</I> and initializes its variable <I>m</I><I>_</I><I>uIDTemplate </I>accordingly. It then calculates the size of the page on the basis of the dialog template and uses it later within <I>IPropertyPage::GetPageInfo</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeperPropPage::SetPageSite<BR>    (LPPROPERTYPAGESITE pPageSite)<BR>    {<BR>    if (NULL==pPageSite)<BR>        ReleaseInterface(m_pIPropertyPageSite)<BR>    else<BR>        {<BR>        HWND        hDlg;<BR>        RECT        rc;<BR>        LCID        lcid;<BR><BR>        m_pIPropertyPageSite=pPageSite;<BR>        m_pIPropertyPageSite-&gt;AddRef();<BR><BR>        if (SUCCEEDED(m_pIPropertyPageSite-&gt;GetLocaleID(&amp;lcid)))<BR>            m_lcid=lcid;<BR><BR>        switch (PRIMARYLANGID(m_lcid))<BR>            {<BR>            case LANG_GERMAN:<BR>                m_uIDTemplate=IDD_BEEPERPROPS_7;<BR>                break;<BR><BR>            case LANG_NEUTRAL:<BR>            case LANG_ENGLISH:<BR>            default:<BR>                m_uIDTemplate=IDD_BEEPERPROPS_0;<BR>                break;<BR>            }<BR><BR>        hDlg=CreateDialogParam(m_hInst<BR>            , MAKEINTRESOURCE(m_uIDTemplate), GetDesktopWindow()<BR>            , (DLGPROC)BeepPropPageProc, 0L);<BR><BR>        //If creation fails, use default values set in constructor.<BR>        if (NULL!=hDlg)<BR>            {<BR>            GetWindowRect(hDlg, &amp;rc);<BR>            m_cx=rc.right-rc.left;<BR>            m_cy=rc.bottom-rc.top;<BR><BR>            DestroyWindow(hDlg);<BR>            }<BR>        }<BR><BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CBeeperPropPage::GetPageInfo(LPPROPPAGEINFO pPageInfo)<BR>    {<BR>    IMalloc     *pIMalloc;<BR><BR>    if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc)))<BR>        return ResultFromScode(E_FAIL);<BR><BR>    pPageInfo-&gt;pszTitle=(LPOLESTR)pIMalloc-&gt;Alloc(CCHSTRINGMAX);<BR><BR>    if (NULL!=pPageInfo-&gt;pszTitle)<BR>        {<BR>        UINT        ids=IDS_0_PAGETITLE;<BR><BR>        if (PRIMARYLANGID(m_lcid)==LANG_GERMAN)<BR>            ids=IDS_7_PAGETITLE;<BR><BR>        LoadString(m_hInst, ids, pPageInfo-&gt;pszTitle, CCHSTRINGMAX);<BR>        }<BR><BR>    pIMalloc-&gt;Release();<BR><BR>    pPageInfo-&gt;size.cx      = m_cx;<BR>    pPageInfo-&gt;size.cy      = m_cy;<BR>    pPageInfo-&gt;pszDocString = NULL;<BR>    pPageInfo-&gt;pszHelpFile  = NULL;<BR>    pPageInfo-&gt;dwHelpContext= 0;<BR>    return NOERROR;<BR>    }</code></pre>
<P>Notice how <I>SetPageSite </I>creates the page dialog, retrieves its dimensions, and destroys the dialog immediately. This is done only to initialize <I>m</I><I>_</I><I>cx </I>and <I>m</I><I>_</I><I>cy </I>for use in <I>GetPageInfo</I>, which will be called before this page is activated, if ever. Creating the dialog and calling the Windows function <I>GetWindowRect </I>is much easier than loading the dialog template directly and trying to calculate the extents on the basis of the dialog units in the template. This would involve creating a font, mucking with font sizes and extents, and converting all the values. Windows does this automatically when you create a dialog from the same template, so here I'm simply taking advantage of that convenience. I destroy the dialog immediately because I don't want to hog extra resources by keeping this page in memory when it might not be displayed at all. We want the <I>IPropertyPage::Activate </I>and <I>Deactivate </I>functions to control our use of these resources, in which we create the appropriate dialog or destroy it:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeperPropPage::Activate(HWND hWndParent<BR>    , LPCRECT prc, BOOL fModal)<BR>    {<BR>    if (NULL!=m_hDlg)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    m_hDlg=CreateDialogParam(m_hInst, MAKEINTRESOURCE(m_uIDTemplate)<BR>        , hWndParent, BeepPropPageProc, (LPARAM)this);<BR><BR>    if (NULL==m_hDlg)<BR>        return ResultFromScode(E_OUTOFMEMORY);<BR><BR>    //Move page into position and show it.<BR>    SetWindowPos(m_hDlg, NULL, prc-&gt;left, prc-&gt;top<BR>        , prc-&gt;right-prc-&gt;left, prc-&gt;bottom-prc-&gt;top, 0);<BR><BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CBeeperPropPage::Deactivate(void)<BR>    {<BR>    if (NULL==m_hDlg)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    DestroyWindow(m_hDlg);<BR>    m_hDlg=NULL;<BR>    return NOERROR;<BR>    }</code></pre>
<P>Nothing fancy going on, simply straight Windows programming, which applies equally for the <I>Show </I>and <I>Move </I>members of <I>IPropertyPage </I>as well:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeperPropPage::Show(UINT nCmdShow)<BR>    {<BR>    if (NULL==m_hDlg)<BR>        ResultFromScode(E_UNEXPECTED);<BR><BR>    ShowWindow(m_hDlg, nCmdShow);<BR><BR>    //Take the focus.<BR>    if (SW_SHOWNORMAL==nCmdShow œœ SW_SHOW==nCmdShow)<BR>        SetFocus(m_hDlg);<BR><BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CBeeperPropPage::Move(LPCRECT prc)<BR>    {<BR>    SetWindowPos(m_hDlg, NULL, prc-&gt;left, prc-&gt;top<BR>        , prc-&gt;right-prc-&gt;left, prc-&gt;bottom-prc-&gt;top, 0);<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>Before <I>Activate </I>is called, however, the frame will pass the array of <I>IUnknown </I>pointers for the affected objects to our <I>IPropertyPage::SetObjects. </I>Here we must free any object selection we might already have and then copy the pointers we need, being sure to call <I>AddRef </I>through them.  BeepProp specifically queries for <I>IBeeper</I>, through which it knows it can access the necessary features of the Beeper object:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeperPropPage::SetObjects(ULONG cObjects<BR>    , IUnknown **ppUnk)<BR>    {<BR>    BOOL        fRet=TRUE;<BR><BR>    FreeAllObjects();<BR><BR>    if (0!=cObjects)<BR>        {<BR>        UINT        i;<BR>        HRESULT     hr;<BR><BR>        m_ppIBeeper=new IBeeper * [(UINT)cObjects];<BR><BR>        for (i=0; i &lt; cObjects; i++)<BR>            {<BR>            hr=ppUnk[i]-&gt;QueryInterface(IID_IBeeper<BR>                , (void **)&amp;m_ppIBeeper[i]);<BR><BR>            if (FAILED(hr))<BR>                fRet=FALSE;<BR>            }<BR>        }<BR><BR>    //If we didn't get one of our objects, fail this call.<BR>    if (!fRet)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    m_cObjects=cObjects;<BR>    return NOERROR;<BR>    }</code></pre>
<P>The internal function <I>CBeeperPropPage::FreeAllObjects </I>calls <I>Release </I>on every pointer in <I>m</I><I>_</I><I>ppIBeeper </I>and deletes the <I>m</I><I>_</I><I>ppIBeeper</I> array itself.</P>
<P>After we know the objects for which this property page is being displayed, we can use those objects to set up the initial state of the control on the page. This happens in the WM_INITDIALOG case of <I>BeepPropPageProc</I>, which is the dialog procedure for the property page. (The local variable <I>pObj </I>inside this dialog procedure is the <I>CBeeperPropPage </I>pointer, managed with the Windows API functions <I>SetProp </I>and <I>GetProp.</I>) We retrieve the current sound from the underlying Beeper object and check the appropriate radio button:</P>
<P><BR></P>
<pre><code>case WM_INITDIALOG:<BR>    §<BR>    if (1==pObj-&gt;m_cObjects)<BR>        {<BR>        UINT        iButton;<BR><BR>        iButton=(UINT)pObj-&gt;m_ppIBeeper[0]-&gt;get_Sound();<BR><BR>        if (0==iButton)<BR>            iButton=IDC_BEEPDEFAULT;<BR><BR>        CheckRadioButton(hDlg, IDC_BEEPDEFAULT<BR>            , IDC_BEEPASTERISK, iButton);<BR><BR>        pObj-&gt;m_uIDLastSound=iButton;<BR>        }<BR>    §</code></pre>
<P>This code initializes the dialog state only if there is a single object—otherwise, it leaves the state uninitialized. A more sophisticated property page would try to reconcile the states of all underlying objects in a way that if they all have the same state, some of the dialog controls could be initialized.</P>
<P>The variable <I>m</I><I>_</I><I>uIDLastSound </I>in <I>CBeeperPropPage </I>is used to keep track of changes that occur in the radio button selection in this property page. In the WM_COMMAND message processing of <I>BeepPropPageProc</I>, we execute the following code whenever a radio button is selected:</P>
<P><BR></P>
<pre><code>if (pObj-&gt;m_uIDLastSound==wID)<BR>    break;<BR><BR>//Save most recently selected sound.<BR>pObj-&gt;m_uIDLastSound=LOWORD(wParam);<BR>pObj-&gt;m_fDirty=TRUE;<BR><BR>if (NULL!=pObj-&gt;m_pIPropertyPageSite)<BR>    {<BR>    pObj-&gt;m_pIPropertyPageSite<BR>        -&gt;OnStatusChange(PROPPAGESTATUS_DIRTY);<BR>    }</code></pre>
<P>In short, if the newly selected sound is different from the last selection, we consider the page to be dirty by setting <I>m</I><I>_</I><I>fDirty</I>. At the same time, we have to notify the page site of the change by calling <I>IPropertyPageSite::OnStatusChange </I>with PROPPAGESTATUS_DIRTY. Now our dirty flag will affect the return value from <I>IPropertyPage::IsPageDirty </I>in this way:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeperPropPage::IsPageDirty(void)<BR>    {<BR>    return ResultFromScode(m_fDirty ? S_OK : S_FALSE);<BR>    }</code></pre>
<P>This function is called when the user closes the dialog box with the OK button. If our page is dirty, the frame will call <I>IPropertyPage::Apply</I> before deactivating this page and destroying the object. Of course, we might receive an <I>Apply </I>call before this time because our call to <I>IPropertyPageSite::OnStatusChange </I>will tell the frame to enable its Apply Now button. The frame will call <I>Apply </I>when the user presses this button. In response, we send the current sound value (<I>m</I><I>_</I><I>uIDLastSound</I>) to the affected objects:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CBeeperPropPage::Apply(void)<BR>    {<BR>    UINT        i;<BR>    UINT        lSound, lSoundNew;<BR>    BOOL        fChanged;<BR><BR>    if (0==m_cObjects)<BR>        return NOERROR;<BR><BR>    lSound=(IDC_BEEPDEFAULT==m_uIDLastSound) ? 0L : m_uIDLastSound;<BR>    fChanged=TRUE;<BR><BR>    for (i=0; i &lt; m_cObjects; i++)<BR>        {<BR>        m_ppIBeeper[i]-&gt;put_Sound(lSound);<BR>        lSoundNew=m_ppIBeeper[i]-&gt;get_Sound();<BR><BR>        fChanged &amp;= (lSound==lSoundNew);<BR>        }<BR><BR>    m_fDirty=!fChanged;<BR>    return NOERROR;<BR>    }</code></pre>
<P>Because this property page knows that the Beeper object implements the interface <I>IBeeper </I>(defined in ..\BEEPER6\IBEEPER.H, an output file from MKTYPLIB), we can call its <I>put</I><I>_</I><I>Sound </I>member to apply the changes. However, because <I>put</I><I>_</I><I>Sound </I>doesn't return an error code, we must call <I>get</I><I>_</I><I>Sound </I>afterward to check whether the sound actually did change. For example, if you choose Enforce Read-Only in AutoCli2 before choosing Properties, changes made in the property page will not affect the Beeper object at all. Our implementation of <I>Apply </I>here will not clear its dirty flag unless changes are applied successfully. What is the result? After calling <I>Apply</I>,<I> </I>the frame will immediately call <I>IsPageDirty </I>to see whether the changes made the page clean. If so, it disables the Apply Now button until another call to <I>IPropertyPageSite::OnStatusChange</I>. If we do not clear the dirty flag within <I>Apply</I>,<I> </I>the Apply Now button will remain enabled, as it should be to indicate a dirty state.</P>
<P>Remember, the way a property page applies its changes to the affected objects is decided between the page and the object. In this sample, BeepProp knows about Beeper6's custom interface, so it uses that interface directly, which has the nice side effect of being independent of localization concerns. We could accomplish the same thing by calling <I>IDispatch::GetIDsOfNames </I>for the <I>Sound</I> property (or <I>Ton</I> in German) followed by a call to <I>IDispatch::Invoke</I>. It doesn't matter when a custom property page is involved. A standard property page—one that is intended to be used for different object classes—must specify exactly how it intends to apply changes to the objects. The standard font, color, and picture pages in the OLE Control Development Kit will always send standard dispID values to the object's <I>IDispatch::Invoke</I> and assume that the object knows what to do with the new values.</P>
<P>Only three things are left in this implementation. First, the Test button in our property page is really only a convenience for the user. To implement it, we call <I>MessageBeep </I>with <I>m</I><I>_</I><I>uIDLastSound</I> because we know exactly what the Beeper object does with a sound. This is appropriate because the object may, in fact, not be allowed to change its properties at all if the client is disallowing changes through <I>IPropertyNotifySink::OnRequestEdit. </I>But even if changes were allowed, we'd have to save the existing sound value, set the new one, have the object play the sound, and then restore the original—a big waste of time. We already assume knowledge about the object, so we might as well use it.</P>
<P>The final two items are the <I>Help </I>and <I>TranslateAccelerator </I>members of <I>IProp-</I><I> </I><I>ertyNotifySink</I>. We don't implement any help, so this function returns E_NOTIMPL, but it will never be called because our <I>GetPageInfo </I>didn't provide any help information. BeepProp also returns E_NOTIMPL from <I>TranslateAccelerator, </I>which means that this page lacks a keyboard interface. You'll notice that the Tab key does nothing and that mnemonics do not work (except for the buttons that the frame owns). Supporting these requires that <I>TranslateAccelerator </I>watch for Alt key combinations as well as for Tab and Shift+Tab, setting the focus to the appropriate control for the various keystrokes. This is necessary because the frame's message loop sees all keyboard messages first and can't do anything more than send the keystrokes to the active page. The page dialog will not handle this automatically; you have to implement the keyboard interface directly. The OLE Control Development Kit has facilities for creating property pages with little effort, and MFC provides the implementation of a keyboard interface based on your dialog template.</P></font></body></HTML>
