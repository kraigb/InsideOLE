<HTML><HEAD><TITLE>Component Software: The Breakthrough</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Component Software: The Breakthrough</H3><P>Object-oriented programming has long been advanced as a solution to the problems at hand. However, while object-oriented programming is powerful, it has yet to reach its full potential because, in part, no standard framework exists through which software created by different vendors can interact within the same address space—much less across address spaces—and across network and machine architecture boundaries. The major result of the object-oriented programming revolution has been the production of islands of objects that can't talk to one another across the oceanic boundaries in a meaningful way. Messages in bottles just don't cut it.</P>
<P>The solution is a system in which software developers create <I>software</I> <I>components</I>. A software component is reusable pieces of code and data in binary form that can be plugged into other software components from other vendors with relatively little effort. Software components must adhere to an external binary standard, but their internal implementation is completely unconstrained. They can be built using procedural languages as well as object-oriented languages and frameworks (although the latter usually provide many development advantages).</P>
<P>Software component objects are much like integrated circuit (IC) components, and component software is the integrated circuitry of tomorrow. The software industry today is very much where the hardware industry was 20 years ago. At that time, vendors learned how to shrink transistors and put them into a package so that no one had to figure out how to build a particular discrete function—a NAND gate, for example—ever again. Such functions were built into an integrated circuit, a neat package that designers could conveniently buy and design around. As the hardware functions became more complex, the ICs were further integrated to make a board of chips that provided more complex functionality and increased capability. As integrated circuits got smaller yet provided more functionality, boards of chips became just bigger chips. So hardware technology now uses chips to build even bigger chips.</P>
<P>The software industry is now at a point where software developers have been busy building the software equivalent of discrete transistors—software routines—for a long time.</P>
<P>OLE offers a solution and a future—extensible standards and mechanisms to enable software developers to package their functionality, and content, into reusable components, like an integrated circuit. Instead of worrying about how<I> </I>to build functions, developers can simply acquire or purchase that function without having to care about its internal implementation. Just as electronics engineers do not purchase the sources for integrated circuits and rebuild them, OLE allows you to buy a binary component and reuse it, plugging into it through its external interfaces. Not only is this component software a great benefit for developers, but it will eventually allow even end users to assemble custom applications. Users will then have the ability to solve their own problems immediately on a level they understand instead of having to wait months or years for a one-size-fits-all solution. Thus, OLE is the innovation to spark an exciting new fire in all aspects of computing.</P></font></body></HTML>
