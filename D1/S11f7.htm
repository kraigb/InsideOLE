<HTML><HEAD><TITLE>Freeloading from the Data Cache</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Freeloading from the Data Cache</H2><P>The data cache is a rich service that can do quite a lot for whatever happens to be using it. With the cache, you get a service that knows how to draw, save, and load a variety of presentation formats as well as how to connect itself to a remote object and automatically update its data when that object's data changes. The data cache obviously has a number of potential uses.</P>
<P>The primary use is that of implementing an object in an in-process handler, especially in OLE Documents. I mentioned earlier how a handler object must synchronize data changes with its local server to keep its implementation of <I>IViewObject2::Draw </I>up to date. If that handler object doesn't have reason to implement <I>Draw </I>itself, it can rely entirely on the cache for its implementation. The cache can then manage its own internal state by connecting to a remote object, asking for presentations through <I>IDataObject::GetData</I>, and watching for changes in those presentations through <I>IAdviseSink::OnDataChange.</I> The handler object doesn't even need its own advise sink! Because the data cache has such great utility in this manner, a handler object can aggregate on the cache for any interfaces it finds useful to expose. The handler object customizes only those interfaces that it really wants to control.</P>
<P>The second use of the data cache is as a cache for static graphics. In this case, it is never connected to a remote object. Instead, you can store and retrieve metafiles and bitmaps and take advantage of the cache's drawing and persistence capabilities. In Chapter 12, when we look at the OLE Clipboard, we'll add <I>tenants</I> to the Patron sample (last seen in Chapter 7) that can contain static metafiles or bitmaps. (This lends itself well to enabling tenants to contain compound document content objects, which we'll see in Chapter 17.) Many applications, especially word processors and business graphics applications, do something similar because their users like to integrate graphics into documents and slide shows. When I thought about adding these features to Patron, I felt a tad queasy: I would first have to write code to draw metafiles and bitmaps (not too bad) and then more code to save that data in a disk file and load it back into memory again. I don't know about you, but serializing graphics to a file and then figuring out how to load them again involve a degree of tedium that I avoid like the plague.</P>
<P>This is exactly what the data cache is good at doing already. The trick is to figure out how to freeload from OLE in the right way. This isn't all that hard because OLE supports two CLSIDs, named <I>CLSID</I><I>_</I><I>Picture</I><I>_</I><I>Metafile (00000315-0000-0000-C000-000000000046) </I>and <I>CLSID</I><I>_</I><I>Picture</I><I>_</I><I>Dib (00000316-0000-0000-C000-000000000046)</I>, that are specific instances of the data cache that manage a single presentation format. OLE supports these CLSIDs for the purposes of static compound document objects, which are presentations without a known source.</P>
<P>To test how much I could take advantage of OLE's inherent services, I came up with the sample named Freeloader (CHAP11\FREELOAD), shown in Figure 11-3. This handy application can copy or paste any metafile or bitmap from the clipboard and load or save it to a compound file with the FRE extension. Freeloader is built on the sample code CLASSLIB, as are Patron and Cosmo, in which each document can contain one graphic. Freeloader demonstrates the use of the data cache and the client side of <I>IViewObject2</I>. We'll see an implementation of <I>IViewObject2</I> in Chapter 19, where we implement a handler for use in conjunction with an OLE Documents server.</P>
<P>    <img src="f11dd03p.gif"></P>
<P><B>Figure 11-3.</B></P>
<P><B>The Freeloader program, with three open presentations.</B></P>
<P>In Freeloader, all the relevant code for working with the cache and its interfaces is found in DOCUMENT.CPP. In particular, this file includes the functions dealing with the clipboard: <I>Clip</I>, <I>RenderFormat</I>, and <I>Paste</I> members in the class <I>CFreeloaderDoc</I>. The <I>Load</I> and <I>Save</I> members call the cache's <I>IPersistStorage</I> members according to the contract described for this interface in Chapter 7, so there's little need to look at the code. More to the point, a Freeloader document saves itself by creating a compound file and asking the cache to save its data in that storage through <I>IPersistStorage::Save</I>. Loading is a matter of opening that file, creating a cache, and telling it to load through <I>IPersistStorage::Load.</I></P>
<P>The <I>CFreeloaderDoc::FMessageHook</I> function shows how to call <I>IViewObject2::Draw</I> with a continuation function (for which <I>OleDraw </I>doesn't suffice):</P>
<P><BR></P>
<pre><code>BOOL CFreeloaderDoc::FMessageHook(HWND hWnd, UINT iMsg<BR>    , WPARAM wParam, LPARAM lParam, LRESULT *pLRes)<BR>    {<BR>    PAINTSTRUCT     ps;<BR>    HDC             hDC;<BR>    RECT            rc;<BR>    RECTL           rcl;<BR>    LPVIEWOBJECT2   pIViewObject2;<BR>    HRESULT         hr;<BR><BR>    if (WM_PAINT!=iMsg)<BR>        return FALSE;<BR><BR>    hDC=BeginPaint(hWnd, &amp;ps);<BR>    GetClientRect(hWnd, &amp;rc);<BR><BR>    if (NULL!=m_pIUnknown)<BR>        {<BR>        hr=m_pIUnknown-&gt;QueryInterface(IID_IViewObject2<BR>            , (PPVOID)&amp;pIViewObject2);<BR><BR>        if (SUCCEEDED(hr))<BR>            {<BR>            //Put "Hit Esc to stop" in status line.<BR>            m_pFR-&gt;StatusLine()-&gt;MessageSet(PSZ(IDS_HITESCTOSTOP));<BR><BR>            RECTLFROMRECT(rcl, rc);<BR>            pIViewObject2-&gt;Draw(DVASPECT_CONTENT, -1, NULL, NULL<BR>                , 0, hDC, &amp;rcl, NULL, ContinuePaint, 0);<BR>            pIViewObject2-&gt;Release();<BR><BR>            m_pFR-&gt;StatusLine()-&gt;MessageDisplay(ID_MESSAGEREADY);<BR>            }<BR>        }<BR><BR>    EndPaint(hWnd, &amp;ps);<BR>    return FALSE;<BR>    }<BR><BR>BOOL CALLBACK ContinuePaint(DWORD dwContinue)<BR>    {<BR>    return !(GetAsyncKeyState(VK_ESCAPE) &lt; 0);<BR>    }</code></pre>
<P>In all truth, the <I>Clip</I> and <I>RenderFormat</I> functions do very little. <I>Cl</I><I>ip </I>opens the clipboard, asks <I>RenderFormat </I>for a presentation, and sticks that presentation on the clipboard. <I>RenderFormat </I>does its thing by calling the cache's <I>IDataObject::GetData</I>:</P>
<P><BR></P>
<pre><code>HGLOBAL CFreeloaderDoc::RenderFormat(UINT cf)<BR>    {<BR>    LPDATAOBJECT        pIDataObject;<BR>    FORMATETC           fe;<BR>    STGMEDIUM           stm;<BR><BR>    if (NULL==m_pIUnknown)<BR>        return NULL;<BR><BR>    [Set up fe and stm appropriately for format.]<BR><BR>    m_pIUnknown-&gt;QueryInterface(IID_IDataObject<BR>        , (PPVOID)&amp;pIDataObject);<BR>    pIDataObject-&gt;GetData(&amp;fe, &amp;stm);<BR>    pIDataObject-&gt;Release();<BR><BR>    return stm.hGlobal;<BR>    }</code></pre>
<P>But how on earth did we originally obtain the pointer to the object? The answer lies in <I>CFreeloaderDoc::Paste</I>:</P>
<P><BR></P>
<pre><code>BOOL CFreeloaderDoc::Paste(HWND hWndFrame)<BR>    {<BR>    UINT                cf=0;<BR>    BOOL                fRet=FALSE;<BR>    HRESULT             hr;<BR>    DWORD               dwConn;<BR>    LPUNKNOWN           pIUnknown;<BR>    LPOLECACHE          pIOleCache;<BR>    LPPERSISTSTORAGE    pIPersistStorage;<BR>    FORMATETC           fe;<BR>    STGMEDIUM           stm;<BR>    CLSID               clsID;<BR><BR>    if (!OpenClipboard(hWndFrame))<BR>        return FALSE;<BR><BR>    /*<BR>     * Try to get data in order of metafile, dib, bitmap.  We set<BR>     * stm.tymed up front so that if we actually get something a <BR>     * call to ReleaseStgMedium will clean it up for us.<BR>     */<BR><BR>    stm.pUnkForRelease=NULL;<BR>    stm.tymed=TYMED_MFPICT;<BR>    stm.hGlobal=GetClipboardData(CF_METAFILEPICT);<BR><BR>    if (NULL!=stm.hGlobal)<BR>        cf=CF_METAFILEPICT;<BR><BR>    if (0==cf)<BR>        {<BR>        stm.tymed=TYMED_HGLOBAL;<BR>        stm.hGlobal=GetClipboardData(CF_DIB);<BR><BR>        if (NULL!=stm.hGlobal)<BR>            cf=CF_DIB;<BR>        }<BR><BR>    if (0==cf)<BR>        {<BR>        stm.tymed=TYMED_GDI;<BR>        stm.hGlobal=GetClipboardData(CF_BITMAP);<BR><BR>        if (NULL!=stm.hGlobal)<BR>            cf=CF_BITMAP;<BR>        }<BR><BR>    CloseClipboard();<BR><BR>    //Didn't get anything?  Then we're finished.<BR>    if (0==cf)<BR>        return FALSE;<BR><BR>    //This now describes data we have.<BR>    SETDefFormatEtc(fe, cf, stm.tymed);<BR><BR>    hr=CreateDataCache(NULL, CLSID_NULL, IID_IUnknown<BR>        , (PPVOID)&amp;pIUnknown);<BR><BR>    if (FAILED(hr))<BR>        {<BR>        ReleaseStgMedium(&amp;stm);<BR>        return FALSE;<BR>        }<BR><BR>    pIUnknown-&gt;QueryInterface(IID_IPersistStorage<BR>        , (PPVOID)&amp;pIPersistStorage);<BR>    pIPersistStorage-&gt;InitNew(m_pIStorage);<BR>    pIPersistStorage-&gt;Release();<BR><BR>    pIUnknown-&gt;QueryInterface(IID_IOleCache, (PPVOID)&amp;pIOleCache);<BR>    pIOleCache-&gt;Cache(&amp;fe, 0, &amp;dwConn);<BR><BR>    hr=pIOleCache-&gt;SetData(&amp;fe, &amp;stm, TRUE);<BR>    pIOleCache-&gt;Release();<BR><BR>    if (FAILED(hr))<BR>        {<BR>        ReleaseStgMedium(&amp;stm);<BR>        pIUnknown-&gt;Release();<BR>        return FALSE;<BR>        }<BR><BR>    //Now that that's all done, replace our current with the new.<BR>    ReleaseObject();<BR>    m_pIUnknown=pIUnknown;<BR>    m_dwConn=dwConn;<BR><BR>    FDirtySet(TRUE);<BR><BR>    InvalidateRect(m_hWnd, NULL, TRUE);<BR>    UpdateWindow(m_hWnd);<BR>    return TRUE;<BR>    }</code></pre>
<P>The first half of <I>Paste</I> looks like a reasonably normal piece of Windows code that gets a graphics image from the clipboard. The slightly odd thing about it is that I'm storing the data handle directly into a STGMEDIUM (because it's there). I also initialize a FORMATETC with the description of the data I actually pasted. I call <I>CreateDataCache </I>to create a cache object and tell it to initialize itself through <I>IPersistStorage::InitNew</I>. I then tell the cache object to cache the format I found on the clipboard through <I>IOleCache::Cache</I>, stuff that data into it with <I>IOleCache::SetData</I>, and then clean everything up.</P>
<P>Freeloader also uses <I>IViewObject2::GetExtent </I>to size the window to match the graphic when reopening a file. This occurs in <I>CFreeloaderDoc::SizeToGraphic</I>, (also called from Freeloader's Edit/Size To Graphic menu item).</P>
<P>That's really all there is to it, and it seems much simpler than having to write so much more code. (Code I don't need to write to make Patron functional in Chapter 12.) All compliments of OLE.</P></font></body></HTML>
