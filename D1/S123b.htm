<HTML><HEAD><TITLE>Five Variations on the Theme of Implementing a Simple Automation Object</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Five Variations on the Theme of Implementing a Simple Automation Object</H2><P>A few short steps from where I'm writing this chapter sits a piano. I often take breaks and play for a while to let my brain incubate and organize the next stage of writing. It happens that my current practice includes Beethoven's Fifteen Variations with Fugue on a Theme from the Eroïca Symphony, op. 35, and Brahms's Variations and Fugue on a Theme by Handel for Pianoforte, op. 24. Fabulous pieces, but perhaps they have influenced me a bit too much as I've worked on Automation. The samples in this chapter seem to follow a similar pattern: a number of variations (only five of them!) on a theme of a simple automation object, followed by a longer and more complex fugue in the form of an automated version of our dear friend Cosmo<I>. </I>What's scary is that the musical analogy holds better than you might think.</P>
<P>To illustrate a simple automation object, let's fully define the Beeper object used as an example earlier in this chapter. This object, implemented in a DLL, has one property and one method in its incoming interface. Furthermore, we'll support both English and German interfaces in all but the last variation. Our theme is specified as follows:</P>
<H3><A NAME="sec0"></A>Property:</H3><P><I>Sound</I> (German: <I>Ton</I>), a <I>long</I> that can be set to 0, 16, 32, 48, or 64, corresponding to the allowable values that can be sent to the <I>MessageBeep</I> function.</P>
<H3><A NAME="sec1"></A>Method:</H3><P><I>Beep</I> (German: <I>Piep</I>), takes no arguments (<I>void</I>) and returns a <I>long</I>, the sound that was played.</P>
<P><img src="16bit.gif"></P>
<P>We'll examine five different ways to implement the <I>IDispatch</I> interface through which <I>Sound</I> and <I>Beep</I> can be invoked, progressing as follows. (The name in the parentheses is the directory of the associated sample.)</P>
<H3><A NAME="sec2"></A>Variation I</H3><P>(BEEPER1) A completely raw and manual implementation of <I>IDispatch</I> that supports simultaneous access to the dispinterface in either English or German, with full help in either language. This variation raises an exception if the controller tries to change the <I>Sound</I> property to an incorrect value, but it does not have any type information.</P>
<H3><A NAME="sec3"></A>Variation II</H3><P>(BEEPER2) A more convenient implementation of <I>IDispatch</I> that takes advantage of type information to perform type coercion and name-to-dispID mapping. This variation supports English and German simultaneously and raises exceptions. The exception handling mechanism, however, works only for a single-threaded model.</P>
<H3><A NAME="sec4"></A>Variation III</H3><P>(BEEPER3) Solves the single-thread exception problem of Variation II through the error object mechanisms that OLE provides.</P>
<H3><A NAME="sec5"></A>Variation IV</H3><P>(BEEPER4) Implements our dispinterface through a dual interface, illustrating the special techniques involved.</P>
<H3><A NAME="sec6"></A>Variation V</H3><P>(BEEPER5) A reprise of Variation III that takes advantage of an OLE-provided Standard Dispatch object to free us from having our own <I>IDispatch</I> entry points at all. However, this allows us to support only one language.</P>
<P>Beeper2 and Beeper3 will usually be the most common of these implementation techniques because they are the most flexible and are easy to implement (depending on what sort of threading you use). Beeper4 will be the next most common, suitable for when you need more performance. Beeper5 is easier to implement than the others but is restricted to a single language. Lastly, although Beeper1 won't be too useful for most automation objects, it is useful when you need to implement only a simple <I>IDispatch</I> interface—to use with an event sink, for example—because you have no need for type information or even for implementing <I>IDispatch::GetIDsOfNames.</I> These five techniques will show us the full set of options when it comes to <I>IDispatch</I>. Choose the method that makes sense for you.</P>
<P>To let you play these variations, the BEEPTEST\DISPTEST directory in this chapter contains a DispTest/Visual Basic 3 program for thoroughly pummeling each Beeper. BEEPTEST\NEWVB has the same program saved in the format of the next version of Visual Basic. If you want to watch what happens with one of these objects in a controller's source code, you can use the AutoCli sample from Chapter 15, which is written specifically for using a Beeper object.</P>
<P>Before looking at each variation, note that the DLL server code surrounding the object is the same in all of them (with one minor exception for multithreading concerns). The files DBEEPER.CPP and DBEEPER.H contain the standard DLL entry point and exported functions as well as the class factory implementation. The Beeper's CLSID in all cases is <I>{</I><I>00021125-0000-0000-C000-000000000046</I><I>}</I>, defined as CLSID_Beeper in INC\BOOKGUID.H. In each sample, the most important files are BEEPER.CPP, BEEPER.H, and the ODL files that are present. BEEPER.CPP contains the implementation of the object in the class <I>CBeeper</I>; BEEPER.H contains the definitions; and the ODL files provide type information. <I>CBeeper</I> is usually defined as follows in BEEPER.H:</P>
<P><BR></P>
<pre><code>class CBeeper : public IUnknown  //Possibly a different base interface<BR>    {<BR>    //Possible friend declarations<BR><BR>    protected:<BR>        ULONG           m_cRef;             //Object reference count<BR>        LPUNKNOWN       m_pUnkOuter;        //Controlling unknown<BR>        PFNDESTROYED    m_pfnDestroy;       //To call on closure<BR><BR>        long            m_lSound;           //Type of sound<BR><BR>        //Some kind of IDispatch implementation pointer and other<BR>        //variables are needed to manage implementation.<BR><BR>    public:<BR>        CBeeper(LPUNKNOWN, PFNDESTROYED);<BR>        ~CBeeper(void);<BR><BR>        BOOL Init(void);<BR><BR>        //Nondelegating object IUnknown<BR>        STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>        STDMETHODIMP_(ULONG) AddRef(void);<BR>        STDMETHODIMP_(ULONG) Release(void);<BR><BR>        //Possibly other member functions<BR>    };<BR><BR>typedef CBeeper *PCBeeper;</code></pre>
<P>The comments in the code above mark where we'll generally modify for the variations of the object. In all cases, however, the <I>CBeeper</I> class has a set of <I>IUnknown</I> functions, a reference count, an <I>m</I><I>_</I><I>lSound</I> value, and the other members shown here.</P></font></body></HTML>
