<HTML><HEAD><TITLE>DKoala1 and EKoala1</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>DKoala1 and EKoala1</H3><P>As I mentioned earlier, both the DKoala1 and the EKoala1 server contain exactly the same implementation of the Koala object. In fact, their class factory implementations are almost identical as well, and their registry entries differ only by the <I>InprocServer32</I> and <I>LocalServer32</I> entries.</P>
<P>As you know by now, each server has to maintain a count of its current objects so it can properly control unloading. Typically this will be a global variable. But because I don't want the Koala object tied to a global variable in some other source file, I instead have the class factory pass Koala's constructor (<I>CKoala::CKoala</I>) a pointer to an "object destroyed" function with the following prototype:</P>
<P><BR></P>
<pre><code>void ObjectDestroyed(void)</code></pre>
<P>The Koala object stores the pointer in <I>m</I><I>_</I><I>pfnDestroy</I> and calls the function when destroying itself in <I>Release</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(ULONG) CKoala::Release(void)<BR>    {<BR>    if (0L!=--m_cRef)<BR>        return m_cRef;<BR><BR>    if (NULL!=m_pfnDestroy)<BR>        (*m_pfnDestroy)();<BR><BR>    delete this;<BR>    return 0;<BR>    }</code></pre>
<P>This little trick eliminates any compile-time relationship between the server code and the object code, making it a run-time relationship instead. Koala doesn't call <I>ObjectDestroyed </I>by name; it calls a function that matches the prototype, a pointer it receives when constructed. This trick makes such an object rather portable between different server modules, which you might find useful.</P>
<P>The second point about the Koala object is that it is also given a <I>pUnkOuter</I> pointer if it's created as part of an aggregation. Because Koala implements only <I>IUnknown</I>, this is pretty useless in and of itself. I included it here not only to show how the <I>IClassFactory </I>implementation should handle the aggregation scenario but also to make a clean object framework that can be easily extended with additional interfaces that might be used in aggregation. If you use this code as such a base, any additional interfaces' <I>IUnknown </I>members should delegate to the <I>pUnkOuter </I>pointer passed to Koala's constructor, which was demonstrated in Chapter 2.</P>
<H4><A NAME="sec0"></A>The Class Factory and the Unloading Mechanism</H4><P>Both KOALA servers define for their class factory objects a C++ class <I>CKoalaClassFactory</I>, which singly inherits from <I>IClassFactory</I>. The definitions (in DKOALA1.H and EKOALA1.H) are identical, with the only member variable being a reference count. In the same manner, the <I>IUnknown </I>members in both implementations (DKOALA1.CPP and EKOALA1.CPP) are also identical: the class factory deletes itself when its reference count goes to 0, as usual. Nothing else special happens in <I>Release </I>because the class factory's existence has little to do with the server's own lifetime.</P>
<P>The <I>CKoalaClassFactory </I>members <I>CreateInstance </I>and <I>LockServer </I>appear as follows in DKoala1:</P>
<P><BR></P>
<pre><code>//From DKOALA1.CPP<BR>STDMETHODIMP CKoalaClassFactory::CreateInstance(LPUNKNOWN pUnkOuter<BR>    , REFIID riid, PPVOID ppvObj)<BR>    {<BR>    PCKoala             pObj;<BR>    HRESULT             hr;<BR><BR>    *ppvObj=NULL;<BR>    hr=ResultFromScode(E_OUTOFMEMORY);<BR><BR>    if (NULL!=pUnkOuter &amp;&amp; IID_IUnknown!=riid)<BR>        return ResultFromScode(CLASS_E_NOAGGREGATION);<BR><BR>    pObj=new CKoala(pUnkOuter, ObjectDestroyed);<BR><BR>    if (NULL==pObj)<BR>        return hr;<BR><BR>    if (pObj-&gt;Init())<BR>        hr=pObj-&gt;QueryInterface(riid, ppvObj);<BR><BR>    if (FAILED(hr))<BR>        delete pObj;<BR>    else<BR>        g_cObj++;<BR><BR>    return hr;<BR>    }<BR><BR>STDMETHODIMP CKoalaClassFactory::LockServer(BOOL fLock)<BR>    {<BR>    if (fLock)<BR>        g_cLock++;<BR>    else<BR>        g_cLock--;<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>Here you can see a number of features. First <I>CreateInstance</I> verifies that aggregation rules are being followed correctly if <I>pUnkOuter </I>is non-NULL. We then create an instance of the Koala object (the C++ class <I>CKoala</I>), passing to the constructor the outer unknown and a pointer to the object destroyed function named <I>ObjectDestroyed</I>. If the C++ <I>new </I>operator succeeds, we have a new C++ object but not an interface pointer, so we initialize the object and query for an interface pointer if initialization succeeds. The <I>QueryInterface </I>call conveniently calls <I>AddRef </I>as well. If all of this succeeds, we increment the global counter <I>g</I><I>_</I><I>cObj</I> and return. Along similar lines the <I>LockServer </I>function increments or decrements another global counter, <I>g</I><I>_</I><I>cLock</I>. We could have <I>LockServer </I>fiddle with <I>g</I><I>_</I><I>cObj</I> instead of a separate counter, but having two counters greatly simplifies debugging objects and locks separately.</P>
<P>Again, EKoala1's implementation is almost identical. Can you spot the differences?</P>
<P><BR></P>
<pre><code>//From EKOALA1.CPP<BR>STDMETHODIMP CKoalaClassFactory::CreateInstance(LPUNKNOWN pUnkOuter<BR>    , REFIID riid, PPVOID ppvObj)<BR>    {<BR>    PCKoala             pObj;<BR>    HRESULT             hr;<BR><BR>    *ppvObj=NULL;<BR>    hr=ResultFromScode(E_OUTOFMEMORY);<BR><BR>    if (NULL!=pUnkOuter &amp;&amp; IID_IUnknown!=riid)<BR>        return ResultFromScode(CLASS_E_NOAGGREGATION);<BR><BR>    pObj=new CKoala(pUnkOuter, ObjectDestroyed);<BR><BR>    if (NULL==pObj)<BR>        {<BR>        g_cObj++;<BR>        ObjectDestroyed();<BR>        return hr;<BR>        }<BR><BR>    if (pObj-&gt;Init())<BR>        hr=pObj-&gt;QueryInterface(riid, ppvObj);<BR><BR>    g_cObj++;<BR><BR>    if (FAILED(hr))<BR>        {<BR>        delete pObj;<BR>        ObjectDestroyed();<BR>        }<BR><BR>    return hr;<BR>    }<BR><BR>STDMETHODIMP CKoalaClassFactory::LockServer(BOOL fLock)<BR>    {<BR>    if (fLock)<BR>        g_cLock++;<BR>    else<BR>        {<BR>        g_cLock--;<BR>        g_cObj++;<BR>        ObjectDestroyed();<BR>        }<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>The differences exist because EKoala1 was launched for no reason other than to create an object. If creation fails, the server shuts itself down—no reason to keep hogging memory uselessly! As we'll see shortly, an EXE server has to start its own shutdown when its last object is destroyed or the last lock removed. This requirement lets us isolate shutdown initiation code inside a function such as <I>ObjectDestroyed</I>, which tests for the right conditions and posts a WM_CLOSE message to the main hidden window to generate a <I>PostQuitMessage</I> call:</P>
<P><BR></P>
<pre><code>//From EKOALA1.CPP<BR>void ObjectDestroyed(void)<BR>    {<BR>    g_cObj--;<BR><BR>    //No more objects and no locks; shut the application down.<BR>    if (0L==g_cObj &amp;&amp; 0L==g_cLock &amp;&amp; IsWindow(g_hWnd))<BR>        PostMessage(g_hWnd, WM_CLOSE, 0, 0L);<BR><BR>    return;<BR>    }</code></pre>
<P>So anywhere else that we need to start shutdown, we can fake an object destruction by incrementing <I>g</I><I>_</I><I>cObj</I> and calling <I>ObjectDestroyed </I>directly as when <I>new </I>fails, when object initialization or <I>QueryInterface </I>fails, and inside <I>LockServer </I>as well. <I>ObjectDestroyed </I>worries about testing the conditions.</P>
<P>This is actually the full extent of how EKoala1 terminates itself when the last lock is removed and <I>g</I><I>_</I><I>cObj </I>is zero or when <I>g</I><I>_</I><I>cLock </I>is zero and the last Koala object goes away, in which case Koala incorrectly calls <I>ObjectDestroyed</I>.</P>
<P>DKoala1, on the other hand, doesn't unload itself but implements <I>DllCanUnloadNow</I> instead to return S_OK or S_FALSE for the same conditions under which EKoala1 terminates. Correspondingly, its <I>ObjectDestroyed </I>function does nothing more than decrement <I>g</I><I>_</I><I>cObj</I>:</P>
<P><BR></P>
<pre><code>//From DKOALA1.CPP<BR>STDAPI DllCanUnloadNow(void)<BR>    {<BR>    SCODE   sc;<BR><BR>    sc=(0L==g_cObj &amp;&amp; 0L==g_cLock) ? S_OK : S_FALSE;<BR>    return ResultFromScode(sc);<BR>    }<BR><BR>void ObjectDestroyed(void)<BR>    {<BR>    g_cObj--;<BR>    return;<BR>    }</code></pre>
<H4><A NAME="sec1"></A>Expose the Class Factory</H4><P>To expose its class factory, a DLL needs only to implement and export <I>DllGetClassObject</I>. This function looks quite similar to <I>IClassFactory::CreateInstance</I>:</P>
<P><BR></P>
<pre><code>//From DKOALA1.CPP<BR>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)<BR>    {<BR>    HRESULT             hr;<BR>    CKoalaClassFactory *pObj;<BR><BR>    if (CLSID_Koala!=rclsid)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    pObj=new CKoalaClassFactory();<BR><BR>    if (NULL==pObj)<BR>        return ResultFromScode(E_OUTOFMEMORY);<BR><BR>    hr=pObj-&gt;QueryInterface(riid, ppv);<BR><BR>    if (FAILED(hr))<BR>        delete pObj;<BR><BR>    return hr;<BR>    }</code></pre>
<P>The only special note to make here is that <I>DllGetClassObject</I> should always validate the CLSID passed to it, as done here. You don't want to return a class factory for the wrong CLSID!</P>
<P>An EXE server, on the other hand, must first check for the -<I>Embedding </I>flag and register its class factories using <I>CoRegisterClassObject</I>. In EKoala1, we should do all of this in <I>CApp::Init</I>, which registers the class factory for multiple use. (Note that <I>-</I><I>Embedding</I> always appears in ANSI characters, as does the entire command line.)</P>
<P><BR></P>
<pre><code>BOOL CApp::Init(void)<BR>    {<BR>    HRESULT     hr;<BR><BR>    //Fail if we're run outside of CoGetClassObject.<BR>    if (lstrcmpiA(m_pszCmdLine, "-Embedding")<BR>        &amp;&amp; lstrcmpiA(m_pszCmdLine, "/Embedding"))<BR>        return FALSE;<BR><BR>    if (FAILED(CoInitialize(NULL)))<BR>        return FALSE;<BR><BR>    m_fInitialized=TRUE;<BR><BR>    [Register window class and create main hidden window.]<BR><BR>    m_pIClassFactory=new CKoalaClassFactory();<BR><BR>    if (NULL==m_pIClassFactory)<BR>        return FALSE;<BR><BR>    m_pIClassFactory-&gt;AddRef();<BR><BR>    hr=CoRegisterClassObject(CLSID_Koala, m_pIClassFactory<BR>        , CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &amp;m_dwRegCO);<BR><BR>    if (FAILED(hr))<BR>        return FALSE;<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>If EKoala1 served more than one CLSID, it would repeat the process of creating a class factory and calling <I>CoRegisterClassObject </I>for each CLSID. In the preceding code, the <I>m</I><I>_</I><I>dwRegCO </I>variable receives the registration key for our single class factory. If we had multiple class factories, we'd need to have an array of such keys, of course. Also, EKoala1 does not allow itself to run stand-alone: if -<I>Embedding </I>does not appear, EKoala1 terminates immediately. If you are writing a server that can run stand-alone, use -<I>Embedding </I>to determine whether you must register all your class factories or skip them all. A server will generally register its multiple-use class factories with or without -<I>Embedding</I>, but it only registers single-use ones when the flag is present.</P>
<P><img src="16bit.gif"></P>
<P>Because this class factory is registered as REGCLS_MULTIPLE_USE, this same class factory is used to create objects for any number of separate clients. To demonstrate this, run two or more instances of ObjectUser, and in each choose Use EXE Object followed by Create (CoCreateInstance). Now run a tool like PView and look at the loaded modules. Because EKoala1 registers itself for multiple use, only one instance of the EXE will appear in the list. Notice that the time it takes to create the first object is longer than the time to create subsequent instances. EKoala1 is already running, so we don't have to incur the overhead of launching another instance. Now change EKoala1 to use REGCLS_SINGLE_USE, and run the same test with multiple instances of ObjectUser. This time you'll see multiple instances of EKoala1, each servicing only a single object.</P>
<P>The final piece of EKoala1's implementation is revoking and releasing its class factory on shutdown. This happens in the application destructor <I>CApp::~CApp</I>:</P>
<P><BR></P>
<pre><code>CApp::~CApp(void)<BR>    {<BR>    if (0L!=m_dwRegCO)<BR>        CoRevokeClassObject(m_dwRegCO);<BR><BR>    if (NULL!=m_pIClassFactory)<BR>        m_pIClassFactory-&gt;Release();<BR><BR>    if (m_fInitialized)<BR>        CoUninitialize();<BR><BR>    return;<BR>    }</code></pre>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H5><A NAME="sec2"></A>The "OLE Is Difficult" Myth Debunked</H5><P>Take a moment to reflect on the amount of code that we've seen in the last two sections. Even if we include the implementations of the <I>IUnknown </I>members of <I>CKoalaClassFactory </I>and <I>CKoala</I>, there are really only a few dozen lines of code in DKoala1 and EKoala1 that deal with the class factory and the objects that it creates.</P>
<P>Such code is the core of any custom component in OLE, which includes OLE Automation objects, OLE Document objects, OLE Controls, and any other type of component you want to make with OLE and access using a CLSID. The core functionality for exposing an object in a component is very simple and occupies little code. As we have seen in the last few pages, none of this code is at all complex—it's just as simple as writing any other exported functions or creating something such as a window class. If you take the time to understand these fundamental mechanisms, most everything else you might implement with OLE will make a lot more sense and will cease to be something overly complex and foreign. More complex objects simply have more interfaces than the KOALA object has.</P>
<P>OLE has been called "difficult" and "hard," a myth perpetuated largely by competitive marketing efforts and by people who stand to win big if you believe the myth. Certainly the more OLE technologies you use and the more complex the problems you're trying to solve, the more complex your programming will become. But this is true of any programming.</P>
<P>So understand that any belief you might have that OLE is just too damned hard is just that—a belief. And beliefs often do not correspond to reality.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
