<HTML><HEAD><TITLE>Concurrency Management</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Concurrency Management</H2><P>In our discussion of standard marshaling, we tacitly assumed that a proxy's call to <I>IRpcChannelBuffer::S</I><I>endReceive </I>actually works and that a remote object is ready and waiting to receive the call and process it. However, there is always the possibility that the RPC takes an intolerably long time (a network is overloaded, for example) or that the server is blocked in some modal process and cannot take the call.</P>
<P>For this reason, COM provides a service called <I>concurrency management,</I> or <I>message filtering,</I> through which an application (a client or a local or remote server) can filter calls or messages coming into it, allowing the application to handle or reject some calls and defer others. This applies to clients that call objects and objects that call back to a client sink through some notification or event interface.</P>
<P>These calls fall into three categories that help us discern why we'd want to handle certain calls in certain ways, as shown on the following page.8</P>
<UL><LI><I>Synchronous calls, </I>in which the client waits for the object to reply before continuing but can receive other messages in a controlled way while waiting. All calls are synchronous unless they fall explicitly into one of the other two categories.</LI><LI><I>Asynchronous notifications and events,</I> in which the caller proceeds without waiting for the called object to process the call. Notifications and events, as we saw in Chapter 4, are usually calls from an object back to a sink in its client. While processing an asynchronous call, COM prevents the sink from making any synchronous calls back to the calling object. For example, a sink notified of a data change in the object cannot make a synchronous call to the object to request a new data rendering. Message filtering enables the client providing the sink to know when an asynchronous call is in progress.</LI><LI><I>Input-synchronized calls,</I> in which the object must not yield in any way before the call is complete so that user interface concerns such as focus management and keyboard type-ahead will work correctly. While processing one of these calls, the object cannot call any function that has the possibility of yielding (that is, entering a message loop), which includes synchronous calls to other objects.</LI></UL><P>The vast majority of interface calls are synchronous because asynchronous ones increase programming complexity. A synchronous call means that the client process basically waits in a message loop inside <I>IRpcChannelBuffer::SendReceive </I>until the call is complete. From within this message loop, COM will notify a <I>message filter </I>when certain conditions occur, allowing the caller to time-out as well as handle any incoming calls that may occur in the meantime.</P>
<P>The conditions in question occur when a sequence of calls is made in the same thread of execution that eventually calls back into the original client process. Whenever a client makes a call (or an object sends a notification or fires an event), COM considers this a top-level call and assigns a logical thread ID to it, nominally the caller's HTASK. This is just some machine-unique integer and doesn't bear any relation to the multitasking system thread that is executing the caller's code. This COM thread identifies a series of calls <I>between </I>processes, which might involve multiple system threads.</P>
<P>Anyway, this ID travels from process to process as the recipients of this call themselves make other calls to other processes. This, of course, has the possibility of winding up in a call back to the original top-level process, which is currently waiting for the original top-level call to return. This is the exact condition that COM will detect inside this message loop; otherwise, such a situation would result in utter deadlock. Message filtering is the means by which the original caller, or any caller in between, can handle such a call and return the result through the entire chain.</P>
<P>The core of this mechanism is the message filter, a simple object that implements the <I>IMessageFilter </I>interface. (All of these calls return a DWORD and not an HRESULT.)</P>
<P><BR></P>
<pre><code>interface IMessageFilter : IUnknown<BR>    {<BR>    DWORD HandleInComingCall (DWORD dwCallType, HTASK threadIDCaller<BR>        , DWORD dwTickCount, LPINTERFACEINFO pInterfaceInfo);<BR>    DWORD RetryRejectedCall(HTASK threadIDCallee, DWORD dwTickCount<BR>        , DWORD dwRejectType);<BR>    DWORD MessagePending (HTASK threadIDCallee, DWORD dwTickCount<BR>        , DWORD dwPendingType); <BR>    };<BR><BR>/*<BR> * Return values for HandleInComingCall and RetryRejectedCall,<BR> * the latter two also being the values for dwRejectType in <BR> * RetryRejectedCall.<BR> */<BR>typedef enum tagSERVERCALL<BR>    {<BR>    SERVERCALL_ISHANDLED  = 0,<BR>    SERVERCALL_REJECTED   = 1,<BR>    SERVERCALL_RETRYLATER = 2<BR>    } SERVERCALL;</code></pre>
<P>It is very important to note that <I>HandleInComingCall </I>is the object side of message filtering; <I>RetryRejectedCall </I>and <I>MessagePending </I>are client-side operations. The object-side member allows that task to handle, delay, or reject calls being made from external clients. The other operations allow the calling client to determine when the object delayed or rejected a call and also to handle other calls that might occur while waiting to try a previously rejected call. These differences apply regardless of who or what the caller and callee are.</P>
<P>In order to handle concurrency issues, you must implement your own simple message filter with this interface and register that filter with COM, which then calls it from within its internal message loop. By default, COM always installs its own standard message filter. Your implementation is a customization of COM's standard filtering service. This is an example of a small object, one without a CLSID and without a server or any registry entries, through which you can customize a standard OLE-provided service.</P>
<P>If you do implement your own message filter, you install it with COM using the function <I>CoRegisterMessageFilter</I>, which has the following arguments:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Argument</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>pIMessageFilter</P></TD><TD VALIGN="TOP"><P>The pointer to your <I>IMessageFilter</I> implementation</P></TD></TR><TR><TD VALIGN="TOP"><P>ppIMsgFilterPrev</P></TD><TD VALIGN="TOP"><P>A pointer to another <I>IMessageFilter</I> pointer variable that receives, as an out-parameter, the pointer to the previously installed message filter</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>To unregister your message filter, call <I>CoRegisterMessageFilter(NULL, NULL)</I>.<B><I> </I></B>Whereas registration will call <I>AddRef </I>on the message filter, unregistration will call <I>Release</I>.<B><I> </I></B>Registration, however, never involves global object tables, marshaling, or anything else, even though the name of the API function is almost the same as <I>CoR</I><I>egisterClassObject. </I>A message filter is a simple object that serves only to customize COM's default message filtering.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>8 IDL has keywords that allow you to express these call types for members of a custom interface.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
