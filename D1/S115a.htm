<HTML><HEAD><TITLE>Self-Registration</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Self-Registration</H2><P>After having looked at the details of creating and exposing a server's class factories, implementing self-registration is a snap. Three samples demonstrate this feature: SelfReg (CHAP05\SELFREG), DKoala2 (CHAP05\DKOALA2), and EKoala2 (CHAP05\EKOALA2). The two servers are simple enhancements to DKoala1 and EKoala1 to support self-registration. SelfReg is nothing more than a command-line tool (a Windows application nevertheless) with the following syntax:</P>
<P><BR></P>
<pre><code>selfreg [/e] [/u] &lt;<I>path to server</I>&gt;</code></pre>
<P>The <I>/e </I>switch specifies that the path is to an EXE as opposed to a DLL, and <I>/u</I> instructs the server to unregister as opposed to register. The code in SELFREG.CPP parses the command line and generates the appropriate calls: when the code sees <I>/e</I>, it will attempt to call <I>WinExec</I> with the given path, passing /REGSERVER or /UNREGSERVER as the command line, depending on the presence of <I>/u</I>. If <I>/e </I>is not present, SelfReg calls <I>CoLoadLibrary</I> with the server specified on the path and then calls <I>DllRegisterServer </I>or <I>DllUnregisterServer</I>, depending again on <I>/u</I>. SelfReg displays a message box with the result of whatever sequence it executes (and calls <I>CoFreeLibrary </I>to unload the DLL).</P>
<P>Prior to calling <I>CoLoadLibrary</I>, SelfReg calls <I>CoInitialize</I>. It then calls <I>CoUninitialize </I>after calling <I>CoFreeLibrary</I>. SelfReg does this because in-process servers will expect that COM has been initialized by the application that owns the process. SelfReg falls into that category and so must perform the initialization.</P>
<P>How you actually choose to create the registry entries from within the server itself is up to you. You can use either the straight registry APIs (<I>RegCreateKeyEx</I>, <I>RegSetValueEx</I>, <I>RegCloseKey</I>, <I>RegDeleteKey</I>, and so on) as done in DKoala2 and EKoala2, or you can use another technique, such as launching REGEDIT.EXE with an appropriate registration file. What is most important in all of this is that the <I>InprocServer32</I>, <I>InprocHandler32</I>, and <I>LocalServer32 </I>entries have values equivalent to the full path of the loaded module. This is true also for any entries for your type libraries, which you should also register at this time. These paths are the only entries that depend on the directory in which the component resides, and that directory is the most important way OLE has of finding a component. This isn't hard to accomplish, mind you, as the Windows function <I>GetModuleFilename </I>gives you the full path to the loaded server, exactly what you want to store in the registry. If you perform registration using a REG file, be sure to update the keys with pathnames in them after that process is complete.</P>
<P>A final note to make here is that the function <I>RegDeleteKey </I>is picky: it will not delete a registry key if there are any subkeys below it. This means that just as you need to register entries one by one, you have to delete them one by one. You want to delete only the keys and subkeys that you registered from within your own server because other servers might have stored, for example, a <I>TreatAs </I>key under your CLSID. If you simply removed everything in the registry that pertained to your server, you'd obliterate this <I>TreatAs </I>key and potentially break clients that weren't using your server anyway. So delete only what you stored in the registry, and leave the rest alone.</P></font></body></HTML>
