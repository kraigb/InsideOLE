<HTML><HEAD><TITLE>The IOleCacheControl Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The <I>IOleCacheControl</I> Interface</H3><P>Describing <I>IOleCache2</I>, I made several references to a local or remote object, by which I mean an object running in a local or remote server. The remaining interface on the data cache, <I>IOleCacheControl</I>, has two members through which the client of the cache makes the cache aware of this object:</P>
<P><BR></P>
<pre><code>interface IOleCacheControl : IUnknown<BR>    {<BR>    HRESULT OnRun(IDataObject *pIDataObject);<BR>    HRESULT OnStop(void);<BR>    };</code></pre>
<P>The <I>OnRun </I>function tells the cache that the object identified with <I>pIDataObject </I>is now running, and <I>OnStop </I>tells the cache that the same object has stopped running. (The data cache manages only one remote object at a time.) When the data cache becomes aware of this remote object, it establishes advisory connections for any cached format using the ADVF_* flags previously passed to <I>IOleCache2::Cache</I> for those formats, as shown in Figure 11-2. The sink objects here are simple objects with <I>IAdviseSink</I>; their pointers are enumerated through <I>IOleCache2::EnumCache.</I></P>
<P>    <img src="f11dd02.gif"></P>
<P><B>Figure 11-2.</B></P>
<P><B>Through <I>IOleCacheControl</I>, the data cache becomes connected with an object running in a local or remote server.</B></P>
<P>When these connections are active, the cache updates its cached formats whenever the remote object sends an <I>IAdviseSink::OnDataChange</I>. The various flags that you can pass to <I>IOleCache2::UpdateCache </I>determine which formats are updated according to the type of advisory connection they use with the remote object. For example, UPDFCACHE_ALLBUTNODATACACHE updates all the data formats that were cached with flags other than ADVF_NODATA.</P>
<P>We can now understand the other values of the ADVF enumeration that we glossed over in Chapter 10. ADVFCACHE_NOHANDLER itself is reserved for future use, so you will have occasion to use it presently. ADVFCACHE_FORCEBUILTIN restricts cached presentation data to that which OLE itself can handle, namely metafiles and bitmaps (both CF_BITMAP and CF_DIB). ADVFCACHE_ONSAVE causes the cache to update data only when the remote object is itself saved—that is, when and if the data source object calls <I>IAdviseSink::OnSave</I>. Obviously, the client using this flag should have some knowledge about the nature of the data source.</P></font></body></HTML>
