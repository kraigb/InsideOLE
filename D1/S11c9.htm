<HTML><HEAD><TITLE>IMoniker: Display Name Group</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IMoniker</I>: Display Name Group</H3><P>The final two member functions of <I>IMoniker</I>, <I>GetDisplayName </I>and <I>ParseDisplayName</I>, deal with a textual representation of the moniker that can be used in a user interface. <I>GetDisplayName </I>asks a moniker for this display name, but this might actually be as costly an operation as binding the object altogether, which it might require anyway. For this reason, <I>GetDisplayName</I> takes <I>as arguments</I> a bind context and the moniker to its left in a composite. The resulting display name is returned in *<I>ppszDisplayName</I>, which the moniker allocates with <I>CoTaskMemAlloc</I>; thus, the caller is responsible for freeing that memory with <I>CoTaskMemFree.</I></P>
<P>For example, a file moniker that contains the path \\BUNNYKINS\CDRIVE\DATA\OLE\CH09.DOC will generally use that string for the display name unless it can resolve the \\<I>machine</I>\<I>volume</I> part into a local drive letter, which results in C:\DATA\OLE\CH09.DOC, for example. An isolated item moniker (<I>pmkLeft </I>is NULL) will do nothing more than return its item string, and pointer monikers and anti-monikers have no display name, so they fail this function altogether.</P>
<P>A composite moniker creates a display name out of the strings of each constituent moniker. A File!Item!Item moniker will create a display name like C:\DATA\OLE\CH09.DOC!Section5!Graphic6. Keep in mind that when the composite asks an item moniker for its display name, it will pass a non-NULL <I>pmkLeft </I>to that moniker. In such a case, the item moniker will prefix its item string with the delimiter character originally passed to <I>CreateItemMoniker</I>. This character thus separates the item from whatever comes before it in the display name.</P>
<P>This separation not only is useful for providing a user with a visual separation but also provides for parsing a display string into a moniker—that is, for performing the opposite of <I>GetDisplayName</I>. The function <I>IMoniker::ParseDisplayName </I>does this—the moniker called names the object that knows how to parse the display name. In other words, the moniker called is not parsing its own display name but some display name that is relevant to the object named by the moniker. The <I>pszDisplayName </I>argument is thus the string to parse, *<I>ppmkOut </I>is the resulting moniker, and <I>pchEaten </I>is filled with the number of characters parsed from <I>pszDisplayName </I>in the process of creating *<I>ppmkOut</I>.</P>
<P>Some monikers might understand enough about their named objects to actually perform some of this parsing themselves. Most monikers, however, including file, item, and pointer monikers, depend on the objects they themselves name to perform the parsing. More specifically, these monikers bind to their named objects (calling their own <I>BindToObject</I>) and request the <I>IParseDisplayName </I>interface. The monikers then call <I>IParseDisplayName::ParseDisplayName </I>to do the honors, which returns the new moniker and the value to store in <I>pchEaten</I>, which the moniker called originally and then returns to the client.</P>
<P>Because this parsing will generally bind to the named object anyway, the operation can be just as expensive as binding is already. Usually parsing is needed only when the user has provided some name to an application and has told the application to create a link from it. We'll see examples when we talk about OLE Document containers in Part V of this book.</P>
<P>Parsing a display name almost always happens on a composite, which asks each of its constituent monikers to parse in turn. This is the whole reason why <I>I</I><I>Moniker::ParseDisplayName </I>takes arguments such as <I>pchEaten</I>: the composite must track each moniker as it gets parsed from the name. In addition, simple monikers will call <I>IBindCtx::RegisterObjectBound </I>in the process to optimize possible later uses of the same object for parsing.</P>
<P>A client that wants to parse a user-provided string into a moniker doesn't actually have a composite moniker to call in the first place! This is the reason for the OLE API function <I>MkParseDisplayName </I>(the <I>Mk</I> stands for "moniker"), which has the following signature:</P>
<P><BR></P>
<pre><code>HRESULT MkParseDisplayName(IBindCtx *pbc, LPCWSTR pszName<BR>    , ULONG *pchEaten, IMoniker **ppmk)</code></pre>
<P>Here the caller must create a new bind context before calling, passing that pointer in <I>pbc</I> along with the display string in <I>pszName</I>. On return, <I>pchEaten </I>will specify how far the parsing was successful, and <I>ppmk</I> will have a moniker for whatever was successfully parsed. You can use <I>pchEaten </I>to show the user how much of a string was parsed (with a highlight) and where the first parsing error occurred, allowing the user to correct the name if necessary.</P>
<P><I>MkParseDisplayName </I>has the challenge to figure out exactly what type of moniker to start with, after which it can call <I>IMoniker::ParseDisplayName </I>as often as needed. Because of this, the display name passed to <I>MkParseDisplayName </I>must contain one of two initial patterns: a UNC pathname or the character @. If a UNC path is found, this function creates a file moniker and calls its <I>ParseDisplayName </I>to get the ball rolling down the rest of the string. (The file parses the next moniker in the string, which is asked to parse the rest, and so on.) If the string begins with @, <I>MkParseDisplayName </I>assumes the next string of characters is a ProgID, up to the next character that is not legal for a ProgID (such as \ or ! or anything other than 0–9, a–z, A–Z, and a period). With this ProgID, <I>MkParseDisplayName </I>looks up the CLSID registered for it and calls <I>CoCreateInstance(clsid</I>, <I>NULL</I>,<I> CLSCTX</I><I>_</I><I>ALL</I>,<I> IID</I><I>_</I><I>IParseDisplayName</I>,<I> </I><I>&amp;</I><I>pIPDN)</I>. The resulting object is given the entire<I> </I>display name to parse, so it must understand what sort of moniker to create initially. <I>MkParseDisplayName </I>then asks this initial moniker to parse its display name, and this continues until the whole string is parsed or an error occurs.</P></font></body></HTML>
