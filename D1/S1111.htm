<HTML><HEAD><TITLE>Multiple Inheritance (CObject3)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Multiple Inheritance (<I>CObject3</I>)</H3><P>You are probably thinking that both of the previous techniques are too verbose—they have a lot of source code and still use a bunch of classes to implement one object. Multiple inheritance in C++ is the way to cut out the extra classes and combine all the <I>IUnknown </I>implementations into one. That means no delegation and no backpointers: you have only one object. <I>CObject3</I> is the multiple-inheritance version of what we've already seen, declared in OBJECT3.H:</P>
<P><BR></P>
<pre><code>class CObject3 : public ISampleOne, public ISampleTwo<BR>    {<BR>    private:<BR>        DWORD           m_cRef;         //Object reference count<BR><BR>    public:<BR>        CObject3(void);<BR>        ~CObject3(void);<BR><BR>        //Shared IUnknown members<BR>        STDMETHODIMP         QueryInterface(REFIID, PPVOID);<BR>        STDMETHODIMP_(DWORD) AddRef(void);<BR>        STDMETHODIMP_(DWORD) Release(void);<BR><BR>        //ISampleOne members<BR>        STDMETHODIMP         GetMessage(LPTSTR, UINT);<BR><BR>        //ISampleTwo members<BR>        STDMETHODIMP         GetString(LPTSTR, UINT);<BR>    };<BR><BR>typedef CObject3 *PCObject3;</code></pre>
<P>This uses a lot less code to declare the object, and because there are no other classes, the total amount of memory is less. You also avoid the extra step of delegation for <I>IUnknown </I>functions.</P>
<P>One important factor to remember, however, is that a pointer to the object is not a direct pointer to <I>any </I>interface, even <I>IUnknown</I>. (The compiler will complain that <I>IUnknown </I>is ambiguous because it is inherited from both the other interfaces.) This means that we must use explicit typecasts in <I>QueryInterface </I>to retrieve the correct pointers for each interface, as in the following:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CObject3::QueryInterface(REFIID riid, PPVOID ppv)<BR>    {<BR>    *ppv=NULL;<BR><BR>    if (IID_IUnknown==riid || IID_ISampleOne==riid)<BR>        *ppv=(ISampleOne *)this;<BR><BR>    if (IID_ISampleTwo==riid)<BR>        *ppv=(ISampleTwo *)this;<BR><BR>    if (NULL==*ppv)<BR>        return ResultFromScode(E_NOINTERFACE);<BR><BR>    ((LPUNKNOWN)*ppv)-&gt;AddRef();<BR>    return NOERROR;<BR>    }</code></pre>
<P>Because we don't have an explicit <I>IUnknown</I>, we use <I>ISampleOne </I>as our <I>IUnknown</I>.<I> </I>This is because <I>ISampleOne </I>has an <I>IUnknown </I>vtable itself.</P>
<P>It is important to realize that when multiple inheritance is involved, a typecast operation will change the pointer value. What the preceding code stores in <I>*</I><I>ppv </I>is not the same as what is stored in <I>this</I>. The reason is that C++ overloads the typecast operators to allocate the right vtable for the interface type, and thus you have to have a different pointer to that vtable as well as a different pointer to that pointer, which is what gets stored in <I>*</I><I>ppv</I>. If you are unfamiliar with how this works, please refer to the "Multiple Inheritance" section in the APPA.WRI file on the companion CD for more details.</P>
<P>Failure to typecast properly can result in some very strange side effects: because <I>ppv </I>is a <I>void </I><I>**</I>, you can store any pointer you want in it without complaint from the compiler. This means that if you forget the typecast, you'll effectively give the client an interface pointer that points to the object's vtable, not the interface vtable. In multiple inheritance, this object vtable includes all object member functions, such as the constructor and destructor. I've encountered situations in which my object destructor was called from a client, which confused the heck out of me for a long time. Other people have asked me about this same problem, in which they saw a function being called twice. Any strange symptom involving a call to the wrong function indicates a possible failure to typecast in <I>QueryInterface</I>. Do be careful.</P>
<P>As just described, multiple inheritance has the drawback of difficult debugging, especially when vtables are not created properly. But its primary advantage is that the expression of such an object is much more concise and generally looks cleaner in code. When you involve more than a few interfaces, however, things start to get messy, and the whole technique breaks down if you have two interfaces with identically named member functions, which does occasionally occur. For most situations, multiple inheritance is a great technique for production development projects because of its concise nature. If you are planning to implement an aggregatable object, however, you will need to use one of the other techniques to make a set of <I>IUnknown </I>functions outside those inherited from all the other interfaces. In that case, you'll have the main object delegate its <I>IUnknown </I>functions to some other unknown, either the outer unknown (in aggregation) or the object's own <I>IUnknown </I>(outside of aggregation).</P></font></body></HTML>
