<HTML><HEAD><TITLE>IUnknown: The Root of All Evil</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2><I>IUnknown</I>: The Root of All Evil</H2><P>The <I>IUnknown </I>interface is the one interface that all objects must implement, regardless of what other interfaces are present. <I>IUnknown</I> is what defines <I>object-ness</I> in OLE. An Object's <I>IUnknown </I>pointer value is what gives that object <I>instance</I> its run-time identity. Implementing <I>IUnknown </I>presents little challenge because <I>IUnknown </I>is the base interface for every other interface in OLE. By virtue of implementing any interface, you'll implement <I>IUnknown</I> to boot. In some cases, as we'll see in "Object Polymorphism and Reusability" later in this chapter, you'll need to implement two different sets of <I>IUnknown </I>member functions, but most of the time you'll implement only one set.</P>
<P>This interface itself encapsulates two operations: the control of an object's lifetime (or life cycle, as it is sometimes called, which sounds like a piece of horrendous exercise equipment, so I prefer the first term) and the navigation of multiple interfaces:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>IUnknown<BR>Member Function</B></P></TD><TD VALIGN="TOP"><P><B><BR>Result</B></P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG AddRef(void)</P></TD><TD VALIGN="TOP"><P>Increments the object's reference count, returning the new count.</P></TD></TR><TR><TD VALIGN="TOP"><P>ULONG Release(void)</P></TD><TD VALIGN="TOP"><P>Decrements the object's reference count, returning the new count. If the new count is 0, the object is allowed to free (delete, destroy) itself, and the caller must then assume that all interface pointers to the object are invalid.</P></TD></TR><TR><TD VALIGN="TOP"><P>HRESULT QueryInterface</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>(REFIID riid, void **ppv)</P></TD><TD VALIGN="TOP"><P>Asks the object whether it supports the interface identified by <I>riid</I> (an IID reference); a return value of NOERROR indicates support exists, and the necessary interface pointer is stored in the out-parameter *<I>ppv</I>. On error, E_NOINTERFACE says the object does not support the interface.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The following sections examine reference counting and <I>QueryInterface </I>in more detail.</P></font></body></HTML>
