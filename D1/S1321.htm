<HTML><HEAD><TITLE>Implement Simple Activation and Deactivation</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement Simple Activation and Deactivation</H3><P>As described in Chapter 22, <I>IOleObject::DoVerb</I> is the function in which in-place activation starts. First, then, we need to decide which verbs will try to activate an object in place. For example, a Play verb will not need to activate an object in place because it can temporarily play in the container already. Merging the user interface isn't necessary. We'll need to define the behavior for all our supported verbs as well as any standard ones according to Table 23-1.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="182pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Verb</B></P></TD><TD VALIGN="TOP"><P><B>Behavior</B></P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_PRIMARY</P></TD><TD VALIGN="TOP"><P>Attempt full in-place UI activation if appropriate for this object.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_SHOW</P></TD><TD VALIGN="TOP"><P>Attempt full in-place UI activation. On failure, open the object in a server window as usual.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_HIDE</P></TD><TD VALIGN="TOP"><P>Fully deactivate the object if it's currently active in place; otherwise, hide the server window as usual.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_OPEN</P></TD><TD VALIGN="TOP"><P>Do not attempt to activate in place. Always open in a server window.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_INPLACEACTIVATE</P></TD><TD VALIGN="TOP"><P>Activate in place without UI activation, or fail if in-place activation by itself is not possible.</P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_UIACTIVATE</P></TD><TD VALIGN="TOP"><P>Activate the object UI. (Implies activation in place first.)</P></TD></TR><TR><TD VALIGN="TOP"><P>OLEIVERB_DISCARDUNDOSTATE</P></TD><TD VALIGN="TOP"><P>Free any Undo information you are holding. (See "Provide Undo Support" on page 1095.)</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 23-1.</B></P>
<P><B>In-place–activation behavior for standard verbs.</B></P>
<P>We can see how Cosmo handles these in its <I>DoVerb </I>implementation:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleObject::DoVerb(LONG iVerb, LPMSG pMSG<BR>    , LPOLECLIENTSITE pActiveSite, LONG lIndex, HWND hWndParent<BR>    , LPCRECT pRectPos)<BR>    {<BR><BR>    §<BR>    switch (iVerb)<BR>        {<BR>        case OLEIVERB_HIDE:<BR>            if (NULL!=m_pObj-&gt;m_pIOleIPSite)<BR>                m_pObj-&gt;InPlaceDeactivate();<BR>            else<BR>                {<BR>                ShowWindow(hWnd, SW_HIDE);<BR>                m_pObj-&gt;SendAdvise(OBJECTCODE_HIDEWINDOW);<BR>                }<BR>            break;<BR><BR>        case OLEIVERB_PRIMARY:<BR>        case OLEIVERB_SHOW:<BR>            //If already in-place active, nothing much to do here.<BR>            if (NULL!=m_pObj-&gt;m_pIOleIPSite)<BR>                return NOERROR;<BR><BR>            if (m_pObj-&gt;m_fAllowInPlace)<BR>                {<BR>                if (SUCCEEDED(m_pObj-&gt;InPlaceActivate(pActiveSite<BR>                    , TRUE))) return NOERROR;<BR>                }<BR><BR>            //FALL-THROUGH<BR><BR>        case OLEIVERB_OPEN:<BR>            /*<BR>             * If already in-place active, deactivate and <BR>             * prevent later reactivation.<BR>             */<BR>            if (NULL!=m_pObj-&gt;m_pIOleIPSite)<BR>                {<BR>                m_pObj-&gt;InPlaceDeactivate();<BR>                m_pObj-&gt;m_fAllowInPlace=FALSE;<BR>                }<BR><BR>            /*<BR>             * With all in-place stuff gone, we can go back to<BR>             * our normal open state.<BR>             */<BR>            ShowWindow(hWnd, SW_SHOWNORMAL);<BR>            SetFocus(hWnd);<BR><BR>            m_pObj-&gt;SendAdvise(OBJECTCODE_SHOWOBJECT);<BR>            m_pObj-&gt;SendAdvise(OBJECTCODE_SHOWWINDOW);<BR>            break;<BR><BR>        case OLEIVERB_INPLACEACTIVATE:<BR>            return m_pObj-&gt;InPlaceActivate(pActiveSite, FALSE);<BR><BR>        case OLEIVERB_UIACTIVATE:<BR>            return m_pObj-&gt;InPlaceActivate(pActiveSite, TRUE);<BR><BR>        case OLEIVERB_DISCARDUNDOSTATE:<BR>            //This program doesn't hold a state, but if yours does,<BR>            //free it here.<BR>            break;<BR><BR>        default:<BR>            return ResultFromScode(OLEOBJ_S_INVALIDVERB);<BR>        }<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>If Cosmo fails to activate in place for OLEIVERB_SHOW or OLEIVERB_PRIMARY, it tries to open the object in a window as usual. This always happens with OLEIVERB_OPEN, so opening an object in a separate window from an in-place–active state is tricky because it requires deactivation first, after which we can show Cosmo's main window. After we're open in the main window, we cannot return to the in-place–active state unless the user closes the window and reactivates the object in the container. We must also guard against additional calls to <I>DoVerb </I>while we're open so that we don't attempt to become in-place active again. The <I>m</I><I>_</I><I>fAllowInPlace </I>variable controls this.</P>
<P>Now, to make any of these verbs work as advertised, we need to do a little work in our <I>InPlaceActivate</I> and <I>InPlaceDeactivate</I> helper functions.</P>
<H4><A NAME="sec0"></A>Basic In-Place Activation (sans UI)</H4><P>The steps for basic activation are similar to steps we used in Chapter 22:</P>
<P>Using the <I>IOleClientSite</I> pointer passed to <I>IOleObject::DoVerb</I>, query for <I>IOleInPlaceSite</I>. If that interface is available, call <I>IOleInPlaceSite::CanInPlaceActivate</I>. If that call succeeds, call <I>IOleInPlaceSite::OnInPlaceActivate</I>.</P>
<P>Call <I>IOleInPlaceSite::GetWindowContext</I>, use the window context returned to change the parent and position of your editing window, show the window in the container, and call <I>IOleClientSite::ShowObject</I>.</P>
<P>Call <I>IOleInPlaceFrame::SetActiveObject</I> and <I>IOleInPlaceUIWindow::SetActiveObject</I> to give the container your <I>IOleInPlaceActiveObject</I> pointer.</P>
<P>If you want to fully activate the UI as well, call your own <I>UIActivate</I> helper function. The function does nothing at this point, but you'll want to call it later, so you might as well add it now while you're thinking about it.</P>
<P>You can see these steps implemented in Cosmo's <I>CFigure::InPlaceActivate</I>:</P>
<P><BR></P>
<pre><code>HRESULT CFigure::InPlaceActivate(LPOLECLIENTSITE pActiveSite<BR>    , BOOL fIncludeUI)<BR>    {<BR>    HRESULT                 hr;<BR>    HWND                    hWnd, hWndHW;<BR>    RECT                    rcPos;<BR>    RECT                    rcClip;<BR><BR>    if (NULL==pActiveSite)<BR>        return ResultFromScode(E_INVALIDARG);<BR><BR>    //If already active, activate UI and we're done.<BR>    if (NULL!=m_pIOleIPSite)<BR>        {<BR>        if (fIncludeUI)<BR>            UIActivate();<BR><BR>        return NOERROR;<BR>        }<BR><BR>    hr=pActiveSite-&gt;QueryInterface(IID_IOleInPlaceSite<BR>        , (PPVOID)&amp;m_pIOleIPSite);<BR><BR>    if (FAILED(hr))<BR>        return hr;<BR><BR>    hr=m_pIOleIPSite-&gt;CanInPlaceActivate();<BR><BR>    if (NOERROR!=hr)<BR>        {<BR>        m_pIOleIPSite-&gt;Release();<BR>        m_pIOleIPSite=NULL;<BR>        return ResultFromScode(E_FAIL);<BR>        }<BR><BR>    m_pIOleIPSite-&gt;OnInPlaceActivate();<BR>    m_fUndoDeactivates=TRUE;<BR><BR>    m_pIOleIPSite-&gt;GetWindow(&amp;hWnd);<BR>    m_pFR-&gt;m_frameInfo.cb=sizeof(OLEINPLACEFRAMEINFO);<BR><BR>    m_pIOleIPSite-&gt;GetWindowContext(&amp;m_pIOleIPFrame<BR>        , &amp;m_pIOleIPUIWindow, &amp;rcPos, &amp;rcClip<BR>        , &amp;m_pFR-&gt;m_frameInfo);<BR><BR>    m_pFR-&gt;m_pIOleIPFrame=m_pIOleIPFrame;<BR><BR>    m_pHW-&gt;HwndAssociateSet (m_pFR-&gt;Window());<BR>    m_pHW-&gt;ChildSet(m_pPL-&gt;Window());   //Calls SetParent<BR>    m_pHW-&gt;RectsSet(&amp;rcPos, &amp;rcClip);   //Positions Polyline<BR><BR>    hWndHW=m_pHW-&gt;Window();<BR>    SetParent(hWndHW, hWnd);            //Move hatch window.<BR>    ShowWindow(hWndHW, SW_SHOW);        //Make us visible.<BR>    SendAdvise(OBJECTCODE_SHOWOBJECT);<BR><BR>    if (fIncludeUI)<BR>        return UIActivate();<BR><BR>    return NOERROR;<BR>    }</code></pre>
<P>As we discussed in Chapter 22, the query for <I>IOleInPlaceSite </I>and the call to <I>IOleInPlaceSite::CanInPlaceActivate </I>are made to ensure that the container is both in-place capable and willing to activate this particular object in place. Failure in either case means that we activate the object in a separate window, remaining fully compatible with non-in-place containers. Success in Cosmo means that <I>CFigure::m</I><I>_</I><I>pIOleIPSite </I>is set to a non-NULL value. This variable is used in other places around the code to determine whether we're in-place activated.</P>
<P>If we can proceed to in-place activation, we call <I>IOleInPlaceSite::OnInPlaceActivate</I> so that it can initialize whatever state it wants. We also want to remember that the next Undo command we see should deactivate us, so we set our <I>m</I><I>_</I><I>fUndoDeactivates</I> variable to TRUE.</P>
<P>Our next task is to get all the information we need to work with the container by calling <I>IOleInPlaceSite::GetWindow</I>, which will be the parent of our editing window, and by calling <I>IOleInPlaceSite::GetWindowContext</I>. The call to <I>GetWindowContext</I> provides us with the position rectangle that the object's data area should occupy, a clipping rectangle, the container's <I>IOleInPlaceFrame</I> and <I>IOleInPlaceUIWindow</I> pointers, and the container's OLEINPLACEFRAMEINFO structure, which holds the container's accelerators.1 We'll need this information in our frame's message loop later on, so Cosmo stores this filled structure directly in its <I>CCosmoFrame</I> (<I>m</I><I>_</I><I>pFR</I>)<I> </I>object along with the container's <I>IOleInPlaceFrame</I> pointer, which our frame will need as well.</P>
<P>Next we need to take our editing window, which in Cosmo is the Polyline window referenced through <I>CFigure::m</I><I>_</I><I>pPL</I>, and move it to the container as a child of whatever window we get from <I>IOleInPlaceSite::GetWindow</I>. We don't actually place the Polyline window in the container alone: the Polyline window is a child of a special hatch window that is implemented in the sample code's CLASSLIB framework as <I>CHatchWin</I> (CLASSLIB\CHATCH.CPP). <I>CFigure</I> creates a <I>CHatchWin</I> object in <I>CFigure::Init</I>, storing the pointer in <I>m</I><I>_</I><I>pHW</I> for our use here. The hatch window itself doesn't send any messages to its parent window but rather to an "associate" that we set with <I>CHatchWin::AssociateSet</I>. This ensures that our in-place window will not send spurious messages to the container.</P>
<P>This hatch window, in its WM_PAINT processing, draws the border hatching around the object (as described in Chapter 22) using our INOLE.DLL helper function <I>UIDrawShading</I> (INOLE\UIEFFECT.CPP). The width of the border is read from the OleInPlaceBorderWidth entry in WIN.INI (with a default of 4 pixels). In addition, the hatch window manages the position and the clipping rectangles that we obtain from the container. Basically, we make the Polyline window a child of the hatch window (<I>CHatchWin::ChildSet</I>). Then we tell the hatch window through <I>CHatchWin::RectsSet</I> to size the Polyline window within it to the position rectangle (<I>rcPos</I>) and to size itself according to the intersection of the position rectangle and the clipping rectangle (<I>prcClip</I>):</P>
<P><BR></P>
<pre><code>//From CLASSLIB\CHATCH.CPP<BR>void CHatchWin::RectsSet(LPRECT prcPos, LPRECT prcClip)<BR>    {<BR>    RECT    rc;<BR>    RECT    rcPos;<BR><BR>    //Calculate rectangle for hatch window; then clip it.<BR>    rcPos=*prcPos;<BR>    InflateRect(&amp;rcPos, m_dBorder, m_dBorder);<BR>    IntersectRect(&amp;rc, &amp;rcPos, prcClip);<BR><BR>    SetWindowPos(m_hWnd, NULL, rc.left, rc.top, rc.right-rc.left<BR>        , rc.bottom-rc.top, SWP_NOZORDER œ SWP_NOACTIVATE);<BR><BR>    /*<BR>     * Set rectangle of child window to be at m_dBorder<BR>     * from top and left but with same size in prcPos.<BR>     * The hatch window will clip it.<BR>     */<BR>    SetWindowPos(m_hWndKid, NULL, rcPos.left-rc.left+m_dBorder<BR>        , rcPos.top-rc.top+m_dBorder, prcPos-&gt;right-prcPos-&gt;left<BR>        , prcPos-&gt;bottom-prcPos-&gt;top, SWP_NOZORDER œ SWP_NOACTIVATE);<BR><BR>    return;<BR>    }</code></pre>
<P>The cumulative effect is that the object window is always scaled to the position rectangle but at the same time the position rectangle is clipped to the window's parent. (The hatch window has WS_CLIPCHILDREN for this purpose.) As the hatch window clips itself to the clipping rectangle, the object is also clipped to the clipping rectangle while still showing the proper scaling. The hatch window keeps itself slightly larger than its child window by the hatch border width on all sides, subject, of course, to the container's clipping rectangle.</P>
<P>After the hatch window is positioned with the Polyline window inside it, we can move it to the container with <I>SetParent</I>, make it visible with <I>ShowWindow</I>, and call <I>IOleClientSite::ShowObject</I> to let the container know our application is visible. This last call allows the container to scroll our application into view if it is scrolled out of view at the time.</P>
<P>We should now also implement both <I>IOleInPlaceObject::GetWindow</I> and <I>IO</I><I>leInPlaceActiveObject::GetWindow</I> to return the topmost window that was moved into the container. In Cosmo, this is the hatch window:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceObject::GetWindow(HWND FAR *phWnd)<BR>    {<BR>    *phWnd=m_pObj-&gt;m_pHW-&gt;Window();<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIOleInPlaceActiveObject::GetWindow(HWND FAR *phWnd)<BR>    {<BR>    *phWnd=m_pObj-&gt;m_pHW-&gt;Window();<BR>    return NOERROR;<BR>    }</code></pre>
<P>This works well because when the object is UI active and the container gets a WM_SETFOCUS in the frame, the container calls <I>SetFocus</I> on whatever window is returned from the UI-active object's <I>IOleInPlaceActiveObject::GetWindow</I>. That means it will call <I>SetFocus</I> on the hatch window, which will call <I>SetFocus</I> on our editing window. This is exactly how things should happen.</P>
<P>As the final step, <I>CFigure::InPlaceActivate</I> calls <I>CFigure::UIActivate </I>if we're going that far. We'll see what happens here shortly.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H5><A NAME="sec1"></A>Object Adornments</H5><P>The hatch window is a special case of what are called <I>object adornments,</I> or additional user interface elements that appear outside the position rectangle of the object but inside the clipping rectangle. A spreadsheet object might display row and column headings, for example. The position rectangle defines the space that the object's data area should occupy, so adornments are not affected by that rectangle. If you need additional space for similar adornments, you can expand whatever windows you place in the container to accommodate them as long as those windows stay within the container's clipping rectangle and the object area stays the same size as the position rectangle, at least initially. No matter what adornments you add, the hatched border should always surround the object and all adornments.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec2"></A>Basic Deactivation (sans UI)</H4><P>Deactivation basically means reversing anything we did in the activation phase, in the opposite order. Where we previously obtained an interface pointer, we release it here. Where we called <I>SetParent</I> to move a window to the container, we call <I>SetParent</I> here to bring it back to the server. Deactivation involves the following steps:</P>
<P>Call the <I>UIDeactivate</I> helper function to remove menus and tools.</P>
<P>Call <I>SetParent</I> to move the hatch window and editing window back to the server.</P>
<P>Call <I>IOleInPlaceSite::OnInPlaceDeactivate</I>, release the pointers obtained from <I>IOleInPlaceSite::GetWindowContext</I>, and release the <I>IOleInPlaceSite</I> pointer obtained from <I>QueryInterface</I>.</P>
<P>We can see these steps implemented in the code for Cosmo's <I>CFigure::InPlaceDeactivate</I>:</P>
<P><BR></P>
<pre><code>void CFigure::InPlaceDeactivate(void)<BR>    {<BR>    RECT        rc;<BR><BR>    UIDeactivate();<BR><BR>    SetParent(m_pPL-&gt;Window(), m_pDoc-&gt;m_hWnd);<BR>    m_pHW-&gt;ChildSet(NULL);<BR><BR>    //Be sure the hatch window is invisible and owned by Cosmo.<BR>    ShowWindow(m_pHW-&gt;Window(), SW_HIDE);<BR>    SetParent(m_pHW-&gt;Window(), m_pDoc-&gt;m_hWnd);<BR>    GetClientRect(m_pDoc-&gt;m_hWnd, &amp;rc);<BR>    InflateRect(&amp;rc, -8, -8);<BR><BR>    SetWindowPos(m_pPL-&gt;Window(), NULL, rc.left, rc.top<BR>        , rc.right-rc.left, rc.bottom-rc.top<BR>        , SWP_NOZORDER œ SWP_NOACTIVATE);<BR><BR>    if (NULL!=m_pIOleIPSite)<BR>        m_pIOleIPSite-&gt;OnInPlaceDeactivate();<BR><BR>    m_pFR-&gt;m_pIOleIPFrame=NULL;<BR>    ReleaseInterface(m_pIOleIPFrame);<BR>    ReleaseInterface(m_pIOleIPUIWindow);<BR>    ReleaseInterface(m_pIOleIPSite);<BR><BR>    return;<BR>    }</code></pre>
<P>When we set Cosmo's Polyline window as a child of the hatch window, we repositioned it in relation to its parent. When we move it back to Cosmo's document window now, we have to adjust this relative position again. If we're deactivating because of OLEIVERB_OPEN, we'll be showing the document window in the server, so the Polyline window better appear in the right place!</P>
<P>Also, in-place deactivation takes the object back only to the running state, not to the loaded state. That means that a local server such as Cosmo will still be running. (An in-process server such as the Polyline sample in this chapter will always be in memory anyway.) Because the object has not been destroyed, you cannot assume that in-place activation will give you a chance to reinitialize your object's variables. So you need to be sure they are set back to whatever state you expect in <I>IOleObject::DoVerb</I>. For Cosmo, we set the <I>m</I><I>_</I><I>pIOleIPSite </I>pointer to NULL so that we can activate in place again.</P>
<P>At this point in our implementation, we could compile our code, test it with a container, and see many of the in-place–activation steps take place. When you click outside the object in the container, you can trace through the deactivation steps.2 What's missing are the extra pieces of user interface, which we'll now build in Cosmo.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 The object must fill the <I>cb</I> field of the OLEINPLACEFRAMEINFO structure before calling <I>GetWindowContext </I>to identify the version of the structure desired.</P></TD></TR><TR><TD VALIGN="TOP"><P>2 As an extra debugging measure, you might also display your server window during this time so that you can watch the editing window disappear from within the server document on activation and reappear on deactivation.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
