<HTML><HEAD><TITLE>Create and Manage Monikers</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Create and Manage Monikers</H3><P>Patron maintains three monikers within its various objects: a File moniker naming the document, a File!Item moniker naming the page, and a File!Item!Item moniker naming each tenant. All of this starts in <I>CPatronDoc::Rename</I>,<I> </I>in which we first learn of the document name itself:</P>
<P><BR></P>
<pre><code>void CPatronDoc::Rename(LPTSTR pszFile)<BR>    {<BR>    LPMONIKER   pmk;<BR><BR>    CDocument::Rename(pszFile);<BR><BR>    //Unregister old moniker (m_dwRegROT set to 0).<BR>    INOLE_RevokeAsRunning(&amp;m_dwRegROT);<BR><BR>    if (NULL==pszFile)<BR>        return;<BR><BR>    CreateFileMoniker(pszFile, &amp;pmk);<BR><BR>    if (NULL!=pmk)<BR>        {<BR>        LPMONIKER   pmkAll;<BR><BR>        INOLE_RegisterAsRunning(this, pmk, 0, &amp;m_dwRegROT);<BR><BR>        //Give a moniker to linked objects in tenants.<BR>        m_pPG-&gt;NotifyTenantsOfRename(pszFile, pmk);<BR><BR>        //Register a File!"\" wildcard moniker as well.<BR>        CreateItemMoniker(TEXT("!"), TEXT("\\"), &amp;pmkAll);<BR><BR>        if (NULL!=pmkAll)<BR>            {<BR>            LPMONIKER   pmkWild;<BR><BR>            INOLE_RevokeAsRunning(&amp;m_dwRegROTWild);<BR>            pmk-&gt;ComposeWith(pmkAll, FALSE, &amp;pmkWild);<BR><BR>            if (NULL!=pmkWild)<BR>                {<BR>                INOLE_RegisterAsRunning(this, pmk, 0<BR>                    , &amp;m_dwRegROTWild);<BR>                pmkWild-&gt;Release();<BR>                }<BR><BR>            pmkAll-&gt;Release();<BR>            }<BR><BR>        //There's no need for us to hold on to this.<BR>        pmk-&gt;Release();<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>First we create a file moniker and register that moniker as running. Then we pass this moniker down to the current page through <I>CPages::NotifyTenantOfRename</I>, which calls <I>CPage::NotifyTenantsOfRename</I>. After this, we create a File!"\" wildcard moniker and register it as running too. Thus, all pages in this document are marked as running. An external client can retrieve the document object's pointer, query for <I>IOleItemContainer</I>, and call <I>IOleItemContainer::GetObject </I>to look up any page in the document.</P>
<P>Patron's document object does not hold on to its file moniker because we never have occasion to use it outside this renaming sequence. It does hold the registration value that comes back from <I>IRunningObjectTable::Register</I>. <I>CPatronDoc::FDirtySet</I> uses this value to call <I>IRunningObjectTable::NoteChangeTime</I> as needed.</P>
<P>This is not to say that the file moniker is not needed elsewhere. The page and tenants hold on to a copy of this moniker for their own needs, such as creating CFSTR_LINKSOURCE data, passing the moniker to <I>IOleObject::SetMoniker</I>, and implementing <I>IOleClientSite::GetMoniker. </I>This means that we have to pass down this document moniker to the page and tenants, as described earlier. This lands us in <I>CPage::NotifyTenantsOfRename</I>:</P>
<P><BR></P>
<pre><code>void CPage::NotifyTenantsOfRename(LPTSTR pszFile, LPMONIKER pmk)<BR>    {<BR>    PCTenant    pTenant;<BR>    UINT        i;<BR>    LPMONIKER   pmkPage;<BR>    LPMONIKER   pmkAll;<BR>    OLECHAR     szTemp[32];<BR><BR>    //Save file moniker.<BR>    if (NULL!=m_pmkFile)<BR>        m_pmkFile-&gt;Release();<BR><BR>    m_pmkFile=pmk;<BR>    m_pmkFile-&gt;AddRef();<BR><BR>    //Create page moniker to send to tenants.<BR>    GetStorageName(szTemp);<BR>    CreateItemMoniker(TEXT("!"), szTemp, &amp;pmkPage);<BR><BR>    for (i=0; i &lt; m_cTenants; i++)<BR>        {<BR>        if (TenantGet(i, &amp;pTenant, FALSE))<BR>            pTenant-&gt;NotifyOfRename(pszFile, pmk, pmkPage);<BR>        }<BR><BR>    /*<BR>     * Register a File!Page!"\" wildcard moniker as well.<BR>     * Notice that page is already marked as running<BR>     * with document's wildcard moniker.<BR>     */<BR>    CreateItemMoniker(TEXT("!"), TEXT("\\"), &amp;pmkAll);<BR><BR>    if (NULL!=pmkAll)<BR>        {<BR>        LPMONIKER   pmkWild=NULL;<BR>        LPMONIKER   pmkTemp=NULL;<BR><BR>        INOLE_RevokeAsRunning(&amp;m_dwRegROTWild);<BR>        pmk-&gt;ComposeWith(pmkPage, FALSE, &amp;pmkTemp);<BR><BR>        if (NULL!=pmkTemp)<BR>            {<BR>            pmkTemp-&gt;ComposeWith(pmkAll, FALSE, &amp;pmkWild);<BR>            pmkTemp-&gt;Release();<BR>            }<BR><BR>        if (NULL!=pmkWild)<BR>            {<BR>            INOLE_RegisterAsRunning(this, pmk, 0<BR>                , &amp;m_dwRegROTWild);<BR>            pmkWild-&gt;Release();<BR>            }<BR><BR>        pmkAll-&gt;Release();<BR>        }<BR><BR>    //If anything held on to this, it called AddRef.<BR>    pmkPage-&gt;Release();<BR>    return;<BR>    }</code></pre>
<P>Here we do much the same thing as we did in <I>CPatronDoc::Rename</I>—we create a moniker naming the page, hand that moniker and the file moniker to each tenant in the page, and register a wildcard moniker for all the tenants in the page. This wildcard moniker has the form File!Item!"\", of course. Note that the page has no need to register itself as running because the wildcard moniker we registered in the document has already accounted for the page. This applies to the tenants as well: because the page registers a wildcard moniker for all its tenants, all those tenants are already marked as running.</P>
<P>We still need to tell embedded objects of the document's file moniker, however, by calling <I>IOleObject::SetMoniker</I>. This occurs in <I>CTenant::NotifyOfRename</I>:</P>
<P><BR></P>
<pre><code>void CTenant::NotifyOfRename(LPTSTR pszFile, LPMONIKER pmkFile<BR>    , LPMONIKER pmkPage)<BR>    {<BR>    [Code to call IOleObject::SetHostNames omitted]<BR><BR>    §<BR><BR>    if (NULL!=pmkFile)<BR>        {<BR>        if (NULL!=m_pmkFile)<BR>            m_pmkFile-&gt;Release();<BR><BR>        m_pmkFile=pmkFile;<BR>        m_pmkFile-&gt;AddRef();<BR><BR>        m_pIOleObject-&gt;SetMoniker(OLEWHICHMK_CONTAINER, pmkFile);<BR>        }<BR><BR>    if (NULL!=pmkFile &amp;&amp; NULL!=pmkPage)<BR>        {<BR>        LPMONIKER   pmkTenant=NULL;<BR>        LPMONIKER   pmkRel=NULL;<BR>        HRESULT     hr;<BR><BR>        //Create moniker for this tenant.<BR>        GetStorageName(szObj);<BR>        hr=CreateItemMoniker(TEXT("!"), szObj, &amp;pmkTenant);<BR><BR>        if (SUCCEEDED(hr))<BR>            {<BR>            //Create relative moniker--no pathname.<BR>            pmkPage-&gt;ComposeWith(pmkTenant, FALSE, &amp;pmkRel);<BR>            pmkTenant-&gt;Release();<BR><BR>            if (SUCCEEDED(hr))<BR>                m_pIOleObject-&gt;SetMoniker(OLEWHICHMK_OBJREL, pmkRel);<BR><BR>            //Hold on to relative moniker.<BR>            ReleaseInterface(m_pmk);<BR>            m_pmk=pmkRel;<BR>            }<BR>        }<BR><BR>    return;<BR>    }</code></pre>
<P>We call <I>IOleObject::SetMoniker</I> twice: once with OLEWHICHMK_CONTAINER (the document moniker) and once with OLEWHICHMK_OBJREL (the Page!Tenant moniker). This gives a linked object all the information it needs to maintain both its absolute and its relative monikers, as described earlier.</P>
<P>You'll notice that the tenant holds on to the document-relative moniker in the variable <I>m</I><I>_</I><I>pmk.</I> This is used later for implementing <I>IOleClientSite::GetMoniker</I>,<I> </I>which must now support all the various OLEWHICHMK_* options:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleClientSite::GetMoniker(DWORD dwAssign<BR>    , DWORD dwWhich, LPMONIKER *ppmk)<BR>    {<BR>    *ppmk=NULL;<BR><BR>    switch (dwWhich)<BR>        {<BR>        case OLEWHICHMK_CONTAINER:<BR>            //This is just the file we're living in.<BR>            if (NULL!=m_pTen-&gt;m_pmkFile)<BR>                *ppmk=m_pTen-&gt;m_pmkFile;<BR><BR>            break;<BR><BR>        case OLEWHICHMK_OBJREL:<BR>            //This is everything but the filename.<BR>            if (NULL!=m_pTen-&gt;m_pmk)<BR>                *ppmk=m_pTen-&gt;m_pmk;<BR><BR>            break;<BR><BR>        case OLEWHICHMK_OBJFULL:<BR>            //Concatenate file and relative monikers for this one.<BR>            if (NULL!=m_pTen-&gt;m_pmkFile &amp;&amp; NULL!=m_pTen-&gt;m_pmk)<BR>                {<BR>                return m_pTen-&gt;m_pmkFile-&gt;ComposeWith<BR>                    (m_pTen-&gt;m_pmk, FALSE, ppmk);<BR>                }<BR><BR>            break;<BR>        }<BR><BR>    if (NULL==*ppmk)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    (*ppmk)-&gt;AddRef();<BR>    return NOERROR;<BR>    }</code></pre>
<P>Most of the preceding code applies equally well to any link-source server that wants to provide linking to pseudo-objects or to other portions of a file, a database, or other material. Managing the monikers that name items and supplying those monikers through <I>IOleObject </I>and <I>IOleClientSite </I>are requirements of all types of link sources in OLE Documents.</P></font></body></HTML>
