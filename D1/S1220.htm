<HTML><HEAD><TITLE>A Feedback Rectangle</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>A Feedback Rectangle</H3><P>The version of Patron in Chapter 12 defined a private clipboard format named <I>Patron Object</I>, which contained necessary information about the original position of an object within a page:</P>
<P><BR></P>
<pre><code>typedef struct tagPATRONOBJECT<BR>    {<BR>    POINTL      ptl;        //Location of object<BR>    POINTL      ptlPick;    //Pick point from drag-and-drop operation<BR>    SIZEL       szl;        //Extents of object (absolute)<BR>    FORMATETC   fe;         //Actual object format<BR>    } PATRONOBJECT, *PPATRONOBJECT;</code></pre>
<P>This structure contains not only the location of the original tenant but also its size (extents). We can use this information to draw the same-size rectangle in the target window to show the space that the data would occupy if a drop happened. In addition, the field <I>ptlPick</I> is used to store the exact location of the mouse in relation to the upper left corner of the tenant, specifically for a drag and drop. This way we can draw a feedback rectangle in relation to the mouse in the same way as shown below. In Chapter 11, Patron always stored (0,0) in this field. Now <I>CPage::DragDrop </I>calculates these offsets and stores them in the PATRONOBJECT structure included with the data object. This is all so that the feedback rectangle will first appear exactly over the object that is picked up.</P>
<P><img src="f13dd06h.gif"></P>
<P>The offset is picked up in <I>CDropTarget::DragEnter </I>and used to place the rectangle properly. If the PATRONOBJECT structure is unavailable, we punt and show a default rectangle size, although the representation obviously will not be true to the size of the graphic. This approach lets us avoid having the source render data simply to determine the size. In later chapters, we'll add some code to also check for a structure named OBJECTDESCRIPTOR, which is defined in OLE2UI.H for the CFSTR_OBJECTDESCRIPTOR format. This structure has information similar to PATRONOBJECT but lacks a field with the offset point of the cursor from the upper left corner of the object itself. As a result, Patron will continue to look for its own structure later on, using OBJECTDESCRIPTOR as a backup.</P>
<P><I>CDropTarget::DragEnter </I>then copies the pick point offset (into <I>m</I><I>_</I><I>ptPick</I>)<I> </I>and the extents of the object (into <I>m</I><I>_</I><I>szl</I>)<I> </I>for later use in <I>DragOver. DragEnter</I> now also draws the first feedback rectangle through <I>CPages::DrawDropTargetRect </I>(DRAGDROP.CPP), which then calls the Windows function <I>DrawFocusRect </I>to draw a dotted rectangle with an XOR operation. The upper left corner of this rectangle is simply the mouse coordinates minus the offset of the pick point:</P>
<P><BR></P>
<pre><code>//In CDropTarget::DragEnter<BR>pt.x-=m_ptPick.x;<BR>pt.y-=m_ptPick.y;<BR><BR>m_ptLast=pt;<BR>m_fFeedback=TRUE;<BR>m_pDoc-&gt;m_pPG-&gt;DrawDropTargetRect(&amp;pt, &amp;m_szl);</code></pre>
<P><I>DrawDropTargetRect</I> is a toggle function because <I>DrawFocusRect</I> is a toggle function. Therefore, to remove the rectangle from inside the other <I>CDropTarget</I> functions, we have to remember where it is and whether it's currently visible. That's the purpose of the <I>CDropTarget </I>members <I>m</I><I>_</I><I>ptLast</I> and <I>m</I><I>_</I><I>fFeedback</I>. Early in <I>DragOver</I>, <I>DragLeave</I>, and <I>Drop</I>, we remove the old rectangle if it's showing:</P>
<P><BR></P>
<pre><code>if (m_fFeedback)<BR>    ppg-&gt;DrawDropTargetRect(&amp;m_ptLast, &amp;m_szl);</code></pre>
<P>In <I>DragOver</I>, we have to remember that OLE will pulse this function even if the mouse doesn't move. In such a case, we don't want to remove the feedback rectangle only to redraw it (which would cause annoying flicker). So we leave it be if the point passed to <I>DragOver </I>differs from <I>m</I><I>_</I><I>ptLast</I>:</P>
<P><BR></P>
<pre><code>if ((pt.x-m_ptPick.x==m_ptLast.x) &amp;&amp; (pt.y-m_ptPick.y==m_ptLast.y))<BR>    return NOERROR;</code></pre></font></body></HTML>
