<HTML><HEAD><TITLE>Of Clients and Persistent Objects: CoCosmo</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Of Clients and Persistent Objects: CoCosmo</H2><P>Our earlier discussion of <I>IPersistStorage </I>outlined some of a client's responsibilities when dealing with an object using this persistence model. To demonstrate this, we'll use the Component Cosmo sample for this chapter (CHAP08\COCOSMO) as the client and a modification of Polyline (CHAP08\POLYLINE) as the object. </P>
<P>CoCosmo now uses compound files as its native file format, just as the Cosmo sample from Chapter 7 does. In order to save or load Polyline's data, CoCosmo queries Polyline for <I>IPersistStorage. </I>Failing that, it will query for <I>IPersistStreamInit</I> and then <I>IPersistStream. </I>Whichever interface it finds, CoCosmo follows the appropriate protocol, as the fragments of code shown in this section (taken from DOCUMENT.CPP) will illustrate.</P>
<P>To facilitate the handling of multiple persistence models, I've defined the following flags and data structure in the INC\INOLE.H file to hold one of the <I>IPersist</I>*<I> </I>pointers in a union:</P>
<P><BR></P>
<pre><code>typedef enum<BR>    {<BR>    PERSIST_UNKNOWN=0,<BR>    PERSIST_STORAGE,<BR>    PERSIST_STREAM,<BR>    PERSIST_STREAMINIT,<BR>    PERSIST_FILE<BR>    } PERSIST_MODEL;<BR><BR>typedef struct<BR>    {<BR>    PERSIST_MODEL   psModel;<BR>    union<BR>        {<BR>        IPersistStorage    *pIPersistStorage;<BR>        IPersistStream     *pIPersistStream;<BR>        IPersistStreamInit *pIPersistStreamInit;<BR>        IPersistFile       *pIPersistFile;<BR>        } pIP;<BR>    } PERSISTPOINTER;</code></pre>
<P>This work is merely an implementation convenience for CoCosmo and later samples. CoCosmo includes a PERSISTPOINTER in its <I>CCosmoDoc </I>class named <I>m</I>_<I>pp</I>. This holds whatever pointer it obtained from the Polyline object along with the specific type of pointer it happens to be. The <I>m</I>_<I>pp </I>variable is set inside <I>CCosmoDoc::Init </I>through a series of <I>QueryInterface </I>calls:</P>
<P><BR></P>
<pre><code>BOOL CCosmoDoc::Init(...)<BR>    {<BR>    §<BR><BR>    hr=CoCreateInstance(CLSID_Polyline8, NULL, CLSCTX_INPROC_SERVER<BR>        , IID_IPolyline8, (PPVOID)&amp;m_pPL);<BR><BR>    if (FAILED(hr))<BR>        [Show error and return.]<BR><BR>    [Other initialization omitted]<BR><BR>    hr=m_pPL-&gt;QueryInterface(IID_IPersistStorage<BR>        , (PPVOID)&amp;m_pp.pIP.pIPersistStorage);<BR><BR>    if (SUCCEEDED(hr))<BR>        m_pp.psModel=PERSIST_STORAGE;<BR>    else<BR>        {<BR>        hr=m_pPL-&gt;QueryInterface(IID_IPersistStreamInit<BR>            , (PPVOID)&amp;m_pp.pIP.pIPersistStreamInit);<BR><BR>        if (SUCCEEDED(hr))<BR>            m_pp.psModel=PERSIST_STREAMINIT;<BR>        else<BR>            {<BR>            hr=m_pPL-&gt;QueryInterface(IID_IPersistStream<BR>                , (PPVOID)&amp;m_pp.pIP.pIPersistStream);<BR><BR>            if (SUCCEEDED(hr))<BR>                m_pp.psModel=PERSIST_STREAM;<BR>            else<BR>                return FALSE;<BR>            }<BR>        }<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>Whatever pointer we obtain here is released in <I>CCosmoDoc::~CCosmoDoc </I>along with the member <I>m</I>_<I>pIStorage</I>, which refers to the document's open compound file.</P>
<P>When loading an existing file or creating a new file in <I>CCosmoDoc::Load</I>, CoCosmo follows its responsibilities and passes an <I>IStorage</I> pointer to Polyline's <I>IPersistStorage::Load </I>or <I>IPersistStorage::InitNew</I>, or it passes an <I>IStream </I>pointer to <I>IPersistStream::Load </I>or calls <I>IPersistStreamInit::InitNew</I>. When CoCosmo has to call <I>IPersistStream::Load</I>, the code it uses to open the stream is exactly what would appear in an object's <I>IPersistStorage::Load</I> function, as we'll see later in our discussion of Polyline.</P>
<P>In all cases, CoCosmo holds onto the open <I>IStorage</I> pointer itself, regardless of what Polyline does with it. CoCosmo is the owner of that storage, but Polyline needs it in order to create any of its own streams or substorages. As the following code shows, CoCosmo saves the pointer after calling <I>StgCreateDocfile</I> (for a new file) or <I>StgOpenStorage</I> (for an existing file):</P>
<P><BR></P>
<pre><code>//From CCosmoDoc::Load<BR><BR>//For new files<BR>hr=StgCreateDocfile(NULL, STGM_DIRECT | STGM_READWRITE<BR>    | STGM_CREATE | STGM_DELETEONRELEASE<BR>    | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage);<BR><BR>if (FAILED(hr))<BR>    return DOCERR_COULDNOTOPEN;<BR><BR>if (PERSIST_STORAGE==m_pp.psModel)<BR>    m_pp.pIP.pIPersistStorage-&gt;InitNew(pIStorage);<BR>else<BR>    {<BR>    if (PERSIST_STREAMINIT==m_pp.psModel)<BR>        m_pp.pIP.pIPersistStreamInit-&gt;InitNew();<BR>    }<BR><BR>m_pIStorage=pIStorage;<BR><BR>§<BR><BR>//For existing files<BR>hr=StgOpenStorage(pszFile, NULL, STGM_DIRECT | STGM_READWRITE<BR>    | STGM_SHARE_EXCLUSIVE, NULL, 0, &amp;pIStorage);<BR><BR>if (FAILED(hr))<BR>    return DOCERR_COULDNOTOPEN;<BR><BR>if (PERSIST_STORAGE==m_pp.psModel)<BR>    hr=m_pp.pIP.pIPersistStorage-&gt;Load(pIStorage);<BR>else<BR>    {<BR>    LPSTREAM    pIStream;<BR><BR>    hr=pIStorage-&gt;OpenStream(SZSTREAM, 0, STGM_DIRECT<BR>        | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream);<BR><BR>    if (SUCCEEDED(hr))<BR>        {<BR>        //This also works for PERSIST_STREAMINIT<BR>        hr=m_pp.pIP.pIPersistStream-&gt;Load(pIStream);<BR>        pIStream-&gt;Release();<BR>        }<BR><BR>m_pIStorage=pIStorage;</code></pre>
<P>Within <I>CCosmoDoc::Save</I>, CoCosmo calls <I>IPersistStorage::Save</I> or <I>IPersistStream[Init]::Save</I>, passing the appropriate pointer. Again, the extra step of opening a stream in which to save through <I>IPersistStream </I>is what the object would do inside <I>IPersistStorage </I>itself. The difference between the interfaces is mostly where that stream creation occurs. Anyway, in the case of <I>IPersistStorage</I>, CoCosmo passes either the existing <I>IStorage</I> pointer obtained when loading the document (for File Save) or a new <I>IStorage</I> pointer from <I>StgCreateDocfile</I> when writing a new file (File Save As). It sets <I>fSameAsLoad </I>to TRUE in the former case, FALSE in the latter. After calling <I>IPersistStorage::Save</I>, we have to complete the protocol by calling <I>IPersistStorage::SaveCompleted</I> with a NULL if <I>fSameAsLoad</I> was TRUE; otherwise, we have to pass the <I>IStorage </I>of the new file we saved so that Polyline can reinitialize its pointers:</P>
<P><BR></P>
<pre><code>//From CCosmoDoc::Save<BR>LPSTORAGE           pIStorage;<BR>BOOL                fSameAsLoad;<BR><BR>//If Save or Save As under the same name, do Save.<BR>if (NULL==pszFile || 0==lstrcmpi(pszFile, m_szFile))<BR>    {<BR>    fRename=FALSE;<BR>    pszFile=m_szFile;<BR>    fSameAsLoad=TRUE;<BR>    }<BR>else<BR>    {<BR>    hr=StgCreateDocfile(pszFile, STGM_DIRECT | STGM_READWRITE<BR>        | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage);<BR><BR>    if (FAILED(hr))<BR>        return DOCERR_COULDNOTOPEN;<BR><BR>    fSameAsLoad=FALSE;<BR>    m_pIStorage-&gt;Release();<BR>    m_pIStorage=pIStorage;<BR>    }<BR><BR>if (PERSIST_STORAGE==m_pp.psModel)<BR>    {<BR>    hr=m_pp.pIP.pIPersistStorage-&gt;Save(m_pIStorage, fSameAsLoad);<BR><BR>    if (SUCCEEDED(hr))<BR>        {<BR>        hr=m_pp.pIP.pIPersistStorage-&gt;SaveCompleted(fSameAsLoad<BR>            ? NULL : m_pIStorage);<BR>        }<BR>    }<BR>else<BR>    {<BR>    LPSTREAM    pIStream;<BR><BR>    hr=m_pIStorage-&gt;CreateStream(SZSTREAM, STGM_DIRECT<BR>        | STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE<BR>        , 0, 0, &amp;pIStream);<BR><BR>    if (SUCCEEDED(hr))<BR>        {<BR>        //This also works for PERSIST_STREAMINIT.<BR>        hr=m_pp.pIP.pIPersistStream-&gt;Save(pIStream, TRUE);<BR>        pIStream-&gt;Release();<BR>        }<BR>    }</code></pre>
<P>Through this little bit of code, CoCosmo can handle an object with any persistence model except <I>IPersistFile</I>. To demonstrate this ability, we'll look at two implementations of Polyline: one with <I>IPersistStorage</I> and the other with <I>IPersistStreamInit.</I> But first, as a close to this section, note that CoCosmo never has occasion to place Polyline in the hands-off state, so it never calls <I>IPersistStorage::HandsOffStorage.</I> In addition, when saving a stream-based object, CoCosmo could fail to create the stream because of an out-of-memory condition. To be more robust, it would create and cache the stream when it found a stream-based object, just as a storage-based object would cache a pointer inside its <I>InitNew </I>or <I>Load.</I></P></font></body></HTML>
