<HTML><HEAD><TITLE>Round the Corners: Other Miscellany</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Round the Corners: Other Miscellany</H3><P>To finish up a complete container, we need to make a number of minor modifications, some of which are required and others of which are optional:</P>
<UL><LI>(Required) Call <I>IOleInPlaceActiveObject::OnFrameWindowActivate </I>and <I>OnDocWindowActivate</I> when your frame and document windows receive WM_ACTIVATEAPP and WM_MDIACTIVATE messages. Switching document windows might also mean restoring your container's normal UI.</LI><LI>(Required) Call <I>IOleInPlaceActiveObject::ResizeBorder</I> when either your frame or your document window is resized so that the UI-active object can adjust its tools.</LI><LI>(Required) Call <I>IOleInPlaceObject::SetObjectRects</I> whenever you scroll the document or otherwise change the position and clipping rectangles of the object in relation to the document window (the object's parent). Also implement <I>IOleInPlaceSite::OnPosRectChange</I> and <I>IOleInPlaceSite::Scroll</I>.</LI><LI>(Required) Implement minimal context-sensitive help support in case the server supports it, even if you don't.</LI><LI>(Required) Provide minimal Undo support by calling <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>DISCARDUNDOSTATE)</I> when making a change after deactivation and by implementing <I>IOleInPlaceSite::DeactivateAndUndo</I>.</LI><LI>(Optional) If you have an Undo command, call <I>IOleInPlaceObject::ReactivateAndUndo</I> if the command is given immediately after deactivation. Also implement <I>IOleInPlaceSite::DiscardUndoState</I>.</LI><LI>(Optional) Provide a Ctrl+Enter accelerator to generate a call to <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>OPEN)</I>.</LI><LI>(Optional) If you have a status line, implement <I>IOleInPlaceFrame::SetStatusText</I>.</LI><LI>(Optional) If you have modeless pop-up windows that are typically shown as part of your user interface, show/enable or hide/disable these when <I>IOleInPlaceFrame::EnableModeless</I> is called. You can tell an object to do the same by calling <I>IOleInPlaceActiveObject::EnableModeless</I> when displaying a modal user interface yourself.</LI></UL><P>The following sections briefly discuss each of these modifications.</P>
<H4><A NAME="sec0"></A>Call <I>IOleInPlaceActiveObject::On[Frame </I><I>¦</I><I> Document]WindowActivate</I></H4><P>For the frame window, process the WM_ACTIVATEAPP message and call <I>IOleInPlaceActiveObject::OnFrameWindowActivate</I> if you have a UI-active object from <I>IOle</I><I>InPlaceFrame::SetActiveObject</I>. The argument to <I>OnFrameWindowActivate</I> is a BOOL indicating whether the frame window is becoming active (TRUE) or inactive (FALSE). You can see a demonstration of this in<I>CPatronFrame::FMessageHook.</I></P>
<P>Document switching is a little more complex, but it applies only to an MDI application. You need to process the WM_MDIACTIVATE message and check whether there is a UI-active object in the document at all. If there is, you need to call <I>IOleInPlaceActiveObject::OnDocWindowActivate</I> with a BOOL indicating activation (TRUE) or deactivation (FALSE) of the window itself. In response, the object will deactivate or activate its own UI (calling <I>IOleInPlaceSite </I>members accordingly). On the other hand, if a document window is becoming active and does not have a UI-active object in it, the container should reinstate its own frame UI. All of this occurs in <I>CPatronDoc::FMessageHook</I>,<I> </I>which calls <I>CPatronFrame::ReinstateUI </I>when activating a document without a UI-active object. The result is that switching documents will switch the necessary UI, depending on the contents of the documents.</P>
<H4><A NAME="sec1"></A>Call <I>IOleInPlaceActiveObject::ResizeBorder</I></H4><P>Because a UI-active object initially calls <I>IOleInPlaceUIWindow::GetBorder </I>to obtain the dimensions with which to create its in-place tools, a container has to tell the UI-active object when those dimensions change by calling <I>IOleInPlaceActiveObject::ResizeBorder</I>. The container passes the new size of the window (a RECT), the appropriate <I>IOleInPlaceUIWindow</I> pointer for the frame or document window, and a flag, <I>fFrame</I>,<I> </I>to indicate which window was resized. In response, the object will renegotiate for tool space and resize its tools as necessary. Patron makes these calls from within the WM_SIZE cases of <I>CPatronFrame::FMessageHook </I>and <I>CPatronDoc::FMessageHook</I>, calling <I>GetClientRect </I>to determine the rectangle and passing the other arguments as appropriate.</P>
<P>Be careful with the <I>fFrame </I>argument. When I first wrote this code, my document passed a TRUE and all sorts of wild things started happening as the object was resizing its frame tools to the dimensions of the document window. It was a hard bug to find, so give your implementation a little extra care.</P>
<H4><A NAME="sec2"></A>Call <I>IOleInPlaceObject::SetObjectRects</I> and Flush Out <I>IOleInPlaceSite</I></H4><P>Remember when we implemented <I>IOleInPlaceSite::GetWindowContext</I>? This function returned initial position and clipping rectangles to the object. If you scroll the document, however, you change these rectangles and must pass new values to all in-place–active objects, not only the UI-active object, by calling <I>IOleInPlaceObject::SetObjectRects</I> for each. Whenever Patron detects that scrolling has occurred, it will call <I>CPage::ScrolledWindow</I>, which loops over all the tenants in the page, calling <I>CTenant::UpdateInPlaceObjectRects</I> in each. This function calculates the new position rectangle based on the current scroll position and calls <I>IOleInPlaceObject::SetObjectRects</I> if that tenant holds an in-place–active object.</P>
<P><I>CTenant::UpdateInPlaceObjectRects</I> also handles calls that come into <I>IOleInPlaceSite::OnPosRectChange. </I>An object will call this with a rectangle whenever it needs a larger position rectangle in the container. This might be in response to the user resizing the object with its own grab handles or to the object executing some command to change a scaling factor.</P>
<P>You can handle this in the container in two ways. Both methods end in a call to <I>IOleInPlaceObject::SetObjectRects</I> once again. First, you can restrict the object's size to the size of the site or to whatever other limit you want to enforce. In this case, you'll call <I>SetObjectRects </I>again with the rectangle of your choice. The object can choose to display (or remove) scrollbars as adornments, or it can scale the object as it sees fit. The other method is to let the object grow by passing whatever rectangle the object passed to you back to <I>IOleInPlaceObject::SetObjectRects</I>. In any case, the container controls the space the object occupies in the container, but the object controls how the object decides to use that space for scaling or whatever.</P>
<P>Besides the end user scrolling the document directly, the object can ask the container to scroll programmatically by calling <I>IOleInPlaceSite::Scroll</I>. This is useful when the object knows that it is clipped by the document window but the end user has done something to indicate that he or she would like to see that part of the object. Thus, Patron implements this function as follows:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceSite::Scroll(SIZE sz)<BR>    {<BR>    int         x, y;<BR><BR>    x=m_pTen-&gt;m_pPG-&gt;m_xPos+sz.cx;<BR>    y=m_pTen-&gt;m_pPG-&gt;m_yPos+sz.cy;<BR><BR>    SendScrollPosition(m_pTen-&gt;m_hWnd, WM_HSCROLL, x);<BR>    SendScrollPosition(m_pTen-&gt;m_hWnd, WM_VSCROLL, y);<BR>    return NOERROR;<BR>    }</code></pre>
<P>The <I>SendScrollPosition</I> macros (INC\BOOK1632.H) here cause the document to scroll, which will generate calls to <I>IOleInPlaceObject::SetObjectRects</I> once again.</P>
<H4><A NAME="sec3"></A>Implement Minimal Context-Sensitive Help Support</H4><P>Even if a container does not understand context-sensitive help, it must support an object that does. This means that a container must implement accelerators for Shift+F1 (enter mode) and Esc (exit mode) and process them as follows. (<I>fEnterMode</I> is TRUE on Shift+F1 and FALSE on Esc.)</P>
<P>Call your own <I>IOleInPlaceFrame::ContextSensitiveHelp(fEnterMode)</I>.</P>
<P>If your application is an SDI application, have the frame implementation call <I>IOleInPlaceActiveObject::ContextSensitiveHelp(fEnterMode)</I>.</P>
<P>If your application is an MDI application, have the frame implementation call <I>IOleInPlaceUIWindow::ContextSensitiveHelp(fEnterMode)</I> for each document. Patron does this in <I>CPatronClient::CallContextHelpOnDocuments</I>.</P>
<P>For MDI documents, have their <I>IOleInPlaceUIWindow</I> implementations call <I>IOleInPlaceActiveObject::ContextSensitiveHelp(fEnterMode)</I>.</P>
<P>If the object detects Shift+F1 or Esc, it will call your <I>IOleInPlaceSite::ContextSensitiveHelp</I>, which should be implemented as follows:</P>
<UL><LI>If your application is an SDI application, call your document window's <I>IOleInPla</I><I>ceUIWindow::ContextSensitiveHelp(fEnterMode)</I>.</LI><LI>If your application is an MDI application, call the frame window's <I>IOleInPlaceFrame::ContextSensitiveHelp(fEnterMode)</I>, which will propagate the mode to all the documents.</LI></UL><P>There are some special considerations for an application that is both a container and a server and that has its own object embedded within itself. See the <I>OLE Programmer</I><I>'</I><I>s Reference </I>for more details.</P>
<H4><A NAME="sec4"></A>Provide Minimal Undo Support</H4><P>Even if the container does not have an Undo command (à la Patron), it still has two small responsibilities in that regard. First, it must implement <I>IOleInPlaceSite::DeactivateAndUndo</I> by calling <I>IOleInPlaceObject::InPlaceDeactivate</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceSite::DeactivateAndUndo(void)<BR>    {<BR>    m_pTen-&gt;m_pIOleIPObject-&gt;InPlaceDeactivate();<BR>    return NOERROR;<BR>    }</code></pre>
<P>Second, whenever the object is deactivated, the container should call <I>IOleObject::DoVerb</I> with OLEIVERB_DISCARDUNDOSTATE. Why do we do this? Read on. It's important if you have an Undo command of your own—or if you are just exceptionally curious.</P>
<H4><A NAME="sec5"></A>Support Your Own Undo Command</H4><P>Applications that support Undo operations generally save some Undo information whenever a change takes place. An application such as this will have this state when it activates an in-place object. If the first thing a user does afterward is choose an Undo command, the object will call your <I>IOleInPlaceSite::DeactivateAndUndo</I>. At this time, you deactivate the object and undo the last change in the container. You do this because activation and deactivation are not considered separate undoable actions, so the container reverses the last action that occurred before the Undo. If the user makes any changes to the object, it will call the container's <I>IOleInPlaceSite::DiscardUndoState</I>, at which time you can discard the last change state. Thus you hold the Undo state only as long as needed.</P>
<P>Now let's go the other direction. Suppose we just deactivated an object in a container and the user chooses Undo. We need to undo the deactivation and tell the object to undo its last change (which is one reason the object remains running after being deactivated). So the container calls <I>IOleInPlaceObject::ReactivateAndUndo</I>. If you make some other change before the Undo occurs, you have to tell the object to discard whatever Undo state it might have by calling <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>DISCARDUNDOSTATE)</I>.</P>
<P>The <I>fUndoable </I>flag passed to <I>IOleInPlaceSite::OnUIDeactivate </I>tells the container whether the object supports this sort of Undo at all.</P>
<H4><A NAME="sec6"></A>Provide an Open Accelerator</H4><P>If you want, you can add a Ctrl+Enter accelerator for in-place activation that would generate a call to <I>IOleObject::DoVerb(OLEIVERB</I><I>_</I><I>OPEN)</I> to take an object from the in-place–active state to the open state. The object will generally also provide a way to do this on its own menus, so don't add a menu item, simply add the accelerator. Of course, you can use this accelerator all the time if you want, even outside in-place activation.</P>
<H4><A NAME="sec7"></A>Implement <I>IOleInP</I><I>laceFrame::SetStatusText</I></H4><P>If the container has a status line, it remains visible all through an in-place session. You also need to give the UI-active object a way to display status information. This is the purpose of <I>IOleInPlaceFrame::SetStatusText</I>,<I> </I>in which you take whatever text the object gives and display it in your status line, as Patron does here:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CPatronFrame::SetStatusText(LPCOLESTR pszText)<BR>    {<BR>    m_pSL-&gt;MessageSet(pszText);<BR>    return NOERROR;<BR>    }</code></pre>
<P>If an object calls <I>SetStatusTe</I><I>xt </I>with NULL, it is asking whether you have a status line at all. If you don't, return E_FAIL, which allows the object to display its own status line as an in-place tool.</P>
<H4><A NAME="sec8"></A>Show or Hide Modeless Pop-Up Windows</H4><P>If a container has any modeless pop-up windows, an object might ask that you hide or disable them (your choice) by calling <I>IOleInPlaceFrame::EnableModeless(FALSE)</I>. It will later call this function with TRUE to show and enable those same windows. You can ask the object to do the same through <I>IOleInPlaceActiveObject::EnableModeless</I>, typically when you display some modal dialog box in which you want to disable anything else that appears<I> </I>to be part of the container. So both <I>EnableModeless </I>functions allow either container or object to enter a modal state and have that state apply to both.</P></font></body></HTML>
