<HTML><HEAD><TITLE>IPersistStorage: A Heavy Dose of Protocol</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3><I>IPersistStorage</I>: A Heavy Dose of Protocol</H3><P>The persistence model of <I>IPersistFile </I>introduces a few of the complications that arise when an object is allowed incremental access to its persistent data—that is, allowed to scribble in its storage. The persistence model of <I>IPersistStora</I><I>ge </I>is even more complicated because it allows an object to read and write its information to a storage hierarchy that begins with an arbitrary storage element (<I>IStorage</I>) as well as to handle low-memory save situations. As with <I>IPersistFile</I>, a client of an object that implements <I>IPersistStorage </I>has to be able to tell that object when to release its pointers to open storage and stream elements so that the client can manipulate the storage, change an underlying file location, and so on.</P>
<P>So the <I>IPersistStorage</I><I> </I>interface describes not only load and save semantics but also includes initialization semantics such as <I>IPersistStreamInit </I>and the operations necessary to determine when the object can scribble to its storage:</P>
<P><BR></P>
<pre><code>interface IPersistStorage : IPersist<BR>    {<BR>    HRESULT IsDirty(void);<BR>    HRESULT InitNew(IStorage *pstg);<BR>    HRESULT Load(IStorage *pstg);<BR>    HRESULT Save(IStorage *pstg, BOOL fSameAsLoad);<BR>    HRESULT SaveCompleted(IStorage *pstg);<BR>    HRESULT HandsOffStorage(void);<BR>    };</code></pre>
<P>These functions behave as follows:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Member<BR>Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>IsDirty</P></TD><TD VALIGN="TOP"><P>Same semantics as in <I>IPersistStream[Init]</I> and <I>IPersistFile</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>InitNew</P></TD><TD VALIGN="TOP"><P>Instructs the object to fully initialize a new storage identified by <I>pstg</I>. The object should create and open every storage and stream element into which it would like to scribble, as well as any element that it will require in a low-memory save situation. It should also preallocate stream space (<I>IStream::SetSize</I>) that it will need in a save operation in case the storage medium is full. It may also hold a reference on <I>pstg</I> itself.</P></TD></TR><TR><TD VALIGN="TOP"><P>Load</P></TD><TD VALIGN="TOP"><P>Instructs the object to load its persistent data from the storage element identified by <I>pstg</I>. The object should hold open any element it may want (for scribbling) or require (for low-memory saves) as described for <I>InitNew</I>. <I>Load</I> is always called in lieu of <I>InitNew</I> to initialize the object.</P></TD></TR><TR><TD VALIGN="TOP"><P>Save</P></TD><TD VALIGN="TOP"><P>Instructs the object to save its persistent data in either its current storage or a different storage, depending on the <I>fSameAsLoad</I> flag (<I>pstg</I> will always be non-NULL). If <I>fSameAsLoad</I> is TRUE, the object can write changes incrementally; otherwise, the object must completely rewrite all of its data. In either case, the object continues to hold its present pointers to open elements, al-though it cannot scribble until <I>SaveCompleted</I> is called. The object clears its dirty flag on <I>Save</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P><I>Save</I> is not allowed to<B> </B>fail as the result of an out-of-memory condition, which means that the object must open and hold pointers to any element it might need in order to complete a save during <I>InitNew</I> and <I>Load</I>. Creating and opening elements requires memory that might not be available.</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>The object should never call <I>IStorage::Commit</I> on the <I>pstg</I> passed to this function nor write a CLSID with <I>WriteClassStg</I>; the client owns those operations.</P></TD></TR><TR><TD VALIGN="TOP"><P>SaveCompleted</P></TD><TD VALIGN="TOP"><P>Informs the object that the calling client has completed its overall save procedure. If <I>pstg</I> is NULL, the object can once again scribble to its open elements. If <I>pstg</I> is non-NULL, the object must release its pointers and reopen its elements underneath <I>pstg</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>HandsOffStorage</P></TD><TD VALIGN="TOP"><P>Instructs the object to release all of its pointers to any and all elements, including the pointer passed to <I>InitNew</I> or <I>Load</I>. This call can follow <I>Save</I> and precede <I>SaveCompleted</I> to allow the client to manipulate the storage without possibility of access violations (see the following discussion).</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>As with <I>IPersistStreamInit</I>, both the <I>Load </I>and <I>InitNew </I>functions can initialize the object as well as its storage. <I>InitNew </I>is called only if the object as yet has no persistent storage; otherwise, <I>Load </I>is always called. The two will never be used on the same instance of an object. <I>InitNew </I>should, however, preallocate stream space with <I>IStream::SetSize. </I>It's silly to go to all the trouble to save pointers for a low-memory save just to run out of disk space at the same time!5</P>
<P>The relationship between <I>Save</I>, <I>SaveCompleted</I>, and <I>HandsOffStorage </I>is a little more complex than with <I>IPersistFile</I>. These functions provide an object with incremental access to its storage (including access needed for low-memory saves) but allow the client to temporarily suspend that right in order to rename the storage element, save a file and reopen it, move a file, and so on. The nature of <I>IPersistStorage </I>allows an object to hold an <I>IStorage </I>pointer for its own use, which it may access incrementally throughout its lifetime. When that client wants to perform a complete save, or when that client wants to save everything into a new file, it has to have some way of telling the persistent object to release whatever pointers it holds to open storage and stream elements.</P>
<P>To illustrate the process, let's assume that we have a client in control of a root storage, which in turn contains a substorage. The client instantiates some object to which it hands the <I>IStorage </I>pointer to that substorage, allowing the object to create whatever hierarchy it wants within that substorage. At this point the object is uninitialized. If the storage is brand-new, the client initializes the object (and its storage) through <I>IPersistFile::InitNew</I>; if the storage is opened within an existing file, initialization occurs with <I>IPersistStorage::Load</I>:</P>
<P><img src="f08ddaa.gif"></P>
<P>In either case, the client hands an <I>IStorage </I>pointer to the object, which is now in the scribble state, in which it can open and hold any pointers to any elements in the storage (it must call <I>AddRef </I>on the <I>pstg </I>passed to <I>Load </I>or <I>InitNew </I>to hold that pointer):</P>
<P><img src="f08ddbb.gif"></P>
<P>At some later time, the client tells the object to save its data through <I>IPersistStorage::Save</I>, to perform either a full save or an incremental save. In both cases, the object is passed the <I>IStorage </I>in which to save, using <I>fSameAsLoad</I> to distinguish the operations to perform. Again, <I>IPersistStorage::Save</I> is contractually obligated to save its data without failing as a result of out-of-memory conditions. This last statement has some heavy implications. It means that to fulfill this requirement, the object must not attempt to create new streams or substorages from within <I>Save</I> because creating them requires memory. Again, this means that in its implementation of both <I>Load</I> and <I>InitNew</I>, the object must not only hold onto the <I>IStorage</I> pointer, but it must also create and hold open any element it might need in a subsequent incremental save. This ensures that a user's data can be saved with zero available memory, which is all that matters in such conditions. Of course, if you are not interested in robustness of this kind, feel free to ignore the rules…and then train your product support teams in the fine art of soothing horribly irate customers! Best to follow the rules.</P>
<P>Again, after <I>InitNew</I> or <I>Load</I> is called, the object is in its scribble state, in which it reads and writes in the storage as necessary. In scribble mode, additional calls to <I>InitNew</I> and <I>Load</I> are illegal (client error) and should return E_UNEXPECTED.</P>
<P>Now one of two things might happen to the object: the client can call either <I>Save</I> or <I>HandsOffStorage</I>. As mentioned already, <I>Save</I> instructs the object to perform either an incremental or a full save. After <I>Save</I> is called, the object enters into a zombielike (or no-scribble) state. A zombified object cannot perform any incremental writes to the storage, although it can still read from the storage without problem. When the client wants to allow scribbling again, it calls <I>SaveCompleted</I>, freeing the object from the curse of being undead:</P>
<P><img src="f08ddcc.gif"></P>
<P>In some situations, a client requires the object to release any of its open storage or stream pointers, for example when the client is going to rename the underlying file or when it is reverting to a previously saved state. This is the purpose of <I>HandsOffStorage</I>, which tells the object to get its grubby little mitts off any elements within the storage. If this call occurs before <I>Save</I>, the object must shrug its shoulders, heave a heavy sigh, and blindly call <I>Release</I> on all its pointers. However, the client later makes the same bits available through <I>SaveCompleted</I>, which the object was looking at when <I>HandsOffStorage </I>was called. In other words, the object doesn't lose any data and doesn't have to reinitialize its internal state—it can just reopen its needed elements.</P>
<P>When the client calls <I>HandsOffStorage</I>, the object enters the <I>hands-off</I> state. In this state, it cannot read from <I>or</I> write to a storage—it has no pointers! When the client has finished partying on the storage, it must then call <I>SaveCompleted</I>, passing the <I>IStorage </I>pointer from which the object can reopen its elements. <I>SaveCompleted </I>means a return to the scribble state.</P>
<P><img src="f08dddd.gif"></P>
<P>Obviously, the client must always pass an <I>IStorage</I> pointer to <I>SaveCompleted</I> when the object is in the hands-off state. The storage must always contain the object's expected hierarchy because the object will attempt to reopen its elements. Granted, the storage may or may not be the same as the one passed to <I>InitNew</I>, <I>Load</I>, or even <I>Save</I>. But the same data will be in whichever storage the object receives. Keep in mind as well that a sequence of calls to <I>HandsOffStorage </I>and <I>SaveCompleted </I>should clear the object's dirty flag.</P>
<P>We'll see all of this protocol reduced to code a little later in this chapter.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>5 Do not depend on the stream having a 512-byte allocation granularity as with compound files because it is not necessarily true that the stream is part of a compound file. It could be implemented on global memory or a database field with a different granularity.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
