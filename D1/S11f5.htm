<HTML><HEAD><TITLE>The IOleCache2 Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The <I>IOleCache2 </I>Interface</H3><P>The <I>IOleCache2 </I>interface is the interface a client uses to control what actually gets cached.<I> </I>The <I>IOleCache </I>interface expresses the basic functionality, with <I>IOleCache2 </I>adding the capability of the client to update any cached data that is maintained.<I> </I>The following shows the definitions of the interfaces; the member functions of both interfaces are described in Table 11-4.</P>
<P><BR></P>
<pre><code>interface IOleCache : IUnknown<BR>    { <BR>    HRESULT Cache(FORMATETC *pFE, DWORD dwAdvf, DWORD *pdwConnection);<BR>    HRESULT Uncache(DWORD dwConnection);<BR>    HRESULT EnumCache(IEnumSTATDATA **ppEnum);<BR>    HRESULT InitCache(IDataObject *pIDataObject);<BR>    HRESULT SetData(FORMATETC *pFE, STGMEDIUM *pSTM, BOOL fRelease);<BR>    }; <BR><BR>interface IOleCache2 : IOleCache<BR>    {<BR>    HRESULT UpdateCache(IDataObject *pIDataObject, DWORD dwgrfUpdf<BR>        , void **pvReserved);<BR>    HRESULT DiscardCache(DWORD dwDiscardOptions);<BR>    }</code></pre>
<P></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="107pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="2" VALIGN="TOP"><P><B>IOleCache<BR>and IOleCache2<BR>Member Function</B></P></TD><TD COLSPAN="3" VALIGN="TOP"><P><B>Behavior</B></P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P>Cache</P></TD><TD COLSPAN="3" VALIGN="TOP"><P>Adds the given format to the list of those cached. If <I>FORMATETC::cfFormat</I> is 0, all formats are cached. If CF_BITMAP is cached, the cache will also save CF_DIB and vice versa. The ADVF_* flags specify how the cache relates to a remote object. (See "The <I>IOleCacheControl </I>Interface" later in this chapter.) <I>Cache</I> returns a connection key for use with <I>Uncache</I>.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P>Uncache</P></TD><TD COLSPAN="3" VALIGN="TOP"><P>Removes a format from the list to cache by using the key returned from <I>Cache</I> and releases any data of this format from the cache. Also terminates any connection to a local or remote object for the format.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P>EnumCache</P></TD><TD COLSPAN="3" VALIGN="TOP"><P>Enumerates the present cached formats (not the data) through <I>IEnumSTATDATA</I>, as described for <I>IDataObject::EnumDAdvise</I> in Chapter 10. The <I>pAdvSink</I> field of the enumerated structures holds <I>IAdviseSink</I> pointers to sinks implemented in the cache that are connected to a local or remote object.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P>InitCache</P></TD><TD COLSPAN="3" VALIGN="TOP"><P>Fills the cache with all the data available from a data object. This is easily implemented by enumerating the formats in the data object, calling <I>IDataObject::GetData</I> for each and then saving each one by calling <I>IOleCache2::SetData</I>.</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P>SetData</P></TD><TD COLSPAN="3" VALIGN="TOP"><P>Saves a specific piece of data in the cache. The <I>fRelease</I> flag acts like the same argument to <I>IDataObject::SetData</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>UpdateCache<BR>(IOleCache2 only)</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Updates the data in the cache in bulk from the data available in a data object according to <I>dwgrfUpdf</I>. These flags are fully described in the <I>OLE Programmer</I><I>'</I><I>s Reference</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>DiscardCache<BR>(IOleCache2 only)</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Flushes any data from memory but does not delete it from the cache. Only information about available formats remains in memory. The <I>dwDiscardOptions</I> flag allows the caller to save any data that has been changed or to simply discard it.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Table 11-4</B></P>
<P><B>Behavior of the data cache's <I>IOleCache2</I> interface.</B></P>
<P>Basically, the data cache keeps data on disk as long as possible, bringing it into memory only when necessary. The <I>IOleCache2::Cache </I>and <I>IOleCache2::Uncache </I>members control the information list that determines what is available. Other than that, <I>InitCache</I>, <I>SetData</I>, <I>UpdateCache</I>, and <I>DiscardCache </I>do nothing more than control what will actually be saved, and <I>EnumCache </I>describes what is there.</P>
<P>Using the data cache, you can save any number of pieces of data that you want as long as each has a different FORMATETC (except for <I>tymed</I>). This means you can save CF_METAFILEPICT data for any number of aspects and for any number of target devices per aspect. You can also save an object's presentations for any number of printers, allowing the client to fully control the presentations and output quality that will be available when the object is not available itself. This is a tremendous benefit for OLE Documents because a client can save a cache for each embedded or linked object so that the cached presentations travel with the document wherever it goes. Even when the object's code is unavailable or when the source of linked data is unavailable, the client will still be able to view and print appropriate images.</P></font></body></HTML>
