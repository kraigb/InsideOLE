<HTML><HEAD><TITLE>The FORMATETC Structure</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The FORMATETC Structure</H3><P>FORMATETC (pronounced "format et cetera") is a generalization—and an improvement—of the clipboard format and contains a rich description of data. The name comes from the idea that it contains a clipboard format and some more stuff—the et cetera:</P>
<P><BR></P>
<pre><code>typedef WORD CLIPFORMAT;<BR><BR>typedef struct tagFORMATETC<BR>    {<BR>    CLIPFORMAT      cfFormat;<BR>    DVTARGETDEVICE *ptd;<BR>    DWORD           dwAspect;<BR>    LONG            lindex;<BR>    DWORD           tymed;<BR>    } FORMATETC;<BR><BR>enum tagDVASPECT<BR>    {<BR>    DVASPECT_CONTENT    = 1,<BR>    DVASPECT_THUMBNAIL  = 2,<BR>    DVASPECT_ICON       = 4,<BR>    DVASPECT_DOCPRINT   = 8<BR>    } DVASPECT;</code></pre>
<P>Its fields carry information as follows:</P>
<UL><LI><I>cfFormat</I>: The clipboard format identifying the data structure. This can be a standard format such as CF_TEXT or a format that both source and consumer register with the Windows API <I>RegisterClipboardFormat</I>.  The use of "clipboard" here is archaic—the identified structures themselves have nothing to do with the clipboard.  The name stuck because the clipboard was the first data exchange protocol in Windows and the first to use a simple integer identification of structures.</LI><LI><I>ptd</I>: Information about the device, such as a screen or a printer, for which the data was rendered.  The DVTARGETDEVICE structure looks and acts similar to the Windows DEVNAMES structure. It contains a header for a variable-length block of data, and each offset in the structure points to a specific piece of information in the block, where all strings are stored in Unicode under 32-bit OLE:
<P><BR></P>
<pre><code>typedef struct FARSTRUCT tagDVTARGETDEVICE<BR>    {<BR>    DWORD   tdSize;<BR>    WORD    tdDriverNameOffset;<BR>    WORD    tdDeviceNameOffset;<BR>    WORD    tdPortNameOffset;<BR>    WORD    tdExtDevmodeOffset;<BR>    BYTE    tdData[1];   //Contains the names and DEVMODE<BR>    } DVTARGETDEVICE;</code></pre></LI><LI><I>tdSize</I> always holds the size of the entire structure, including all additional bytes that occur after the DVTARGETDEVICE header. This simplifies copying the structure when necessary. Each <I>td</I><I>…</I><I>Offset</I> field is an offset from the start of the entire structure, not from the start of <I>tdData</I>. Because offsets start at the top of the structure, a 0 means "not present," or a NULL value for that name.</LI><LI><I>dwAspect</I>: The detail contained in the rendering, particularly useful for graphical formats.  Values are taken from the DVASPECT enumeration:  DVASPECT_CONTENT specifies "full content," as would normally be shown in some kind of document; DVASPECT_THUMBNAIL means "thumbnail sketch," as would be used in a print preview or document preview window; DVASPECT_ICON describes an icon view appropriate for small presentations as an attachment to an e-mail message; and DVASPECT_DOCPRINT identifies the rendering as a full "printer document" that includes all page numbers, headers, and footers, just as if the data were printed as a document from its native application.</LI><LI><I>lindex</I>: Identifier for the piece of the data when the data must be split across page boundaries. An <I>lindex</I> of <FONT FACE="Symbol">-</FONT>1 identifies the entire data and is the most common value. Otherwise, <I>lindex</I> has meaning only in DVASPECT_CONTENT, in which it identifies a piece of data for extended layout negotiation, and in DVASPECT_DOCPRINT, in which it identifies the page number.1</LI><LI><I>tymed</I>: The medium in which the data lives with values taken from the TYMED enumeration. See "The STGMEDIUM Structure" later in this chapter.</LI></UL><P>Obviously, filling out a structure like this every time you want to describe a data format will become tedious; you need five lines of code simply to fill the structure. To address this, I have defined two macros in INC\INOLE.H that facilitate filling a FORMATETC: <I>SETFormatEtc</I>, which allows you to set every field in a FORMATETC structure explicitly, and <I>SETDefFormatEtc</I>, which allows you to set <I>cfFormat</I> and <I>tymed</I> while filling the other fields with defaults (a common operation):</P>
<P><BR></P>
<pre><code>#define SETFormatEtc(fe, cf, asp, td, med, li)   \<BR>    {\<BR>    (fe).cfFormat=cf;\<BR>    (fe).dwAspect=asp;\<BR>    (fe).ptd=td;\<BR>    (fe).tymed=med;\<BR>    (fe).lindex=li;\<BR>    };<BR><BR>#define SETDefFormatEtc(fe, cf, med)   \<BR>    {\<BR>    (fe).cfFormat=cf;\<BR>    (fe).dwAspect=DVASPECT_CONTENT;\<BR>    (fe).ptd=NULL;\<BR>    (fe).tymed=med;\<BR>    (fe).lindex=-1;\<BR>    };</code></pre>
<P>I encourage you to use these macros when dealing with FORMATETC because they are far more convenient than writing each line of code separately.</P>
<H4><A NAME="sec0"></A>Handling DVTARGETDEVICE</H4><P>As described above, the <I>ptd </I>field of a FORMATETC structure is a pointer to a DVTARGETDEVICE<I> </I>structure. A NULL <I>ptd </I>always means "screen device," which is, of course, the easiest to handle. Printer devices, on the other hand, are more complex. Applications and components that deal with device-specific data will end up performing a few basic operations with such a structure: creating a structure, copying or comparing two structures, and creating a device context or an information context from a structure.</P>
<P>To that end, the sample code for this chapter provides a number of standard implementations of these functions, which you can find in CHAP10\TARGDEV\TARGDEV.CPP.2 In this file are the functions <I>TargetDeviceToDC</I>, <I>TargetDeviceFromPrintDlg</I>, <I>TargetDeviceCopy</I>, and <I>TargetDeviceCompare.</I> <I>TargetDeviceToDC </I>calls <I>CreateDC </I>or <I>CreateIC </I>with the information in a DVTARGETDEVICE structure. <I>TargetDeviceFromPrintDlg </I>creates a DVTARGETDEVICE structure (using the task memory allocator through <I>CoTaskMemAlloc</I>) from the PRINTDLG structure filled by the Windows <I>PrintDlg </I>API function. Applications generally use <I>PrintDlg </I>to obtain printer information in the first place, so it's convenient to be able to send that data to <I>TargetDeviceFromPrintDlg </I>and get back the OLE structure you need.</P>
<P>The other two functions are actually quite simple and manipulate the structure on little more than a binary level. In any case, I hope you find this code useful in your own work.</P>
<H4><A NAME="sec1"></A>Copying and Comparing FORMATETC Structures</H4><P>Whenever you want to copy or compare FORMATETC structures, keep the following in mind. When copying one structure to another, be sure to copy the entire DVTARGETDEVICE structure as well, using code such as that found in the sample <I>TargetDeviceCopy </I>function. Other than that, copying is a straightforward duplication of each field.</P>
<P>Comparing two FORMATETC structures presents a slightly different problem. First of all, the <I>cfFormat </I>and <I>lindex </I>fields must match exactly for equivalence. In addition, both structures must have the same target device structure, which is where the sample <I>TargetDeviceCompare </I>function comes in handy. Both <I>dwAspect </I>and <I>tymed </I>require special handling, however. You can compare these either for exact equivalence or on a subset basis. For example, if one FORMATETC has DVASPECT_CONTENT ¦ DVASPECT_THUMBNAIL, another with only DVASPECT_CONTENT could be considered equivalent but not an exact<I> </I>match. The same applies to TYMED_* flags. Why you'd choose either form of comparison depends on why you're making the comparison in the first place. If you want to determine whether one FORMATETC is a subset of a supported set of formats, use a subset comparison. If you need an exact match for a specific rendering, you want an exact comparison.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="540pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>1 Page layout capabilities might not be supported in the version of OLE you are working with. In the original OLE 2 and all shipping versions up to the time of writing in early 1995, <I>lindex </I>must always be <FONT FACE="Symbol">-</FONT>1. Newer interfaces will be using this field in the near future according to its original purpose described here. See your current <I>OLE Programmer</I><I>'</I><I>s Reference </I>for more information.</P></TD></TR><TR><TD VALIGN="TOP"><P>2 These functions are portable between ANSI (16-bit) and Unicode (32-bit) to handle both versions of DVTARGETDEVICE.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
