<HTML><HEAD><TITLE>Negotiate Tool Space</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Negotiate Tool Space</H3><P>Those pesky little objects are now going to make demands on the container for their own in-place tools. But being the good citizens that we are, we'll negotiate with the objects by implementing the <I>IOleInPlaceUIWindow::RequestBorderSpace </I>function for both our frame and our document windows. Negotiating objects will fill a BORDERWIDTHS structure and pass it to this function for your consideration. If you accept, you'll get a call to <I>IOleInPlaceUIWindow::SetBorderSpace </I>to actually allocate the space. Some objects might simply call <I>SetBorderSpace </I>first, and you have to handle that case. Anyway, if <I>SetBorderSpace </I>succeeds, the object will most likely then call <I>IOleInPlaceUIWindow::GetBorder </I>to ask for the size of the window in question. These functions all work on device units (pixels) and not HIMETRIC units, as many other parts of OLE do. Everything we do here is oriented toward the screen, so we don't need any fancy units.</P>
<P>Within <I>SetBorderSpace</I>, a container needs to reposition its various windows when asked to make space for tools. A container should try its best to keep the object in the same absolute position on the screen. After we look at the three member functions, we'll see what this means for our container.</P>
<H4><A NAME="sec0"></A><I>GetBorder</I></H4><P>This function is relatively easy to implement. Simply return the client-area rectangle for the appropriate window if you have no restrictions about where an object can place tools. The rectangle represents the space (the amount can be negotiated) from which the object can make requests for the space it needs and also provides the object with the dimensions it should use when creating tools. Any space you do not include in the rectangle is strictly off-limits to the object. Patron itself makes no restrictions for its document window, but it excludes the status line area for the frame window, as we can see in the following code:</P>
<P><BR></P>
<pre><code>//From IIPUIWIN.CPP<BR>STDMETHODIMP CImpIOleInPlaceUIWindow::GetBorder(LPRECT prcBorder)<BR>    {<BR>    if (NULL==prcBorder)<BR>        return ResultFromScode(E_INVALIDARG);<BR><BR>    GetClientRect(m_pDoc-&gt;m_hWnd, prcBorder);<BR>    return NOERROR;<BR>    }<BR><BR>//From PATRON.CPP<BR>STDMETHODIMP CPatronFrame::GetBorder(LPRECT prcBorder)<BR>    {<BR>    if (NULL==prcBorder)<BR>        return ResultFromScode(E_INVALIDARG);<BR><BR>    GetClientRect(m_hWnd, prcBorder);<BR>    prcBorder-&gt;bottom-=CYSTATSTRIP;  //Height of status line<BR><BR>    return NOERROR;<BR>    }</code></pre>
<H4><A NAME="sec1"></A><I>RequestBorderSpace</I></H4><P>Implementing this function can range from quite trivial to extravagantly complicated, depending on how picky you want to be about giving away border space. If you are not picky at all, simply return NOERROR from this function, as Patron does.</P>
<P>If you have some restrictions, you need to check each of the values in the BORDERWIDTHS structure passed to this function. BORDERWIDTHS has the fields <I>left</I>, <I>top</I>, <I>right</I>, and <I>bottom</I>, which specify how much space the object wants on each side of the window in question (frame or document). If you can grant the space, return NOERROR; otherwise, return INPLACE_E_NOTOOLSPACE.</P>
<H4><A NAME="sec2"></A><I>SetBorderSpace</I></H4><P>Two important things happen inside <I>SetBorderSpace</I>: if the container can grant the request, it should move its windows around to make room for the object's allocation and then remember those allocations so that it can resize its client-area windows properly when resizing the frame or document window.</P>
<P>Objects are allowed to call <I>SetBorderSpace </I>directly without first calling <I>RequestBorderSpace</I>—so don't assume a particular calling sequence. It's easy to have your <I>SetBorderSpace </I>call your own <I>RequestBorderSpace</I> to validate the object's request, returning INPLACE_E_NOTOOLSPACE to deny the request. The object must resort to negotiation at that point.</P>
<P>At the same time that it holds the object's request, the BORDERWIDTHS pointer passed from the object can be NULL or the structure to which it points can contain zeros. In the former case, the object is telling us that it doesn't need any tools itself and that we can leave all of our tools visible. Most OLE Controls do exactly this (as does the Polyline sample from Chapter 23). If we're given a BORDERWIDTHS full of zeros, the object doesn't want anyone's tools to appear, so we have to remove all of ours (excluding the status line) even though the object isn't going to create its own.</P>
<P>When you know what border space to allocate on all four sides of the window in question, you need to remember those allocations in case the user resizes the window. Patron's <I>CFrame::SetBorderSpace</I> saves these values, which are used later in the WM_SIZE case of <I>CPatronFrame::FMessageHook</I> to resize the client-area window (managed in the <I>CPa</I><I>tronClient </I>class) so that it doesn't overlap any of the object's tools. This is pretty basic code.</P>
<P>The trickiest aspect of <I>SetBorderSpace </I>is the initial resizing and repositioning of the client-area window, which is generally necessary to accommodate the object's space request. The trick is that you should, if at all possible, keep the object's window in the same place on the screen regardless of what other windows you need to move around. The reason for this is that the user will be staring at the object in the document. The less you have to move that object, the less disconcerting the user interface changes will be to the user. This means that new object tools might overlap the object itself, but that is better than always shifting that embedded object around on the screen and giving the end user a case of the jitters.</P>
<P>Inside <I>CPatronFrame::SetBorderSpace</I>, Patron calculates the current position of the site (and therefore the object) and calculates the number of pixels, in both horizontal and vertical directions, that we'll have to scroll everything in the document to counter any change in the position of the client-area window. In other words, if we have to move the client-area window down by 10 pixels and right by 18, we need to move everything in the document up by 10 pixels and left by 18, because as children of the client-area window, the document's elements would otherwise move with the parent.</P>
<P>Unless the new border space requests require no repositioning of the client-area window, Patron's <I>SetBorderSp</I><I>ace</I> function calls <I>CPatronClient::MoveWithoutFamily</I> (in CLIENT.CPP), passing the new rectangle that the client window should occupy along with the differences between the old window position and the new one. <I>MoveWithoutFamily </I>moves the client window first and then moves all its children in the opposite direction. Truly the parent is leaving its family behind, as you can see in the following code:</P>
<P><BR></P>
<pre><code>void CPatronClient::MoveWithoutFamily(LPRECT prc, int dx, int dy)<BR>    {<BR>    RECT        rc;<BR>    HWND        hWndFrame;<BR>    HWND        hWnd;<BR>    POINT       pt;<BR><BR>    hWndFrame=GetParent(m_hWnd);<BR>    SendMessage(hWndFrame, WM_SETREDRAW, FALSE, 0L);<BR><BR>    ShowWindow(m_hWnd, SW_HIDE);<BR>    SetWindowPos(m_hWnd, NULL, prc-&gt;left, prc-&gt;top<BR>        , prc-&gt;right-prc-&gt;left, prc-&gt;bottom-prc-&gt;top<BR>        , SWP_NOZORDER œ SWP_NOACTIVATE);<BR><BR>    //Move all children of client.<BR>    hWnd=GetWindow(m_hWnd, GW_CHILD);<BR><BR>    while (NULL!=hWnd)<BR>        {<BR>        GetWindowRect(hWnd, &amp;rc);<BR>        SETPOINT(pt, rc.left, rc.top);<BR>        ScreenToClient(m_hWnd, &amp;pt);<BR><BR>        if (pt.x!=dx &amp;&amp; pt.y!=dy &amp;&amp; !IsZoomed(hWnd))<BR>            {<BR>            //Move window in opposite direction of client.<BR>            SetWindowPos(hWnd, NULL, pt.x-dx, pt.y-dy<BR>                , rc.right-rc.left, rc.bottom-rc.top<BR>                , SWP_NOZORDER œ SWP_NOACTIVATE œ SWP_NOSIZE);<BR>            }<BR><BR>        hWnd=GetWindow(hWnd, GW_HWNDNEXT);<BR>        }<BR><BR>    SendMessage(hWndFrame, WM_SETREDRAW, TRUE, 0L);<BR>    ShowWindow(m_hWnd, SW_SHOW);<BR><BR>    return;<BR>    }</code></pre>
<P>The use of WM_SETREDRAW on the frame prevents the user from seeing some serious jitters. Without it, the user would see all the windows first move with the client and then move back one by one. To avoid this, we disable repaints and hide the client before moving anything. After moving everything, we reenable repaints and force an update by showing the client again.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H5><A NAME="sec3"></A>EXPERIENCE: The Jitters and <I>DeferWindowPos</I></H5><P><I>BeginDeferWindowPos</I>, <I>DeferWindowPos</I>, and <I>EndDeferWindowPos</I> will not move a collection of container windows together, as we need to do here. These functions turn into no-ops when the windows you send to <I>DeferWindowPos</I> are not all siblings. Thus, you cannot use these functions to move a parent window and its children at the same time. <I>EndDeferWindowPos</I> indicates that the process worked (returns TRUE), but nothing actually happens. Hence the solution used in Patron.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H5><A NAME="sec4"></A>EXPERIENCE: Take Care with <I>IOleClientSite::ShowObject</I></H5><P>In Chapter 17, Patron first implemented <I>ShowObject</I> to scroll an object into view if less than a quarter of it was visible. Such an action can easily ruin all the effort you put into keeping that object steady when activating in place, so if you've seen a call to <I>IOleInPlaceSite::OnInPlaceActivate</I>, don't scroll your document if any part of the object is visible—scroll only if the entire object is completely out of view.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR></TBODY></TABLE>
<P><BR></P><H4><A NAME="sec5"></A>Repaint Optimizations</H4><P>Switching the user interface around can cause considerable flickering and flashing as tools appear and disappear. Consider, for example, the case in which the container has an in-place object fully activated—user interface and all—so that the object's shared menu and tools are displayed. Now the end user immediately jumps over and double-clicks on another in-place object. Without any optimizations, the first object's tools disappear, the container's tools reappear, and then the second object is activated, causing the container's tools to disappear again and the new tools to appear. Blech! We'd like to prevent any excess work in making these changes, which applies to switching menus around as well.</P>
<P>The <I>OLE Programmer</I><I>'</I><I>s Reference </I>documents some techniques for minimizing repaints that affect <I>IOleInPlaceSite::OnUIActivate</I> and <I>OnUIDeactivate</I>. It also suggests the creation of frame-level functions to add or remove specific user interface elements. In Patron, these are implemented as <I>CPatronFrame::ShowUIAndTools</I> and <I>CPatronFrame::ReinstateUI</I>. (The variable <I>m</I><I>_</I><I>fOurToolsShowing</I> determines whether <I>CPatronFrame::FM</I><I>essageHook </I>will take the UI-active object's border space requests into consideration when processing WM_SIZE, as described earlier.)</P>
<P><BR></P>
<pre><code>void CPatronFrame::ShowUIAndTools(BOOL fShow, BOOL fMenu)<BR>    {<BR>    HWND    hWndTB;<BR><BR>    //This is the only menu case....Restore our original menu.<BR>    if (fMenu &amp;&amp; fShow)<BR>        SetMenu(NULL, NULL, NULL);<BR><BR>    hWndTB=m_pTB-&gt;Window();<BR>    ShowWindow(hWndTB, fShow ? SW_SHOW : SW_HIDE);<BR><BR>    if (fShow)<BR>        {<BR>        InvalidateRect(hWndTB, NULL, TRUE);<BR>        UpdateWindow(hWndTB);<BR>        }<BR><BR>    m_fOurToolsShowing=fShow;<BR>    return;<BR>    }<BR><BR><BR>void CPatronFrame::ReinstateUI(void)<BR>    {<BR>    BORDERWIDTHS    bw;<BR><BR>    ShowUIAndTools(TRUE, TRUE);<BR>    SetRect((LPRECT)&amp;bw, 0, m_cyBar, 0, 0,);<BR>    SetBorderSpace(&amp;bw);<BR>    return;<BR>    }</code></pre>
<P>These functions are then used within <I>IOleInPlaceSite::OnUIActivate </I>and <I>IOleInPlaceSite::OnUIDeactivate</I>,<I> </I>which themselves involve a number of Patron's functions. The code is rather lengthy, so here's a description of the process instead:</P>
<UL><LI>When the user clicks or double-clicks on a tenant other than the UI-active one, we end up in <I>CTenant::Select. </I>This calls <I>CTenant::DeactivateInPlaceObject</I>, which we've already seen. No matter what type of object is in the tenant, we'll at least deactivate its UI.</LI><LI>UI deactivation calls <I>IOleInPlaceSite::OnUIDeactivate</I>,<I> </I>which returns immediately if the variable <I>g</I><I>_</I><I>fSwitchingActive </I>is TRUE. (See below.) If we're also shutting down the object, we call <I>CPatronFrame::ReinstateUI </I>and we've finished.</LI><LI>Otherwise, <I>IOleInPlaceSite::OnUIDeactivate</I> checks whether there's a double-click message in the message queue (calling <I>PeekMessage</I>). If not, it calls <I>CPatronFrame::ReinstateUI </I>and we've finished as usual. Also, because the user might have double-clicked on another in-place–capable object, we defer changing the UI by setting the variable <I>CPages::m</I><I>_</I><I>fAddUI</I>.</LI><LI>If another object becomes UI active in response to this double click, we end up in <I>IOleInPlaceSite::OnUIActivate</I>. This first sets <I>CPages::m</I><I>_</I><I>fAddUI </I>to FALSE because <I>CPage::OnLeftDoubleClick </I>will check this flag later, and if it is still TRUE, <I>CPage::OnLeftDoubleClick</I> will, only then, call <I>CPatronFrame::ShowUIAndTools</I> to reinstall Patron's normal user interface. By setting the flag to FALSE here, we avoid Patron changing any of the frame UI itself, leaving that to the newly activated object.</LI><LI><I>IOleInPlaceSite::OnUIActivate </I>then calls <I>CPage::SwitchActiveTenant </I>to change the selected tenant without trying to deactivate the previously selected tenant again—it has already been deactivated. While this is going on, <I>g</I><I>_</I><I>fSwitchingActive </I>is set to TRUE.</LI><LI><I>IOleInPlaceSite::OnUIActivate </I>calls <I>CPatronDoc::NoObjectFrameTools </I>to determine whether there are any other object's tools visible at this time. It then passes the result (TRUE if there are no tools) to <I>CPatronFrame::ShowUIAndTools</I>, with the second argument set to FALSE (so as not to affect the menu). So, if no object tools are visible, the frame will now show its own. This handles the case in which we did indeed activate a new object, but that new object has no tools itself, so we need to display the container's.</LI></UL><P>I admit that this isn't perfect. For one thing, it's single-threaded because we make use of a global variable. Second, the check for a double click doesn't include a check for a single click on an inside-out object. You would still see some flicker in that circumstance. Finally, this code uses functions and variables in almost every internal object inside Patron: <I>CPatronFrame</I>,<I> CPatronDoc</I>,<I> CPage</I>,<I> CPages</I>, and <I>CTenan</I><I>t</I>. Not the cleanest model because such optimizations were an afterthought and had to deal with the existing structures and the permissions each had to access the other. Certainly this could stand improvement, but I hope it will give you a good idea of what is needed to support these optimizations.</P>
<H4><A NAME="sec6"></A>Testing It All</H4><P>It's a good idea to stop here and test everything you've done by using a few different in-place–capable objects. Check that all the menus, toolbars, and other user interface elements show up correctly and that you can keep those objects fixed when shifting around the tools. A good test to see whether you've repositioned windows correctly is to drag a document window (assuming an MDI container) around and watch where the mouse is allowed to go. If you resized your client-area window to not overlap any of the object's tools, the mouse will be restricted to the visible client area. Otherwise, you'll see that you can move the mouse into the area occupied by tools and leave the document window there, perhaps with its caption bar completely hidden!</P>
<P>Also try resizing the frame window to be sure that the client is still resized properly by using the same test. You will notice after resizing the frame (or the document) that the object's tools are not resized to match. That's some of the polish we'll add in the section "Round the Corners: Other Miscellany" later in this chapter. But first let's handle accelerators.</P></font></body></HTML>
