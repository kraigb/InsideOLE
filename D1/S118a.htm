<HTML><HEAD><TITLE>Stream Objects and the IStream Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Stream Objects and the <I>IStream</I> Interface</H3><P>As we've seen already, in Structured Storage a stream is the equivalent of a file in which you can store any bits you want. Like a file, a stream maintains its own seek pointer. But instead of reading and writing through a file handle, you work with an <I>IStream </I>interface pointer, as described in Table 7-2. Through this pointer, a client always views the stream as a contiguous byte array; the actual data, however, might be spread around within the storage medium.</P>
<P>The <I>SetSize </I>function is included in <I>IStream </I>as an optimization allowing a client to preallocate space in the stream. Usually a stream will allocate more space if a <I>Write </I>operation extends past the current end of the stream. However, this allocation might fail, so <I>SetSize </I>allows the client to preallocate space and handle errors outside the process of writing data. Note, however, that <I>SetSize</I>, like the <I>CopyTo </I>function, is often slow. (<I>CopyTo</I>, for example, has to deal with potentially overlapping streams.) In contrast, the most common operations—performed by <I>Read</I>, <I>Write</I>, and <I>Seek</I>—are usually optimized as much as possible to provide the best performance most of the time.</P>
<P>As shown in Table 7-2, many stream functions equate to existing file functions. The practical upshot of this is that most code written to use files through <I>_</I><I>lread</I> and <I>_</I><I>lwrite</I> are easily rewritten to work with <I>IStream::Read </I>and <I>IStream::Write.</I> Streams also have the same access rights as files do (read-only, read/write, share-exclusive, and so forth), as well as their own seek pointer. One advantage of a stream over a file, however, is that you can open as many streams as you want without hogging a lot of file handles: only the root storage of a structured storage file requires a file handle—everything else is simply a memory structure. Because of this efficiency, you might find many new ways in which multiple streams can improve an application's storage architecture that were simply too expensive with file handles.</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="147pt" VALIGN="TOP"><COL WIDTH="92pt" VALIGN="TOP"><COL WIDTH="147pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Istream<BR>Member</B></P></TD><TD VALIGN="TOP"><P><B>File Equivalent*</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P><I>Release </I>(last reference count only)</P></TD><TD VALIGN="TOP"><P><I>_</I><I>lclose</I></P></TD><TD VALIGN="TOP"><P>Closes the stream, discarding changes if the stream is transacted (equivalent of<I> Revert</I>).</P></TD></TR><TR><TD VALIGN="TOP"><P>Read</P></TD><TD VALIGN="TOP"><P><I>_</I><I>lread</I></P></TD><TD VALIGN="TOP"><P>Reads into memory a given number of bytes from the current seek offset.</P></TD></TR><TR><TD VALIGN="TOP"><P>Write</P></TD><TD VALIGN="TOP"><P><I>_</I><I>lwrite</I></P></TD><TD VALIGN="TOP"><P>Writes a number of bytes from memory to the stream, starting at the current seek offset.</P></TD></TR><TR><TD VALIGN="TOP"><P>Seek</P></TD><TD VALIGN="TOP"><P><I>_</I><I>llseek</I></P></TD><TD VALIGN="TOP"><P>Moves the seek offset to a new position from the beginning of the stream, from the end of the stream, or from the current position.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetSize</P></TD><TD VALIGN="TOP"><P><I>_</I><I>chsize</I></P></TD><TD VALIGN="TOP"><P>Preallocates space for the stream but does not preclude writing outside that stream. (See the discussion that follows.)</P></TD></TR><TR><TD VALIGN="TOP"><P>CopyTo</P></TD><TD VALIGN="TOP"><P><I>memcpy</I></P></TD><TD VALIGN="TOP"><P>Copies the number of bytes from the current seek offset in the stream either to the current seek offset in another stream or to the one in a clone of the same stream.</P></TD></TR><TR><TD VALIGN="TOP"><P>Commit</P></TD><TD VALIGN="TOP"><P>(none)</P></TD><TD VALIGN="TOP"><P>Publishes all changes to the parent storage and flushes all internal buffers.</P></TD></TR><TR><TD VALIGN="TOP"><P>Revert</P></TD><TD VALIGN="TOP"><P>(none)</P></TD><TD VALIGN="TOP"><P>Discards any changes made to a transacted stream since the last <I>Commit</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>LockRegion</P></TD><TD VALIGN="TOP"><P><I>_</I><I>locking</I></P></TD><TD VALIGN="TOP"><P>Restricts access to a byte range in the stream instead of the stream as a whole.</P></TD></TR><TR><TD VALIGN="TOP"><P>UnlockRegion</P></TD><TD VALIGN="TOP"><P><I>_</I><I>locking</I></P></TD><TD VALIGN="TOP"><P>Frees restrictions set with <I>LockRegion</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P>Stat</P></TD><TD VALIGN="TOP"><P><I>_</I><I>stat</I></P></TD><TD VALIGN="TOP"><P>Retrieves a STATSTG structure describing stream statistics and attributes.</P></TD></TR><TR><TD VALIGN="TOP"><P>Clone</P></TD><TD VALIGN="TOP"><P><I>_</I><I>dup</I></P></TD><TD VALIGN="TOP"><P>Creates a new stream object that works with the same actual bytes but manages an independent seek offset. This allows you to access different parts of the same stream with multiple clones rather than work with a single seek offset.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>*  Both Windows API and C run-time functions are shown here.</P>
<P><B>Table 7-2. </B></P>
<P><B>The <I>IStream</I> interface.</B></P>
<P>You will notice that <I>IStream</I>, unlike <I>IStorage</I>, has no functions to deal with any other structure within the stream: <I>Read </I>and <I>Write </I>simply expose a byte array. To obtain a pointer to a stream within a storage hierarchy, you call either <I>IStorage::CreateStream </I>or <I>IStorage::OpenStream</I>; the stream always ends a branch in the hierarchy.</P>
<H4><A NAME="sec0"></A>Streams on Memory</H4><P>As we saw in the discussion of custom marshaling in Chapter 6, OLE provides a stand-alone stream object that works on a piece of global memory. The function <I>CreateStreamOnHGlobal</I> will construct such a stream on any memory block you give it, returning an <I>IStream </I>pointer that you can use in the same way as an <I>IStream </I>pointer in some other storage hierarchy. Memory streams can be extremely useful for tasks such as making a memory snapshot of a stream within a storage hierarchy. In other cases, it is convenient to work with memory through an <I>IStream </I>pointer instead of through a <I>BYTE</I> * pointer—a stream is a higher-level abstraction than an array of bytes.</P>
<P><I>CreateStreamOnHGlobal </I>takes a Boolean argument indicating whether the stream is to take control of the underlying memory such that the last <I>IStream::Release </I>call will free the memory in addition to freeing the stream itself. This means that the client of a memory stream needs only to hold an <I>IStream </I>pointer instead of the pointer and the HGLOBAL underneath it. In other words, the following code has no memory leaks because <I>GlobalFree </I>is contained inside <I>IStream::Release</I>:</P>
<P><BR></P>
<pre><code>IStream    *pIStream;<BR>HGLOBAL     hMem;<BR><BR>hMem=GlobalAlloc(...);<BR>CreateIStreamOnHGlobal(hMem, &amp;pIStream, TRUE);<BR>[Use stream as long as necessary.]<BR>pIStream-&gt;Release();   //Memory freed.</code></pre>
<P>The function <I>GetHGlobalFromStream </I>exists in case you need to retrieve the memory handle from the stream at some later time. Even if the client retains control of the memory, it still doesn't have to hold the handle itself: the stream holds the handle regardless of ownership.</P>
<H4><A NAME="sec1"></A>Streams on Existing Files</H4><P>Because streams and files are so close in nature, it seems natural that you should be able to create a stream object that accesses a file through <I>IStream </I>instead of through a file handle. OLE doesn't currently provide a simple API function for this exact purpose, although for small files you can easily load the file into memory and create a stream on that memory.</P>
<P>Structured Storage does, however, define a special access mode that allows a client to open an existing file as if it were a root storage, and the contents of the existing file are exposed through a stream named CONTENTS (big surprise). So while you can't simply open a stream on top of a file, you can open a root storage and then open a stream.</P></font></body></HTML>
