<HTML><HEAD><TITLE>The Custom Marshaling Object: EKoala5</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Custom Marshaling Object: EKoala5</H3><P>The EKoala4 sample that worked with custom interfaces and standard marshaling actually implemented all of the entry points for each interface member function. In EKoala5, with custom marshaling, these entry points are no longer necessary: calls from the client process come into a window procedure because that's the communication channel between the processes. The Koala object (KOALA.CPP) in this sample implements only one interface: <I>IMarshal </I>(which includes <I>IUnknown</I>). In addition, it creates a window for itself inside its <I>CKoala::Init </I>function (called from EKoala5's <I>IClassFactory::CreateInstance</I>). The Koala object eventually passes the handle to this window to the proxy in a marshaling packet:</P>
<P><BR></P>
<pre><code>BOOL CKoala::Init(HINSTANCE hInst, HWND hWndParent)<BR>    {<BR>    m_hWnd=CreateWindow(TEXT("KoalaObject"), TEXT("KoalaObject")<BR>        , WS_CHILD, 35, 35, 35, 25, hWndParent, NULL<BR>        , hInst, this);<BR><BR>    if (NULL==m_hWnd)<BR>        return FALSE;<BR><BR>    return TRUE;<BR>    }</code></pre>
<P>By the time <I>IClassFactory::CreateInstance </I>returns an interface pointer to this Koala object, the object will have created a window for itself. (EKoala5's initialization code, <I>CApp::Init</I>, registers the KoalaObject window class.)</P>
<P>Now COM's <I>IClassFactory </I>stublet knows that it has to create a new stub for this object unless that object supports custom marshaling. The stublet calls <I>CoMarshalInterface </I>to do the honors, which in turn queries for <I>IMarshal</I> and, finding it, calls <I>IMarshal::GetMarshalSizeMax</I>. To make a connection with its proxy, the Koala object knows that it needs to send the proxy only its window handle, which thus forms the entire contents of the marshaling packet for which the Koala object defines this structure:</P>
<P><BR></P>
<pre><code>typedef struct<BR>    {<BR>    HWND        hWnd;       //Message window<BR>    } KOALAMARSHAL, *PKOALAMARSHAL;</code></pre>
<P>The implementation of <I>GetMarshalSizeMax</I> merely returns the size of this structure:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CKoala::GetMarshalSizeMax(REFIID riid, LPVOID pv<BR>    , DWORD dwDestCtx, LPVOID pvDestCtx, DWORD dwFlags<BR>    , LPDWORD pdwSize)<BR>    {<BR>    if (dwDestCtx &amp; MSHCTX_DIFFERENTMACHINE)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    *pdwSize=sizeof(KOALAMARSHAL);<BR>    return NOERROR;<BR>    }</code></pre>
<P>Notice how we check the marshaling context in use here for MSHCTX_DIFFERENTMACHINE. Because we know that we use a window handle for communication, a machine boundary disallows our custom marshaling, so we fail this call. This tells <I>CoMarshalInterface </I>to fail, so <I>CreateInstance </I>will also fail: marshaling simply isn't available in such a case.</P>
<P>Assuming that we're on the same machine, <I>GetMarshalSizeMax </I>then returns the size of the KOALAMARSHAL structure. <I>CoMarshalInterface </I>creates the marshaling packet stream and calls our <I>IMarshal::GetUnmarshalClass</I>, where we return the proxy CLSID:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CKoala::GetUnmarshalClass(REFIID riid<BR>    , LPVOID pv, DWORD dwCtx, LPVOID pvCtx, DWORD dwFlags<BR>    , LPCLSID pClsID)<BR>    {<BR>    /*<BR>     * If context is on different machine, we cannot use<BR>     * our custom marshaling based on SendMessage.<BR>     */<BR>    if (dwCtx &amp; MSHCTX_DIFFERENTMACHINE)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    //Same proxy for all interfaces<BR>    *pClsID=CLSID_KoalaProxy;<BR>    return NOERROR;<BR>    }</code></pre>
<P>Then <I>CoMarshalInterface </I>calls our <I>IMarshal::MarshalInterface</I> function, in which we create our marshaling packet structure and write it into the stream:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CKoala::MarshalInterface(LPSTREAM pstm<BR>    , REFIID riid, LPVOID pv, DWORD dwDestCtx, LPVOID pvDestCtx<BR>    , DWORD dwFlags)<BR>    {<BR>    KOALAMARSHAL        km;<BR><BR>    if (dwDestCtx &amp; MSHCTX_DIFFERENTMACHINE)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    //Proxy needs to know only where to send messages.<BR>    km.hWnd=m_hWnd;<BR><BR>    //This is for the client that will call Release when needed.<BR>    AddRef();<BR><BR>    //Write marshaling packet to stream.<BR>    return pstm-&gt;Write((void *)&amp;km, sizeof(KOALAMARSHAL), NULL);<BR>    }</code></pre>
<P>Nothing fancy is going on here except the extra <I>AddRef </I>call, which is really quite necessary because there is no stub that actually holds a reference to the Koala object itself. Usually a stub will maintain a reference count for an object, but with custom marshaling there is no stub. Therefore, the Koala object holds a reference count on itself, which its proxy actually controls. In other words, the object and the proxy have an unwritten agreement that the proxy will not send a <I>Release </I>call until the client has released the proxy for the final time. We'll see shortly where Koala makes the <I>Release </I>call that reverses this <I>AddRef</I>.</P>
<P>Once we return from <I>MarshalInterface</I>,<I> </I>COM has all the information it needs to create the proxy in the client process, and all we do now is wait for WM_COMMAND messages, which are handled in <I>CKoala::HandleCall</I>, to show up in the object's window procedure:</P>
<P><BR></P>
<pre><code>DWORD CKoala::HandleCall(UINT iMsg, LPARAM lParam)<BR>    {<BR>    DWORD       dw;<BR>    short       iRet=0;<BR><BR>    switch (iMsg)<BR>        {<BR>        case MSG_RELEASE:          //Last IUnknown::Release<BR>            Release();<BR>            break;<BR><BR>        case MSG_EAT:<BR>            m_fJustAte=TRUE;<BR>            break;<BR><BR>        case MSG_SLEEP:            //IAnimal::Sleep<BR>            //Client's in-parameter in LOWORD(lParam)<BR>            iRet=LOWORD(lParam)+m_cSleepAfterEat;<BR>            m_fJustAte=FALSE;      //Probably want to eat again.<BR>            break;<BR><BR>        case MSG_PROCREATE:        //IAnimal::Procreate<BR>            dw=GetTickCount()/100;<BR><BR>            iRet=((dw/10)*10==dw) ? 1 : 0;<BR>            break;<BR><BR>        case MSG_SLEEPAFTEREATING: //IKoala::SleepAfterEating<BR>            m_cSleepAfterEat=LOWORD(lParam);<BR>            break;<BR><BR>        default:<BR>            break;<BR>        }<BR><BR>    return iRet;<BR>    }</code></pre>
<P>The <I>HandleCall </I>function actually contains the entire implementation of the object's member functions that are not otherwise handled in the proxy. Most of the code you see in each message case is what the Koala object in EKoala4 had in its individual interface member functions. From this, you can thus see how custom marshaling allows you to put this code wherever is most convenient for your implementation.</P>
<P>Notice that the MSG_RELEASE case contains the <I>Release </I>call to match the <I>AddRef </I>call we made in <I>IMarshal::MarshalInterface</I>. This is how the proxy effectively calls <I>Release</I>, illustrating why we had to call <I>AddRef </I>on ourselves in the first place.</P>
<P>The final point to make about this custom marshaling Koala is that it doesn't do anything in the other <I>IMarshal </I>member functions. Specifically, <I>Disconnect </I>is never called because EKoala5 never calls <I>CoDisconnectObject</I>,<I> </I>and COM never calls <I>UnmarshalInterface </I>or <I>ReleaseMarshalData </I>because they have meaning only for the client-side proxy. To see the corresponding implementation of these functions, we examine the sources for KOALAPRX.DLL.</P></font></body></HTML>
