<HTML><HEAD><TITLE>Variation II: Exploit Your Type Information</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Variation II: Exploit Your Type Information</H3><P>There has just got to be an easier way to implement <I>IDispatch::GetIDsOfNames</I> and <I>Invoke</I>, right? The amount of code shown in Variation I for just one property and one method is obnoxious enough—now imagine a complex object with 30 methods and 50 properties! If you don't like 300-page switch statements, it's time to create a type library. In Beeper2 (CHAP14\BEEPER2), the files BEEP0000.ODL and BEEP0007.ODL describe the object's dispinterface in English and German, through use of an interface description. Here's the core of BEEP0000.ODL. (BEEP0007.ODL uses German strings.)</P>
<P><BR></P>
<pre><code>[attributes]<BR>library BeeperTypeLibrary<BR>    {<BR>    §<BR><BR>    [attributes]<BR>    interface IBeeper : IUnknown<BR>        {<BR>        //Properties<BR>        [propget, helpstring("The current sound")]<BR>            long Sound(void);<BR><BR>        [propput]<BR>            void Sound([in] long lSound);<BR><BR>        //Methods<BR>        [helpstring("Play the current sound")]<BR>            long Beep(void);<BR>        }<BR><BR>    [attributes]<BR>    dispinterface DIBeeper<BR>        {<BR>        interface   IBeeper;<BR>        }<BR><BR>    §<BR>    }</code></pre>
<P>In the ODL files, we define the object class, <I>CLSID</I><I>_</I><I>Beeper</I>, as implementing the dispinterface <I>DIBeeper</I> and the interface <I>IBeeper</I>. <I>DIBeeper</I> is defined as a dispinterface that obtains its methods and properties from <I>IBeeper</I>. <I>IBeeper</I> is defined as having a <I>Sound</I> (<I>Ton</I>) property and a <I>Beep</I> (<I>Piep</I>) method. The same property name is listed twice: once with <I>propget</I> and once with <I>propput</I>.</P>
<P>To see why we're doing this, let's look at what happens when we run the MKTYPLIB tool (described in Chapter 3) on one of these ODL files.</P>
<H4><A NAME="sec0"></A>MKTYPLIB and Generated Headers</H4><P>The most common command line for MKTYPLIB, which is used in the samples for this chapter, is as follows:</P>
<P><BR></P>
<pre><code>mktyplib /h &lt;header&gt;.H /l &lt;errors&gt;.LOG /o &lt;library&gt;.TLB &lt;file&gt;.ODL</code></pre>
<P>You'll find the batch file MAKELIB in the BUILD directory of the sample code. MAKELIB lets you generate a header, a log, and a type library from a given ODL file; the files created will have the same name as the ODL file.</P>
<P>When you build Beeper2, its make file calls MKTYPLIB for BEEP0000.ODL with a special command-line switch, <I>/h ibeeper.h</I>, which instructs MKTYPLIB to create that header file.8 The IBEEPER.H output from compiling BEEP0000.ODL is shown in Listing 14-1 beginning on the following page. (This is a built file, so you won't find it on the companion CD until you've actually built Beeper2.) Because the ODL files define an <I>interface</I> and a <I>dispinterface</I>, the header ends up with two interface definitions. In addition, MKTYPLIB automatically turns whatever <I>uuid</I> attributes you defined into DECLARE_GUID statements so that you don't have to define them elsewhere.9</P>
<H5><A NAME="sec1"></A>IBEEPER.H</H5><P><BR></P>
<pre><code>/* This header file machine-generated by mktyplib.exe */<BR>/* Interface to type library: BeeperTypeLibrary */<BR><BR>#ifndef _BeeperTypeLibrary_H_<BR>#define _BeeperTypeLibrary_H_<BR><BR>DEFINE_GUID(LIBID_BeeperTypeLibrary,0x0002115E,0x0000,0x0000,0xC0<BR>    ,0x00,0x00,0x00,0x00,0x00,0x00,0x46);<BR><BR>DEFINE_GUID(IID_IBeeper,0x0002115C,0x0000,0x0000,0xC0,0x00,0x00<BR>    ,0x00,0x00,0x00,0x00,0x46);<BR><BR>/* Definition of interface: IBeeper */<BR>DECLARE_INTERFACE_(IBeeper, IUnknown)<BR>{<BR>#ifndef NO_BASEINTERFACE_FUNCS<BR><BR>    /* IUnknown methods */<BR>    STDMETHOD(QueryInterface)(THIS_ REFIID riid,<BR>        LPVOID FAR* ppvObj) PURE;<BR>    STDMETHOD_(ULONG, AddRef)(THIS) PURE;<BR>    STDMETHOD_(ULONG, Release)(THIS) PURE;<BR>#endif<BR><BR>    /* IBeeper methods */<BR>    STDMETHOD_(long, get_Sound)(THIS) PURE;<BR>    STDMETHOD_(void, put_Sound)(THIS_ long lSound) PURE;<BR>    STDMETHOD_(long, Beep)(THIS) PURE;<BR>};<BR><BR>DEFINE_GUID(DIID_DIBeeper,0x0002115D,0x0000,0x0000,0xC0,0x00<BR>    ,0x00,0x00,0x00,0x00,0x00,0x46);<BR><BR>/* Definition of dispatch interface: DIBeeper */<BR>DECLARE_INTERFACE_(DIBeeper, IDispatch)<BR>{<BR>#ifndef NO_BASEINTERFACE_FUNCS<BR><BR>    /* IUnknown methods */<BR>    STDMETHOD(QueryInterface)(THIS_ REFIID riid<BR>        , LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;<BR>    STDMETHOD_(ULONG, Release)(THIS) PURE;<BR><BR>    /* IDispatch methods */<BR>    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;<BR><BR>    STDMETHOD(GetTypeInfo)(<BR>      THIS_<BR>      UINT itinfo,<BR>      LCID lcid,<BR>      ITypeInfo FAR* FAR* pptinfo) PURE;<BR><BR>    STDMETHOD(GetIDsOfNames)(<BR>      THIS_<BR>      REFIID riid,<BR>      OLECHAR FAR* FAR* rgszNames,<BR>      UINT cNames,<BR>      LCID lcid,<BR>      DISPID FAR* rgdispid) PURE;<BR><BR>    STDMETHOD(Invoke)(<BR>      THIS_<BR>      DISPID dispidMember,<BR>      REFIID riid,<BR>      LCID lcid,<BR>      WORD wFlags,<BR>      DISPPARAMS FAR* pdispparams,<BR>      VARIANT FAR* pvarResult,<BR>      EXCEPINFO FAR* pexcepinfo,<BR>      UINT FAR* puArgErr) PURE;<BR>#endif<BR><BR>/* Capable of dispatching all methods of interface IBeeper */<BR>};<BR><BR>DEFINE_GUID(CLSID_Beeper,0x0002115B,0x0000,0x0000,0xC0,0x00,0x00<BR>    ,0x00,0x00,0x00,0x00,0x46);<BR><BR>class Beeper;<BR><BR>#endif</code></pre>
<P><B>Listing 14-1</B></P>
<P><B>MKTYPLIB-generated header file from BEEP0000.ODL.</B></P>
<P>What we now have in the IBEEPER.H file is the definition of a dispinterface that is nothing more than <I>IDispatch</I> and the definition of a custom interface, <I>IBeeper</I>, which inherits from <I>IUnknown</I>. The functions in <I>IBeeper</I>, however, are a bit odd: where did those <I>get</I><I>_</I> and <I>put</I><I>_</I> prefixes come from? In the ODL file, the definition of <I>IBeeper</I> listed the <I>Sound</I> function twice: one had the <I>propget</I> attribute, and the other, <I>propput</I>. MKTYPLIB uses these attributes to prepend <I>get</I><I>_</I> or <I>put</I><I>_</I> to the function name to avoid name conflicts. Method names, of course, need no munging.</P>
<P>But now that we have this custom interface, what are we supposed to do with it? The answer requires that we first look at how we actually get our type information into memory and then look at some of the powerful benefits of OLE's <I>ITypeInfo</I> implementation.</P>
<H4><A NAME="sec2"></A>Load Your Type Information</H4><P>We now have type information, so we can implement <I>IDispatch::GetTypeInfoCount</I> and <I>IDispatch::GetTypeInfo</I>, as shown in Beeper2's BEEPER.CPP file:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)<BR>    {<BR>    //We implement GetTypeInfo, so return 1.<BR>    *pctInfo=1;<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid<BR>    , ITypeInfo **ppITypeInfo)<BR>    {<BR>    HRESULT     hr;<BR>    ITypeLib   *pITypeLib;<BR>    ITypeInfo **ppITI=NULL;<BR><BR>    if (0!=itInfo)<BR>        return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);<BR><BR>    if (NULL==ppITypeInfo)<BR>        return ResultFromScode(E_POINTER);<BR><BR>    *ppITypeInfo=NULL;<BR><BR>    switch (PRIMARYLANGID(lcid))<BR>        {<BR>        case LANG_NEUTRAL:<BR>        case LANG_ENGLISH:<BR>            ppITI=&amp;m_pITINeutral;<BR>            break;<BR><BR>        case LANG_GERMAN:<BR>            ppITI=&amp;m_pITIGerman;<BR>            break;<BR><BR>        default:<BR>            return ResultFromScode(DISP_E_UNKNOWNLCID);<BR>        }<BR><BR>    //Load a type lib if we don't have information already.<BR>    if (NULL==*ppITI)<BR>        {<BR>        hr=LoadRegTypeLib(LIBID_BeeperTypeLibrary, 1, 0<BR>            , PRIMARYLANGID(lcid), &amp;pITypeLib);<BR><BR>        if (FAILED(hr))<BR>            {<BR>            switch (PRIMARYLANGID(lcid))<BR>                {<BR>                case LANG_NEUTRAL:<BR>                case LANG_ENGLISH:<BR>                    hr=LoadTypeLib(OLETEXT("BEEP0000.TLB"), &amp;pITypeLib);<BR>                    break;<BR><BR>                case LANG_GERMAN:<BR>                    hr=LoadTypeLib(OLETEXT("BEEP0007.TLB"), &amp;pITypeLib);<BR>                    break;<BR>                }<BR>            }<BR><BR>        if (FAILED(hr))<BR>            return hr;<BR><BR>        hr=pITypeLib-&gt;GetTypeInfoOfGuid(DIID_DIBeeper, ppITI);<BR>        pITypeLib-&gt;Release();<BR><BR>        if (FAILED(hr))<BR>            return hr;<BR>        }<BR><BR>    (*ppITI)-&gt;AddRef();<BR>    *ppITypeInfo=*ppITI;<BR>    return NOERROR;<BR>    }</code></pre>
<P>This code is perhaps more convoluted than it really needs to be. It is written so that after we've loaded our type information once, we never have to load it again for this instance of the object. The <I>CImpIDispatch</I> class in Beeper2 (BEEPER.H) maintains two <I>ITypeInfo</I> pointers in <I>m</I><I>_</I><I>pITINeutral</I> and <I>m</I><I>_</I><I>pITIGerman</I>. The <I>switch</I> statement in <I>GetTypeInfo</I> is used to set <I>ppITI</I> to the appropriate <I>CImpIDispatch</I> variable (depending on the language), and if that variable is NULL, we have to load the type library.</P>
<P>The easiest way to load a type library is to call <I>LoadRegTypeLib</I>, which looks for the LIBID you specify under the TypeLib key in the registry and tries to find an LIBID that matches the version number (in our case, 1.0) and the LANGID you specify (9 for English or 7 for German). It also attempts to load the type library listed for either Win16 or Win32 (as appropriate for the environment). If the file listed is a TLB file, <I>LoadRegTypeLib</I> loads it directly. If an EXE10 or a DLL is listed, it extracts the file from that module's resources. Failing that, it attempts to open the file as a compound file and extract the type library from the "\006typelib" stream. In addition, <I>LoadRegTypeLib</I> first looks for an exact match to the LANGID you pass. If that fails, it looks for a match with only the primary LANGID (which we're starting with immediately in this code). If that fails, it looks for LANGID_NEUTRAL (0) as a last resort.</P>
<P>If <I>LoadRegTypeLib</I> does fail, we try to load our TLB files directly with <I>LoadTypeLib</I> as a backup. This function tries to locate the given type library file in the registered DIR key that you place under your type library registration alongside HELPDIR. (See Chapter 3 for a review.)</P>
<P>If <I>LoadTypeLib</I> loads a type library successfully, it automatically creates the proper registry entries for the type library. This is the other reason that using <I>LoadTypeLib</I> as a backup to <I>LoadRegTypeLib</I> is good practice. If we ever get to <I>LoadTypeLib</I>, the next call to <I>LoadRegTypeLib</I> will work.</P>
<P>After we load the type library, we have an <I>ITypeLib</I> pointer. That's not, however, what we need to return from <I>IDispatch::GetTypeInfo</I>; we need instead an <I>ITypeInfo</I> pointer that describes our dispinterface. To get this, we must call <I>ITypeLib::GetTypeInfoOfGUID</I> passing <I>DIID</I><I>_</I><I>DIBeeper</I>, the IID of our dispinterface. This returns the <I>ITypeInfo</I>, which we save in our own <I>m</I><I>_</I><I>pITI</I>* variable (and, therefore, we call <I>AddRef</I>) and return to the controller. Even though we call <I>ITypeLib::Release</I>, the type library is still loaded because we have an <I>ITypeInfo</I> pointer to the same structure; therefore, we don't need to worry about reloading it later.</P>
<H4><A NAME="sec3"></A>Your Friend: <I>ITypeInfo</I></H4><P>After you retrieve an <I>ITypeInfo</I> pointer for your dispinterface's type information, the implementation of <I>IDispatch::GetIDsOfNames</I> becomes considerably easier. Take a look at Beeper2's <I>GetIDsOfNames</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid<BR>    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)<BR>    {<BR>    HRESULT     hr;<BR>    ITypeInfo  *pTI;<BR><BR>    if (IID_NULL!=riid)<BR>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);<BR><BR>    hr=GetTypeInfo(0, lcid, &amp;pTI);<BR><BR>    if (SUCCEEDED(hr))<BR>        {<BR>        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);<BR>        pTI-&gt;Release();<BR>        }<BR><BR>    return hr;<BR>    }</code></pre>
<P>What happened to matching strings to dispIDs? All that information is contained within our type information, and because we have an <I>ITypeInfo</I> pointer to that information (which <I>GetIDsOfNames</I> obtains from <I>GetTypeInfo</I> in the same <I>IDispatch</I>), we can actually ask <I>ITypeInfo</I> to do all the work for us. The OLE API function <I>DispGetIDsOfNames</I> takes an <I>ITypeInfo</I> pointer and the rest of the <I>GetIDsOfNames</I> parameters and performs all the necessary mapping. <I>DispGet</I><I>IDsOfNames</I> is, however, nothing more than a trivial wrapper around <I>ITypeInfo::GetIDsOfNames</I>:</P>
<P><BR></P>
<pre><code>STDAPI DispGetIDsOfNames(ITypeInfo FAR* ptinfo<BR>    , OLECHAR FAR* FAR* rgszNames, unsigned int cNames<BR>    , DISPID FAR* rgdispid)<BR>    {<BR>    return ptinfo-&gt;GetIDsOfNames(rgszNames, cNames, rgdispid);<BR>    }</code></pre>
<P>You could simply call the <I>ITypeInfo</I> function directly and skip the overhead if you wanted. Internally, <I>ITypeInfo</I> uses its own member functions to extract the names and attributes of the properties, methods, and arguments in the dispinterface, matching names to <I>id</I> values. It's very similar to what we did in Beeper1's manual implementation.</P>
<H4><A NAME="sec4"></A><I>ITypeInfo</I> and Your Custom Interface</H4><P>If <I>ITypeInfo::GetIDsOfNames</I> can do so much for name mapping, can it do as much for our implementation of <I>Invoke</I>? Absolutely. In fact, in the implementation of <I>Invoke</I> in Beeper1, almost all of the type coercion and argument extraction is generic enough that a central piece of code could perform those steps based on the type information. What a generic function such as <I>GetIDsOfNames</I> cannot do, of course, is interpret what to do with the properties and methods. Somehow we have to break out the specific dispinterface code from <I>Invoke</I> and structure it so that a central piece of type manipulation code can call it when necessary.</P>
<P>This is the reason why the header file generated by MKTYPLIB defined a custom interface—in our case, <I>IBeeper</I>. This interface describes <I>exactly</I> those operations that are specific to the dispinterface. Beeper2's definition of <I>CBeeper</I> in BEEPER.H actually inherits from the <I>IBeeper</I> interface in IBEEPER.H, and <I>CBeeper</I>'s <I>QueryInterface</I> also responds to <I>IID</I><I>_</I><I>IBeeper</I> as well as <I>DIID</I><I>_</I><I>DIBeeper.</I> The implementation of the <I>get</I><I>_</I><I>Sound</I>, <I>put</I><I>_</I><I>Sound</I>, and <I>Beep</I> functions is found in BEEPER.CPP:</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(long) CBeeper::get_Sound(void)<BR>    {<BR>    return m_lSound;<BR>    }<BR><BR>STDMETHODIMP_(void) CBeeper::put_Sound(long lSound)<BR>    {<BR>    if (MB_OK!=lSound &amp;&amp; MB_ICONEXCLAMATION!=lSound<BR>        &amp;&amp; MB_ICONQUESTION!=lSound &amp;&amp; MB_ICONHAND!=lSound<BR>        &amp;&amp; MB_ICONASTERISK!=lSound)<BR>        {<BR>        m_pImpIDispatch-&gt;Exception(EXCEPTION_INVALIDSOUND);<BR>        return;<BR>        }<BR><BR>    m_lSound=lSound;<BR>    return;<BR>    }<BR><BR>STDMETHODIMP_(long) CBeeper::Beep(void)<BR>    {<BR>    MessageBeep((UINT)m_lSound);<BR>    return m_lSound;<BR>    }</code></pre>
<P>This is fabulous news! These three simple functions are the only object-specific parts of the listing of <I>IDispatch::Invoke</I> that we saw with Beeper1. The rest of it can be handled in a central piece of code. That central piece is <I>ITypeInfo::Invoke</I>, which is trivially wrapped by the OLE API <I>DispInvoke</I>, the same as <I>DispGetIDsOfNames</I>. The question to answer is, how do we tie our custom <I>IBeeper</I> implementation to whatever <I>ITypeInfo::Invoke</I> does for us? To do that, let's look at Beeper2's <I>Invoke</I>:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid<BR>    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams<BR>    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)<BR>    {<BR>    HRESULT     hr;<BR>    ITypeInfo  *pTI;<BR><BR>    if (IID_NULL!=riid)<BR>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);<BR><BR>    hr=GetTypeInfo(0, lcid, &amp;pTI);<BR><BR>    if (FAILED(hr))<BR>        return hr;<BR><BR>    m_wException=EXCEPTION_NONE;<BR><BR>    //This is exactly what DispInvoke does, so skip the overhead.<BR>    hr=pTI-&gt;Invoke((IBeeper *)m_pObj, dispID, wFlags<BR>        , pDispParams, pVarResult, pExcepInfo, puArgErr);<BR><BR>    if (EXCEPTION_NONE!=m_wException)<BR>        {<BR>        pExcepInfo-&gt;scode<BR>            =(SCODE)MAKELONG(m_wException, PRIMARYLANGID(lcid));<BR>        FillException(pExcepInfo);<BR>        hr=ResultFromScode(DISP_E_EXCEPTION);<BR>        }<BR><BR>    pTI-&gt;Release();<BR>    return hr;<BR>    }</code></pre>
<P>As we did for <I>GetIDsOfNames</I>, we use our own <I>GetTypeInfo</I> to retrieve the <I>ITypeInfo</I> pointer we want. When we call <I>ITypeInfo::Invoke</I>, the first argument is a pointer to the custom interface from which the dispinterface was defined. In our case, the <I>m</I><I>_</I><I>pObj</I> variable in <I>CImpIDispatch</I> is a backpointer to <I>CBeeper</I>. Casting it to <I>(IBeeper</I> *<I>)</I> gives us the correct <I>IBeeper</I> vtable pointer. After <I>ITypeInfo::Invoke</I> performs type coercion and argument extraction, it passes the necessary values to the <I>CBeeper</I> members that implement the <I>Sound</I> property and the <I>Beep</I> method.</P>
<P>Personally, I like the services that <I>ITypeInfo</I> provides: they allow you to implement your functionality as a clean custom interface and eliminate the need for all the grungy work of implementing <I>Invoke</I> yourself. Not every implementation of <I>IDispatch</I>, however, will necessarily use <I>ITypeInfo</I>. For example, an event sink that has to respond to an arbitrary event set cannot install a bunch of arbitrary custom interface functions in a vtable at run time simply to get <I>ITypeInfo</I> to invoke those functions. It's much easier to implement the event handling code inside <I>Invoke</I> manually. There are times and places for both Beeper1 and Beeper2 techniques, which is why I've shown each of them in this chapter.</P>
<H4><A NAME="sec5"></A>Exceptions and <I>ITypeInfo::Invoke</I></H4><P>You might have noticed that <I>CBeeper::put</I><I>_</I><I>Sound</I> performs the same argument validation in Beeper2 that it did in Beeper1. In Beeper1, we raised an exception when the wrong value was sent to the <I>Sound</I> property, which was easy because the exception occurred inside <I>Invoke</I>. But <I>CBeeper::put</I><I>_</I><I>Sound</I> doesn't have a direct way to return an exception code—the return value of the function is a <I>void</I>, as is required for a property put function. How, then, can it raise an exception?</P>
<P>In Beeper2, I've added a function named <I>Exception</I> to its <I>CImpIDispatch</I> class and a member variable named <I>m</I><I>_</I><I>wException</I> for the purpose of supporting some kind of exception model that can be used from within the custom interface implementation. Before calling <I>ITypeInfo::Invoke</I>, <I>CImpIDispatch::Invoke</I> clears exceptions by setting <I>m</I><I>_</I><I>wException</I> to EXCEPTION_NONE (0). If a function called from within <I>ITypeInfo::Invoke</I> wants to raise an exception, it calls <I>CImpIDispatch::Exception</I> with the exception code, and <I>Exception</I> just stuffs the exception code into <I>m</I><I>_</I><I>wException</I>. When <I>ITypeInfo::Invoke</I> returns, <I>CImpIDispatch::Invoke</I> checks for a nonzero <I>m</I><I>_</I><I>wException</I>. If <I>CImpIDispatch::Invoke</I> finds one, it calls our old friend <I>FillException</I> (the same function we have in Beeper1, except now we rely on HELPDIR) to fill the EXCEPINFO structure. <I>Invoke</I> then returns DISP_E_EXCEPTION. This type of mechanism is necessary because <I>ITypeInfo::Invoke</I> has no knowledge of the semantics of our dispinterface, only the syntax.</P>
<P>This solution works well only in a single-threaded operating system, however, or, more appropriately, with a single-threaded controller. This is perfectly acceptable for a Microsoft Windows 3.1 target, but it is not acceptable for a Microsoft Windows NT or Microsoft Windows 95 target, which offers preemptive multitasking. To support multiple threads, we have to maintain some sort of exception code inside <I>CImpIDispatch</I> on a per-thread basis. Fortunately, OLE has just the solution—<I>error objects.</I></P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>8 MKTYPLIB is very aggressive when you tell it to create a header with the /h switch: it will overwrite any existing file of that name without warning.</P></TD></TR><TR><TD VALIGN="TOP"><P>9 The central INC\BOOKGUID.H file used for all the samples in this book redundantly defines these same GUIDs for use from samples such as Beeper1 and AutoCli (in Chapter 15) that don't use a MKTYPLIB-generated header. To prevent compiling errors, the GUIDs in BOOKGUID.H are conditionally excluded from compiling if the symbol GUIDS_FROM_TYPELIB is defined. This symbol is specific to these samples—it's not anything you'll find documented, and you'll <BR>see it defined, for example, in Beeper2's BEEPER.H before Beeper2 includes INOLE.H, which in turn includes BOOKGUID.H.</P></TD></TR><TR><TD VALIGN="TOP"><P>10 Prior to OLE 2.02 (September 1994), <I>LoadRegTypeLib</I> doesn't work properly with an EXE.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
