<HTML><HEAD><TITLE>Manage a File Moniker, Call IOleObject::SetMoniker, and Implement IOleClientSite::GetMoniker</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Manage a File Moniker, Call <I>IOleObject::SetMoniker</I>, and Implement <I>IOleClientSite::GetMoniker</I></H3><P>Linked objects always appreciate knowing exactly where they live so they can manage their absolute and relative monikers. The container's part in this is to provide a file moniker for its document through <I>IOleClientSite::GetMoniker</I> and to give all your linked (and embedded) objects that same moniker through <I>IOleObject::SetMoniker. </I>To do this, we first need to create the moniker, which we do in <I>CPatronDoc::Rename</I>.<I> </I>This is called whenever a document is assigned a known filename (loading or saving a file). This function then passes that moniker down to all its tenants through <I>CPages::NotifyTenantsOfRename</I>, which calls <I>CPage::NotifyTenantsOfRename</I>, which calls each tenant's <I>CTenant::NotifyOfRename</I>.<I> </I>(Most of this code was already in place in Chapter 17 for calling <I>IOleObject::SetHostNames</I>; we're now including a moniker.)</P>
<P><BR></P>
<pre><code>//DOCUMENT.CCP<BR>void CPatronDoc::Rename(LPTSTR pszFile)<BR>    {<BR>    LPMONIKER   pmk;<BR><BR>    CDocument::Rename(pszFile);<BR><BR>    //Give a moniker to linked objects in tenants.<BR>    if (NULL!=pszFile)<BR>        {<BR>        CreateFileMoniker(pszFile, &amp;pmk);<BR>        m_pPG-&gt;NotifyTenantsOfRename(pszFile, pmk);<BR><BR>        //No need for us to hold on to this.<BR>        pmk-&gt;Release();<BR>        }<BR><BR>    return;<BR>    }<BR><BR>//TENANT.CPP<BR>void CTenant::NotifyOfRename(LPTSTR pszFile, LPMONIKER pmk)<BR>    {<BR>    [Unmodified code to call IOleObject::SetHostNames]<BR><BR>    §<BR><BR>    if (NULL!=pmk)<BR>        {<BR>        if (NULL!=m_pmkFile)<BR>            m_pmkFile-&gt;Release();<BR><BR>        m_pmkFile=pmk;<BR>        m_pmkFile-&gt;AddRef();<BR><BR>        m_pIOleObject-&gt;SetMoniker(OLEWHICHMK_CONTAINER, pmk);<BR>        }<BR><BR>    return;<BR><BR>    }</code></pre>
<P>Along with the moniker, we pass the flag OLEWHICHMK_CONTAINER (WHICHMK reads as "which moniker") to <I>SetMoniker</I> to identify the moniker as the one naming the container document. Another possibility, which we'll use in Chapter 21, is OLEWHICHMK_OBJFULL. This describes the moniker as naming the object itself within the container document, useful for linking to embeddings.</P>
<P>The container may see some of these same flags in calls to its own <I>IOleClientSite::GetMoniker</I>, which might also include OLEWHICHMK_OBJREL. This asks for a moniker naming the object relative to the document, which is basically OLEWHICHMK_OBJFULL sans OLEWHICHMK_CONTAINER.</P>
<P>A basic linking container needs to handle only the OLEWHICHMK_CONTAINER case in <I>IOleClientSite::GetMoniker </I>for now. This flag supplies the information necessary for the linked object to maintain its relative moniker to the link source:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleClientSite::GetMoniker(DWORD dwAssign<BR>    , DWORD dwWhich, LPMONIKER *ppmk)<BR>    {<BR>    *ppmk=NULL;<BR><BR>    switch (dwWhich)<BR>        {<BR>        case OLEWHICHMK_CONTAINER:<BR>            //This is just the file we're living in.<BR>            if (NULL!=m_pTen-&gt;m_pmkFile)<BR>                *ppmk=m_pTen-&gt;m_pmkFile;<BR><BR>            break;<BR>        }<BR><BR>    if (NULL==*ppmk)<BR>        return ResultFromScode(E_FAIL);<BR><BR>    (*ppmk)-&gt;AddRef();<BR>    return NOERROR;<BR>    }</code></pre>
<P>The other moniker types are important for linking to embedding scenarios that we'll see in Chapter 21. For now, this code allows you to perform an experiment to see how linked objects can track a link source.</P>
<P>First create a file from some server and save it in a subdirectory. Then create a linked object to that source, and save your container document in a subdirectory that shares some elements with the source file but is not in the same directory as the source. If you activate the object now, the server will run appropriately and load the file. No problem.</P>
<P>Now go to another directory or another drive and re-create the same directory structure as the one in which you have the original container and source files. Copy the container document and the link-source files here, and then delete the original files so that any absolute pathnames in any file monikers are now invalid. Now run your container again, reload the file containing the link, and activate the linked object. Guess what? It still worked. The server still found and loaded the source file. The relative file moniker still contained a valid path because you preserved the directory structure.2</P>
<P>When a linked object finds an invalid absolute moniker but a valid relative moniker, it updates the absolute moniker to point to the new location, re-creating the absolute path from the relative moniker. To do this, OLE asks the container for the absolute path to its document through <I>IOleClientSite::GetMoniker(OLEWHICHMK</I><I>_</I><I>CONTAINER)</I>. To prove that this works, save your container document (to save the moniker) and move that file to a random location so that you invalidate the relative moniker but not the updated absolute moniker. Loading the file and activating the linked object will still work, and in the process OLE will update the relative moniker (which precipitates another call to <I>GetMoniker</I>).</P>
<P>Keep in mind that whenever moniker changes such as these occur, the container must save the linked object again or the new monikers will not be written to storage. The container is not notified of these changes, so you'll need to call the object's <I>IPersist::IsDirty</I> function to see whether the object needs to be saved.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 Under OLE 1, this experiment would have failed because you would have broken the absolute pathname, which is all that OLE 1 linked objects maintained.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
