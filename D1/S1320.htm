<HTML><HEAD><TITLE>Implement Skeletal In-Place Interfaces and Object Helper Functions</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement Skeletal In-Place Interfaces and Object Helper Functions</H3><P>In-place activation for a server generally affects only the object in question, leaving most of the rest of the server unaffected. Cosmo's embedded object is implemented in <I>CFigure</I>. To this we need to add the <I>IOleInPlaceObject </I>interface (IIPOBJ.CPP) and provide an implementation of <I>IOleInPlaceActiveObject </I>(IIPAOBJ.CPP). We'll implement the latter as part of <I>CFigure </I>as well, but its <I>QueryInterface </I>is hobbled so as not to respond to any interface but itself. I've included this interface with <I>CFigure </I>because most of what we need to do in it concerns the object. But we could have implemented it with a separate object altogether.</P>
<P>At this point, it is useful to start implementing a set of centralized functions to do most of the work involved with in-place activation. For this reason, I've added a number of internal (but public in C++) member functions to <I>CFigure</I> that will be called from the in-place interfaces:</P>
<P><BR></P>
<pre><code>class CFigure : public IUnknown<BR>    {<BR>    §<BR><BR>    public:<BR>        §<BR><BR>        HRESULT  InPlaceActivate(LPOLECLIENTSITE, BOOL);<BR>        void     InPlaceDeactivate(void);<BR>        HRESULT  UIActivate(void);<BR>        void     UIDeactivate(void);<BR>        BOOL     InPlaceMenuCreate(void);<BR>        BOOL     InPlaceMenuDestroy(void);<BR>        BOOL     InPlaceToolsCreate(void);<BR>        BOOL     InPlaceToolsDestroy(void);<BR>        BOOL     InPlaceToolsRenegotiate(void);<BR><BR>        void     OpenIntoWindow(void);<BR>        BOOL     Undo(void);<BR>    }</code></pre>
<P><I>InPlaceDeactivate</I> and <I>UIDeactivate</I> will contain the same code we need in the <I>IOleInPlaceObject</I> functions of the same name, so we can have the interface simply call <I>CFigure </I>directly:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIOleInPlaceObject::InPlaceDeactivate(void)<BR>    {<BR>    m_pObj-&gt;InPlaceDeactivate();<BR>    return NOERROR;<BR>    }<BR><BR>STDMETHODIMP CImpIOleInPlaceObject::UIDeactivate(void)<BR>    {<BR>    m_pObj-&gt;UIDeactivate();<BR>    return NOERROR;<BR>    }</code></pre>
<P>Why bother with these and functions such as <I>CFigure::InPlaceActivate</I>? The reason is that we might need to call them from multiple locations—for example, <I>IOleObject::DoVerb</I> and <I>IOleInPlaceOb</I><I>ject::ReactivateAndUndo</I>. In Cosmo, <I>CFigure </I>has more access to the rest of the application than the interface implementations themselves, so we end up with cleaner code in the bargain. Also, <I>InPlaceActivate</I> is the only function that takes any arguments—an <I>IOleClientSite</I> pointer (generally the one passed to <I>IOleObject::DoVerb</I>) and a BOOL flag indicating that we want to activate the UI as well.</P></font></body></HTML>
