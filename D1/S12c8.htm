<HTML><HEAD><TITLE>Notes on Implementing an In-Process Server</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Notes on Implementing an In-Process Server</H2><P>In Chapter 18, we saw how to implement a complete local server, and in the last section we saw how to implement an in-process handler. Now we can bring the two together in a single in-process server, as I have done with the Polyline component (CHAP19\POLYLINE). Because we've seen most of the implementation already, this section will highlight specific issues that I faced when modifying this sample. When implementing an in-process server for content objects yourself, be sure to use OLE's caching services through <I>CreateDataCache </I>and not through <I>OleCreateDefaultHandler. </I></P>
<P>Let me point out that modifications made to Polyline for OLE Documents have not affected its usefulness to Component Cosmo (last seen in Chapter 13). In fact, the only change necessary for CoCosmo is to have it use CLSID_Polyline19 instead of CLSID_Polyline10, as it has been doing in <I>CCosmoDoc::Init</I>.3 If I hadn't changed Polyline's CLSID, CoCosmo would require no changes at all! This shows that support for OLE Documents does not interfere with the general operation of the object as a general purpose component. Although a container can now use Polyline's embedded objects, CoCosmo can still use exactly the same in-process server as before. That's the beauty of the <I>QueryInterface</I> mechanism and interface separation.</P>
<P>Much of Polyline's implementation is a cross between the code we've seen in this chapter for HCosmo and the code we saw in the last chapter for Cosmo itself. One of the more interesting points to note is that because Polyline cannot run stand-alone, it really can't create the same user interface as Cosmo does for editing a figure. I originally set out to do just this, but I soon discovered that it is difficult to manage a top-level pop-up window with a menu, a toolbar, and document windows within a DLL. For that reason, Polyline uses a dialog box–style user interface to display its figure from <I>IOleObject::DoVerb</I>, as we'll see in a moment. First let's look briefly at how this version of Polyline differs from the one we saw in Chapter 10:</P>
<UL><LI>The <I>CPolyline</I> class now manages additional interface pointers as well as pointers to the default handler <I>m</I><I>_</I><I>pDef&lt;Interface&gt;</I>, exactly as the <I>CFigure</I> class in HCosmo does. It also maintains the window handle of the dialog box we use to implement <I>IOleObject::DoVerb</I>. These additional variables are initialized to NULL in the <I>CPolyline</I> constructor and set to their real values in <I>CPolyline::Init</I> through <I>QueryInterface</I> on an <I>IUnknown</I> as returned from <I>CreateDataCache</I>.</LI><LI>RESOURCE.H now contains many more identifiers for additions to POLYLINE.RC: an icon (for the default icon), strings we use in the user interface, and a dialog box used for object activation.</LI><LI>The <I>SendAdvise</I> function added to <I>CPolyline</I> takes a notification code and calls the appropriate member function in <I>IOleClientSite</I>, <I>IOleAdviseHolder</I>, or <I>IDataAdviseHolder </I>(as we implemented for Cosmo in Chapter 18). The most frequent notification that required a number of changes in Polyline is <I>OnDataChange</I> (generated by calling <I>CPolyline::SendAdvise</I> with OBJECTCODE_DATACHANGED). Any member function in <I>IPolyline10</I> (IPOLYLIN.CPP) that changes data, such as <I>LineStyleSet</I> and <I>ColorSet</I>, has been modified to send data changes, as has <I>CPolyline::DataSet</I>. In addition, we send this code when the user clicks in the Polyline window, thus adding a point to the figure.</LI><LI>Member functions of <I>IPersistStorage</I> (IPERSTOR.CPP), in addition to their normal operation, now call the default handler's <I>IPersistStorage</I> to allow the cache to do what caches do.</LI><LI>Polyline's <I>IDataObject</I> now implements <I>GetDataHere</I> for CFSTR_EMBEDDEDOBJECT.</LI><LI>An implementation of <I>IViewObject2</I> is added. This is virtually identical to the one for HCosmo shown in Listing 19-1 earlier.</LI><LI><I>CPolyline</I>'s <I>QueryInterface</I> now includes the additional interfaces <I>IViewObject2</I>,<I> IRunnableObject</I>,<I> </I>and <I>IOleObject. </I>It also returns the default handler's <I>IOleCache2</I> interface but no others.</LI><LI>Polyline creates its activation dialog from within <I>IRunnableObject::Run </I>in a way that it can place the figure in a window to determine the object's extents. This dialog is not initially visible.</LI><LI>Most of the implementation of <I>IOleObject</I> is identical to implementations we have already seen. The exception is <I>DoVerb</I>, which makes the dialog created in <I>IRunnableObject::Run </I>visible or hidden, depending on the verb. <I>PolyDlgProc</I> in POLYWIN.CPP handles the messages that come to the dialog from the various controls inside it.</LI></UL><P>These last two changes are most important because they deal with the special needs of activating an in-process object. Again, Polyline uses a dialog in which to display its figure because of the difficulty of creating a normal application user interface from within a DLL. This is actually a good thing—it doesn't make sense to display a user interface that's part of a stand-alone application for a module that cannot run stand-alone at all.</P>
<P>The better user interface for an in-process server is a dialog box, which makes your object look a lot like a part of the container application. Because you are invoking this dialog box from a DLL that has already been loaded, a window such as this will appear quite quickly after the end user activates the object in the container. This further reinforces the idea that the dialog box is tightly integrated with the container. Dialog boxes also give you quite a bit of support, such as keyboard mnemonics for controls, that you would not otherwise get without your own message loop.</P>
<P>Polyline actually creates its dialog box, shown in Figure 19-2 on the next page, with <I>CreateDialogParam </I>inside <I>IRunnableObject::Run</I>,<I> </I>which will be called whenever the object enters at least the running state. At this time, Polyline can create a figure window within that dialog and give the figure a definite size so that implementations of <I>IViewObject2::GetExtent </I>and <I>IOleObject::GetExtent </I>can return something meaningful.</P>
<P>    <img src="f19dd02p.gif"></P>
<P><B>Figure 19-2.</B></P>
<P><B>Polyline's dialog box user interface for editing an embedded object.</B></P>
<P><I>IOleObject::DoVerb </I>then needs only to make this window visible or invisible, depending on the verb. <I>DoVerb </I>will create the dialog by calling <I>IRunnableObject::Run </I>if for some reason that dialog is not yet active or has been closed. A call to <I>IOleObject::Close </I>will destroy the dialog box itself, although the Polyline object remains loaded.</P>
<P>When we make the dialog visible, we also center it on the screen instead of letting it be placed in relation to the container window. This is because the default placement of a dialog box will typically cover the upper left portion of the container's client area, just where a site is usually found. The dialog box covers the object in the document. When I had Polyline working in this way, I found that the first thing I did after activating the object was move the dialog box out of the way. I expect other users would be frustrated by the same thing. Centering the dialog on the screen will generally keep the site visible, your server more usable, and your customers more satisfied.</P>
<P>Other than that, the dialog box processes commands the same way any other dialog box does, changing Polyline's line style or invoking the Choose Color dialog box to change background and line colors. It also sends the appropriate notifications when closing the dialog box, as we would when closing a document window in a server application. We don't need to call <I>IOleClientSite::SaveObject</I> because we aren't unloading the server; we're simply closing the dialog box. We had to do this in a local server because the application would generally shut down when the user interface went away, and that would mean the data was lost as well. But because this is an in-process server, it's going to stay in memory along with the object's most current data, data that will be used in subsequent calls to <I>IViewObject2::Draw</I> and the like. When the container wants to actually save the object, it calls <I>OleSave</I>, which will call our <I>IPersist</I><I>Storage::Save</I>, in which we'll save our current data. Therefore, no <I>SaveObject</I> call is necessary.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>3 The CHAP19\COCOSMO directory contains a README.TXT describing the changes necessary to make a new version of CoCosmo.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
