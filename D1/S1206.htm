<HTML><HEAD><TITLE>Tenant Creation, Paste</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Tenant Creation, Paste</H3><P>The difference between Paste Special and the typical Paste operation is that Paste does not allow selection of the specific format. For Paste, Patron conducts a series of checks to find the best format on the clipboard by calling <I>IDataObject::QueryGetData</I>; when it finds a suitable format, it uses the same "paste from data" function that Paste Special uses. Checking for formats occurs in <I>CPatronDoc::FQueryPasteFromData</I>,<I> </I>which returns the FORMATETC of the best format to paste. Actual pasting occurs in <I>CPatronDoc::Paste</I>:</P>
<P><BR></P>
<pre><code>BOOL CPatronDoc::FQueryPasteFromData(LPDATAOBJECT pIDataObject<BR>    , LPFORMATETC pFE, LPTENANTTYPE ptType)<BR>    {<BR>    FORMATETC       fe;<BR>    HRESULT         hr;<BR><BR>    if (NULL!=(LPVOID)ptType)<BR>        *ptType=TENANTTYPE_STATIC;<BR><BR>    //Any of our specific data here?<BR>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL);<BR>    hr=pIDataObject-&gt;QueryGetData(&amp;fe);<BR><BR>    if (NOERROR!=hr)<BR>        {<BR>        //Try metafile, DIB, and then bitmap, setting fe each time.<BR>        SETDefFormatEtc(fe, CF_METAFILEPICT, TYMED_MFPICT);<BR>        hr=pIDataObject-&gt;QueryGetData(&amp;fe);<BR><BR>        if (NOERROR!=hr)<BR>            {<BR>            SETDefFormatEtc(fe, CF_DIB, TYMED_HGLOBAL);<BR>            hr=pIDataObject-&gt;QueryGetData(&amp;fe);<BR><BR>            if (NOERROR!=hr)<BR>                {<BR>                SETDefFormatEtc(fe, CF_BITMAP, TYMED_GDI);<BR>                hr=pIDataObject-&gt;QueryGetData(&amp;fe);<BR>                }<BR>            }<BR>        }<BR><BR>    if (NOERROR==hr &amp;&amp; NULL!=pFE)<BR>        *pFE=fe;<BR><BR>    return (NOERROR==hr);<BR>    }<BR><BR><BR>BOOL CPatronDoc::Paste(HWND hWndFrame)<BR>    {<BR>    LPDATAOBJECT    pIDataObject;<BR>    BOOL            fRet=FALSE;<BR>    FORMATETC       fe;<BR>    TENANTTYPE      tType;<BR><BR>    if (NULL==m_pPG)<BR>        return FALSE;<BR><BR>    if (FAILED(OleGetClipboard(&amp;pIDataObject)))<BR>        return FALSE;<BR><BR>    //Go get type and format we *can* paste; then paste it.<BR>    if (FQueryPasteFromData(pIDataObject, &amp;fe, &amp;tType))<BR>        fRet=PasteFromData(pIDataObject, &amp;fe, tType, NULL, 0L);<BR><BR>    pIDataObject-&gt;Release();<BR>    return fRet;<BR>    }<BR><BR>BOOL CPatronDoc::PasteFromData(LPDATAOBJECT pIDataObject<BR>    , LPFORMATETC pFE, TENANTTYPE tType, LPPATRONOBJECT ppo<BR>    , DWORD dwData)<BR>    {<BR>    BOOL            fRet;<BR>    HRESULT         hr;<BR>    PATRONOBJECT    po;<BR>    STGMEDIUM       stm;<BR><BR>    if (NULL==pFE)<BR>        return FALSE;<BR><BR>    //If we're not given any placement data, see if we can retrieve it.<BR>    if (pFE-&gt;cfFormat==m_cf &amp;&amp; NULL==ppo)<BR>        {<BR>        hr=pIDataObject-&gt;GetData(pFE, &amp;stm);<BR><BR>        if (SUCCEEDED(hr))<BR>            {<BR>            ppo=(LPPATRONOBJECT)GlobalLock(stm.hGlobal);<BR><BR>            po=*ppo;<BR>            ppo=&amp;po;<BR>            GlobalUnlock(stm.hGlobal);<BR>            ReleaseStgMedium(&amp;stm);<BR>            }<BR>        }<BR><BR>    fRet=m_pPG-&gt;TenantCreate(tType, (LPVOID)pIDataObject, pFE<BR>        , ppo, dwData);<BR><BR>    if (fRet)<BR>        {<BR>        //Disable Printer Setup once we've created a tenant.<BR>        if (m_fPrintSetup)<BR>            m_fPrintSetup=FALSE;<BR><BR>        FDirtySet(TRUE);<BR>        }<BR><BR>    return fRet;<BR>    }</code></pre>
<P><I>PasteFromData</I> first checks to see whether it was given explicit placement data for whatever it pastes. This way we can allow an end user to simply move a tenant on a page instead of copying it and pasting it. Placement data consists of a point for the upper left corner of the tenant on the page and the tenant extents. I separated the corner point and the extents so that they can be manipulated independently—changing the size of a tenant doesn't necessarily change the upper left corner; moving a tenant doesn't necessarily change the extents.2</P>
<P>In any case, during pastes from the clipboard the <I>ppo</I> parameter to <I>PasteFromData</I> will always be NULL. This means that if the clipboard holds our private Patron Object data, <I>PasteFromData </I>pastes the best available graphic format at the point specified by any present positioning information. In this chapter, Patron always passes a NULL in <I>ppo </I>to this function—a preparation for Chapter 13's work. In all honesty, I implemented this differently on my first pass through this chapter's code, and after finding it deficient for drag and drop, I came back and modified it. This is a worthy consideration for your own designs.</P>
<P>Now let's look at what actually creates a tenant, which is an object of the C++ class <I>CTenant</I> and has member functions such as <I>Open</I>, <I>Load</I>, <I>Update</I>, <I>Destroy</I>, <I>Select</I>, <I>Activate</I>, <I>Draw</I>, and <I>SizeSet</I>, just to name a few. This tenant class will expand into a compound document site in Chapter 17 and a control site in Chapter 25. In this chapter, a tenant already does much of what it needs in OLE Documents: it holds some object's <I>IUnknown</I> pointer, asks that object to draw through <I>IViewObject2</I>, and uses the OLE functions <I>OleSave</I> and <I>OleLoad</I> to save and load the object and its presentations to and from a piece of storage. (We'll see these APIs in Chapter 17.)</P>
<P>Each tenant's storage is a uniquely named storage element created in the storage element for the tenant's page. This happens in <I>CTenant::Open</I>, if you care to look, which opens the storage of a given name if it exists or, failing</P>
<P>that, creates a new storage of that name. The names are "Tenant <I>n</I>" (<I>n </I>is the value of a persistent counter kept in each page). The page saves this counter with a list of tenants, just as the <I>CPages</I> implementation saves lists of pages to its own storage element, as we saw in Chapter 7.</P>
<P>When Patron creates a tenant (a process that usually begins at the document level and works through <I>CPages </I>and then to <I>CPage</I>), it instantiates the tenant with <I>new CTenant</I> (see <I>CPages::TenantAdd</I>) and then asks that tenant to initialize itself (<I>CTenant::Create</I>)<I> </I>to obtain the <I>IUnknown</I> pointer for whatever object is stored in the tenant. <I>Create </I>is the only piece of code that knows how to take something like an <I>IDataObject </I>pointer and create an object with whatever is there. Exactly what it should try is determined by the TENANTTYPE (see TENANT.H) argument. For this chapter, the type is always TENANTTYPE_STATIC, so <I>Create</I> generally uses the same technique as Chapter 11's Freeloader to create a static picture. In later chapters, we'll add more types, such as compound document objects and controls.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 The code that disables Printer Setup after creating a tenant is simply to accommodate my own laziness—I didn't want to introduce the complication of reformatting a page to a new paper size after tenants have been placed on that page. This hack has nothing to do with OLE.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
