<HTML><HEAD><TITLE>Handling IMessageFilter::MessagePending</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Handling <I>IMessageFilter::Mes</I><I>sagePending</I></H3><P>One of the pieces of sample code found in the original OLEUI sources is a sort of standard message filter implementation—not the default one, but a more typical sort that shows the sort of thing you can do within <I>MessagePending </I>to process additional input. (This code is cleaned up a little from the actual sources, with some bits omitted to simplify our discussion.)</P>
<P><BR></P>
<pre><code>/*<BR> * Macro checks for WM_LBUTTONDOWN, WM_LBUTTONDBLCLK, <BR> * WM_NCLBUTTONDOWN, WM_NCLBUTTONDBLCLK, WM_KEYDOWN, and WM_SYSKEYDOWN <BR> * through PeekMessage calls with PM_NOREMOVE | PM_NOYIELD.<BR> */<BR>#define IS_SIGNIFICANT_MSG(lpmsg)  [Expansion omitted]<BR><BR>STDMETHODIMP_(DWORD) OleStdMsgFilter_MessagePending(LPMESSAGEFILTER lpThis<BR>    , HTASK htaskCallee, DWORD dwTickCount, DWORD dwPendingType)<BR>    {<BR>    LPOLESTDMESSAGEFILTER   this=(LPOLESTDMESSAGEFILTER)lpThis;<BR>    DWORD                   dwReturn=PENDINGMSG_WAITDEFPROCESS;<BR>    MSG                     msg;<BR>    BOOL                    fIsSignificantMsg=IS_SIGNIFICANT_MSG(&amp;msg);<BR>    UINT                    uRet;<BR><BR>    if (dwTickCount &gt; 5000 &amp;&amp; fIsSignificantMsg <BR>        &amp;&amp; !this-&gt;m_bUnblocking)<BR>        {<BR>        this-&gt;m_bUnblocking=TRUE;<BR><BR>        //Eat messages in our queue that we do NOT want dispatched.<BR>        while (PeekMessage(&amp;msg, NULL, WM_CLOSE, WM_CLOSE<BR>           , PM_REMOVE | PM_NOYIELD))<BR>           ;<BR><BR>        [Invoke the dialog box with BZ_NOTRESPONDING.]<BR>        uRet=OleUIBusy(&amp;bz);<BR><BR>        this-&gt;m_bUnblocking = TRUE;<BR>        return PENDINGMSG_WAITNOPROCESS;<BR>        }<BR><BR>    if (this-&gt;m_bUnblocking)<BR>        return PENDINGMSG_WAITDEFPROCESS;<BR><BR>    if (this-&gt;m_lpfnMessagePendingCallback)<BR>        {<BR>        MSG msg;<BR><BR>        if (PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD))<BR>            {<BR>            if (this-&gt;m_lpfnMessagePendingCallback(&amp;msg))<BR>                dwReturn=PENDINGMSG_WAITNOPROCESS;<BR>            else<BR>                dwReturn=PENDINGMSG_WAITDEFPROCESS;<BR>            }<BR>        }<BR><BR>    return dwReturn;<BR>    }</code></pre>
<P>This implementation displays the "not responding" version of the busy dialog box if a significant message (mouse click or keystroke) has occurred and we've waited more than 5 seconds (which you may want to make as little as 2 seconds) for a call to complete. Note that the <I>m</I><I>_</I><I>fUnblocking </I>flag protects against reentrant calls. Anyway, only significant messages are considered good enough to warrant the dialog box because something like a mouse move shouldn't really be considered input. Before the dialog box appears, this implementation removes any messages that might be in the queue and that it doesn't want dispatched from the message loop within the Windows <I>DialogBox </I>function (called from <I>OleUIBusy</I>). In this case, the implementation removes WM_CLOSE to prevent the client from disappearing when it's inside this busy state. Not a bad idea!</P>
<P>What happens <I>before </I>the waiting period is over is most interesting. As described earlier in this chapter, you should try to process or cache an end user's pending work (keystrokes and mouse clicks) while waiting for a call to be completed. The preceding code calls an application-supplied hook (a <I>callback</I>) to process the next message in the queue. The hook returns, indicating (by a TRUE or a FALSE) whether the message was processed. If it was processed, the return value from <I>MessagePending </I>tells COM to discard the message; otherwise, COM performs its default action with it.</P>
<P>For your own implementation, you can take this basic code and replace the callback material with whatever message processing you want.</P></font></body></HTML>
