<HTML><HEAD><TITLE>Persistent Object Interfaces</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Persistent Object Interfaces</H2><P>When a client wants to ask an object whether it can read or write its persistent data to some type of medium—either a storage, a stream, or a file—that client queries for one of four interfaces that begin with <I>IPersist</I> and, in fact, derive from the <I>IPersist</I> interface we saw first in Chapter 6. All of these interfaces can be marshaled between processes:2</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="113pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><I>IPersistStorage</I></P></TD><TD VALIGN="TOP"><P>The object can read and write its information in a storage hierarchy in which the object is allowed to create additional substorages and streams to any depth it requires. The object can also open elements and hold their pointers outside the scope of calls to this interface.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>IPersistStream</I></P></TD><TD VALIGN="TOP"><P>The object can read and write its information in a single stream and must do so within the scope of calls to this interface.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>IPersistStreamInit</I></P></TD><TD VALIGN="TOP"><P>Same as <I>IPersistStream</I>, but this interface means the object would like to be informed when it is newly created and has no persistent state as yet. The member function for this purpose does not exist in <I>IPersistStream</I>.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>IPersistFile</I></P></TD><TD VALIGN="TOP"><P>The object can read and write its information into a completely separate file (traditional or compound) outside the scope of Structured Storage.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>All of these interfaces are considered <I>initialization</I> interfaces as described in Chapter 5. Each has specific member functions that perform the initialization; each one has a <I>Load </I>member for this purpose, and <I>IPersistStorage </I>and <I>IPersistStreamInit </I>have an additional <I>InitNew </I>member to distinguish new initializations from an initialization based on existing data. This existing data does not need to have come from a previous instantiation of the object—a client is perfectly free to create the data itself in a storage hierarchy, a stream, or a file prior to calling any initialization function. As long as the client knows about the object's persistent state structures, the client can fabricate data and initialize objects from the object all it wants.3</P>
<P>Each interface is derived from <I>IPersist</I>, so they all share the <I>GetClassID </I>member function. This call identifies the CLSID of the code that knows how to work with the persistent data. This is particularly useful for OLE, which uses the CLSID to determine what proxy or handler to load in another process that can also work with the data, as we saw in Chapter 6.</P>
<P><I>GetClassID </I>is not the only member function that these interfaces have in common. All the interfaces also share two common operations: <I>Load </I>and <I>Save</I>. We'll see these functions as we look at <I>IPersistStream[Init]</I>, then <I>IPersistFile</I>, and finally <I>IPersistStorage</I>, which has a more complex behavior than the others, introducing a specific set of rules that both object and client must follow.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 At the time of writing <I>IPersistStreamInit</I> did not have marshaling support. Check your current system.</P></TD></TR><TR><TD VALIGN="TOP"><P>3 An instance of this technique is the function <I>OleCreateFromFile</I>, which we'll use in Chapters 17 and 20 to create embedded and linked compound document objects based on the contents of an existing file. It doesn't mean that such objects had to exist before: we're using the file contents for initialization purposes.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
