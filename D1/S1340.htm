<HTML><HEAD><TITLE>Notes on Patron as a Partial OLE Control Container</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Notes on Patron as a Partial OLE Control Container</H2><P>As an in-place–capable container for OLE Documents, the Patron sample from Chapter 22 is already well on its way to becoming an OLE control container. For this chapter's sample (CHAP24\PATRON), we'll try adding some control-related features to demonstrate a number of the concepts we've been describing. As elsewhere in our work with OLE Documents, implementing container features involves a good deal of user interface. Supporting OLE Controls is no exception.</P>
<P>Let me state again that Patron is <I>not </I>a complete control container by any stretch of the imagination. Patron merely demonstrates some of the techniques involved while leaving others unsupported. This sample doesn't implement any Tab key handling or tab order support, nor does it implement <I>ISimpleFrameSite</I>. It also does not handle default and cancel buttons, exclusive buttons, or labels.<I> </I>It doesn't have any way to call a control's methods or to manipulate its properties. Patron does not implement <I>IPropertyNotifySink</I>, demonstrate extended controls, provide a user interface for self-registering controls, use a control's toolbox bitmap, or deal at all with licensing issues.<I> </I>And finally, Patron ignores OLEMISC_SETCLIENTSITEFIRST and works only with controls that implement <I>IPersistStorage </I>and those marked "Insertable."</P>
<P>This last point deserves some clarification—Patron doesn't supply its own Insert Control dialog box, which normally would be populated with those objects marked with "Control" in the registry.<I> </I>Instead, it relies on the Insert Object dialog box we've used since Chapter 17.<I> </I>Therefore, Patron works only with controls marked "Insertable" and those that use the storage-based persistence model.<I> </I>If you'd like to play around with a control in Patron, you'll have to manually add the Insertable key and see what happens.</P>
<P>So does Patron do anything?<I> </I>What's left to demonstrate?<I> </I>Well, we still have a number of important pieces of a container—event handling, ambient properties, and keyboard mnemonics.<I> </I>The following list describes those parts of the OLE Controls technology that are demonstrated in this sample:</P>
<UL><LI>Patron supplies the ambient properties <I>UserMode</I>, <I>UIDead</I>, <I>SupportsMnemonics</I>, <I>Font</I>, <I>BackColor</I>, <I>ForeColor</I>, <I>LocaleID</I>, <I>ShowGrabHandles</I>, and <I>ShowHatching. </I>The site's implementation of <I>IDispatch </I>is found in AMBIENTS.CPP. The interface does little more than copy values stored in Patron's <I>CTenant </I>class to the VARIANT out-parameters.<I> </I>The standard font object (14-point Arial) to return for the <I>Font </I>ambient property is managed in the <I>CPages </I>class, which creates the font inside <I>CPages::Init </I>with a call to <I>OleCreateFontIndirect.</I></LI><LI>Patron provides menu items for switching between design mode and run mode, toggling the <I>UserMode</I> ambient property.<I> </I>In design mode, Patron deactivates all the controls and will return S_FALSE from <I>IOleInPlaceSite::CanInPlaceActivate</I>.<I> </I>In this mode, Patron supplies its own grab handles for sizing controls and its own drag-and-drop pick region for moving controls around in the document.<I> </I>Various classes in Patron, such as <I>CPatronDoc</I>, <I>CPages</I>, and <I>CTenant</I>, maintain duplicate flags named <I>m</I><I>_</I><I>fDesignMode </I>for the purpose of knowing which mode is in use.<I> </I>In the tenant, for example, this flag will suppress the initial activation of any object marked OLEMISC_ACTIVATEWHENVISIBLE.<I> </I>When you switch to run mode, Patron will reactivate any such control and activate the UI of the currently selected one.<I> </I>When you create a new control in design mode, Patron does not initially activate it as usual for an embedded object because most controls have no open active state.</LI><LI>Patron also provides menu items for toggling the <I>UIDead</I>, <I>ShowGrabHandles</I>, and <I>ShowHatching</I> ambient properties—you can watch what effect they have on various controls.<I> </I>The latter two properties are toggled together.<I> </I>All changes to ambient properties do, of course, generate a call to <I>IOleControl::OnAmbientPropertyChange</I>, which is centralized in the function <I>CTenant::AmbientChange</I>.</LI><LI>Patron's site object, implemented in the class <I>CTenant</I>, implements <I>IOleControlSite </I>(ICONSITE.CPP) and the <I>IDispatch</I> interface for ambient properties (AMBIENTS.CPP).<I> </I>Inside <I>IOleControlSite</I>, Patron implements the members <I>OnControlInfoChanged</I>, <I>LockInPlaceActive</I>, and <I>TransformCoords. </I>Having no extended controls, we have no need to implement <I>GetExtendedControl </I>and <I>ShowPropertyFrame</I>.<I> </I>Having no keyboard support—nor support for default and cancel buttons—allows us to return E_NOTIMPL from <I>OnFocus </I>and <I>TranslateAccelerator.</I></LI><LI>The implementation of <I>IOleControlSite::LockInPlaceActive </I>simply increments or decrements a lock count.<I> </I>This affects <I>CTenant::DeactivateInPlaceObject</I>, which will not deactivate a control when the lock count is nonzero.<I> </I>Instead, it sets a flag in <I>CTenant </I>named <I>m</I><I>_</I><I>fPendingDeactivate</I>.<I> </I>Whenever <I>IOleControlSite::LockInPlaceActive </I>decrements the lock count to 0, it will call <I>CTenant::DeactivateIn-PlaceObject</I> if <I>m</I><I>_</I><I>fPendingDeactivate</I> is set.</LI><LI>When Patron detects WM_KEYDOWN or WM_SYSKEYDOWN for Alt or Ctrl key combinations, it attempts to match a control's mnemonic in order to call <I>IOleControl::OnMnemonic</I>.<I> </I>This ends up in <I>CPage::TryMnemonic</I>, which loops through all controls on a page (using the current z-order), calling <I>CTenant::TryMnemonic. </I>This latter function will then scan the accelerator table in the control's CONTROLINFO structure as returned from <I>IOleControl::GetControlInfo</I>. If a match is found, we call <I>IOleControl::OnMnemonic.</I> Patron loads an object's CONTROLINFO structure initially inside <I>CTenant::ControlInitialize</I>, replacing it whenever <I>IOleControlSite::OnControlInfoChanged </I>is called.</LI><LI>Patron will call <I>OleRun </I>for any control marked with OLEMISC_ALWAYSRUN. (See <I>CTenant::ObjectInitialize</I>.) Furthermore, code in <I>CTenant::Draw </I>and <I>CTenant::Select </I>suppresses drawing anything for a given control at run time when that control is marked OLEMISC_INVISIBLEATRUNTIME. The tenant code will also avoid UI activation of controls marked OLEMISC_NOUIACTIVE.</LI><LI>Patron implements <I>IOleClientSite::RequestNewObjectLayout </I>to retrieve the control's new size. It passes the size to <I>CTenant::UpdateInPlaceObjectRects.</I> This latter function generates the clipping rectangle and calls <I>IOleInPlaceObject::SetObjectRects.</I></LI><LI>Patron allows you to assign a system sound to any control event through the Control Events dialog box shown in Figure 24-4. The Edit Events menu item is enabled whenever a control has events, which is determined through its type information. (This item is also placed on the right mouse button pop-up menu.) Although the actions you can assign to any event are limited, Patron does demonstrate how to handle a generic event set and how to save and load the action assignments persistently—with the limitation that it does not process event-specific arguments.</LI></UL><P>Patron best demonstrates the handling of an arbitrary event set. To display the dialog shown in Figure 24-4 (whose template is in EVENTS.DLG, by the way), we need some list of events and also to maintain a mapping from each event dispID to an action. We also need to implement an <I>IDispatch </I>that works with any event set to execute the action assigned to whatever event comes into <I>IDispatch::Invoke.</I> To receive these events in the first place, we have to find the type information for the event set. The following sections describe how Patron performs these steps.</P>
<P>    <img src="f24dd04p.gif"></P>
<P><B>Figure 24-4.</B></P>
<P><B>Patron's Control Events dialog box in which the user can assign actions (system sounds) to individual events. The events shown are those of the Polyline control implemented in this chapter.</B></P></font></body></HTML>
