<HTML><HEAD><TITLE>Complex Compound Files: Patron</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Complex Compound Files: Patron</H2><P>English grammar defines a number of sentence structures. A simple sentence expresses one idea, such as "The rabbit sat in its form."4 Compound sentences express more than one independent idea, such as "The rabbit sat in its form, and the photographer set up her camera." These sentences have a vague notion of concurrency but no hard evidence of it. A complex sentence, however, defines such a relationship, as in "The rabbit sat in its form while the photographer set up her camera." A complex compound sentence is more on the order of "Although the rabbit felt trepidation about most humans, it calmly sat in its form, and the photographer continued to set up her camera."</P>
<P>The idea of a single flat traditional file is an analog of the simple sentence structure. A compound file, one with a single storage and a single stream, is much like a compound sentence: two elements that are related by being in the same place at the same time. When we add more streams in the root storage, we make things more complex—the meaning of the data in one stream might be partially or completely defined by the context of the data in another stream. As we use even more complex structures, we add substorages alongside these streams and new streams under those substorages. We can build any complexity we want, and thus we can call such structures complex compound files.</P>
<P>For this chapter's version of Patron (CHAP07\PATRON), we'll implement the storage structure shown in Figure 7-8, which is the same as that shown in Figure 7-6 on page 353, but without the page header streams or tenant storages because we haven't yet added the capability of creating tenants. Each Patron file is a root storage, underneath which live two streams. The first contains the printer configuration; the second contains the list of pages within the document, including the number of pages, the current page (the one to view when opening the file), and any number of page identifiers. Each page is assigned a unique DWORD according to the order of creation, and the page list stream contains the next ID to use. The ordering of pages in the document is determined by the sequence of IDs in the page list, not by the ID values themselves, because the fourth page created might have been inserted at the beginning of the document. Each page is given its own substorage under the root; the substorage name is Page &lt;<I>ID</I>&gt;, where &lt;<I>ID</I>&gt; is the ASCII representation of the identifier. For this chapter, these substorages will not contain anything else—they do, however, provide the structure in which we can create tenants later on.</P>
<P>    <img src="f07dd08.gif"></P>
<P><B>Figure 7-8.</B></P>
<P><B>Exact layout of Patron's compound files as described in this chapter, prior to adding tenant support.</B></P>
<P>Adding file I/O capabilities using compound files requires considerable modifications and additions to Patron: filling out its <I>CPatronDoc </I>members <I>Load </I>and <I>Save</I> (DOCUMENT.CPP), adding structural support in the <I>CPages </I>class (PAGES.CPP), and adding functionality to the <I>CPage </I>class (PAGE.CPP). All the code is available on the companion CD and need not be shown here. For the most part, Patron follows the same sorts of call sequences for saving and loading files that were described for Cosmo earlier in this chapter, except that not everything happens at the same time and in the same place. Patron's file handling is summarized as follows:</P>
<UL><LI><I>CPatronDoc::Load </I>either opens an existing file (<I>StgOpenStorage</I>) or creates a temporary file (using <I>StgCreateDocfile </I>with a NULL filename). It passes the resulting <I>IStorage </I>pointer to <I>CPages::StorageSet</I>, which uses the pointer when creating or opening the page substorages.</LI><LI><I>CPages::S</I><I>torageSet </I>reads the Page List stream in the storage given to it and creates all the necessary pages described by that stream. (This is more efficient than calling <I>IStorage::EnumElements </I>to find all the page names directly. The information in the stream is sufficient to re-create those names more quickly.) If this is a new file, <I>StorageSet</I> creates the "Page List" stream, setting the next ID counter to 0. This function then creates or reads the device configuration stream, switches to the current page, and returns. When a repaint occurs, the user will see the current page.</LI><LI><I>CPatronDoc::Save</I>, when performing a simple Save operation, tells each page to update its storages by calling <I>CPages::StorageUpdate</I>, followed by a call to <I>IStorage::Commit(STGC</I><I>_</I><I>DEFAULT)</I>. If performing a Save As operation, <I>CPatronDoc::Save </I>creates a new compound file, updates all the page storages, calls <I>CopyTo</I> to store all the information in the new file, and then calls <I>Commit</I> to make it all permanent. If <I>CopyTo </I>fails due to lack of memory, Patron queries for <I>IRootStorage </I>and calls <I>IRootStorage::SwitchToFile </I>followed by <I>IStorage::Commit</I>. In either case, the new file is saved properly.</LI><LI><I>CPages::StorageUpdate</I> calls <I>CPage::Update </I>for the current page, closes that page, and rewrites the "Page List" stream. This function needs only to update the current page: when the user switches to another page, Patron ends up in <I>CPages::CurPageSet</I>, calling <I>CPage::Close</I>, which tells the page to commit its changes. That page's substorage then contains the current copy of its information, so we can release that substorage and open the new page to view. In other words, changing pages commits the previous one and opens the new one, so when we save the entire file we need only commit the changes to the current page. In this manner, Patron performs the necessary commits on each level of its storage, which we'll expand in a later chapter when adding tenants.</LI><LI>The functions <I>CPatronDoc::Print</I> and <I>CPatronDoc::PrinterSetup</I>, along with <I>CP</I><I>ages::DevModeSet</I>, <I>CPages::DevModeGet</I>, <I>CPages::ConfigureForDevice</I>, and <I>CPages::Print</I>—all of which you can find in PRINT.CPP—manage the printer information inside the "device configuration" stream. This is an example of keeping an infrequently used data structure in a stream at all times instead of loading it into memory. The only drawbacks are that Patron ties a document to a specific printer device and that the DEVMODE structure it stores in this stream is not portable between platforms. Both design decisions would be silly in a shipping software product, but I use DEVMODE here as a matter of convenience for this sample, whose fundamental purpose is not sales but demonstration of concepts.5</LI><LI>Deleting a page calls <I>CPages::DeletePage</I>, which calls <I>CPage::Destroy</I>. This in turn calls <I>IStorage::DestroyElement </I>to delete its own substorage. (Remember that the <I>CPage </I>class is a run-time C++ object in memory, which is here destroying its own substorage in the compound file. This is not a case of the object destroying itself, only its storage.)</LI></UL><P>I encourage you to follow through the code and see where each piece of Patron's architecture (I don't call it ideal by any means) works with its piece of the storage hierarchy. The <I>CPatronDoc </I>and <I>CPages </I>classes both work with the root storage, whereas instances of <I>CPage </I>work with their own substorage. Let's look at two of the more interesting parts of this implementation.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>4 A form is a rabbit's resting place.</P></TD></TR><TR><TD VALIGN="TOP"><P>5 Patron does not gracefully handle the case in which a document created for one printer, with a specific DEVMODE, is taken to another machine without that printer installed. What will happen is that Patron will call <I>CreateIC</I> with that information and will fail to find the driver specified in DEVMODE. As a result, the user gets blasted with one of those ugly "Cannot find MSHPPCL5.DRV" messages. If you encounter this, remember it's just a sample.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
