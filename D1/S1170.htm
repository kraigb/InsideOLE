<HTML><HEAD><TITLE>Limitations of Outgoing Calls</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Limitations of Outgoing Calls</H3><P>Besides the errors that message filtering might generate, COM places a few other restrictions on outgoing calls from any process to an object in any other process, as described in the following error list:</P>
<P><img src="16bit.gif"></P>
<P></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>RPC_E_CANTCALLOUT-_INASYNCCALL</P></TD><TD VALIGN="TOP"><P>An object cannot make other outgoing calls while processing an asynchronous call to itself. See the discussion that follows this table for more information.</P></TD></TR><TR><TD VALIGN="TOP"><P>RPC_E_CANTCALLOUT-_ININPUTSYNCCALL</P></TD><TD VALIGN="TOP"><P>An object cannot make other outgoing calls while processing an input-synchronous call itself.</P></TD></TR><TR><TD VALIGN="TOP"><P>RPC_E_CANTCALLOUT-_INEXTERNALCALL</P></TD><TD VALIGN="TOP"><P>It is illegal to call out while inside a message filter.</P></TD></TR><TR><TD VALIGN="TOP"><P>RPC_E_CANTCALLOUT-_AGAIN</P></TD><TD VALIGN="TOP"><P>There is no second outgoing call on a DDE channel, used when communicating with an OLE version 1 server (OLE Documents only).</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>We will encounter a few of these as we progress through other subjects in this book, especially RPC_E_CANTCALLOUT_INASYNCCALL, which you will probably encounter in your own work at some time or other. The reason for this restriction is that the source of an asynchronous call is usually making a series of such calls to potentially multiple sinks. That source might also make a synchronous call after it has completed making asynchronous calls, expecting that it will not receive any incoming calls in the meantime. In such a case, the receiver (sink) of the asynchronous call is not allowed to make a synchronous call to the source. This avoids problems in which the sink calls back to the source but the source rejects the call. The sink can then go into a retry loop, during which time the source tries another asynchronous call to the same sink. These calls fail now that the sink is blocked. If the source itself goes into a retry loop, we get deadlocked. Not good. This means that you cannot make a call from within an asynchronous call—instead, you'll need to post yourself a message to make that call later.</P></font></body></HTML>
