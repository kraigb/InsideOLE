<HTML><HEAD><TITLE>Implement IPersistStorage</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Implement <I>IPersistStorage</I></H3><P>It's best to first implement <I>IPersistStorage</I> on an embedded object because the first thing <I>OleCreate </I>or <I>OleLoad </I>will do is call member functions in this initialization interface. For the most part, the code is similar to the code we implemented for Polyline back in Chapter 8. Inside <I>InitNew </I>and <I>Load</I>,<I> </I>this implementation of <I>IPersistStorage </I>creates or opens streams as necessary, holding on to those pointers for low-memory saves, releasing those pointers as needed in <I>HandsOffStorage</I>, and so forth.</P>
<P><I>IPersistStorage::IsDirty </I>is implemented by calling <I>CFigure::FIsDirty, </I>which in turn asks the document holding the figure if the document is dirty. The document, however, always returns FALSE when it is open in order to edit an embedded object. Why is this? Remember that an embedded object continually notifies its container about changes, so the object in the server's user interface and the object image in the container always match. From the user's point of view, the object is never actually dirty, although we still need to ask the container to save it before we close, as we'll see.</P>
<P>The core implementation of <I>IPersistStorage::Load </I>and <I>IPersistStorage::Save </I>delegates its functionality to <I>CPolyline::ReadFromStream </I>and <I>CPolyline::WriteToStream</I>. These functions contain code that I broke out of the implementations of <I>CPolyline::ReadFromStorage </I>and <I>CPolyline::WriteToStorage </I>that we added in Chapter 7. The core functionality of Cosmo's <I>CPolyline </I>class, then, stays exactly the same. All we've done here is reorganize that code to make it more accessible from an interface implementation.</P>
<P>We also handle conversion and emulation considerations inside <I>Load </I>and <I>Save</I>.2 First we handle emulation of the Polyline class because both Cosmo and the Polyline component from Chapter 19 share the same stream name and stream format. Thus, we need not make any special consideration. The conversion case is more interesting. If you read through the container side of these features in Chapter 17, you'll know that the container calls the function <I>SetConvertStg </I>before reloading a newly converted object. When we enter <I>Load</I>,<I> </I>we call <I>GetConvertStg </I>to see if this is, in fact, a conversion case. We also read whatever CLSID is in the storage so we can return it from <I>IPersistStorage::GetClassID </I>when we're doing emulation:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIPersistStorage::GetClassID(LPCLSID pClsID)<BR>    {<BR>    if (PSSTATE_UNINIT==m_psState)<BR>        return ResultFromScode(E_UNEXPECTED);<BR><BR>    *pClsID=m_pObj-&gt;m_clsID;<BR>    return NOERROR;<BR>    }<BR><BR><BR>STDMETHODIMP CImpIPersistStorage::Load(LPSTORAGE pIStorage)<BR>    {<BR>    [Validation code omitted]<BR><BR>    //The next statement tells us whether we're <BR>    //coming from another class storage.<BR>    m_fConvert=(NOERROR==GetConvertStg(pIStorage));<BR><BR>    ReadClassStg(pIStorage, &amp;m_pObj-&gt;m_clsID);<BR>    §<BR>    }</code></pre>
<P>From here we simply load the data as necessary from whatever streams are present in the storage. When we now go to save, we have to ensure that the storage format is converted to our own. The <I>m</I><I>_</I><I>fConvert </I>flag we saved in <I>Load </I>tells us to do this. We first write our own streams as necessary, delete the original object's streams (which amounts to nothing when we're converting a Polyline object because the streams are identical), update the format and user type in the storage, and turn off the convert bit:</P>
<P><BR></P>
<pre><code>STDMETHODIMP CImpIPersistStorage::Save(LPSTORAGE pIStorage<BR>    , BOOL fSameAsLoad)<BR>    {<BR>    §<BR>    if (m_fConvert)<BR>        {<BR>        UINT    cf;<BR><BR>        cf=RegisterClipboardFormat((*m_pObj-&gt;m_pST)[IDS_FORMAT]);<BR>        WriteFmtUserTypeStg(pIStorage, cf<BR>            , (*m_pObj-&gt;m_pST)[IDS_USERTYPE]);<BR><BR>        SetConvertStg(pIStorage, FALSE);<BR>        m_fConvert=FALSE;<BR>        }<BR>    §<BR>    }</code></pre>
<P>After this process, the object's persistent storage will be fully a Cosmo figure no matter what it was originally. The code we've demonstrated in Cosmo is perhaps artificially simple because Cosmo and Polyline share the same storage formats. This might be true of different versions of your own server. It should be obvious, however, that handling different formats from other competitive servers, through both conversion and emulation, will involve the handling of more streams with different data, in both <I>Load </I>and <I>Save. </I>Nevertheless, the same pattern of operations holds. In conversion, load the storage that is there and write your own formats when saving. In emulation, you need to both load and save the same format.</P>
<P>To finish up <I>IPersistStorage</I>,<I> </I>the implementations of <I>SaveCompleted </I>and <I>HandsOffStorage </I>are pretty standard except for one thing. Just before we return from <I>SaveCompleted</I>, we make a call to any connected container's <I>IAdviseSink::OnSave. </I>(This happens through <I>CFigure::SendAdvise</I>, which we'll look at later.) This tells containers that a save has been completed, which some older containers (in particular Microsoft Excel 5) use to know that saving succeeded. The call is benign for containers that don't care otherwise, but it is a wise call to include for maximum compatibility.</P>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>2 This includes OLE 1 version handling.  Again, see OLE1.WRI on the companion CD.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
