<HTML><HEAD><TITLE>Persistence Through Property Sets</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Persistence Through Property Sets</H2><P>At the beginning of this chapter, I described a property set as a "sparse, flexible, and extensible stream format in which you can serialize almost any information you want." By <I>stream format,</I> I mean a format for a series of bytes stored in a stream object and accessed through the <I>IStream </I>interface, although the same property set format can be used anywhere that byte streams are in use. In fact, the format also accommodates property sets spanning multiple streams that are all contained within a single storage object. We will see how this can be done shortly. First, however, what do I mean by sparse, flexible, and extensible?</P>
<UL><LI>Flexible. You can store any type of data whatsoever inside this format, be it a single character, a floating-point value, a VARIANT, a BLOB, and so forth. Every piece of information is tagged in the format with a VT_* value from the VARTYPE enumeration that we saw in Chapter 14 on page 649.</LI><LI>Sparse. The format is specified so that any code that attempts to read information from a property set can attempt to read only what is there. In other words, reading code will not attempt to extract nonexistent information. Instead of an object writing a large data structure containing its properties that might have invalid fields, it can write only those properties with meaningful values, essentially storing a sparse structure without taking up unnecessary space. Code that reads this property set reads only those values that were written.</LI><LI>Extensible. The property set format can accommodate new data types simply by adding new VARTYPE flags. New data structure types composed of existing types can be stored as a sequence of those existing types while still retaining structural identity. If a new type is added to an existing property set, code that knows how to read the old version of the property set will robustly skip the new unknown type.</LI></UL><P>In one sentence, a general property set is a serial collection of property values in which each property is tagged with a type (a VT_* value) and a 32-bit <I>property identifier,</I> or PID. This information is stored in the order PID, type, value so that any code reading the property set can first check the identifier to see whether the property is of interest, and if so, it can read the type. That type then describes the format and length of the value that follows in the stream. This sort of structure means that the semantics of the type are easily determined, although the meaning of the value is left to the program to decide. The property set writer can also include a dictionary that maps binary PIDs to human-readable strings for display in the user interface.</P>
<P>Individual properties are grouped into a <I>format,</I> or <I>section.</I> Each section, tagged with a <I>format identifier,</I> or FMTID, represents a particular set of properties, although any code reading this format will again attempt to read only those properties that exist.</P>
<P>Obviously, because a property set is intended to be used as a data exchange format, you'd think some standards must exist as far as property identifiers and format identifiers are concerned, yes? Well, yes and no. Take a quick look through the standard OLE header files on your machine for any value that starts with PID_. (Include a space before the P so that you don't pick up DISPID_ values.) You didn't find any, did you? Now look for anything containing FMTID. Didn't find any for that either. So do any standards exist? What use is this format specification if there are no standard property or format identifiers?</P>
<P>The fact of the matter is that the plural <I>property sets</I> describes a general format in which you can store any information. A singular <I>property set</I> describes a named collection of specific information. The specifications for that single property set are responsible for defining which identifiers are used for which formats and properties, giving each property a name that is meaningful in the context of that single property set. The format identifiers themselves are GUIDs, and the designer of the specific property set is responsible for assigning a GUID as the FMTID. For example, I mentioned the Summary Information property set at the beginning of this chapter. This set is assigned the FMTID <I>F29F85E0-4FF9-1068-AB91-08002B27B3D9</I> and is defined to contain strings for a document title, a subject, an author, keywords, and comments; integers for page count, word count, and character count; time stamps for creation, modification, and print times; and so on. In the Summary Information set, the symbol PID_TITLE, for example, is assigned the value 2 and has the type VT_LPSTR. In another property set, the PID 2 might be for something completely different, but because the second set has its own FMTID, no one will attempt to interpret that property as if it belonged to a different format. So while the specific contents of any two sets differ, the means of storing individual values in a PID/type/value triplet is the same. In other words, a VT_LPSTR will always have the same layout in the stream regardless of the specific property set.</P></font></body></HTML>
