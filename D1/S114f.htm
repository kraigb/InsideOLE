<HTML><HEAD><TITLE>Creating and Initializing Objects from a CLSID</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Creating and Initializing Objects from a CLSID</H3><P>Given a CLSID, you can create objects in two ways:</P>
<UL><LI>If you need only one object, call the COM API function <I>CoCreateInstance</I> with the CLSID and the IID of the interface you want on the object.</LI><LI>If you need more than one object, call <I>CoGetClassObject</I> to obtain an <I>IClassFactory </I>pointer for that CLSID, and then call <I>IClassFactory::CreateInstance</I> as often as you want with the desired IID. Call <I>IClassFactory::Release</I> when you have finished.</LI></UL><P><I>CoCreateInstance </I>is really nothing more than a convenient wrapper around <I>CoGetClassObject</I> and <I>IClassFactory::CreateInstance</I> that creates a single object. The following code shows the basic implementation of this function:</P>
<P><BR></P>
<pre><code>STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter<BR>    , DWORD dwContext, REFIID iid, void **ppv)<BR>    {<BR>    HRESULT        hr;<BR>    IClassFactory *pCF;<BR><BR>    *ppv=NULL;<BR><BR>    hr=CoGetClassObject(rclsid, dwContext, NULL, IID_IClassFactory<BR>        , (void **)&amp;pCF);<BR><BR>    if (FAILED(hr))<BR>        return hr;<BR><BR>    hr=pCF-&gt;CreateInstance(pUnkOuter, iid, ppv);<BR>    pCF-&gt;Release();<BR>    return hr;<BR>    }</code></pre>
<P>What the arguments to this function mean is not hard to figure out: <I>rclsid </I>is the CLSID of interest, <I>pUnkOuter </I>points to the outer unknown if this call is being made for aggregation purposes, and <I>riid </I>and <I>ppv </I>are just like the arguments passed to <I>QueryInterface </I>that specify the type of interface pointer to obtain from the newly created object. The most interesting argument is <I>dwContext</I>, which allows the caller to restrict the types of servers used for the object: it can be CLSCTX_INPROC_SERVER, CLSCTX_INPROC_HANDLER, CLSCTX_LOCAL_SERVER, or any combination of these values. The value CLSCTX_ALL is defined as the combination of all three. So a client (or an aggregate object) can choose to use only handlers or only in-process or local servers. You can play with these flags to change the order in which COM typically looks for servers (normally, in-process, handler, local).</P>
<P>In looking at the code for <I>CoCreateInstance</I>, you can see where <I>pUnkOuter</I>, <I>riid</I>, and <I>ppv </I>are passed to <I>IClassFactory::CreateInstance</I>, which is the only place they are used. This leaves the function <I>CoGetClassObject</I>, whose sole purpose in life is to access a class factory for a specific CLSID, returning some interface pointer to that factory. Its complete function prototype and argument list are as follows:</P>
<P><BR></P>
<pre><code>HRESULT CoGetClassObject(REFCLSID clsid, DWORD dwContext<BR>    , LPOLESTR pszRemote, REFIID iid, void **ppv)</code></pre>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="74pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Argument</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P>clsid</P></TD><TD VALIGN="TOP"><P>A REFCLSID identifying the class factory to obtain</P></TD></TR><TR><TD VALIGN="TOP"><P>dwContext</P></TD><TD VALIGN="TOP"><P>A DWORD identifying the allowable execution contexts</P></TD></TR><TR><TD VALIGN="TOP"><P>pszRemote</P></TD><TD VALIGN="TOP"><P>An LPOLESTR to the name of the remote machine on which the remote server is to run5</P></TD></TR><TR><TD VALIGN="TOP"><P>iid</P></TD><TD VALIGN="TOP"><P>A REFIID identifying the interface to obtain on the factory object6</P></TD></TR><TR><TD VALIGN="TOP"><P>ppv</P></TD><TD VALIGN="TOP"><P>A void ** in which to store the interface pointer upon return</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Calling <I>CoGetClassObject </I>yourself is necessary in three situations:</P>
<UL><LI>You want to create more than one object from the same class factory</LI><LI>You need to obtain an interface other than <I>IClassFactory </I>on the class factory, such as <I>IClassFactory2</I></LI><LI>You need to call <I>IClassFactory::LockServer</I></LI></UL><P>In all of these cases, <I>CoCreateInstance </I>is either inefficient for the task (the first case) or unable to perform the task (the second and third cases), so you must go to the class factory directly. Be sure to call <I>Release </I>when you're finished with the class factory, even if you still hold interface pointers to objects you created through it.</P>
<P>Note once again that <I>IClassFactory::CreateInstance </I>(and therefore <I>CoCreateInstance</I>) creates an uninitialized object, so the first act a client should perform is to query for an appropriate initialization interface and call an initialization member function. But whether this really happens depends on the type of object in question because some objects need no initialization. Usually such requirements are defined (and documented) as part of the prototype of which the object class is an instance.</P>
<P>One last note: if <I>CoCreateInstance </I>or <I>CoGetClassObject </I>returns REGDB_E_CLASSNOTREG, check the registry. You might have forgotten to register a server, or those entries might have been corrupted. The registry is always a good place to start looking for problems when object creation fails.</P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="432pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B></B></P></TD></TR><TR><TD VALIGN="TOP"><P>5 At the time of writing this argument was nonfunctional as OLE's distributed services are not yet available. A NULL value must be passed in the meantime. When distributed services are available there will be more than just <I>pszRemote </I>involved to access a remote server—for example security and load balancing. This will most likely be handled through use of monikers that can dynamically determine which server to use and that can perform security checks. The <I>pszRemote </I>argument is really intended for later use with such monikers.</P></TD></TR><TR><TD VALIGN="TOP"><P>6 Windows NT 3.5 allows a client to pass <I>IID</I><I>_</I><I>IClassFactory</I> in this argument only when a local server is going to be used. This restriction will be removed in the near future.</P></TD></TR></TBODY></TABLE>
<P><BR></P></font></body></HTML>
