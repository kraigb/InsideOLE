<HTML><HEAD><TITLE>Optional: Implement IPersistFile and Register as Running</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Optional: Implement <I>IPersistFile</I> and Register as Running</H3><P>You might want to add the <I>IPersistFile</I> interface to your document object, associate your file type (through extension or a CLSID in a compound file) with your document object's CLSID, and register a file moniker for any loaded document in the running object table. This allows controllers to access an object that represents the contents of the file instead of a new document, whether or not the document is already loaded. For example, Visual Basic supports an object-creation function that can take a filename as an argument:</P>
<P><BR></P>
<pre><code>Dim doc as Object<BR>set doc = CreateObject("sample.doc")</code></pre>
<P>The <I>CreateObject</I> function takes the filename in the argument, creates a file moniker with it, and then calls that moniker's <I>BindToObject(IID</I><I>_</I><I>IDispatch)</I> to get the <I>IDispatch</I> pointer for an object that has that document loaded. To support this construct, you have to support the binding action of a file moniker, as we've seen in Chapter 9. This means implementing <I>IPersistFile</I> right next to your document's <I>IDispatch</I>. Without this sort of support, you would require controllers to first create an instance of your application object, then get the documents collection, and then ask that collection to open the same file:</P>
<P><BR></P>
<pre><code>Dim app as Object<BR>Dim doc as Object<BR>set app = CreateObject("Name.Application")<BR>set doc = app.Documents.Open("sample.doc")</code></pre>
<P>Granted, this isn't much more code, but it is more confusing to the controller's user because it is much more indirect. Users like to specify their intentions as directly as possible, and getting at a document through the application <FONT FACE="Symbol">&reg;</FONT> collection <FONT FACE="Symbol">&reg;</FONT> document sequence is not as direct as asking for the document in the first place.</P>
<P>When you do load a document, you should create a file moniker for the name with <I>CreateFileMoniker</I> and register that moniker along with your document object's <I>IUnknown</I> in the running object table. This allows a controller to support some syntax that would allow run-time connection to a running instance. Visual Basic supports this through the <I>GetObject</I> function, which creates a moniker based on the arguments given to the function and checks whether that moniker is in the running object table. If so, it connects immediately. If not, it binds that moniker, which will launch your application and work with your <I>IPersistFile</I> interface to get the document loaded.</P>
<P>Of course, you might want to support binding to more than just the document as a whole, which involves composite monikers and implementations of other interfaces such as <I>IOleItemContainer</I> to support binding to item monikers in the composite. This is great when you have a deep hierarchy. If you have addressable objects within a document, it makes sense to allow a controller to access these objects directly, without having to navigate the hierarchy.</P></font></body></HTML>
