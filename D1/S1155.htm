<HTML><HEAD><TITLE>ObjectUser</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>ObjectUser</H3><P>When you start ObjectUser, you'll see (after COM is initialized) a small window with a single menu. With the menu items on this menu you can do the following:</P>
<UL><LI>Select which server to use, DLL or EXE. This controls the CLSCTX flags that ObjectUser will pass to <I>IClassFactory::CreateInstance</I>. The choice is stored in the flag <I>CApp::m</I><I>_</I><I>fEXE.</I></LI><LI>Create a Koala object with the selected server through either <I>CoCreateInstance </I>or <I>CoGetClassObject </I>and <I>IClassFactory::CreateInstance</I>.</LI><LI>Call <I>AddRef </I>and <I>Release </I>for the available Koala object, displaying its reference count as well as a "usage count" that ObjectUser maintains to track its own calls to <I>AddRef </I>and <I>Release.</I></LI></UL><P>When you select the Create (CoGetClassObject) menu item, you end up in the IDM_OBJECTCREATECOGCO case of <I>ObjectUserWndProc </I>in OBJUSER.CPP. This selection provokes the execution of the following code (<I>pApp </I>is a pointer to the ObjectUser application structure that maintains variables such as <I>m</I><I>_</I><I>pIUnknown</I>, a pointer to the last Koala object created):</P>
<P><BR></P>
<pre><code>HRESULT         hr;<BR>LPCLASSFACTORY  pIClassFactory;<BR>DWORD           dwClsCtx;<BR><BR>    [Other code omitted]<BR><BR>    case IDM_OBJECTCREATECOGCO:<BR>        if (NULL!=pApp-&gt;m_pIUnknown)<BR>            {<BR>            while (pApp-&gt;m_cRefOurs--)<BR>                ReleaseInterface(pApp-&gt;m_pIUnknown);<BR><BR>            CoFreeUnusedLibraries();<BR>            }<BR><BR>         dwClsCtx=(pApp-&gt;m_fEXE) ? CLSCTX_LOCAL_SERVER<BR>            : CLSCTX_INPROC_SERVER;<BR><BR>         hr=CoGetClassObject(CLSID_Koala, dwClsCtx, NULL<BR>            , IID_IClassFactory, (PPVOID)&amp;pIClassFactory);<BR><BR>         if (SUCCEEDED(hr))<BR>            {<BR>            hr=pIClassFactory-&gt;CreateInstance(NULL<BR>                , IID_IUnknown, (PPVOID)&amp;pApp-&gt;m_pIUnknown);<BR><BR>            pIClassFactory-&gt;Release();<BR><BR>            if (SUCCEEDED(hr))<BR>                {<BR>                pApp-&gt;Message(TEXT("Creation succeeded."));<BR>                pApp-&gt;m_cRefOurs=1;<BR>                }<BR>            else<BR>                pApp-&gt;Message(TEXT("Creation failed."));<BR>            }<BR>        else<BR>            pApp-&gt;Message(TEXT("CoGetClassObject failed."));<BR><BR>        break;</code></pre>
<P>The Create (CoCreateInstance) menu command does exactly the same thing in a more concise manner because we're creating only one instance of the object:</P>
<P><BR></P>
<pre><code>    case IDM_OBJECTCREATECOCI:<BR>        if (NULL!=pApp-&gt;m_pIUnknown)<BR>            {<BR>            while (pApp-&gt;m_cRefOurs--)<BR>                ReleaseInterface(pApp-&gt;m_pIUnknown);<BR><BR>            CoFreeUnusedLibraries();<BR>            }<BR><BR>        //Simpler creation: use CoCreateInstance.<BR>        dwClsCtx=(pApp-&gt;m_fEXE) ? CLSCTX_LOCAL_SERVER<BR>            : CLSCTX_INPROC_SERVER;<BR><BR>        hr=CoCreateInstance(CLSID_Koala, NULL, dwClsCtx<BR>            , IID_IUnknown, (PPVOID)&amp;pApp-&gt;m_pIUnknown);<BR><BR>        if (SUCCEEDED(hr))<BR>            {<BR>            pApp-&gt;Message(TEXT("Creation succeeded."));<BR>            pApp-&gt;m_cRefOurs=1;<BR>            }<BR>        else<BR>            pApp-&gt;Message(TEXT("Creation failed."));<BR><BR>        break;</code></pre>
<P>The two sequences of code produce exactly the same result: an <I>IUnknown </I>pointer to the new Koala instance. If an instance is already available, we first call <I>m</I><I>_</I><I>pIUnknown-&gt;Release </I>as many times as needed to free the object<I> </I>(through the <I>ReleaseInterface</I> macro in INC\INOLE.H) and then call <I>CoFreeUnusedLibraries.</I> This latter call allows you to watch what happens in the DKoala1 server's implementation of <I>DllCanUnloadNow</I>.</P>
<P>ObjectUser maintains in the variable <I>pApp-&gt;m</I><I>_</I><I>cRefOurs </I>a count of how many references it thinks it owns on the object. The counter is initially 0 but is set to 1 after creating an instance. ObjectUser's AddRef and Release menu items either increment or decrement this counter, after which ObjectUser displays the reference count returned from the object's function next to its own counter.</P>
<P>When you run ObjectUser with the DLL server option, you'll see that the object's reference count and ObjectUser's internal count are equal. But when you use the EXE server, you'll see something strange: the value returned by any call to <I>AddRef </I>might be something huge like 1336120 and remain that way no matter how many <I>AddRef </I>calls you make. In the same manner, this number is also returned from <I>Release </I>as long as the actual reference count is nonzero. Why is this? The specification for <I>IUnknown::Release</I> (described in Chapter 2) explicitly states that the client cannot attach any meaning to a nonzero return value. In addition, the client cannot really attach much meaning to a zero return value except for knowing that its own responsibility for the object is complete. In no way does the return value tell you whether the object has actually been destroyed—at most it tells you that the in-process proxy object has been destroyed and that you can no longer access the local or remote object to which you were connected. That object, however, could easily remain running if other clients are accessing it as well.</P>
<P>To prevent clients from reading too much into the return value from <I>AddRef </I>and <I>Release</I>, proxy objects generally return some large constant unless the proxy is destroyed, in which case <I>Rele</I><I>ase </I>returns 0. Of course, because proxy objects are not used with in-process servers such as DKoala1, a client will generally get back the actual object reference count. In any case, clients can't do very much with the information.</P></font></body></HTML>
