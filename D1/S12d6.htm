<HTML><HEAD><TITLE>The Links Dialog Box and the IOleUILinkContainer Interface</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>The Links Dialog Box and the <I>IOleUILinkContainer</I> Interface</H3><P>Now we come to what I consider the ugliest part of implementing a container application: the Links dialog box. This dialog is supposed to show <I>all</I> links in the current document. In Patron, I found this difficult to implement because I open only one page at a time, and opening all the pages at once only for this dialog would be a major change to the application architecture. So instead, Patron shows only the links in the current page.</P>
<P>As rich as this dialog is, we're fortunate that it's implemented in the OLE UI Library through <I>OleUIEditLinks</I>,<I> </I>which takes an OLEUIEDITLINKS structure. The only custom field (not common to all the OLE dialogs) in this structure, <I>lpOleUILinkContainer</I>,<I> </I>is a pointer to an interface named <I>IOleUILinkContainer</I>, which is defined in OLEDLG.H for the express purpose of the Links dialog box:</P>
<P><BR></P>
<pre><code>interface IOleUILinkContainer : IUnknown<BR>    {<BR>    DWORD   GetNextLink(DWORD dwLink);<BR>    HRESULT SetLinkUpdateOptions(DWORD dwLink, DWORD dwUpdateOpt);<BR>    HRESULT GetLinkUpdateOptions(DWORD dwLink<BR>        , DWORD *lpdwUpdateOpt);<BR>    HRESULT SetLinkSource(DWORD dwLink, LPOLESTR lpszDisplayName<BR>        , ULONG lenFileName, ULONG *pchEaten, BOOL fValidateSource);<BR>    HRESULT GetLinkSource(DWORD dwLink, LPOLESTR *lplpszDisplayName<BR>        , ULONG *lplenFileName, LPOLESTR *lplpszFullLinkType<BR>        , LPOLESTR *lplpszShortLinkType, BOOL *lpfSourceAvailable<BR>        , BOOL *lpfIsSelected);<BR>    HRESULT OpenLinkSource(DWORD dwLink);<BR>    HRESULT UpdateLink(DWORD dwLink, BOOL fErrorMessage<BR>        , BOOL fErrorAction);<BR>    HRESULT CancelLink(DWORD dwLink);<BR>    };</code></pre>
<P>This interface is the way the Links dialog box calls back to the container to tell the container to perform actions in response to the end user's actions in the dialog box itself. You can see direct analogs between controls in the dialog (Figure 20-4 on page 954) and the member functions of this interface. <I>GetNextLink </I>is what the dialog uses to enumerate the container's linked objects in order to populate the list box. This is a better mechanism than something like messages or a hook procedure. The table on the following page describes when each function is called.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>Function</B></P></TD><TD VALIGN="TOP"><P><B>When Called</B></P></TD></TR><TR><TD VALIGN="TOP"><P>GetNextLink, GetUpdateOptions, GetLinkSource</P></TD><TD VALIGN="TOP"><P>All three of these functions are used to fill the dialog box. The dialog box manages a DWORD for each link in the list box, and <I>GetNextLink</I> is the function called repeatedly to obtain those DWORDs. Typically, this will be some pointer. When the dialog box initially fills the list box, it will, after calling <I>GetNextLink</I>, call <I>GetUpdateOptions</I> and <I>GetLinkSource</I> to obtain additional information to create the list box items.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetLinkUpdateOptions</P></TD><TD VALIGN="TOP"><P>Called when the user selects the Automatic or Manual option button.</P></TD></TR><TR><TD VALIGN="TOP"><P>SetLinkSource</P></TD><TD VALIGN="TOP"><P>Called when the user makes changes in the Change Source dialog box.</P></TD></TR><TR><TD VALIGN="TOP"><P>OpenLinkSource</P></TD><TD VALIGN="TOP"><P>Called when the user chooses Open Source.</P></TD></TR><TR><TD VALIGN="TOP"><P>UpdateLink</P></TD><TD VALIGN="TOP"><P>Called when the user chooses Update Now.</P></TD></TR><TR><TD VALIGN="TOP"><P>CancelLink</P></TD><TD VALIGN="TOP"><P>Called when the user chooses Break Link.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>To invoke the Links dialog box, we'll need an implementation of this interface. Patron's implementation comes from <I>CIOleUILinkContainer</I>, defined in PAGES.H and implemented in IUILINK.CPP. The header comments in the source file itself describe the arguments and necessary behavior of each member. Let me also point out that <I>CIUILinkContainer </I>uses the value <I>IID</I><I>_</I><I>IOleUILinkContainer </I>in its <I>QueryInterface</I> function<I>. </I>I could leave this out because the OLE UI Library is the only client of this object, and it never calls <I>QueryInterface</I>. In addition, OLE doesn't define this IID itself—I've defined it for my own uses in INC\BOOKGUID.H with one of my own values. Basically, no standard IID is assigned to this oddball.</P>
<P>As seems typical with my code, a few weird things deserve explanation. First is the extra protected function I've added to <I>CIUILinkContainer. </I>Named <I>GetObjectInterface</I>, the function merely queries for an interface pointer from a tenant identified by the DWORD <I>dwLink</I>. For Patron, every DWORD identifier in this interface is a pointer to a <I>CTenant</I>. Because most of what we use in <I>IOleUILinkContainer</I> is a pointer to <I>IOleLink</I>, the <I>GetObjectInterface</I> function exists to clean up the code everywhere else.</P>
<P>Next, because this is a stand-alone object, it maintains some of its own variables, such as <I>m</I><I>_</I><I>pPage</I>, a pointer to the current page from which we can obtain tenant pointers; <I>m</I><I>_</I><I>iTenant</I>, which is used to implement <I>GetNextLink</I>; and <I>m</I><I>_</I><I>fDirty</I>, which is a public variable in <I>CIOleUILinkContainer</I> and operates in such a way that after invoking the Links dialog box, the code in <I>CPatronDoc</I> can see whether anything happened in the dialog box that would make the document dirty. This is a little inelegant, but it provides an efficient way for the document to know whether any changes occurred.</P>
<P>There's also <I>m</I><I>_</I><I>pDelIUILinks</I>, which has to do with the other strange part of this code: a call to <I>CoCreateInstance</I> with <I>CLSID</I><I>_</I><I>LinksAssistant </I>found in <I>CIOleUILinkContainer::Init</I>. This CLSID refers to a component (named Links Assistant) that I implemented to help me—and ultimately you—implement the <I>IOleUILinkContainer</I> interface. The source code for this component is found in CHAP20\LNKASSIS and is compiled as LNKASSIS.DLL. You must be sure to register this component to make Patron work properly. (Patron's REG files include the entries as well, for convenience.)</P>
<P><BR></P>
<pre><code>BOOL CIOleUILinkContainer::Init(void)<BR>    {<BR>    HRESULT     hr;<BR><BR>    hr=CoCreateInstance(CLSID_LinksAssistant, NULL<BR>        , CLSCTX_INPROC_SERVER, IID_IOleUILinkContainer<BR>        , (PPVOID)&amp;m_pDelIUILinks);<BR><BR>    return SUCCEEDED(hr);<BR>    }</code></pre>
<P>Links Assistant essentially provides default implementations of most of the <I>IOleUILinkContainer </I>member functions to which we can delegate, as you'll see in the IUILINK.CPP code. (Yep, we like delegation; it makes life easier.) I created this object because, in my opinion, the developers of the original OLE UI Library were in a hurry and put a greater burden on the container's implementation of <I>IOleUILinkContainer </I>than necessary. Links Assistant contains the container-independent parts of this interface that I think could have been built into the dialog in the first place. Take a look at the source code if you're interested in the grungy details. I won't show any of it here.</P>
<P>That leaves us to look at the interesting parts of <I>IOleUILinkContainer</I>. First, <I>GetNextLink</I> is an iterative function that is called in order to fill the list in the dialog box. The first call passes a 0 in <I>dwLink</I>, meaning "Return the first linked object." What it returns is again a DWORD that all the other functions are passed to identify which object is being manipulated. <I>GetNextLink</I> returns a 0 when there are no more links. Patron is concerned only with keeping an index of the current tenant to return (<I>m</I><I>_</I><I>iTenant</I>), and when this function is called, it gets the tenant pointer and checks to see whether it's an embedded or a linked object by means of the function <I>CTenant::TypeGet</I>. (Note that Links Assistant can't implement this function, so it simply returns an error.)</P>
<P><BR></P>
<pre><code>STDMETHODIMP_(DWORD) CIOleUILinkContainer::GetNextLink(DWORD dwLink)<BR>    {<BR>    PCTenant        pTenant;<BR><BR>    //If we're told to start sequence, set index to 0.<BR>    if (0L==dwLink)<BR>        m_iTenant=0;<BR><BR>    /*<BR>     * On each subsequent call, find next linked object in<BR>     * this document and return it. Be sure index is<BR>     * incremented for next time this function is called.<BR>     */<BR>    for ( ; m_iTenant &lt; m_pPage-&gt;m_cTenants; m_iTenant++)<BR>        {<BR>        if (m_pPage-&gt;TenantGet(m_iTenant, &amp;pTenant, FALSE))<BR>            {<BR>            if (TENANTTYPE_LINKEDOBJECT==pTenant-&gt;TypeGet())<BR>                {<BR>                m_iTenant++;<BR>                return (DWORD)pTenant;<BR>                }<BR>            }<BR>        }<BR><BR>    //If we hit end of list, this tells dialog to stop.<BR>    return 0L;<BR>    }</code></pre>
<P><I>SetUpdateOptions </I>and <I>GetUpdateOptions </I>do little more than call the same named functions in <I>IOleLink</I>. <I>SetUpdateOptions</I>,<I> </I>however, sets the dirty flag if the change succeeds.</P>
<P><I>SetLinkSource</I> is called when the user changes the source of the link. The implementation of this function is somewhat complex, so most of the meat is down in the Links Assistant object. If the change was successful, we set <I>m</I><I>_</I><I>fDirty</I> so that the rest of the application knows. We also must remember whether this change worked for the implementation of <I>GetLinkSource</I>. We do this here with a public flag in <I>CTenant</I> named <I>m</I><I>_</I><I>fLinkAvail</I>, which was added to <I>CTenant</I> specifically for this interface. It's part of <I>CTenant</I> because we need to maintain one value for each object, not for the <I>IOle</I><I>UILinkContainer</I> interface as a whole. With this flag, we start by assuming that the new source is not valid, but if Links Assistant succeeds in changing the source, we can mark it as available. The reason we need to remember is exposed in <I>GetLinkSource</I>, which is called whenever the Links dialog box needs to update the list box entry for an object. <I>GetLinkSource</I> returns a flag indicating whether the link source is available, which is simply <I>CTenant::m</I><I>_</I><I>fLinkAvail</I>, and another flag indicating whether the object is currently selected in the container, which the application determines by calling another new function, <I>CTenant::FIsSelected</I>. The rest of the information needed from <I>GetLinkSource</I> is handled by the code in Links Assistant. If you say this object is unavailable, the rightmost column of the list box entry will read <I>Unavail</I>. If you say the object is selected, that entry, as well as any others that you say are selected, will be selected when the dialog box is initially displayed. The selected flag is meaningless anytime thereafter, however.</P>
<P><I>OpenLinkSource</I> is another way of saying "activate with OLEIVERB_OPEN." So that's what we do. <I>UpdateLink</I> is not quite as simple: Links Assistant calls <I>IOleObject::IsUpToDate</I>, and if it returns S_FALSE, Links Assistant calls <I>IOleObject::Update</I>, which might launch servers to obtain the update. Because the presentation might have changed, we should repaint the container site as well as update the tenant's <I>m</I><I>_</I><I>fLinkAvail</I> according to the success of the update. If the argument <I>fErrorMessage</I> is set, we're also responsible for displaying some meaningful error message on failure.</P>
<P>The last function in this interface, <I>CancelLink</I>, is meant to convert a linked object to a static object—that is, it causes the object to lose the ability to be activated and disconnects the object entirely from its link source. Links Assistant disconnects the object by calling <I>IOleLink::SetSourceMoniker(NULL)</I>, which forces the linked object to forget about its source completely, although the object still maintains any cached presentations. We want to keep those presentations, however, because a static object still needs something to show for itself.</P>
<P>Removing an object's ability to be activated is handled by yet another new function in Patron, <I>CTenant::ConvertToStatic</I>. I use this function to mark the object as static, which effectively prevents the tenant from activating it. This makes the object appear to be static, although it's still a linked object as far as OLE is concerned:</P>
<P><BR></P>
<pre><code>BOOL CTenant::ConvertToStatic(void)<BR>    {<BR>    m_tType=TENANTTYPE_STATIC;<BR>    return TRUE;<BR>    }</code></pre>
<P>The catch in all of this is that we must remember that this object is static when we reload it. Patron handles this situation with a flag in its storage and code in <I>CTenant::ObjectInitialize </I>that calls <I>IOleLink::GetSourceMoniker</I>. Because we set the moniker to NULL, this call will return NULL as well, and we use that condition to reinitialize the object as static.</P>
<P>So that does it for implementing the <I>IOleUILinkContainer</I> interface. Now let's see where we use it.</P></font></body></HTML>
