{\rtf1\ansi \deff8\deflang1033{\fonttbl{\f3\fmodern\fcharset0\fprq1 Courier;}{\f4\froman\fcharset0\fprq2 Times New Roman{\*\falt Times};}{\f5\fswiss\fcharset0\fprq2 Arial{\*\falt Helvetica};}
{\f8\froman\fcharset0\fprq2 Times;}{\f11\fmodern\fcharset0\fprq1 Courier New{\*\falt Courier};}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;
\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\nowidctlpar \f8\fs20 \snext0 Normal;}{\s1\sb240\sa60\keepn\nowidctlpar \b\f5\fs28\kerning28 \sbasedon0\snext17 heading 1;}{\s2\sb240\sa60\keepn\nowidctlpar \b\i\f5 \sbasedon0\snext17 heading 2;}{\s3\sb240\sa60\keepn\nowidctlpar \b\f4 \sbasedon0\snext17 
heading 3;}{\s4\sb240\sa60\keepn\nowidctlpar \b\i\f4 \sbasedon0\snext17 heading 4;}{\s5\sb240\sa60\nowidctlpar \f5\fs22 \sbasedon0\snext0 heading 5;}{\s6\sb240\sa60\nowidctlpar \i\f5\fs22 \sbasedon0\snext0 heading 6;}{\s7\sb240\sa60\nowidctlpar \f5\fs20 
\sbasedon0\snext0 heading 7;}{\s8\sb240\sa60\nowidctlpar \i\f5\fs20 \sbasedon0\snext0 heading 8;}{\s9\sb240\sa60\nowidctlpar \i\f5\fs18 \sbasedon0\snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\s15\ri-480\sa120\sl-240\slmult1\nowidctlpar 
\f4\fs20 \sbasedon16\snext15 footer;}{\s16\sb240\sa120\sl-240\slmult1\nowidctlpar \b\f4\fs20 \snext17 *Heads;}{\s17\sa120\sl-360\slmult1\nowidctlpar \f8\fs22 \sbasedon18\snext19 NonIndent Para;}{\s18\sb120\sa120\sl-360\slmult1\nowidctlpar \f8\fs22 
\snext18 *Text;}{\s19\fi360\sb120\sa120\sl-360\slmult1\nowidctlpar \f8\fs22 \sbasedon18\snext19 Indent Para;}{\s20\qr\ri-480\sa120\sl-240\slmult1\nowidctlpar \b\f4\fs20 \sbasedon16\snext20 header;}{\s21\sl-240\slmult1\nowidctlpar \f3\fs20 \snext21 *User;}
{\s22\fi-360\li720\sa120\sl-360\slmult1\nowidctlpar\tx720 \f4\fs22 \snext22 *List;}{\s23\sb180\sa480\nowidctlpar\box\brdrs\brdrw15\brsp20 \f8\fs20 \sbasedon0\snext23 *Graphic;}{\s24\li-360\sb240\sa120\nowidctlpar \b\f4\fs36 \sbasedon16\snext17 Ch Head;}{
\s25\li-360\sb240\sa120\sl-320\slmult1\nowidctlpar \b\f4\fs30 \sbasedon16\snext17 A Head;}{\s26\sb240\sa120\sl-240\slmult1\nowidctlpar \b\f4\fs26 \sbasedon16\snext17 B Head;}{\s27\li360\sb180\sa180\nowidctlpar\box\brdrs\brdrw15\brsp20 \f8\fs20 
\sbasedon23\snext28 Fig-Graphic;}{\s28\li360\sb120\sa360\sl-220\slmult1\nowidctlpar \f8\fs22 \sbasedon18\snext17 caption;}{\s29\sb240\sa200\nowidctlpar \b\f4\fs22 \sbasedon16\snext17 C Head;}{\s30\fi-360\li720\sa120\sl-360\slmult1\nowidctlpar\tx720 
\f4\fs22 \sbasedon22\snext30 Bull List;}{\s31\fi-360\li720\sb120\sa120\sl-360\slmult1\nowidctlpar\tx720 \f4\fs22 \sbasedon22\snext31 Num List;}{\s32\li720\sa120\sl-360\slmult1\nowidctlpar\tx720 \f4\fs22 \sbasedon22\snext32 List Para;}{
\s33\li720\sb180\sa180\nowidctlpar\box\brdrs\brdrw15\brsp20 \f8\fs20 \sbasedon23\snext31 List Graphic;}{\s34\li360\ri360\sb240\sl-240\slmult1\nowidctlpar \b\f4\fs20 \sbasedon16\snext35 Sbar Head;}{\s35\li360\sa120\sl-360\slmult1\nowidctlpar \f8\fs22 
\sbasedon18\snext35 Sbar Text;}{\s36\li360\sb120\sa240\sl-360\slmult1\nowidctlpar \f8\fs22 \sbasedon18\snext19 Note;}{\s37\li360\sb300\sl-240\slmult1\nowidctlpar \b\f4\fs20 \sbasedon16\snext37 Table Head;}{\s38\li360\sb60\sa60\sl-360\slmult1\nowidctlpar 
\f8\fs22 \sbasedon18\snext38 Table Text;}{\s39\ri-1200\sb60\sa60\sl-240\slmult1\nowidctlpar \f11\fs20 \sbasedon21\snext39 Prog List;}{\s40\nowidctlpar \f8\fs20 \sbasedon0\snext40 footnote text;}{\s41\li4320\nowidctlpar \f8\fs20 \sbasedon0\snext41 
Signature;}{\*\cs42 \additive\super \sbasedon10 footnote reference;}}{\info{\author Raistlin Majere}{\operator Dick Carter}{\creatim\yr1995\mo5\dy2\hr16\min58}{\revtim\yr1995\mo5\dy2\hr16\min58}{\printim\yr1995\mo5\dy3\hr20\min7}{\version1}{\edmins1}
{\nofpages13}{\nofwords3001}{\nofchars17110}{\vern49221}}\margr2160 \widowctrl\ftnbj\aenddoc\noextrasprl\prcolbl\cvmme\sprsspbf\brkfrm\swpbdr\hyphcaps0 \fet0\sectd \linex0\endnhere {\header \pard\plain \s20\qr\ri-480\sa120\sl-240\slmult1\widctlpar 
\b\f4\fs20 \tab {\field{\*\fldinst PAGE}{\fldrslt 1}}
\par }{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s24\li-360\sb240\sa120\nowidctlpar \b\f4\fs36 Notes Concerning 16-Bit OLE
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 This edition of {\i Inside OLE} focuses on  32-bit operating systems. There are, however, still some important considerations for 16-bit OLE components, which we\rquote ll cover in this appendix.

\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 2
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Globally Unique Identifiers (GUIDs)
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 In 16-bit OLE, {\i CoCreateGuid }is a duplicate implementation of {\i UUIDCreate}. It is not available elsewhere in the system, as it is under Win32.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Interface Definitions
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 The Windows 3.1 SDK for 16 bits uses a set of macros that expand to the same code; C and C++ differences are hidden in the macro expansions:
\par \pard\plain \s39\ri-1200\sb60\sa60\sl-240\slmult1\widctlpar \f11\fs20 #undef  INTERFACE\line #define INTERFACE   IUnknown\line \line DECLARE_INTERFACE(IUnknown)\line     \{\line     STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
\line     STDMETHOD_(ULONG,AddRef) (THIS) PURE;\line     STDMETHOD_(ULONG,Release) (THIS) PURE;\line     \};
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Calling Conventions and Parameter Types
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 In 16-bit OLE, the standard call type is {\i __cdecl} rather than {\i __stdcall}, which is used in 32-bit OLE. Header files also include the {\i __far }
keyword, which is necessary only on 16-bit platforms.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 The macro {\i STDMETHOD(method)} expands to {\i HRESULT __cdecl method }whereas {\i STDMETHOD_(type, method) }expands to {\i type __cdecl method}
. The macros STDMETHOD and STDMETHODIMP expand identically but also include {\i __export}.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Return Types:{\i0  HRESULT} and {\i0 SCODE}
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Note #1: HRESULT{\i  }and SCODE{\i  }are different types on 16-bit platforms. To accommodate the differences, a few COM functions that are obsolete for Win32 are still u
sed in the sample code to retain compatibility with Win16 where possible. These are {\i ResultFromScode},{\i  }which turns an SCODE{\i  }into an HRESULT, {\i GetScode }which extracts an SCODE from an HRESULT, and {\i PropagateResult}
, which changes the error value without changing the facility code so you can propagate an error from a low layer while changing the exact error code. Obviously, if you\rquote 
re writing only 32-bit code, you can ignore these functions completely. Otherwise, a little more work is involved because you have to use {\i ResultFromScode }when returning an error value and {\i GetScode }
when you want to check for specific error or success codes. The only exception is NOERROR, which is interchangeable.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Note #2: {\i FormatMessage }is only available with 32-bit OLE.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Aggregation
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 The last two rules are different under 16-bit OLE: When a 16-bit outer object queries for an interface from the inner object, the outer object must immediately call {\i Release }
through that pointer to fix the outer object\rquote s reference count in order to avoid a circul
ar reference. In addition, the inner object must guarantee that all interface pointers remain valid as long as the object itself is valid, even if those interfaces have a zero reference count. The 32-bit change greatly simplifies the aggregation of remote
 (distributed) objects, which will never be an issue under 16-bits.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 COM/OLE Task Requirements
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 There are two additional steps that 16-bit EXEs must perform prior to COM/OLE library initialization; the second also applies to 16-bit DLLs:
\par \pard\plain \s31\fi-360\li720\sb120\sa120\sl-360\slmult1\widctlpar\tx720 \f4\fs22 1.\tab Call the Windows API {\i SetMessageQueue(96)}
 to set your application's message queue size to 96 messages, if possible. This is the size recommended for LRPC handling. This function is not necessary in Win32 because Win32 message queues size dynamically. In the sample code, the macro SETMESSAGEQUEUE
(96){\i  }is used to make this call. This macro expands to nothing under Win32.
\par 2.\tab Verify the library build version by calling either {\i CoBuildVersion} or {\i OleBuildVersion}. (Which one doesn\rquote t matter.) This step is also compiled conditionally in the sample code.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 The following two sections describe these steps in more detail.
\par \pard\plain \s3\sb240\sa60\keepn\widctlpar \b\f4 Enlarge the Message Queue
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 OLE's LRPC implementation works on top of the Windows API function {\i PostMessage}
. In a nutshell, when the user of an object in another application calls one of the object's member functions, the function generates an LRPC call, which in actuality is a {\i PostMessage} call from the first application\rquote 
s process space to the second application. To handle all the possible {\i PostMessage} traffic, Microsoft recommends that OLE applications with even the slightest chance of engaging in LRPC calls call {\i SetMessageQueue}
 set to 96 on startup. Something such as the following should, in fact, be your first step inside {\i WinMain} to ensure that no messages exist in your queue because {\i SetMessageQueue} will destroy anything already there:
\par \pard\plain \s39\ri-1200\sb60\sa60\sl-240\slmult1\widctlpar \f11\fs20 int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev\line     , LPSTR pszCmdLine, int nCmdShow)\line     \{\line     [variables, but NO code]\line     int      cMsg=96;\line \line 
   #ifndef WIN32\line     //Enlarge the queue as large as we can starting from 96\line     while (!SetMessageQueue(cMsg) && (cMsg-=8));\line    #endif\line \line     [Initialization code, message loop, etc.]\line     \}
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 
If you don't enlarge your message queue sufficiently, the Com Library might reject some LRPC calls when your queue is full. Enlarging your message queue provides sufficient space for LRPC traffic.
\par This book\rquote s sample code uses the macro SETMESSAGEQUEUE (in INC\\BOOK1632.H), which isolates the code above. The macro expands to nothing for Win32 targets but includes the SetMessageQueue call for 16-bit targets.
\par \pard\plain \s3\sb240\sa60\keepn\widctlpar \b\f4 Verify the Library Build Version
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Before using any other COM API function ({\i Co}*) on Windows 3.1, a task should call {\i CoBuildVersion }(or {\i OleBuildVersion}
) to get major and minor build numbers in a returned DWORD. This allows you to check whether the libraries on the system are new enough for your component\rquote 
s use. This step is necessary because the OLE DLLs were not shipped as part of the Windows 3.1 platform, but they are in 32-bit platforms such as Windows NT (3.5 and la
ter) and Windows 95. When you do call this function, the high-order word of the return value is a major version number, and the low-order word is the minor version number.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 
This verification of version numbers applies not only to applications but also to DLLs that depend on certain versions of the OLE DLLs. Dependent modules should perform the same checks described here from within their entry code, failing initialization if
 the version numbers do not match expectations.
\par A component can run against only one major version of the libraries, but it can run against any minor version. The version numbers you can run against are compiled into your application as the symbols {\i rmm} (major) and {\i rup}
 (minor), defined in OLE2VER.H. (There is also a {\i rmj} symbol, which might look like the "major" number but is unfortunately not used this way.) These numbers are {\i build numbers }not {\i product release numbers}
. Do not depend on any interpretation of these numbers. With these numbers, you must compare your {\i rmm} to the major version of the libraries, and if they do not match, you must fail loading your application as shown below.
\par \pard\plain \s39\ri-1200\sb60\sa60\sl-240\slmult1\widctlpar \f11\fs20 #include <compobj.h>    //For Ole... functions, use OLE2.H\line #include <ole2ver.h>\line \line .
\par .
\par .\line \line DWORD    dwVer;\line \line dwVer=CoBuildVersion();    //Or OleBuildVersion\line \line if (rmm==HIWORD(dwVer))\line     \{\line     //Major versions match.\line     \line     if (rup <= LOWORD(dwVer))\line         \{\line 
        //Library is newer than or as old as the app; use normally.\line         \}\line     else\line         \{\line         /*\line          * Component was written for newer libraries. Disable features\line 
         * that depend on API or bug fixes in newer libraries or \line          * simply fail altogether.\line          */\line         \}\line     \}\line else\line     //Major version mismatch; fail loading component.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 
Minor version numbers are useful to applications that want to know whether the libraries they've loaded contain a particular function or have a specific bug fix. Let's say minor version 12 of OLE added a function that improves performance over minor versi
on 11. If I load the minor version 11 libraries, I cannot attempt to call that version 12 function. If, however, I find that I am running against minor version 12, I can take advantage of what's available.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Call CoInitialize or OleInitialize
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 In 16-bit OLE, the argument to either of these functions is a pointer to an {\i IMalloc }
implementation through which the caller can customize the task memory allocator. This allocator would then be returned through {\i CoGetMalloc}.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Memory Management
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Note #1: Under 16-bit OLE, you can pass MEMCTX_TASK or MEMCTX_SHARED to {\i CoGetMalloc}. The latter accesses a shared memory allocator that is not supported under 32-bit OLE.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Note #2: The file INC\\BOOK1632.H contains a macro implementation of {\i CoTaskMemFree }which is legal because it has no return value. But you can use this as a model for implementing your own {\i 
CoTaskMemAlloc }and {\i CoTaskMemRealloc }functions for 16-bits if you want.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The MALLOC1 and MALLOC2 Samples
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 The first edition of this book included illustrations of the Windows 3.1 HeapWalk utility, which shows the memory blocks quite readily. HeapWalk doesn\rquote 
t exist in the Win32 SDK, so you have to look at the memory in a debugger.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Aggregation: Outer Object (KOALAA.CPP)
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 A 16-bit object that is not aggregatable itself has to fix its reference count in the same way. In addition, a 16-bit call to {\i m_pIAnimal->Release }here would need to be wrapped in {\i m_cRef++ }
and {\i m_cRef--} as well.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 In addition, the 16-bit aggregation rules (described earlier in this file under \ldblquote Aggregation\rdblquote ) that differ from the 32-bit rules appear in code as follows:
\par \pard\plain \s39\ri-1200\sb60\sa60\sl-240\slmult1\widctlpar \f11\fs20 //Cache a pointer to Animal's IAnimal
\par m_pIAnimal=NULL;
\par hr=m_pIUnknownAnimal->QueryInterface(IID_IAnimal, (void **)&m_pIAnimal);
\par 
\par if (SUCCEEDED(hr))
\par     \{
\par     m_cRef++;
\par     m_pIAnimal->Release();\tab //m_pIAnimal still valid
\par     m_cRef--;
\par     \}
\par 
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 16-bit code can use the 32-bit rules for caching pointers only if the code knows that the outermost unknown is guarded with the 32-bit technique. An obj
ect that is nonaggregatable can safely use the 32-bit method, but 16-bit aggregates that are aggregatable themselves cannot; they must use this older method.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 The artificial reference count in the outer object\rquote s {\i Release }works fine with 16-bit code as well as 32-bit code.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 3
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Type Library and Element Attributes
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Under 16-bit OLE, the NLS API is not part of the operating system, so the API is included as part of OLE itself. This API is documented in the {\i OLE Programmer\rquote s Reference.}
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Type Library Deployment
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 
Under 16-bit OLE, you can have only one type library per module and a bug prevents loading a type library from an EXE. Both limitations are removed in 32-bit OLE, in which you can have multiple libraries per module, EXE or DLL.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Loading and Using a Type Library
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 {\i LoadTypeLibFromResource }
is first available in OLE 2.02 on 16 and 32 bits. Under 16-bit OLE, this function can load only from DLLs and can load only one library given the resource identifier of one. Under 32-bit OLE, this function can load from DLLs or
 EXEs given any resource identifier.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 5
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Introduction
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Under Win16 the COM Library stands alone and is called COMPOBJ.DLL.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Where the Wild Things Are
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 {\b 16-32 bit Interoperability Between Clients and Components}
: Under a 32-bit operating systems such as Windows NT and Windows 95, or under Windows 3.1 with Win32s, it is possible to have clients and components that are a mixture of 16-bit and 32-bit versions. To accommodate this possibility, 32-bit OLE on Win32 pl
atforms and under Win32s supports interoperability between any combination of like-bitness and any combination involving a local server. The table below summarizes the possible interoperability scenarios
\par \trowd \trgaph108\trleft360 \clbrdrr\brdrs\brdrw15 \cellx1440\cellx2610\cellx3780\cellx5040\cellx6120 \pard\plain \s19\sb120\sa120\sl-360\slmult1\widctlpar\intbl \f8\fs22 \cell Server:\cell \cell \cell \cell \pard\plain \widctlpar\intbl \f8\fs20 \row 
\trowd \trgaph108\trleft360 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx1440\clbrdrb\brdrs\brdrw15 \cellx2610\clbrdrb\brdrs\brdrw15 \cellx3780\clbrdrb\brdrs\brdrw15 \cellx5040\clbrdrb\brdrs\brdrw15 \cellx6120 \pard\plain 
\s19\sb120\sa120\sl-360\slmult1\widctlpar\intbl \f8\fs22 Client\cell 16 In-Proc\cell 16 Local\cell 32 In-Proc\cell 32 Local\cell \pard\plain \widctlpar\intbl \f8\fs20 \row \trowd \trgaph108\trleft360 \clbrdrr\brdrs\brdrw15 \cellx1440\cellx2610\cellx3780
\cellx5040\cellx6120 \pard\plain \s19\sb120\sa120\sl-360\slmult1\widctlpar\intbl \f8\fs22 16-bit\cell \pard \s19\qc\sb120\sa120\sl-360\slmult1\widctlpar\intbl Yes\cell Yes\cell No*\cell Yes\cell \pard\plain \widctlpar\intbl \f8\fs20 \row \trowd 
\trgaph108\trleft360 \clbrdrr\brdrs\brdrw15 \cellx1440\cellx2610\cellx3780\cellx5040\cellx6120 \pard\plain \s19\sb120\sa120\sl-360\slmult1\widctlpar\intbl \f8\fs22 32-bit\cell \pard \s19\qc\sb120\sa120\sl-360\slmult1\widctlpar\intbl No\cell Yes\cell Yes
\cell Yes\cell \pard\plain \widctlpar\intbl \f8\fs20 \row \pard\plain \s17\li360\ri1080\sa120\sl-360\slmult1\widctlpar \f8\fs22 {\fs16 * Windows NT 3.5 actually allows this combination for OLE-defined interfaces other than }{\i\fs16 IDispatch}{\fs16 
, but such support doesn\rquote t exist in Windows 95 or in Windows NT 3.51 (a required upgrade). It is simply a complex testing and development problem, and there is little demand for the feature.
\par }\pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 All of the local server variations are possible because the marshaling layer reduces everything to RPC, so the bitness of either process is not an issue.{\fs16  }
The like-bitness combinations for in-process servers work for custom interfaces as well.{\fs16  }However, even if you provide your own marshaling proxy and stub for a custom interface, OLE allows it only between a 32-bit client and a 32-bit local server.{
\fs16  }In other words, custom interface marshaling cannot be used in a 16-16, 16-32, or 32-16 scenario.
\par Even when 16-32 bit interoperability is supported, there is the possibility that a 32-bit {\i int} or {\i UINT} argument passed to an interface member function could be truncated when it arrives in a 16-bit process as a 16-bit {\i int} or {\i UINT}.{
\fs16  }This is not known to be a problem with the OLE-defined interfaces but is something to consider if you encounter odd problems with incorrect argument values.
\par Also, 32-bit OLE gives different preferences to different types of servers depending on the type of client process.{\fs16  }With a CLSCTX_SERVER passed to {\i CoCreateInstance }from a 32-bit client{\i , }
OLE will attempt to load a server in the order of InprocServer32, LocalServer32, and then LocalServer16.{\fs16  }For a 16-bit client, the order is InprocServer (16-bit), LocalServer32, and then LocalServer16.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The Mechanisms of Server, Client, and COM
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 16-bit executables must also check COM version numbers and enlarge the message queue as described earlier for Chapter 2.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Registry Entries
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 The 16-bit version of COM requires the registry keys InprocServer{\i , }InprocHandler{\i ,} and LocalServer instead of those with the 32 suffix.{\fs16  }
In addition, 16-bit COM does not enforce the requirement for full pathnames.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Expose the Class Factory
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Use the HeapWalk or WPS tools under Windows 3.1 to view loaded modules.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 6
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Introduction
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 As mentioned earlier under \ldblquote Where the Wild Things Are,\rdblquote  {\i int }or {\i UINT }function arguments being passe
d from a 32-bit address space to a 16-bit address space might be truncated, amounting to a real \ldblquote transmission loss.\rdblquote {\fs16  }
For that reason, Microsoft discourages any use of variable-size argument types, with the exception of HWND and other \ldblquote handle\rdblquote  arguments, in any sort of interface function, which you\rquote ll see enforced in all OLE-defined interfaces.
{\fs16  }The problem usually doesn\rquote t show with handles, however, because handle values usually have 0 in the upper 16 bits anyway.{\fs16  }Still, keep this in mind when designing your own interfaces.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Custom Interfaces and Standard Marshaling
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 The {\i ProxyStubClsid32 }entry appears as {\i ProxyStubClsid }for 16-bit marshalers.{\fs16  }
Also, under 32-bit systems, 16-16 custom interfaces are not supported unless the 16-bit DLLs implement the 32-bit interfaces such as {\i IRpcChannelBuffer}.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The Easy Way: The MIDL Compiler
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Standard marshaling support for custom interfaces must be done manually under 16 bits.{\fs16  }There is no MIDL compiler available.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Limitations of Outgoing Calls
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 There are two other relevant errors for 16-bit systems:
\par \trowd \trgaph108\trleft360 \cellx4410\cellx8388 \pard\plain \s19\sb120\sa120\sl-360\slmult1\widctlpar\intbl \f8\fs22 RPC_E_CANTPOST_INSENDCALL\cell The caller is dispatching an intertask {\i SendMessage}
 call to a 16-bit process and cannot make an outgoing asynchronous call with {\i PostMessage}.\cell \pard\plain \widctlpar\intbl \f8\fs20 \row \trowd \trgaph108\trleft360 \cellx4410\cellx8388 \pard\plain \s19\sb120\sa120\sl-360\slmult1\widctlpar\intbl 
\f8\fs22 RPC_E_CANTTRANSMIT_CALL\cell The call was not transmitted properly to a 16-bit process because its message queue was full and was not emptied after yielding.\cell \pard\plain \widctlpar\intbl \f8\fs20 \row \pard\plain \s17\sa120\sl-360\slmult1
\widctlpar \f8\fs22 
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The OLE UI Library
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Under Windows 3.1, use the MFCOLEUI.DLL included with Visual C++ 1.50 and 1.51 with the import library MFCOLEUI.LIB.{\fs16  }
You can also compile your own 16-bit UI DLL using sample code provided in the 16-bit OLE SDK.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 A Simple Client-Side Message Filter:{\fs16  }ObjectUser2
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 OLE doesn\rquote t provide marshaling support for {\i IPersist }by itself under most of its 16-bit versions.{\fs16  }Therefore, to make this sample work, you\rquote 
ll need to modify EKoala3 to respond to {\i IPersistStorage}, returning only an {\i IPersist }pointer, and also modify ObjectUser2 to ask for {\i IPersistStorage }but only call {\i GetClassID}.{\fs16  }
This is a totally illegal thing to do in shipping code, but it will get you marshaling support for {\i IPersist.}{\fs16  }We get away with it here because the client and server both know about this special use of the interface.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Implementing a Custom Interface with MIDL
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 These samples will not compile on 16 bits:{\fs16  }MIDL is not provided there.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 9
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Custom Monikers and Custom Marshaling
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 {\i IMoniker }pointers cannot be marshaled themselves under most versions of 16-bit OLE, with the exceptions of some later versions of OLE 2.02.{\fs16  }Marshaling the persistent data\emdash 
that is, an {\i IStream }that holds the data\emdash is supported because it is required to support custom marshaling in the first place.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Creating and Using Standard Monikers:{\fs16  }LinkUser
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 The samples only compile and run under 32 bits because they require the custom interface {\i IDescription}.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 10
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The {\i0 STGMEDIUM} Structure
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Note #1:{\fs16  }TYMED_ENHMF is not valid under 16-bit Windows because enhanced metafiles are exclusive to Win32.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Note #2:{\fs16  }TYMED_FILE is freed using {\i OpenFile(OF_DELETE, ...) }under 16-bit Windows.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Implementing a Data Object:{\fs16  }DDataObj and EDataObj
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 16-bit compilations of EDataObj\rquote s code in {\i AdviseWndProc }will include a call to {\i PeekMessage }as well as to {\i TranslateMessage }and {\i DispatchMessage }
for each iteration through the loop:
\par \pard\plain \s39\ri-1200\sb60\sa60\sl-240\slmult1\widctlpar \f11\fs20 while (TRUE)\line     \{\line    #ifdef EXEDATAOBJECT\line    #ifndef WIN32\line     MSG     msg;\line \line     if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))\line         \{\line 
        TranslateMessage(&msg);\line         DispatchMessage(&msg);\line         \}\line     else\line    #endif\line    #endif\line         \{\line         pDO->m_pIDataAdviseHolder->SendOnDataChange\line             (p
DO->m_pImpIDataObject, 0, ADVF_NODATA);\line \line         if (++i >= iAdvise)\line             break;\line         \}\line     \}
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 This allows the 16-bit LRPC layer to process some of the asynchronous {\i IAdviseSink }calls because LRPC uses {\i PostMessage }for such a purpose. If the data object never called {\i PeekMessage}
, it would quickly fill the message queue and OLE would begin rejecting new calls. Obviously we don\rquote t need to do this with a DLL case, nor under a multitasking Win32 system in which the RPC layer for even a local server is not 
dependent on message loops.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 11
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The RECTL Structure
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 On 16-bit platforms, RECTL is still a 32-bit structure, as shown in Chapter 11, but RECT is composed of 16-bit fields. The macros RECTLFROMRECT and RECTFROMRECTL in INC\\
INOLE.H are independent of the underlying platform and offer a convenient means to convert between the two types.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 13
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Two Issues
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 A third issue applies to 16-bit OLE.{\b\i 
\par DoDragDrop}{\b  and Fast Keyboard Repeat Rates: }{\i DoDragDrop} calls {\i PeekMessage }internally to remove keyboard and mouse messages (client and nonclient alike).{\b  }If a message exists, calls are made to source and target and the loop continues.{
\b  }On a machine with a very fast keyboard repeat rate, it is possible to flood the message queue with WM_KEYDOWN messages for VK_CONTROL, so that every iteration through the loop will catch a keyboard message and continue in the loop once again.{\b  }
This means that in some circumstances, letting up on the mouse button with the Ctrl key still down doesn\rquote t cause a drop until you release that key as well.{\b 
\par }\pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 14
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The VARIANT and VARIANTARG Structures
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 VT_UI1 was not originally supported in a VARIANT under 16-bits.{\b  }
Such a data type is useful for creating arrays of binary data with the guarantee that nothing will attempt to perform ANSI to Unicode translations, which may happen with a {\i char }type.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Exceptions
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Error objects are available only under 16-bit OLE with OLE 2.02 and later.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Active Automation Objects
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Prior to OLE 2.02 on 16-bits, {\i RegisterActiveObject }could register only with a strong lock\emdash that is, ACTIVEOBJECT_WEAK was not recognized.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The Dual Interface
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Dual interfaces are available only under 16-bit OLE with OLE 2.02 and later.{\b  }
The dual interface is another reason that error objects were created because these interfaces allow a vtable-based interface to raise Automation exceptions.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Five Variations on the Theme of Implementing a Simple Automation Object
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Variations III and IV require OLE 2.02 on 16-bit platforms.
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 Also, you will experience errors if you attempt to use a 32-bit Beeper DLL with a 16-bit controller such as Visual Basic 3 or DispTest.{\b  }
Match bitness when attempting to use such a controller with samples from this book.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Variation III:{\b0  }Exceptions Through Error Objects
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Because error objects are supported only with OLE 2.02 and later, Beeper3 requires the header files and import libraries from OLE 2.02.{\b  }
Also note that the Thread-Local Storage described in the text for the Win32 version of this sample simply uses a global variable when compiled for 16-bits.
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Variation IV:{\b0  }A Dual Interface
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 As with error objects, dual interfaces are available only with OLE 2.02 and later, so Beeper4 requires the header files and import libraries from OLE 2.02.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 17
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Registry Entries for Content Objects
\par \pard\plain \widctlpar \f8\fs20 The default handler for 16-bit OLE is OLE2.DLL, which should appear under the InprocHandler entry if the server has no specific handler of its own.
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Chapter 24
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 Control-Specific Registry Entries
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 16-bit controls use \ldblquote ToolboxBitmap\rdblquote  instead of \ldblquote ToolboxBitmap32\rdblquote .
\par \pard\plain \s19\fi360\sb120\sa120\sl-360\slmult1\widctlpar \f8\fs22 
\par \pard\plain \s1\sb240\sa60\keepn\widctlpar \b\f5\fs28\kerning28 Appendix B:The Details of Standard Marshaling
\par \pard\plain \s2\sb240\sa60\keepn\widctlpar \b\i\f5 The RPC Channel
\par \pard\plain \s17\sa120\sl-360\slmult1\widctlpar \f8\fs22 Under 16-bit OLE, the RPC Channel implements the interface {\i IRpcChannel }instead of {\i IRpcChannelBuffer}.{\b  }The former is considered obsolete.
\par }